# Comparing `tmp/lightning_thunder-0.2.0.dev20240513.tar.gz` & `tmp/lightning_thunder-0.2.0.dev20240519.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "lightning_thunder-0.2.0.dev20240513.tar", last modified: Mon May 13 14:08:16 2024, max compression
+gzip compressed data, was "lightning_thunder-0.2.0.dev20240519.tar", last modified: Sun May 19 00:21:01 2024, max compression
```

## Comparing `lightning_thunder-0.2.0.dev20240513.tar` & `lightning_thunder-0.2.0.dev20240519.tar`

### file list

```diff
@@ -1,102 +1,103 @@
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-13 14:08:16.422199 lightning_thunder-0.2.0.dev20240513/
--rw-r--r--   0 runner    (1001) docker     (127)    11357 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/LICENSE
--rw-r--r--   0 runner    (1001) docker     (127)      760 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/MANIFEST.in
--rw-r--r--   0 runner    (1001) docker     (127)    12652 2024-05-13 14:08:16.422199 lightning_thunder-0.2.0.dev20240513/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (127)     9728 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/README.md
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-13 14:08:16.418199 lightning_thunder-0.2.0.dev20240513/lightning_thunder.egg-info/
--rw-r--r--   0 runner    (1001) docker     (127)    12652 2024-05-13 14:08:16.000000 lightning_thunder-0.2.0.dev20240513/lightning_thunder.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (127)     2461 2024-05-13 14:08:16.000000 lightning_thunder-0.2.0.dev20240513/lightning_thunder.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (127)        1 2024-05-13 14:08:16.000000 lightning_thunder-0.2.0.dev20240513/lightning_thunder.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (127)        1 2024-05-13 14:08:16.000000 lightning_thunder-0.2.0.dev20240513/lightning_thunder.egg-info/not-zip-safe
--rw-r--r--   0 runner    (1001) docker     (127)      538 2024-05-13 14:08:16.000000 lightning_thunder-0.2.0.dev20240513/lightning_thunder.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (127)        8 2024-05-13 14:08:16.000000 lightning_thunder-0.2.0.dev20240513/lightning_thunder.egg-info/top_level.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-13 14:08:16.402199 lightning_thunder-0.2.0.dev20240513/requirements/
--rw-r--r--   0 runner    (1001) docker     (127)      239 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/requirements/base.txt
--rw-r--r--   0 runner    (1001) docker     (127)       12 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/requirements/devel.txt
--rw-r--r--   0 runner    (1001) docker     (127)      485 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/requirements/docs.txt
--rw-r--r--   0 runner    (1001) docker     (127)      130 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/requirements/notebooks.txt
--rw-r--r--   0 runner    (1001) docker     (127)      836 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/requirements/test.txt
--rw-r--r--   0 runner    (1001) docker     (127)       38 2024-05-13 14:08:16.422199 lightning_thunder-0.2.0.dev20240513/setup.cfg
--rwxr-xr-x   0 runner    (1001) docker     (127)     5871 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-13 14:08:16.402199 lightning_thunder-0.2.0.dev20240513/thunder/
--rw-r--r--   0 runner    (1001) docker     (127)      436 2024-05-13 14:08:16.000000 lightning_thunder-0.2.0.dev20240513/thunder/__about__.py
--rw-r--r--   0 runner    (1001) docker     (127)    34464 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-13 14:08:16.406199 lightning_thunder-0.2.0.dev20240513/thunder/benchmarks/
--rw-r--r--   0 runner    (1001) docker     (127)   102663 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/benchmarks/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    22448 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/benchmarks/benchmark_litgpt.py
--rw-r--r--   0 runner    (1001) docker     (127)    20006 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/benchmarks/distributed.py
--rw-r--r--   0 runner    (1001) docker     (127)     3730 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/benchmarks/einsum.py
--rw-r--r--   0 runner    (1001) docker     (127)    28582 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/benchmarks/targets.py
--rw-r--r--   0 runner    (1001) docker     (127)    11229 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/benchmarks/test_benchmark_litgpt.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-13 14:08:16.406199 lightning_thunder-0.2.0.dev20240513/thunder/clang/
--rw-r--r--   0 runner    (1001) docker     (127)    64146 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/clang/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2516 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/clang/langctx.py
--rw-r--r--   0 runner    (1001) docker     (127)    30798 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/common.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-13 14:08:16.410199 lightning_thunder-0.2.0.dev20240513/thunder/core/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/core/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    14981 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/core/baseutils.py
--rw-r--r--   0 runner    (1001) docker     (127)    13335 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/core/codeutils.py
--rw-r--r--   0 runner    (1001) docker     (127)     2139 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/core/compile_data.py
--rw-r--r--   0 runner    (1001) docker     (127)     6058 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/core/devices.py
--rw-r--r--   0 runner    (1001) docker     (127)    17106 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/core/dtypes.py
--rw-r--r--   0 runner    (1001) docker     (127)   256121 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/core/interpreter.py
--rw-r--r--   0 runner    (1001) docker     (127)    58266 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/core/jit_ext.py
--rw-r--r--   0 runner    (1001) docker     (127)     4484 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/core/langctxs.py
--rw-r--r--   0 runner    (1001) docker     (127)     4343 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/core/module.py
--rw-r--r--   0 runner    (1001) docker     (127)     7046 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/core/options.py
--rw-r--r--   0 runner    (1001) docker     (127)    14058 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/core/patterns.py
--rw-r--r--   0 runner    (1001) docker     (127)   121505 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/core/prims.py
--rw-r--r--   0 runner    (1001) docker     (127)      629 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/core/profile.py
--rw-r--r--   0 runner    (1001) docker     (127)    48852 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/core/proxies.py
--rw-r--r--   0 runner    (1001) docker     (127)      731 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/core/pytree.py
--rw-r--r--   0 runner    (1001) docker     (127)    28189 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/core/rematerialization.py
--rw-r--r--   0 runner    (1001) docker     (127)    25979 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/core/symbol.py
--rw-r--r--   0 runner    (1001) docker     (127)    20436 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/core/trace.py
--rw-r--r--   0 runner    (1001) docker     (127)    10446 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/core/transform_common.py
--rw-r--r--   0 runner    (1001) docker     (127)   141043 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/core/transforms.py
--rw-r--r--   0 runner    (1001) docker     (127)    37010 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/core/utils.py
--rw-r--r--   0 runner    (1001) docker     (127)     7708 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/core/vjp_utils.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-13 14:08:16.410199 lightning_thunder-0.2.0.dev20240513/thunder/cudagraphs/
--rw-r--r--   0 runner    (1001) docker     (127)     5265 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/cudagraphs/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-13 14:08:16.414199 lightning_thunder-0.2.0.dev20240513/thunder/distributed/
--rw-r--r--   0 runner    (1001) docker     (127)    29040 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/distributed/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     7100 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/distributed/bucketing.py
--rw-r--r--   0 runner    (1001) docker     (127)     9307 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/distributed/checkpoint.py
--rw-r--r--   0 runner    (1001) docker     (127)    11709 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/distributed/prims.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-13 14:08:16.414199 lightning_thunder-0.2.0.dev20240513/thunder/distributed/transforms/
--rw-r--r--   0 runner    (1001) docker     (127)      310 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/distributed/transforms/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    10320 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/distributed/transforms/ddp.py
--rw-r--r--   0 runner    (1001) docker     (127)    33491 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/distributed/transforms/fsdp.py
--rw-r--r--   0 runner    (1001) docker     (127)    10897 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/distributed/utils.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-13 14:08:16.414199 lightning_thunder-0.2.0.dev20240513/thunder/examine/
--rw-r--r--   0 runner    (1001) docker     (127)     8681 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/examine/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     5761 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/examine/memory_caculation.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-13 14:08:16.418199 lightning_thunder-0.2.0.dev20240513/thunder/executors/
--rw-r--r--   0 runner    (1001) docker     (127)      598 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/executors/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     7092 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/executors/apex_entropyex.py
--rw-r--r--   0 runner    (1001) docker     (127)     4558 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/executors/cudnn_layernormex.py
--rw-r--r--   0 runner    (1001) docker     (127)    24237 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/executors/cudnnex.py
--rw-r--r--   0 runner    (1001) docker     (127)    10546 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/executors/data_dependent_partition.py
--rw-r--r--   0 runner    (1001) docker     (127)     1086 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/executors/nvfuserex.py
--rw-r--r--   0 runner    (1001) docker     (127)    75941 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/executors/nvfuserex_impl.py
--rw-r--r--   0 runner    (1001) docker     (127)    10861 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/executors/passes.py
--rw-r--r--   0 runner    (1001) docker     (127)    14038 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/executors/pythonex.py
--rw-r--r--   0 runner    (1001) docker     (127)    26538 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/executors/sdpaex.py
--rw-r--r--   0 runner    (1001) docker     (127)    13065 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/executors/torch_autograd.py
--rw-r--r--   0 runner    (1001) docker     (127)     9587 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/executors/torch_compile.py
--rw-r--r--   0 runner    (1001) docker     (127)    83541 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/executors/torchex.py
--rw-r--r--   0 runner    (1001) docker     (127)    24891 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/executors/transformer_engineex.py
--rw-r--r--   0 runner    (1001) docker     (127)      326 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/executors/triton_crossentropy.py
--rw-r--r--   0 runner    (1001) docker     (127)    19675 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/executors/triton_crossentropy_impl.py
--rw-r--r--   0 runner    (1001) docker     (127)      443 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/executors/triton_utils.py
--rw-r--r--   0 runner    (1001) docker     (127)     2646 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/executors/utils.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-13 14:08:16.418199 lightning_thunder-0.2.0.dev20240513/thunder/extend/
--rw-r--r--   0 runner    (1001) docker     (127)    15579 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/extend/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    17149 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/functional.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-13 14:08:16.418199 lightning_thunder-0.2.0.dev20240513/thunder/numpy/
--rw-r--r--   0 runner    (1001) docker     (127)     1652 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/numpy/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2554 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/numpy/langctx.py
--rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/py.typed
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-13 14:08:16.418199 lightning_thunder-0.2.0.dev20240513/thunder/torch/
--rw-r--r--   0 runner    (1001) docker     (127)   158401 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/torch/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2879 2024-05-13 14:08:14.000000 lightning_thunder-0.2.0.dev20240513/thunder/torch/langctx.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 00:21:01.943939 lightning_thunder-0.2.0.dev20240519/
+-rw-r--r--   0 runner    (1001) docker     (127)    11357 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (127)      760 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (127)    12652 2024-05-19 00:21:01.943939 lightning_thunder-0.2.0.dev20240519/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (127)     9728 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/README.md
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 00:21:01.939939 lightning_thunder-0.2.0.dev20240519/lightning_thunder.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (127)    12652 2024-05-19 00:21:01.000000 lightning_thunder-0.2.0.dev20240519/lightning_thunder.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (127)     2503 2024-05-19 00:21:01.000000 lightning_thunder-0.2.0.dev20240519/lightning_thunder.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (127)        1 2024-05-19 00:21:01.000000 lightning_thunder-0.2.0.dev20240519/lightning_thunder.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (127)        1 2024-05-19 00:21:01.000000 lightning_thunder-0.2.0.dev20240519/lightning_thunder.egg-info/not-zip-safe
+-rw-r--r--   0 runner    (1001) docker     (127)      538 2024-05-19 00:21:01.000000 lightning_thunder-0.2.0.dev20240519/lightning_thunder.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (127)        8 2024-05-19 00:21:01.000000 lightning_thunder-0.2.0.dev20240519/lightning_thunder.egg-info/top_level.txt
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 00:21:01.923939 lightning_thunder-0.2.0.dev20240519/requirements/
+-rw-r--r--   0 runner    (1001) docker     (127)      239 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/requirements/base.txt
+-rw-r--r--   0 runner    (1001) docker     (127)       12 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/requirements/devel.txt
+-rw-r--r--   0 runner    (1001) docker     (127)      485 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/requirements/docs.txt
+-rw-r--r--   0 runner    (1001) docker     (127)      130 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/requirements/notebooks.txt
+-rw-r--r--   0 runner    (1001) docker     (127)      836 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/requirements/test.txt
+-rw-r--r--   0 runner    (1001) docker     (127)       38 2024-05-19 00:21:01.943939 lightning_thunder-0.2.0.dev20240519/setup.cfg
+-rwxr-xr-x   0 runner    (1001) docker     (127)     5871 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 00:21:01.923939 lightning_thunder-0.2.0.dev20240519/thunder/
+-rw-r--r--   0 runner    (1001) docker     (127)      436 2024-05-19 00:21:01.000000 lightning_thunder-0.2.0.dev20240519/thunder/__about__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    34699 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 00:21:01.927939 lightning_thunder-0.2.0.dev20240519/thunder/benchmarks/
+-rw-r--r--   0 runner    (1001) docker     (127)   102923 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/benchmarks/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    22406 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/benchmarks/benchmark_litgpt.py
+-rw-r--r--   0 runner    (1001) docker     (127)    20006 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/benchmarks/distributed.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3730 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/benchmarks/einsum.py
+-rw-r--r--   0 runner    (1001) docker     (127)    25820 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/benchmarks/targets.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11229 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/benchmarks/test_benchmark_litgpt.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 00:21:01.927939 lightning_thunder-0.2.0.dev20240519/thunder/clang/
+-rw-r--r--   0 runner    (1001) docker     (127)    64679 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/clang/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2555 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/clang/langctx.py
+-rw-r--r--   0 runner    (1001) docker     (127)    32604 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/common.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 00:21:01.931939 lightning_thunder-0.2.0.dev20240519/thunder/core/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/core/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15070 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/core/baseutils.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13335 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/core/codeutils.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2139 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/core/compile_data.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6058 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/core/devices.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17106 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/core/dtypes.py
+-rw-r--r--   0 runner    (1001) docker     (127)   256121 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/core/interpreter.py
+-rw-r--r--   0 runner    (1001) docker     (127)    59518 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/core/jit_ext.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4484 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/core/langctxs.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5045 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/core/module.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7046 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/core/options.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14058 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/core/patterns.py
+-rw-r--r--   0 runner    (1001) docker     (127)   124824 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/core/prims.py
+-rw-r--r--   0 runner    (1001) docker     (127)      629 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/core/profile.py
+-rw-r--r--   0 runner    (1001) docker     (127)    50626 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/core/proxies.py
+-rw-r--r--   0 runner    (1001) docker     (127)      731 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/core/pytree.py
+-rw-r--r--   0 runner    (1001) docker     (127)    28189 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/core/rematerialization.py
+-rw-r--r--   0 runner    (1001) docker     (127)    25979 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/core/symbol.py
+-rw-r--r--   0 runner    (1001) docker     (127)    20436 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/core/trace.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12551 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/core/transform_common.py
+-rw-r--r--   0 runner    (1001) docker     (127)   141486 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/core/transforms.py
+-rw-r--r--   0 runner    (1001) docker     (127)    37505 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/core/utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7708 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/core/vjp_utils.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 00:21:01.931939 lightning_thunder-0.2.0.dev20240519/thunder/cudagraphs/
+-rw-r--r--   0 runner    (1001) docker     (127)     5265 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/cudagraphs/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 00:21:01.931939 lightning_thunder-0.2.0.dev20240519/thunder/distributed/
+-rw-r--r--   0 runner    (1001) docker     (127)    26699 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/distributed/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7100 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/distributed/bucketing.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9307 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/distributed/checkpoint.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11729 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/distributed/prims.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 00:21:01.931939 lightning_thunder-0.2.0.dev20240519/thunder/distributed/transforms/
+-rw-r--r--   0 runner    (1001) docker     (127)      310 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/distributed/transforms/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10320 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/distributed/transforms/ddp.py
+-rw-r--r--   0 runner    (1001) docker     (127)    33464 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/distributed/transforms/fsdp.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4629 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/distributed/transforms/fsdp_v2.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10897 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/distributed/utils.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 00:21:01.935939 lightning_thunder-0.2.0.dev20240519/thunder/examine/
+-rw-r--r--   0 runner    (1001) docker     (127)     8681 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/examine/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5761 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/examine/memory_caculation.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 00:21:01.935939 lightning_thunder-0.2.0.dev20240519/thunder/executors/
+-rw-r--r--   0 runner    (1001) docker     (127)      598 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/executors/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7092 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/executors/apex_entropyex.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4558 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/executors/cudnn_layernormex.py
+-rw-r--r--   0 runner    (1001) docker     (127)    24237 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/executors/cudnnex.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10546 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/executors/data_dependent_partition.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1086 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/executors/nvfuserex.py
+-rw-r--r--   0 runner    (1001) docker     (127)    75956 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/executors/nvfuserex_impl.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10901 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/executors/passes.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14135 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/executors/pythonex.py
+-rw-r--r--   0 runner    (1001) docker     (127)    26538 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/executors/sdpaex.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13057 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/executors/torch_autograd.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9587 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/executors/torch_compile.py
+-rw-r--r--   0 runner    (1001) docker     (127)    85148 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/executors/torchex.py
+-rw-r--r--   0 runner    (1001) docker     (127)    24891 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/executors/transformer_engineex.py
+-rw-r--r--   0 runner    (1001) docker     (127)      326 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/executors/triton_crossentropy.py
+-rw-r--r--   0 runner    (1001) docker     (127)    19675 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/executors/triton_crossentropy_impl.py
+-rw-r--r--   0 runner    (1001) docker     (127)      443 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/executors/triton_utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2646 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/executors/utils.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 00:21:01.935939 lightning_thunder-0.2.0.dev20240519/thunder/extend/
+-rw-r--r--   0 runner    (1001) docker     (127)    15579 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/extend/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17149 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/functional.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 00:21:01.939939 lightning_thunder-0.2.0.dev20240519/thunder/numpy/
+-rw-r--r--   0 runner    (1001) docker     (127)     1652 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/numpy/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2554 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/numpy/langctx.py
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/py.typed
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 00:21:01.939939 lightning_thunder-0.2.0.dev20240519/thunder/torch/
+-rw-r--r--   0 runner    (1001) docker     (127)   162697 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/torch/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2889 2024-05-19 00:20:59.000000 lightning_thunder-0.2.0.dev20240519/thunder/torch/langctx.py
```

### Comparing `lightning_thunder-0.2.0.dev20240513/LICENSE` & `lightning_thunder-0.2.0.dev20240519/LICENSE`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/MANIFEST.in` & `lightning_thunder-0.2.0.dev20240519/MANIFEST.in`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/PKG-INFO` & `lightning_thunder-0.2.0.dev20240519/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: lightning-thunder
-Version: 0.2.0.dev20240513
+Version: 0.2.0.dev20240519
 Summary: Lightning Thunder project.
 Home-page: https://github.com/Lightning-AI/lightning-thunder
 Download-URL: https://github.com/Lightning-AI/lightning-thunder
 Author: Lightning-AI et al
 Author-email: community@lightning.ai
 License: Apache 2.0
 Project-URL: Bug Tracker, https://github.com/Lightning-AI/lightning-thunder/issues
@@ -28,14 +28,17 @@
 Requires-Dist: looseversion==1.3.0
 Requires-Dist: lightning-utilities>=0.7.0
 Requires-Dist: numpy<2,>=1.23.0
 Requires-Dist: igraph>=0.10.4
 Requires-Dist: optree>=0.9.2
 Requires-Dist: opt_einsum>=3.3.0
 Requires-Dist: mpmath<1.4.0
+Provides-Extra: notebooks
+Requires-Dist: cuda-python; extra == "notebooks"
+Requires-Dist: ipython[all]==8.24.0; extra == "notebooks"
 Provides-Extra: test
 Requires-Dist: absl-py; extra == "test"
 Requires-Dist: coverage==7.5.1; extra == "test"
 Requires-Dist: einops; extra == "test"
 Requires-Dist: expecttest==0.2.1; extra == "test"
 Requires-Dist: fdm==0.4.1; extra == "test"
 Requires-Dist: graphviz==0.20.3; extra == "test"
@@ -49,21 +52,18 @@
 Requires-Dist: pytest-cov==4.1.0; extra == "test"
 Requires-Dist: pytest-random-order==1.1.1; extra == "test"
 Requires-Dist: pytest-timeout==2.3.1; extra == "test"
 Requires-Dist: pytest-timestamper==0.0.10; extra == "test"
 Requires-Dist: pytest-xdist==3.6.1; extra == "test"
 Requires-Dist: pytest==8.1.1; extra == "test"
 Requires-Dist: xlsxwriter; extra == "test"
-Provides-Extra: notebooks
-Requires-Dist: cuda-python; extra == "notebooks"
-Requires-Dist: ipython[all]==8.24.0; extra == "notebooks"
 
 <div align="center">
-<img alt="Thunder" src="https://github.com/Lightning-AI/lightning-thunder/raw/0.2.0.dev20240513/docs/source/_static/images/LightningThunderLightModewByline.png#gh-light-mode-only" width="400px" style="max-width: 100%;">
-<img alt="Thunder" src="https://github.com/Lightning-AI/lightning-thunder/raw/0.2.0.dev20240513/docs/source/_static/images/LightningThunderDarkModewByline.png#gh-dark-mode-only" width="400px" style="max-width: 100%;">
+<img alt="Thunder" src="https://github.com/Lightning-AI/lightning-thunder/raw/0.2.0.dev20240519/docs/source/_static/images/LightningThunderLightModewByline.png#gh-light-mode-only" width="400px" style="max-width: 100%;">
+<img alt="Thunder" src="https://github.com/Lightning-AI/lightning-thunder/raw/0.2.0.dev20240519/docs/source/_static/images/LightningThunderDarkModewByline.png#gh-dark-mode-only" width="400px" style="max-width: 100%;">
     <br/>
 <br/>
 
 **Make PyTorch models Lightning fast.**
 
 ______________________________________________________________________
 
@@ -103,27 +103,27 @@
 &#160;
 
 ## Single-GPU performance
 
 Thunder can achieve significant speedups over standard non-compiled PyTorch code ("PyTorch eager"), through the compounding effects of optimizations and the use of best-in-class executors. The figure below shows the pretraining throughput for Llama 2 7B as implemented in [LitGPT](https://github.com/Lightning-AI/litgpt).
 
 <div align="center">
-<img alt="Thunder" src="https://github.com/Lightning-AI/lightning-thunder/raw/0.2.0.dev20240513/docs/source/_static/images/training_throughput_single.png" width="800px" style="max-width: 100%;">
+<img alt="Thunder" src="https://github.com/Lightning-AI/lightning-thunder/raw/0.2.0.dev20240519/docs/source/_static/images/training_throughput_single.png" width="800px" style="max-width: 100%;">
 </div>
 
 As shown in the plot above, Thunder achieves a 40% speedup in training throughput compared to eager code on H100 using a combination of executors including nvFuser, torch.compile, cuDNN, and TransformerEngine FP8.
 
 &#160;
 
 ## Multi-GPU performance
 
 Thunder also supports distributed strategies such as DDP and FSDP for training models on multiple GPUs. The following plot displays the normalized throughput measured for Llama 2 7B without FP8 mixed precision; support for FSDP is in progress.
 
 <div align="center">
-<img alt="Thunder" src="https://github.com/Lightning-AI/lightning-thunder/raw/0.2.0.dev20240513/docs/source/_static/images/normalized_training_throughput_zero2.png" width="800px" style="max-width: 100%;">
+<img alt="Thunder" src="https://github.com/Lightning-AI/lightning-thunder/raw/0.2.0.dev20240519/docs/source/_static/images/normalized_training_throughput_zero2.png" width="800px" style="max-width: 100%;">
 </div>
 
 &#160;
 
 ## Get started
 
 The easiest way to get started with Thunder, requiring no extra installations or setups, is by using our [Zero to Thunder Tutorial Studio](https://lightning.ai/lightning-ai/studios/zero-to-thunder-tutorial).
```

#### html2text {}

```diff
@@ -1,8 +1,8 @@
-Metadata-Version: 2.1 Name: lightning-thunder Version: 0.2.0.dev20240513
+Metadata-Version: 2.1 Name: lightning-thunder Version: 0.2.0.dev20240519
 Summary: Lightning Thunder project. Home-page: https://github.com/Lightning-AI/
 lightning-thunder Download-URL: https://github.com/Lightning-AI/lightning-
 thunder Author: Lightning-AI et al Author-email: community@lightning.ai
 License: Apache 2.0 Project-URL: Bug Tracker, https://github.com/Lightning-AI/
 lightning-thunder/issues Project-URL: Documentation, https://lightning-
 thunder.rtfd.io/en/latest/ Project-URL: Source Code, https://github.com/
 Lightning-AI/lightning-thunder Keywords: deep learning,AI Classifier:
@@ -13,31 +13,30 @@
 License :: OSI Approved :: Apache Software License Classifier: Operating System
 :: OS Independent Classifier: Programming Language :: Python :: 3 Classifier:
 Programming Language :: Python :: 3.10 Requires-Python: >=3.10, <3.12
 Description-Content-Type: text/markdown License-File: LICENSE Requires-Dist:
 torch>=2.2.0 Requires-Dist: looseversion==1.3.0 Requires-Dist: lightning-
 utilities>=0.7.0 Requires-Dist: numpy<2,>=1.23.0 Requires-Dist: igraph>=0.10.4
 Requires-Dist: optree>=0.9.2 Requires-Dist: opt_einsum>=3.3.0 Requires-Dist:
-mpmath<1.4.0 Provides-Extra: test Requires-Dist: absl-py; extra == "test"
-Requires-Dist: coverage==7.5.1; extra == "test" Requires-Dist: einops; extra ==
-"test" Requires-Dist: expecttest==0.2.1; extra == "test" Requires-Dist:
-fdm==0.4.1; extra == "test" Requires-Dist: graphviz==0.20.3; extra == "test"
-Requires-Dist: hypothesis==6.100.0; extra == "test" Requires-Dist: jax;
+mpmath<1.4.0 Provides-Extra: notebooks Requires-Dist: cuda-python; extra ==
+"notebooks" Requires-Dist: ipython[all]==8.24.0; extra == "notebooks" Provides-
+Extra: test Requires-Dist: absl-py; extra == "test" Requires-Dist:
+coverage==7.5.1; extra == "test" Requires-Dist: einops; extra == "test"
+Requires-Dist: expecttest==0.2.1; extra == "test" Requires-Dist: fdm==0.4.1;
+extra == "test" Requires-Dist: graphviz==0.20.3; extra == "test" Requires-Dist:
+hypothesis==6.100.0; extra == "test" Requires-Dist: jax; (sys_platform ==
+"linux" or sys_platform == "darwin") and extra == "test" Requires-Dist: jaxlib;
 (sys_platform == "linux" or sys_platform == "darwin") and extra == "test"
-Requires-Dist: jaxlib; (sys_platform == "linux" or sys_platform == "darwin")
-and extra == "test" Requires-Dist: jsonargparse; extra == "test" Requires-Dist:
-litgpt==0.3.0; extra == "test" Requires-Dist: numpy; extra == "test" Requires-
-Dist: pandas; extra == "test" Requires-Dist: pytest-cov==4.1.0; extra == "test"
-Requires-Dist: pytest-random-order==1.1.1; extra == "test" Requires-Dist:
-pytest-timeout==2.3.1; extra == "test" Requires-Dist: pytest-
-timestamper==0.0.10; extra == "test" Requires-Dist: pytest-xdist==3.6.1; extra
-== "test" Requires-Dist: pytest==8.1.1; extra == "test" Requires-Dist:
-xlsxwriter; extra == "test" Provides-Extra: notebooks Requires-Dist: cuda-
-python; extra == "notebooks" Requires-Dist: ipython[all]==8.24.0; extra ==
-"notebooks"
+Requires-Dist: jsonargparse; extra == "test" Requires-Dist: litgpt==0.3.0;
+extra == "test" Requires-Dist: numpy; extra == "test" Requires-Dist: pandas;
+extra == "test" Requires-Dist: pytest-cov==4.1.0; extra == "test" Requires-
+Dist: pytest-random-order==1.1.1; extra == "test" Requires-Dist: pytest-
+timeout==2.3.1; extra == "test" Requires-Dist: pytest-timestamper==0.0.10;
+extra == "test" Requires-Dist: pytest-xdist==3.6.1; extra == "test" Requires-
+Dist: pytest==8.1.1; extra == "test" Requires-Dist: xlsxwriter; extra == "test"
                               [Thunder][Thunder]
 
                     **Make PyTorch models Lightning fast.**
     ______________________________________________________________________
    _L_i_g_h_t_n_i_n_g_._a_i â¢ _P_e_r_f_o_r_m_a_n_c_e â¢ _G_e_t_ _s_t_a_r_t_e_d â¢ _I_n_s_t_a_l_l â¢ _E_x_a_m_p_l_e_s â¢
               _I_n_s_i_d_e_ _T_h_u_n_d_e_r â¢ _G_e_t_ _i_n_v_o_l_v_e_d_! â¢ _D_o_c_u_m_e_n_t_a_t_i_o_n
 [![license](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https:
```

### Comparing `lightning_thunder-0.2.0.dev20240513/README.md` & `lightning_thunder-0.2.0.dev20240519/README.md`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/lightning_thunder.egg-info/PKG-INFO` & `lightning_thunder-0.2.0.dev20240519/lightning_thunder.egg-info/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: lightning-thunder
-Version: 0.2.0.dev20240513
+Version: 0.2.0.dev20240519
 Summary: Lightning Thunder project.
 Home-page: https://github.com/Lightning-AI/lightning-thunder
 Download-URL: https://github.com/Lightning-AI/lightning-thunder
 Author: Lightning-AI et al
 Author-email: community@lightning.ai
 License: Apache 2.0
 Project-URL: Bug Tracker, https://github.com/Lightning-AI/lightning-thunder/issues
@@ -28,14 +28,17 @@
 Requires-Dist: looseversion==1.3.0
 Requires-Dist: lightning-utilities>=0.7.0
 Requires-Dist: numpy<2,>=1.23.0
 Requires-Dist: igraph>=0.10.4
 Requires-Dist: optree>=0.9.2
 Requires-Dist: opt_einsum>=3.3.0
 Requires-Dist: mpmath<1.4.0
+Provides-Extra: notebooks
+Requires-Dist: cuda-python; extra == "notebooks"
+Requires-Dist: ipython[all]==8.24.0; extra == "notebooks"
 Provides-Extra: test
 Requires-Dist: absl-py; extra == "test"
 Requires-Dist: coverage==7.5.1; extra == "test"
 Requires-Dist: einops; extra == "test"
 Requires-Dist: expecttest==0.2.1; extra == "test"
 Requires-Dist: fdm==0.4.1; extra == "test"
 Requires-Dist: graphviz==0.20.3; extra == "test"
@@ -49,21 +52,18 @@
 Requires-Dist: pytest-cov==4.1.0; extra == "test"
 Requires-Dist: pytest-random-order==1.1.1; extra == "test"
 Requires-Dist: pytest-timeout==2.3.1; extra == "test"
 Requires-Dist: pytest-timestamper==0.0.10; extra == "test"
 Requires-Dist: pytest-xdist==3.6.1; extra == "test"
 Requires-Dist: pytest==8.1.1; extra == "test"
 Requires-Dist: xlsxwriter; extra == "test"
-Provides-Extra: notebooks
-Requires-Dist: cuda-python; extra == "notebooks"
-Requires-Dist: ipython[all]==8.24.0; extra == "notebooks"
 
 <div align="center">
-<img alt="Thunder" src="https://github.com/Lightning-AI/lightning-thunder/raw/0.2.0.dev20240513/docs/source/_static/images/LightningThunderLightModewByline.png#gh-light-mode-only" width="400px" style="max-width: 100%;">
-<img alt="Thunder" src="https://github.com/Lightning-AI/lightning-thunder/raw/0.2.0.dev20240513/docs/source/_static/images/LightningThunderDarkModewByline.png#gh-dark-mode-only" width="400px" style="max-width: 100%;">
+<img alt="Thunder" src="https://github.com/Lightning-AI/lightning-thunder/raw/0.2.0.dev20240519/docs/source/_static/images/LightningThunderLightModewByline.png#gh-light-mode-only" width="400px" style="max-width: 100%;">
+<img alt="Thunder" src="https://github.com/Lightning-AI/lightning-thunder/raw/0.2.0.dev20240519/docs/source/_static/images/LightningThunderDarkModewByline.png#gh-dark-mode-only" width="400px" style="max-width: 100%;">
     <br/>
 <br/>
 
 **Make PyTorch models Lightning fast.**
 
 ______________________________________________________________________
 
@@ -103,27 +103,27 @@
 &#160;
 
 ## Single-GPU performance
 
 Thunder can achieve significant speedups over standard non-compiled PyTorch code ("PyTorch eager"), through the compounding effects of optimizations and the use of best-in-class executors. The figure below shows the pretraining throughput for Llama 2 7B as implemented in [LitGPT](https://github.com/Lightning-AI/litgpt).
 
 <div align="center">
-<img alt="Thunder" src="https://github.com/Lightning-AI/lightning-thunder/raw/0.2.0.dev20240513/docs/source/_static/images/training_throughput_single.png" width="800px" style="max-width: 100%;">
+<img alt="Thunder" src="https://github.com/Lightning-AI/lightning-thunder/raw/0.2.0.dev20240519/docs/source/_static/images/training_throughput_single.png" width="800px" style="max-width: 100%;">
 </div>
 
 As shown in the plot above, Thunder achieves a 40% speedup in training throughput compared to eager code on H100 using a combination of executors including nvFuser, torch.compile, cuDNN, and TransformerEngine FP8.
 
 &#160;
 
 ## Multi-GPU performance
 
 Thunder also supports distributed strategies such as DDP and FSDP for training models on multiple GPUs. The following plot displays the normalized throughput measured for Llama 2 7B without FP8 mixed precision; support for FSDP is in progress.
 
 <div align="center">
-<img alt="Thunder" src="https://github.com/Lightning-AI/lightning-thunder/raw/0.2.0.dev20240513/docs/source/_static/images/normalized_training_throughput_zero2.png" width="800px" style="max-width: 100%;">
+<img alt="Thunder" src="https://github.com/Lightning-AI/lightning-thunder/raw/0.2.0.dev20240519/docs/source/_static/images/normalized_training_throughput_zero2.png" width="800px" style="max-width: 100%;">
 </div>
 
 &#160;
 
 ## Get started
 
 The easiest way to get started with Thunder, requiring no extra installations or setups, is by using our [Zero to Thunder Tutorial Studio](https://lightning.ai/lightning-ai/studios/zero-to-thunder-tutorial).
```

#### html2text {}

```diff
@@ -1,8 +1,8 @@
-Metadata-Version: 2.1 Name: lightning-thunder Version: 0.2.0.dev20240513
+Metadata-Version: 2.1 Name: lightning-thunder Version: 0.2.0.dev20240519
 Summary: Lightning Thunder project. Home-page: https://github.com/Lightning-AI/
 lightning-thunder Download-URL: https://github.com/Lightning-AI/lightning-
 thunder Author: Lightning-AI et al Author-email: community@lightning.ai
 License: Apache 2.0 Project-URL: Bug Tracker, https://github.com/Lightning-AI/
 lightning-thunder/issues Project-URL: Documentation, https://lightning-
 thunder.rtfd.io/en/latest/ Project-URL: Source Code, https://github.com/
 Lightning-AI/lightning-thunder Keywords: deep learning,AI Classifier:
@@ -13,31 +13,30 @@
 License :: OSI Approved :: Apache Software License Classifier: Operating System
 :: OS Independent Classifier: Programming Language :: Python :: 3 Classifier:
 Programming Language :: Python :: 3.10 Requires-Python: >=3.10, <3.12
 Description-Content-Type: text/markdown License-File: LICENSE Requires-Dist:
 torch>=2.2.0 Requires-Dist: looseversion==1.3.0 Requires-Dist: lightning-
 utilities>=0.7.0 Requires-Dist: numpy<2,>=1.23.0 Requires-Dist: igraph>=0.10.4
 Requires-Dist: optree>=0.9.2 Requires-Dist: opt_einsum>=3.3.0 Requires-Dist:
-mpmath<1.4.0 Provides-Extra: test Requires-Dist: absl-py; extra == "test"
-Requires-Dist: coverage==7.5.1; extra == "test" Requires-Dist: einops; extra ==
-"test" Requires-Dist: expecttest==0.2.1; extra == "test" Requires-Dist:
-fdm==0.4.1; extra == "test" Requires-Dist: graphviz==0.20.3; extra == "test"
-Requires-Dist: hypothesis==6.100.0; extra == "test" Requires-Dist: jax;
+mpmath<1.4.0 Provides-Extra: notebooks Requires-Dist: cuda-python; extra ==
+"notebooks" Requires-Dist: ipython[all]==8.24.0; extra == "notebooks" Provides-
+Extra: test Requires-Dist: absl-py; extra == "test" Requires-Dist:
+coverage==7.5.1; extra == "test" Requires-Dist: einops; extra == "test"
+Requires-Dist: expecttest==0.2.1; extra == "test" Requires-Dist: fdm==0.4.1;
+extra == "test" Requires-Dist: graphviz==0.20.3; extra == "test" Requires-Dist:
+hypothesis==6.100.0; extra == "test" Requires-Dist: jax; (sys_platform ==
+"linux" or sys_platform == "darwin") and extra == "test" Requires-Dist: jaxlib;
 (sys_platform == "linux" or sys_platform == "darwin") and extra == "test"
-Requires-Dist: jaxlib; (sys_platform == "linux" or sys_platform == "darwin")
-and extra == "test" Requires-Dist: jsonargparse; extra == "test" Requires-Dist:
-litgpt==0.3.0; extra == "test" Requires-Dist: numpy; extra == "test" Requires-
-Dist: pandas; extra == "test" Requires-Dist: pytest-cov==4.1.0; extra == "test"
-Requires-Dist: pytest-random-order==1.1.1; extra == "test" Requires-Dist:
-pytest-timeout==2.3.1; extra == "test" Requires-Dist: pytest-
-timestamper==0.0.10; extra == "test" Requires-Dist: pytest-xdist==3.6.1; extra
-== "test" Requires-Dist: pytest==8.1.1; extra == "test" Requires-Dist:
-xlsxwriter; extra == "test" Provides-Extra: notebooks Requires-Dist: cuda-
-python; extra == "notebooks" Requires-Dist: ipython[all]==8.24.0; extra ==
-"notebooks"
+Requires-Dist: jsonargparse; extra == "test" Requires-Dist: litgpt==0.3.0;
+extra == "test" Requires-Dist: numpy; extra == "test" Requires-Dist: pandas;
+extra == "test" Requires-Dist: pytest-cov==4.1.0; extra == "test" Requires-
+Dist: pytest-random-order==1.1.1; extra == "test" Requires-Dist: pytest-
+timeout==2.3.1; extra == "test" Requires-Dist: pytest-timestamper==0.0.10;
+extra == "test" Requires-Dist: pytest-xdist==3.6.1; extra == "test" Requires-
+Dist: pytest==8.1.1; extra == "test" Requires-Dist: xlsxwriter; extra == "test"
                               [Thunder][Thunder]
 
                     **Make PyTorch models Lightning fast.**
     ______________________________________________________________________
    _L_i_g_h_t_n_i_n_g_._a_i â¢ _P_e_r_f_o_r_m_a_n_c_e â¢ _G_e_t_ _s_t_a_r_t_e_d â¢ _I_n_s_t_a_l_l â¢ _E_x_a_m_p_l_e_s â¢
               _I_n_s_i_d_e_ _T_h_u_n_d_e_r â¢ _G_e_t_ _i_n_v_o_l_v_e_d_! â¢ _D_o_c_u_m_e_n_t_a_t_i_o_n
 [![license](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https:
```

### Comparing `lightning_thunder-0.2.0.dev20240513/lightning_thunder.egg-info/SOURCES.txt` & `lightning_thunder-0.2.0.dev20240519/lightning_thunder.egg-info/SOURCES.txt`

 * *Files 4% similar despite different names*

```diff
@@ -54,14 +54,15 @@
 thunder/distributed/bucketing.py
 thunder/distributed/checkpoint.py
 thunder/distributed/prims.py
 thunder/distributed/utils.py
 thunder/distributed/transforms/__init__.py
 thunder/distributed/transforms/ddp.py
 thunder/distributed/transforms/fsdp.py
+thunder/distributed/transforms/fsdp_v2.py
 thunder/examine/__init__.py
 thunder/examine/memory_caculation.py
 thunder/executors/__init__.py
 thunder/executors/apex_entropyex.py
 thunder/executors/cudnn_layernormex.py
 thunder/executors/cudnnex.py
 thunder/executors/data_dependent_partition.py
```

### Comparing `lightning_thunder-0.2.0.dev20240513/lightning_thunder.egg-info/requires.txt` & `lightning_thunder-0.2.0.dev20240519/lightning_thunder.egg-info/requires.txt`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/requirements/test.txt` & `lightning_thunder-0.2.0.dev20240519/requirements/test.txt`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/setup.py` & `lightning_thunder-0.2.0.dev20240519/setup.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/__init__.py` & `lightning_thunder-0.2.0.dev20240519/thunder/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -267,15 +267,15 @@
 ) -> Callable:
     """Just-in-time compile a callable (function or model).
 
     Args:
         fn: A :class:`~torch.nn.Module` or a function to compile.
     Keyword Args:
         langctx: the language context, which language / library to emulate. default: "torch" for PyTorch compatibility.
-        executors: list of executors to use. Defaults to the executors returned by :func:`thunder.get_default_executors` and always amended by :func:`thunder.get_always_executors`.
+        executors: list of executors to use. Defaults to the executors returned by :func:`thunder.extend.get_default_executors` and always amended by :func:`thunder.extend.get_always_executors`.
                    You can get a list of all available executors with :func:`thunder.get_all_executors`. You can also pass the name of an executor that's been registered, and it will be resolved with :func:`thunder.extend.get_executor`.
         sharp_edges: sharp edge detection action. What to do when thunder detects a construct that is likely to lead to errors. Can be ``"allow"``, ``"warn"``, ``"error"``. Defaults to ``"allow"``.
         cache: caching mode. default: ``"constant values"```
 
                - ``"no caching"`` - disable caching and always recompute,
                - ``"constant values"`` - require Tensors to be of the same shape, device, dtype etc., and integers and strings to match exactly,
                - ``"same input"`` - don't check, but just assume that a cached function works if it exists.
@@ -568,14 +568,16 @@
                 with langctxs.langctx(cd.langctx):
                     extraces = transform_for_execution(
                         computation_trc,
                         executors_list=cd.executors_list,
                     )
                 computation_trc = extraces[-1]
 
+            if not compile_options.get("disable_inplace_copy_check", False):
+                thunder.core.transform_common._inplace_copy_sanity_check(computation_trc)
             comp = computation_trc.python_callable()
 
             if backward_trc is not None:
                 backward_fn = backward_trc.python_callable()
             else:
                 backward_fn = None
 
@@ -689,24 +691,24 @@
     _fn = _create_callable(cd, cs)
     return _fn
 
 
 def compile_data(fn) -> CompileData | None:
     """Obtains the compilation data from a JITed function.
 
-    The compile data (:class:`CompileData`) contains information about how the JIT has been configured
+    The compile data (:class:`thunder.common.CompileData`) contains information about how the JIT has been configured
     for compilation (including referencing the function or module that is being compiled).
     """
     return getattr(fn, "_lc_cd", None)
 
 
 def compile_stats(fn) -> CompileStats | None:
     """Obtains the compilation statistics from a JITed function.
 
-    The compilation statistics (:class:`CompileStats`) contain information about each compilation run -
+    The compilation statistics (:class:`thunder.common.CompileStats`) contain information about each compilation run -
     collected when a JITed function is called for the first time or with previously unseen state.
     This includes the cache of traces (pologues, computation, possibly backward and epilogue) and
     how they have been transformed and information about cache hits and misses and timings.
     """
     return getattr(fn, "_lc_cs", None)
 
 
@@ -807,21 +809,21 @@
     max_depth: int | None = None,
     color_internals: bool = False,
     print_source_code: bool = True,
 ) -> None:
     """Prints a log of the last run of the interpreter for the given function.
 
     Args:
-        fn: The function returned by `thunder.jit()` to print the last interpreter run log for. The function must have been called at least once first.
+        fn: The function returned by :func:`thunder.jit` to print the last interpreter run log for. The function must have been called at least once first.
         print_fn: The function to use for printing. Defaults to builtin `print`.
         use_colors: Whether to use colors in the output. Defaults to `None`, which attempts to autodetect if the terminal supports ANSI color.
-        indent: Whether to indent the output with function scope. Defaults to `True`.
-        max_depth: The maximum indentation depth of the output. Doesn't print log items nested deeper than the max depth. Defaults to `None`, which means no limit.
-        color_internals: Whether to color instructions implicitly interpreted by other instructions. Defaults to `False`, so that only the instructions in the user's code are highlighted in color.
-        print_source_code: Whether to print the source line below each LineLogItem in the log. Defaults to `True`.
+        indent: Whether to indent the output with function scope. Defaults to :obj:`True`.
+        max_depth: The maximum indentation depth of the output. Doesn't print log items nested deeper than the max depth. Defaults to :obj:`None`, which means no limit.
+        color_internals: Whether to color instructions implicitly interpreted by other instructions. Defaults to :obj:`False`, so that only the instructions in the user's code are highlighted in color.
+        print_source_code: Whether to print the source line below each LineLogItem in the log. Defaults to :obj:`True`.
     """
     log = last_interpreter_log(fn)
     print_interpreter_log(
         log,
         print_fn=print_fn,
         use_colors=use_colors,
         indent=indent,
```

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/benchmarks/__init__.py` & `lightning_thunder-0.2.0.dev20240519/thunder/benchmarks/__init__.py`

 * *Files 0% similar despite different names*

```diff
@@ -497,22 +497,16 @@
     #   to finish its work just incase
     benchmark_fn = benchmark.fn()
     wait_for_computation_fn()
     start_time: int = time.time_ns()
 
     assert not use_grad_transform or not compile_backward, "Can't set both use_grad_transform and compile_backward!"
     if use_grad_transform:
-        from thunder.core.transforms import _grad_specifier_default
-
-        def grad_specifier(outs) -> None:
-            grad_tensor = benchmark.postprocess_for_backward(outs)
-            _grad_specifier_default(grad_tensor)
-
         benchmark_callable = constructor(benchmark_fn)
-        benchmark_callable = grad(benchmark_callable, grad_specifier=grad_specifier)
+        benchmark_callable = grad(benchmark_callable)
     elif compile_backward:
 
         def _fn(*args, **kwargs):
             result = benchmark_fn(*args, **kwargs)
             grad_tensor = benchmark.postprocess_for_backward(result)
             grad_tensor.backward(torch.ones_like(grad_tensor))
 
@@ -2562,54 +2556,67 @@
         q = make(shape)
         k = make(shape)
         v = make(shape)
 
         return (q, k, v), {"dropout": self.config.dropout}
 
     def fn(self) -> Callable:
-        class nanoGPTScaledDotProductAttention(torch.nn.Module):
-            def __init__(slf):
-                super().__init__()
-
+        class ScaledDotProductAttention(torch.nn.Module):
             def forward(slf, q, k, v, *, dropout):
                 return torch.nn.functional.scaled_dot_product_attention(
                     q, k, v, attn_mask=None, dropout_p=dropout, is_causal=True
                 )
 
-        return nanoGPTScaledDotProductAttention()
+        return ScaledDotProductAttention()
 
 
 class LitGPTSDPABenchmark(NanoGPTSDPABenchmark):
     @classmethod
     @property
     def name(cls) -> str:
-        return "llama2-sdpa"
+        return "litgpt-sdpa"
 
     @classmethod
     @property
     def description(cls) -> str:
         return "Lit-GPT's Scaled Dot Product Attention call."
 
     def __init__(
         self,
-        config: str = "Llama-2-7b-hf",
+        config: str | LitGPTConfig = "Llama-2-7b-hf",
         batchdims: Sequence[int] = (16,),
         device: str = "cuda",
         dtype: dtypes.dtype = thunder.bfloat16,
         requires_grad: bool = True,
     ) -> None:
         from thunder.tests.litgpt_model import Config
 
-        litgptconfig = Config.from_name(config) if not isinstance(config, Config) else config
-        nanogptconfig = NanoGPTConfig(
-            n_head=litgptconfig.n_head,
-            seq_len=litgptconfig.block_size,
-            n_embd=litgptconfig.n_embd,
-        )
-        super().__init__(nanogptconfig, batchdims, device, dtype, requires_grad)
+        # not calling super().__init__() on purpose to avoid the nanogpt config validation
+        self.config = Config.from_name(config) if not isinstance(config, Config) else config
+
+        self.batchdims = batchdims
+        self.device = device
+        self.dtype = dtype
+        self.requires_grad: bool = requires_grad
+
+        # Performs torch dtype conversions
+        self.tdtype: torch.dtype = ltorch.to_torch_dtype(self.dtype)
+
+        # Sets required benchmark parameters
+        self.devices: list[str] = [device]
+
+    def make_batch(self) -> tuple[list, dict]:
+        make = partial(make_tensor, device=self.device, dtype=self.tdtype, requires_grad=self.requires_grad)
+        shape = self.batchdims + (self.config.n_head, self.config.block_size, self.config.head_size)
+
+        q = make(shape)
+        k = make(shape)
+        v = make(shape)
+
+        return (q, k, v), {"dropout": 0.0}  # no litgpt model uses dropout
 
 
 # Taken from HuggingFace Bart-Large model config:
 # https://huggingface.co/facebook/bart-large/blob/main/config.json
 class HuggingFaceSelfAttnBenchmark(Benchmark, metaclass=UserFacingBenchmarkMeta):
     _args = (
         BenchmarkArg(
```

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/benchmarks/benchmark_litgpt.py` & `lightning_thunder-0.2.0.dev20240519/thunder/benchmarks/benchmark_litgpt.py`

 * *Files 0% similar despite different names*

```diff
@@ -383,24 +383,24 @@
             data_sync_ctx = nullcontext
 
         for i in range(self.max_iters):
             iter_t0 = time.perf_counter()
             if i == self.warmup_iter:  # warmup
                 t0 = iter_t0
 
+            if self.nsys_enabled and i == self.profiler_start and global_rank in [0, None]:
+                print("=====Start NSYS Profiling======")
+                torch.cuda.cudart().cudaProfilerStart()
+
             with data_sync_ctx():
                 for step_idx in range(self.gradient_accumulation_steps - 1):
                     input_ids, targets = next(self.train_data_iter)
                     input_ids = input_ids.to(device=self.device)
                     targets = targets.to(device=self.device)
 
-                    if self.nsys_enabled and i == self.profiler_start and global_rank in [0, None] and step_idx == 0:
-                        print("=====Start NSYS Profiling======")
-                        torch.cuda.cudart().cudaProfilerStart()
-
                     loss = run_fwd_bwd_one_microbatch(self.model, input_ids, targets, self.gradient_accumulation_steps)
 
             input_ids, targets = next(self.train_data_iter)
             input_ids = input_ids.to(device=self.device)
             targets = targets.to(device=self.device)
             loss = run_fwd_bwd_one_microbatch(self.model, input_ids, targets, self.gradient_accumulation_steps)
```

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/benchmarks/distributed.py` & `lightning_thunder-0.2.0.dev20240519/thunder/benchmarks/distributed.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/benchmarks/einsum.py` & `lightning_thunder-0.2.0.dev20240519/thunder/benchmarks/einsum.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/benchmarks/targets.py` & `lightning_thunder-0.2.0.dev20240519/thunder/benchmarks/targets.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 from collections.abc import Sequence
 
 from lightning_utilities.core.imports import package_available
 
 import pytest
 import torch
 import thunder
-from thunder.core.transforms import grad, grad_v1, clear_grads, populate_grads, get_grad, put_grad, put_grads
+from thunder.core.transforms import grad, clear_grads, populate_grads, get_grad, put_grad, put_grads
 from thunder.core.interpreter import interpret
 
 from thunder.benchmarks import (
     Benchmark,
     NanoGPTGeLUBenchmark,
     NanoGPTCrossEntropyBenchmark,
     NanoGPTLayerNormBenchmark,
@@ -174,50 +174,14 @@
     def wrapper(*args, **kwargs):
         result = cfn(*args, **kwargs)
         return result
 
     return wrapper
 
 
-# TODO Actually return the fwd, currently just requires computation
-# by making the fwd equal to the grad
-def thunder_value_and_grad_transform(b: Benchmark, compile_fn: Callable):
-    module: torch.nn.Module = b.fn()
-    cfn = compile_fn(module)
-
-    # Note on grad_specifier:
-    # requires the function output actually be computed to compute the grad
-    def grad_specifier(outs):
-        if not isinstance(outs, Sequence):
-            outs = (outs,)
-
-        for out in outs:
-            put_grad(out, out)
-
-    cfn_grad = grad(cfn, grad_specifier=grad_specifier)
-
-    if isinstance(module, torch.nn.Sequential):
-
-        @wraps(cfn_grad)
-        def wrapper(*args):
-            clear_grads(cfn)
-            grads = cfn_grad(args)
-            populate_grads(grads, cfn, args=args)
-
-        return wrapper
-
-    @wraps(cfn_grad)
-    def wrapper(*args, **kwargs):
-        clear_grads(cfn)
-        grads = cfn_grad(*args, **kwargs)
-        populate_grads(grads, cfn, args=args, kwargs=kwargs)
-
-    return wrapper
-
-
 def thunder_grad_transform(b: Benchmark, compile_fn: Callable):
     module: torch.nn.Module = b.fn()
     cfn = compile_fn(module)
     cfn_grad = grad(cfn)
 
     if isinstance(module, torch.nn.Sequential):
 
@@ -234,38 +198,14 @@
         clear_grads(cfn)
         grads = cfn_grad(*args, **kwargs)
         populate_grads(grads, cfn, args=args, kwargs=kwargs)
 
     return wrapper
 
 
-def thunder_grad_transform_v1(b: Benchmark, compile_fn: Callable):
-    module: torch.nn.Module = b.fn()
-    cfn = compile_fn(module)
-    cfn_grad = grad_v1(cfn)
-
-    if isinstance(module, torch.nn.Sequential):
-
-        @wraps(cfn_grad)
-        def wrapper(*args):
-            clear_grads(cfn)
-            grads = cfn_grad(args)
-            populate_grads(grads, cfn, args=args)
-
-        return wrapper
-
-    @wraps(cfn_grad)
-    def wrapper(*args, **kwargs):
-        clear_grads(cfn)
-        grads = cfn_grad(*args, **kwargs)
-        populate_grads(grads, cfn, args=args, kwargs=kwargs)
-
-    return wrapper
-
-
 def thunder_fwd_bwd(b: Benchmark, compile_fn: Callable):
     module: torch.nn.Module = b.fn()
     cfn = compile_fn(module)
 
     if isinstance(module, torch.nn.Sequential):
 
         @wraps(cfn)
@@ -292,37 +232,20 @@
 
 # To compare with PyTorch and raw torch.compile (i.e. not through thunder). The
 # latter can help us isolate whether it's something we need to fix ourselves or
 # report upstream.
 torch_fwd_bwd = partial(thunder_fwd_bwd, compile_fn=torch_executor)
 torchcompile_fwd_bwd = partial(thunder_fwd_bwd, compile_fn=torch_compile_executor)
 
-# Executing with just PyTorch
-thunder_torch_grad = partial(thunder_grad_transform, compile_fn=thunder_torch_executor)
-thunder_torch_gradv1 = partial(thunder_grad_transform_v1, compile_fn=thunder_torch_executor)
-thunder_torch_value_and_grad = partial(thunder_value_and_grad_transform, compile_fn=thunder_torch_executor)
-
 # Default thunder configs
 thunder_fwd = partial(thunder_fwd, compile_fn=thunder_executor)
 thunder_fwd_bwd = partial(thunder_fwd_bwd, compile_fn=thunder_executor)
-thunder_grad = partial(thunder_grad_transform, compile_fn=thunder_executor)
-thunder_gradv1 = partial(thunder_grad_transform_v1, compile_fn=thunder_executor)
-thunder_value_and_grad = partial(thunder_value_and_grad_transform, compile_fn=thunder_executor)
 
 # Executing with torchcompile as a Thunder executor
 thunder_torchcompile_fwd = partial(thunder_fwd, compile_fn=thunder_torch_compile_executor)
-thunder_torchcompile_grad = partial(thunder_grad_transform, compile_fn=thunder_torch_compile_executor)
-thunder_torchcompile_gradv1 = partial(thunder_grad_transform_v1, compile_fn=thunder_torch_compile_executor)
-thunder_torchcompile_value_and_grad = partial(
-    thunder_value_and_grad_transform, compile_fn=thunder_torch_compile_executor
-)
-
-# Executing with just the sdpa executor
-thunder_sdpa_grad = partial(thunder_grad_transform, compile_fn=thunder_sdpa_executor)
-thunder_sdpa_gradv1 = partial(thunder_grad_transform_v1, compile_fn=thunder_sdpa_executor)
 
 # Executing with just the apex executor
 # NOTE apex may or may not be available
 thunder_apex_grad: None | Callable = None
 if thunder_apex_executor is not None:
     thunder_apex_grad = partial(thunder_grad_transform, compile_fn=thunder_apex_executor)
```

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/benchmarks/test_benchmark_litgpt.py` & `lightning_thunder-0.2.0.dev20240519/thunder/benchmarks/test_benchmark_litgpt.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/clang/__init__.py` & `lightning_thunder-0.2.0.dev20240519/thunder/clang/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -15,24 +15,25 @@
 from thunder.core.compile_data import using_symbolic_values
 from thunder.clang.langctx import register_method
 from thunder.core.langctxs import langctx, Languages
 
 import thunder.core.dtypes as dtypes
 from thunder.core import utils
 import thunder.core.prims as prims
-from thunder.core.proxies import TensorProxy, pyval, pytype, proxy, AnyProxy, Proxy
+from thunder.core.proxies import IntegerProxy, NumberProxy, TensorProxy, pyval, pytype, proxy, AnyProxy, Proxy
 import thunder.core.devices as devices
 
 # This file defines the operations in thunder.jit's "core" language.
 #
 # These operators are intended to be used when defining user-facing languages, like the torch or NumPy
 # languages.
 
 __all__ = []
 
+NumberLike = Number | NumberProxy
 TensorLike = TensorProxy
 DeviceLike = Union[str, devices.Device]
 
 _clang_fn_set: set = set()
 
 
 # Decorator that sets the core language context and registers the function
@@ -81,15 +82,15 @@
 @clangop()
 def check_instance(x: Any, types: tuple[type], /) -> None:
     return prims.check_instance(x, types)
 
 
 # Checks a number's value
 @clangop()
-def check_number_type_and_value(n: Number, value: Number, /) -> None:
+def check_number_type_and_value(n: NumberLike, value: Number, /) -> None:
     return prims.check_number_type_and_value(n, value)
 
 
 @clangop()
 def check_string_value(s: str, value: str, /) -> None:
     return prims.check_string_value(s, value)
 
@@ -136,15 +137,15 @@
 
     if isinstance(a, Sequence):
         return tuple(maybe_convert_to_dtype(x, dtype) for x in a)
     if isinstance(a, TensorProxy):
         # Translates numbertypes to dtypes
         if dtypes.is_numbertype(dtype):
             dtype = dtypes.numbertype_to_dtype(dtype)
-    elif isinstance(a, Number):
+    elif isinstance(a, (Number, NumberProxy)):
         # NOTE This allows conversions like (5, float32) -> 5., which is a little odd
         dtype = utils.dtype_to_numbertype(dtype)
     else:
         raise ValueError(
             f"Trying to convert the type of the data of an unknown object {a} of {type(a)} that is neither a tensor, number, or sequence!"
         )
 
@@ -172,15 +173,17 @@
 # Tensor creation operations
 #
 # TODO Is there a good helper/wrapper for _like functions?
 
 
 # TODO Add type annotations
 @clangop()
-def arange(*, start: Number, step: Number, stop: Number, device: DeviceLike, dtype: dtypes.dtype | None = None):
+def arange(
+    *, start: NumberLike, step: NumberLike, stop: NumberLike, device: DeviceLike, dtype: dtypes.dtype | None = None
+):
     # Validates inputs
     # Checks that start, step, and stop are finite
     # TODO Semantically an infinite step seems fine?
     utils.check(math.isfinite(start), lambda: f"start={start} was non-finite")
     utils.check(math.isfinite(step), lambda: f"step={step} was non-finite")
     utils.check(math.isfinite(stop), lambda: f"stop={stop} was non-finite")
 
@@ -198,15 +201,16 @@
     # Canonicalizes device
     if isinstance(device, str):
         device = devices.Device(device)
 
     # (Optionally) infers dtype
     # TODO Replace with default datatypes for integer and float
     if dtype is None:
-        if all(tuple(isinstance(x, int) for x in (start, step, stop))):
+        # TODO: maybe something like a isIntegerType?
+        if all(tuple(isinstance(x, (int, IntegerProxy)) for x in (start, step, stop))):
             dtype = dtypes.int64
         else:
             dtype = dtypes.float32
 
     length = math.ceil((stop - start) / step)
 
     if utils.is_exact_dtype(dtype):
@@ -244,81 +248,88 @@
     groups: int,
 ) -> TensorLike:
     return prims.convolution(a, weight, bias, stride, padding, dilation, bool(transposed), output_padding, groups)
 
 
 @clangop()
 def full(
-    shape: Sequence[int], fill_value: Number, *, device: DeviceLike, dtype: None | dtypes.dtype = None
+    shape: Sequence[int], fill_value: NumberLike, *, device: DeviceLike, dtype: None | dtypes.dtype = None
 ) -> TensorLike:
     # Infers dtype from the fill_value when not explicitly provided
     if dtype is None:
         dtype = dtypes.numbertype_to_dtype(dtypes.to_dtype(fill_value))
     device = devices.to_device(device)
 
     return prims.full(shape, fill_value, device=device, dtype=dtype)
 
 
 @clangop()
 def full_like(
     a: TensorLike | Number,
-    fill_value: Number,
+    fill_value: NumberLike,
     *,
     device: DeviceLike | None = None,
     dtype: dtypes.dtype | None = None,
 ) -> TensorLike:
-    if isinstance(a, Number):
+    if isinstance(a, (Number, NumberProxy)):
         dtype = pytype(fill_value) if dtype is None else dtypes.dtype_to_numbertype(dtype)
         utils.check(
             device is None or devices.to_device(device).devicetype is devices.DeviceType.CPU,
             lambda: f"Numbers can only be created on the CPU, but found a request for device={device}",
         )
         return maybe_convert_to_dtype(fill_value, dtype)
 
     device = devices.to_device(device) if device is not None else a.device
     dtype = dtype if dtype is not None else a.true_dtype
 
     return full(a.shape, fill_value, device=device, dtype=dtype)
 
 
 @clangop()
+def empty(shape: Sequence[int], *, device: DeviceLike, dtype: dtypes.dtype) -> TensorLike:
+    device = devices.to_device(device)
+
+    return prims.empty(tuple(shape), device=device, dtype=dtype)
+
+
+@clangop()
 def uniform(
     shape: Sequence[int],
-    minval: Number = 0.0,
-    maxval: Number = 1.0,
+    minval: NumberLike = 0.0,
+    maxval: NumberLike = 1.0,
     *,
     device: DeviceLike,
     dtype: dtypes.dtype,
 ) -> TensorProxy:
     device = devices.to_device(device)
 
     return prims.uniform(shape, minval, maxval, device=device, dtype=dtype)
 
 
 # TODO Handle a being a number
 @clangop()
 def uniform_like(
     a: TensorProxy,
-    minval: Number = 0.0,
-    maxval: Number = 1.0,
+    minval: NumberLike = 0.0,
+    maxval: NumberLike = 1.0,
     *,
     device: str | devices.Device | None = None,
     dtype: dtypes.dtype | None = None,
 ):
     device = devices.to_device(device) if device is not None else a.device
     dtype = dtype if dtype is not None else a.true_dtype
 
     return prims.uniform(a.shape, minval, maxval, device=device, dtype=dtype)
 
 
 @clangop()
 def uniform_philox(
     shape: Sequence[int],
-    minval: Number = 0.0,
-    maxval: Number = 1.0,
+    minval: NumberLike = 0.0,
+    maxval: NumberLike = 1.0,
     *,
     device: DeviceLike,
     dtype: dtypes.dtype,
     seed: int | TensorProxy,
     offset: int | TensorProxy,
 ) -> TensorProxy:
     device = devices.to_device(device)
@@ -476,15 +487,15 @@
 
     # key is None or Ellipsis -> indexing is a no-op,
     # and we just return an empty signature.
     if isinstance(key, (type(None), EllipsisType)):
         return sig
 
     # Numbers and slices are examples of basic indexing.
-    if isinstance(key, (Number, slice)):
+    if isinstance(key, (Number, NumberProxy, slice)):
         sig.basic.append((None, None))
         return sig
 
     # TensorLike triggers advanced indexing.
     if isinstance(key, TensorLike):
         sig.advanced.append((None, None))
         return sig
@@ -535,15 +546,15 @@
             # Ellipsis is spotted -> iteration direction is changed
             # to iterate from left-most position to the position before Ellipsis.
             # We use negative indices for simplicity.
             a_dim = -1
         elif k is None:
             sig.unsqueeze.append(i)
         else:
-            if isinstance(k, (Number, slice)):
+            if isinstance(k, (Number, slice, NumberProxy)):
                 sig.basic.append((a_dim, i))
             elif isinstance(k, (TensorLike, Sequence)):
                 sig.advanced.append((a_dim, i))
             else:
                 raise ValueError(f"{key[i]=} has unexpected {type(key[i])=}")
 
             a_dim = advance(a_dim)
@@ -562,22 +573,22 @@
 
     # Resolves ellipses and unsqueezes
     unsqueeze_dims_pre_ellipsis = []
     unsqueeze_dims_post_ellipsis = []
     specified_slices = 0
     ellipsis_idx = None
 
-    if key is None or isinstance(key, (Number, slice, EllipsisType)):
+    if key is None or isinstance(key, (Number, NumberProxy, slice, EllipsisType)):
         key = (key,)
 
     for idx, x in enumerate(key):
         if x is Ellipsis:
             utils.check(ellipsis_idx is None, lambda: f"Found two (or more) ellipses in key={key}")
             ellipsis_idx = idx
-        elif isinstance(x, (Number, slice)):
+        elif isinstance(x, (NumberProxy, Number, slice)):
             specified_slices += 1
         elif x is None:
             if ellipsis_idx is None:
                 unsqueeze_dims_pre_ellipsis.append(idx)
             else:
                 unsqueeze_dims_post_ellipsis.append(idx)
         else:
@@ -649,15 +660,15 @@
 
             if stop >= l:
                 stop = l
 
             start_indices.append(start)
             end_indices.append(stop)
             strides.append(step)
-        elif isinstance(x, Number):
+        elif isinstance(x, (Number, NumberProxy)):
             # NOTE Numbers must be valid indices after canonicalization, unlike start and stop
             x = utils.canonicalize_dim(l, x)
             start_indices.append(x)
             end_indices.append(x + 1)
             strides.append(1)
             squeeze_dims.append(idx)
         else:
@@ -818,15 +829,15 @@
     # but a very special case when there is a single advanced index which
     # is a sequence of length 1.
     if len(sig.advanced) == 1 and not isinstance(key, TensorLike):
         (_, key_idx), *_ = sig.advanced
         if key_idx is not None:
             key_idx = key_idx if key_idx >= 0 else len(key) + key_idx
             index = key[key_idx]
-            if isinstance(index, Sequence) and len(index) == 1 and isinstance(index[0], Number):
+            if isinstance(index, Sequence) and len(index) == 1 and isinstance(index[0], (Number, NumberProxy)):
                 start = index[0]
                 # Hande -1 to avoid empty slices
                 if start == -1:
                     end = None
                 else:
                     end = start + 1
                 # 1-len Sequence -> a slice
@@ -1087,15 +1098,15 @@
 
 # Unsqueezes a, adding zero or more dimensions of length 1
 # Added dimensions are specified by their position in the final tensor
 # Based on https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.expand_dims.html
 # NOTE: the dimensions do not have to be specified in any order
 @clangop()
 def unsqueeze(a, /, dims: int | Sequence[int]) -> TensorProxy:
-    if isinstance(dims, Number):
+    if isinstance(dims, (Number, NumberProxy)):
         dims = (dims,)
 
     # Short-circuits if dims is empty
     if len(dims) == 0:
         return a
 
     final_rank = a.ndim + len(dims)
@@ -1327,15 +1338,15 @@
     # Short-circuits on unsigned inputs
     if dtypes.is_exact_dtype(dtypes.to_dtype(a)):
         return a
 
     return _elementwise_unary_wrapper(
         a,
         prim=prims.ceil,
-        type_promotion_kind=utils.ELEMENTWISE_TYPE_PROMOTION_KIND.DEFAULT,
+        type_promotion_kind=utils.ELEMENTWISE_TYPE_PROMOTION_KIND.NUMBER_TO_INT,
     )
 
 
 @clangop()
 def cos(a):
     return _elementwise_unary_wrapper(
         a, prim=prims.cos, type_promotion_kind=utils.ELEMENTWISE_TYPE_PROMOTION_KIND.INT_TO_FLOAT
@@ -1410,15 +1421,15 @@
     # Short-circuits on unsigned inputs
     if dtypes.is_exact_dtype(dtypes.to_dtype(a)):
         return a
 
     return _elementwise_unary_wrapper(
         a,
         prim=prims.floor,
-        type_promotion_kind=utils.ELEMENTWISE_TYPE_PROMOTION_KIND.DEFAULT,
+        type_promotion_kind=utils.ELEMENTWISE_TYPE_PROMOTION_KIND.NUMBER_TO_INT,
     )
 
 
 @clangop()
 def isfinite(a):
     if utils.is_exact_dtype(utils.to_dtype(a)):
         return full_like(a, True, dtype=dtypes.bool8)
```

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/clang/langctx.py` & `lightning_thunder-0.2.0.dev20240519/thunder/clang/langctx.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 from typing import Any
 from collections.abc import Callable, Sequence
 
 from thunder.core.langctxs import LanguageContext, register_langctx, Languages, resolve_language
 from thunder.core.pytree import tree_flatten
-from thunder.core.proxies import TensorProxy
+from thunder.core.proxies import TensorProxy, NumberProxy
 
 #
 # Creates and registers the torch language context
 #
 # NOTE That this is done separately from the definition of thunder.torch operations, because the
 #   language context must be available before those operations are defined
 
@@ -26,27 +26,27 @@
         # Note: concrete implmenetations should only raise AttributeError or
         #       return None for "missing" methods as the proxies will
         #       route __getattr__ to here and hasattr relies on __getattr__
         #       throwing AttributeError (only) when the attribute does
         #       not exist.
         inps, _ = tree_flatten((args, kwargs))
 
-        has_tensor_input: bool = False
+        has_proxy_input: bool = False
         for x in inps:
-            if isinstance(x, TensorProxy):
-                has_tensor_input = True
+            if isinstance(x, TensorProxy) or isinstance(x, NumberProxy):
+                has_proxy_input = True
                 break
 
-        if has_tensor_input:
+        if has_proxy_input:
             method: None | Callable = _method_name_to_fn_map.get(id, None)
             if method is None:
                 raise AttributeError(f"The {self.name} language context has no method {id}")
             return method
 
-        # has_tensor_input is False
+        # has_proxy_input is False
         # Defers to the primitive language context when there are no tensor inputs=
         #   (the primitive language context handles operations on numbers)
         primsctx: LanguageContext = resolve_language(Languages.PRIMS)
         if not primsctx.has_method(id):
             raise AttributeError(
                 f"Attempting to call method {id} in the core language context, but it has no tensor inputs and the primitive language context (which handles numbers) doesn't have the method"
             )
```

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/common.py` & `lightning_thunder-0.2.0.dev20240519/thunder/common.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 import dis
 from typing import Any, Optional
 from collections.abc import Generator
 from collections.abc import Callable
+from collections.abc import Sequence
 from enum import Enum, auto
 from collections import deque, defaultdict
 from contextlib import contextmanager
 import time
 import warnings
 from collections.abc import Hashable, Sequence
 from functools import wraps
@@ -49,14 +50,54 @@
 #
 
 
 # Holds statistics and caches for a compiled function
 # TODO RC1 Update last_executed to last_computation
 # TODO RC1 Review how autograd traces are presented
 class CompileStats:
+    """A class holding statistics and caches for a compiled function.
+
+    .. note::
+        It is highly recommended that some attributes such as :attr:`CompileStats.last_traces` and
+        :attr:`CompileStats.last_backward_traces` via :func:`thunder.last_traces` and
+        :func:`thunder.last_backward_traces`, respectively.
+        See :mod:`thunder` for more of such utility functions.
+
+    Attributes:
+        last_executed:
+        last_traces (Sequence[TraceCtx]):
+        last_prologue (TraceCtx):
+        last_prologue_traces (Sequence[TraceCtx]):
+        last_interpreted_instructions (Generator[dist.Instruction, None, None] | None):
+        last_interpreter_log (list[InterpreterLogItem] | None):
+        last_backward_traces (Sequence[TraceCtx]):
+        last_trace_host_start (int):
+        last_trace_host_stop (int):
+        last_trace_cache_start (int):
+        last_trace_cache_stop (int):
+        last_trace_tracing_start (int):
+        last_trace_tracing_stop (int):
+        last_trace_host_execution_start (int):
+        last_trace_host_execution_stop (int):
+        last_prologue_transformation_start (int):
+        last_prologue_transformation_stop (int):
+        last_prologue_execution_start (int):
+        last_prologue_execution_stop (int):
+        last_computation_transformation_start (int):
+        last_computation_transformation_stop (int):
+        last_computation_execution_start (int):
+        last_computation_execution_stop (int):
+        cache (dict):
+        interpreter_cashe (list):
+        calls (int):
+        cache_hits (int):
+        cache_misses (int):
+        last_compile_reasons (dict):
+    """
+
     def __init__(self):
         # Callables and traces
         self.last_executed = None
         self.last_traces = None
         self.last_prologue = None
         self.last_prologue_traces = None
         self.last_interpreted_instructions: Generator[dis.Instruction, None, None] | None = None
@@ -133,14 +174,19 @@
 
 
 # A class that holds data about the compiled object, including statistics about how it's been called
 # TODO Better document the module-related data the preprocessing harvests,
 #   like additional_param_names
 # TODO RC1 Rename this to CompileOptions
 class CompileData:
+    """A class holding data about the compiled object.
+
+    Data include statistics about how it's been called.
+    """
+
     def __init__(
         self,
         *,
         fn: Callable,
         langctx: None | LanguageContext = None,
         executors_list: None | tuple[Executor, ...] = None,
         cache_option: None | str | CACHE_OPTIONS = None,
```

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/core/baseutils.py` & `lightning_thunder-0.2.0.dev20240519/thunder/core/baseutils.py`

 * *Files 1% similar despite different names*

```diff
@@ -124,15 +124,16 @@
             exception_type=ValueError,
         )
 
 
 def check_valid_length(length: int):
     """Validates that an object represents a valid dimension length."""
 
-    check_type(length, int)
+    # maybe we should skip the check for IntegerProxy in general
+    check_type(length, (int, NumberProxyInterface))
     check(length >= 0, lambda: f"Found invalid length {length}!")
 
 
 def check_valid_shape(shape: tuple[int, ...] | list[int]):
     """Validates that a sequence represents a valid shape."""
 
     check_type(shape, (tuple, list))
```

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/core/codeutils.py` & `lightning_thunder-0.2.0.dev20240519/thunder/core/codeutils.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/core/compile_data.py` & `lightning_thunder-0.2.0.dev20240519/thunder/core/compile_data.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/core/devices.py` & `lightning_thunder-0.2.0.dev20240519/thunder/core/devices.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/core/dtypes.py` & `lightning_thunder-0.2.0.dev20240519/thunder/core/dtypes.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/core/interpreter.py` & `lightning_thunder-0.2.0.dev20240519/thunder/core/interpreter.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/core/jit_ext.py` & `lightning_thunder-0.2.0.dev20240519/thunder/core/jit_ext.py`

 * *Files 1% similar despite different names*

```diff
@@ -566,15 +566,20 @@
 
             p = proxy(uvalue, name=name, history=value.provenance)
 
             # TensorProxy attributes should be considered derived quantities, so we flag TensorProxies here
             value.provenance.ext_flag |= EXT_FLAG_IS_TENSOR_PROXY
 
             if isinstance(p, TensorProxy) and p.ddp_type in (DDPType.REPLICATED, DDPType.FULLY_SHARDED):
-                p_new = thunder.distributed.prims.synchronize(p, self._process_group_for_ddp)
+                p_new = thunder.distributed.prims.synchronize(
+                    p,
+                    self._process_group_for_ddp,
+                )
+                if isinstance(p.thunder_fsdp_padding_size, int):
+                    p_new = p_new[: (p_new.shape[0] - p.thunder_fsdp_padding_size)]
                 p_orig = p
                 p = p_new
             else:
                 p_orig = p
             if p is not uvalue:
                 value.register_proxy(p)
             # TODO: other caching modes
@@ -1126,14 +1131,38 @@
                 inputs_set.add(v)
         for v in bsym.flat_variableified_proxy_outs:
             intermediates_set.add(v)
 
     return inputs_list, intermediates_set
 
 
+def get_parameter_or_buffer_or_submodule_name_and_root(provenance):
+    assert provenance.inputs[0].inst is PseudoInst.LOAD_ATTR
+    assert provenance.inputs[0].inputs[0].ext_flag & EXT_FLAG_IS_MODULE
+    typ = provenance.inputs[0].inputs[1].value
+    name = [provenance.inputs[1].value]
+    mprovenance = provenance.inputs[0].inputs[0]
+
+    while (
+        mprovenance.inst is PseudoInst.BINARY_SUBSCR
+        and mprovenance.inputs[1].inst is PseudoInst.CONSTANT
+        and mprovenance.inputs[0].inst is PseudoInst.LOAD_ATTR
+        and mprovenance.inputs[0].inputs[0].ext_flag & EXT_FLAG_IS_MODULE
+    ):
+        assert (
+            mprovenance.inputs[0].inputs[1].inst is PseudoInst.CONSTANT
+            and mprovenance.inputs[0].inputs[1].value == "_modules"
+        )
+
+        name_component = mprovenance.inputs[1].value
+        name.insert(0, name_component)
+        mprovenance = mprovenance.inputs[0].inputs[0]
+    return typ, name, mprovenance
+
+
 def unpack_inputs(ctx, prologue_trace, pro_to_comp_inps, pro_to_epi_inps, args, kwargs, *, has_epilogue: bool):
     already_unpacked: dict[int, Proxy] = {}
     orig_modules: dict[int, Proxy] = {}
 
     # param_ordering[id(proxy] is a list that contains either finite numbers or (strings preceded by math.inf)
     param_ordering: dict[int, list] = {}
 
@@ -1151,27 +1180,31 @@
             return p
 
         # Adds the name to the prologue trace
         if not prologue_trace.has_name(p.name):
             prologue_trace.add_name(p.name)
 
         def from_input(provenance, *, new_output=False):
-            assert new_output
             if provenance.inst == PseudoInst.INPUT_ARGS:
+                assert new_output
                 param_ordering[id(pro_args_proxy)] = (pro_args_proxy, [0])
                 return pro_args_proxy
             elif provenance.inst == PseudoInst.INPUT_KWARGS:
+                assert new_output
                 param_ordering[id(pro_kwargs_proxy)] = (pro_kwargs_proxy, [1])
                 return pro_kwargs_proxy
             elif provenance.inst == PseudoInst.INPUT_FN:
                 if provenance.ext_flag & EXT_FLAG_IS_MODULE:
                     name = "module"
                 else:
                     name = "fn"
-                output = Proxy(name=name)
+                if new_output:
+                    output = Proxy(name=name)
+                else:
+                    output = p
                 param_ordering[id(output)] = (output, [3])
                 provenance.proxy = output
                 bsym = prims.unpack_function_obj.bind(output, output=output)
                 prologue_trace.bound_symbols.append(bsym)
                 return output
             assert False
 
@@ -1193,36 +1226,16 @@
         def from_constant(provenance, *, new_output=False):
             if isinstance(provenance.value, (int, str)):
                 return provenance.value
             else:
                 raise NotImplementedError(f"constant of type {type(provenance.value)} {provenance.value}")
 
         def unpack_parameter_or_buffer_or_submodule(provenance, *, new_output=False):
-            assert provenance.inputs[0].inst is PseudoInst.LOAD_ATTR
-            assert provenance.inputs[0].inputs[0].ext_flag & EXT_FLAG_IS_MODULE
-            typ = provenance.inputs[0].inputs[1].value
-            name = [provenance.inputs[1].value]
-            mprovenance = provenance.inputs[0].inputs[0]
-
-            while (
-                mprovenance.inst is PseudoInst.BINARY_SUBSCR
-                and mprovenance.inputs[1].inst is PseudoInst.CONSTANT
-                and mprovenance.inputs[0].inst is PseudoInst.LOAD_ATTR
-                and mprovenance.inputs[0].inputs[0].ext_flag & EXT_FLAG_IS_MODULE
-            ):
-                assert (
-                    mprovenance.inputs[0].inputs[1].inst is PseudoInst.CONSTANT
-                    and mprovenance.inputs[0].inputs[1].value == "_modules"
-                )
-
-                name_component = mprovenance.inputs[1].value
-                name.insert(0, name_component)
-                mprovenance = mprovenance.inputs[0].inputs[0]
-
-            root_module = from_provenance(mprovenance, new_output=True)
+            typ, name, root_module_provenance = get_parameter_or_buffer_or_submodule_name_and_root(provenance)
+            root_module = from_provenance(root_module_provenance, new_output=True)
             if new_output:
                 output = Proxy("m")  # name? collectify?
             else:
                 output = p
 
             param_ordering[id(output)] = (
                 output,
@@ -1406,19 +1419,17 @@
         else:
             prims.python_return(pro_to_comp)
 
     return pro_to_comp, pro_to_epi
 
 
 def process_recorded_modifications(ctx, epilogue_trace):
+    root_for_provenances = {}
     for modified_object, modifications in ctx._additional_outputs.items():
         umodified_object = modified_object.value
-        ## we want this to created in the compute trace context for namespace...
-        modified_object_proxy = Proxy(history=modified_object.provenance)
-        epilogue_trace.add_name(modified_object_proxy.name)
 
         if isinstance(umodified_object, dict):
             last_modification = {}
             for inst, *args in modifications:
                 if inst == PseudoInst.STORE_SUBSCR:
                     _, key, value = args
                     # should we warn if we have multiple assignments?
@@ -1426,16 +1437,32 @@
                 else:
                     raise NotImplementedError(f"Modifications {inst} on dicts are not supported")
             for k, (inst, *args) in last_modification.items():
                 if inst == PseudoInst.STORE_SUBSCR:
                     (value,) = args
                     assert isinstance(value.value, Proxy)
 
+                    assert modified_object.provenance.inst is PseudoInst.LOAD_ATTR
+                    assert modified_object.provenance.inputs[1].inst is PseudoInst.CONSTANT
+                    assert modified_object.provenance.inputs[1].value == "_buffers"
+
+                    typ, name, root_module_provenance = get_parameter_or_buffer_or_submodule_name_and_root(
+                        modified_object.provenance.inputs[0]
+                    )
+                    assert typ == "_modules"
+                    root_module_proxy = root_for_provenances.get(root_module_provenance)
+                    if root_module_proxy is None:
+                        ## we want this to created in the compute trace context for namespace...
+                        root_module_proxy = Proxy(history=root_module_provenance)
+                        epilogue_trace.add_name(root_module_proxy.name)
+                        root_for_provenances[root_module_provenance] = root_module_proxy
+
+                    name = ".".join(name + [k])
                     with tracectx(epilogue_trace):
-                        bsym = prims.pack_setitem.bind(modified_object_proxy, k, value.value, output=None)
+                        bsym = prims.pack_buffer.bind(root_module_proxy, name, value.value, output=None)
                         epilogue_trace.bound_symbols.append(bsym)
                 else:
                     raise NotImplementedError(f"Modifications {inst} on dicts are not supported")
         else:
             raise NotImplementedError(f"Modifications of {type(uvalue).__name__} objects are not supported")
```

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/core/langctxs.py` & `lightning_thunder-0.2.0.dev20240519/thunder/core/langctxs.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/core/module.py` & `lightning_thunder-0.2.0.dev20240519/thunder/core/module.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,8 +1,9 @@
 from contextlib import contextmanager
+import itertools
 from typing import Any
 
 import torch as pytorch
 
 from thunder.core.compile_data import get_compile_data
 
 
@@ -22,31 +23,43 @@
         # We delete self.training in order for training to be used from
         # the model itself through `__getattr__`.
         del self.training
 
         self._forward_fn = compiled_model_call
 
         # overrides for parameters and buffers (see get_buffer/get_parameter)
-        self._overrides = {}
+        # we populate these here for performance reasons (sam as module cache),
+        # a single dict lookup is cheaper than traversin the module
+        # hierarchy, see https://github.com/Lightning-AI/lightning-thunder/issues/396#issuecomment-2113231498
+        self._overrides = {
+            k: v for k, v in itertools.chain(self._model.named_parameters(), self._model.named_buffers())
+        }
+        self._module_cache = {k: v for k, v in self._model.named_modules()}
 
         self._null = object()
 
     def get_buffer(self, name):
         p = self._overrides.get(name, self._null)
         if p is not self._null:
             return p
         return self._model.get_buffer(name)
 
+    def set_buffer(self, name, value):
+        p = self._overrides[name] = value
+
     def get_parameter(self, name):
         p = self._overrides.get(name, self._null)
         if p is not self._null:
             return p
         return self._model.get_parameter(name)
 
     def get_submodule(self, name):
+        p = self._module_cache.get(name, self._null)
+        if p is not self._null:
+            return p
         return self._model.get_submodule(name)
 
     def forward(self, *args, **kwargs):
         res = self._forward_fn(*args, **kwargs)
         return res
 
     @contextmanager
@@ -58,17 +71,17 @@
         synchronization in the backward pass. It will not have any effect when
         used with other modules.
 
         .. note::
 
             This could lead to different accumulated gradients with ``torch.nn.parallel.distributed.DistributedDataParallel.no_sync``.
             PyTorch's gradient synchronization is implemented by applying all-reduce to gradient buckets of ``torch.nn.Parameter.grad``.
-            Thus the ``no_sync`` context leads to :math:`\text{AllReduce} \left( \sum_{i = 0}^{\rm{num_grad_accum_steps}} g_i \right)`.
+            Thus the ``no_sync`` context leads to :math:`\text{AllReduce} \left( \sum_{i = 0}^{\text{ga_steps}} g_i \right)` where :math:`\text{ga_steps}` means the number of gradient accumulation steps.
             In contrast, this synchronizes accumulated gradients when exiting, leading to
-            :math:`\text{AllReduce} \left( \sum_{i = 0}^{\rm{num_grad_accum_steps - 1}} g_i \right) + \text{AllReduce}(g_{\rm{num_grad_accum_steps}})`.
+            :math:`\text{AllReduce} \left( \sum_{i = 0}^{\text{ga_steps - 1}} g_i \right) + \text{AllReduce}(g_{\text{ga_steps}})`.
 
         .. warning::
 
             You must reuse this context manager in each group of gradient accumulation iterations since gradients will get synchronized
             on context manager exit.
 
             .. code-block:: python
```

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/core/options.py` & `lightning_thunder-0.2.0.dev20240519/thunder/core/options.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/core/patterns.py` & `lightning_thunder-0.2.0.dev20240519/thunder/core/patterns.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/core/prims.py` & `lightning_thunder-0.2.0.dev20240519/thunder/core/prims.py`

 * *Files 3% similar despite different names*

```diff
@@ -61,14 +61,15 @@
     _method_name_to_fn_map[method_name] = method
 
 
 from thunder.core.symbol import Symbol, BoundSymbol, default_python_printer
 from thunder.core.proxies import (
     CollectionProxy,
     TensorProxy,
+    IntegerProxy,
     NumberProxy,
     is_proxyable,
     proxy,
     numberproxy,
     pytype,
     pyval,
     Proxy,
@@ -120,14 +121,15 @@
     UNPACK_LIST = auto()
     UNPACK_DICT_KEY = auto()
     UNPACK_PARAMETER = auto()
     UNPACK_BUFFER = auto()
     UNPACK_SUBMODULE = auto()
     UNPACK_THUNDER_MODULE = auto()
     CONSTRUCT_TUPLE = auto()
+    PACK_BUFFER = auto()
     PACK_SETITEM = auto()
     # TODO: UNPACK_SET
     # Utility prims
     COMMENT = auto()
     DEL = auto()
     PRINT = auto()
     RETURN = auto()
@@ -141,14 +143,15 @@
     # Tensor creation prims
     EXOGENOUS_LIKE = auto()
     FULL = auto()
     IOTA = auto()
     UNIFORM = auto()
     UNIFORM_PHILOX = auto()
     RANDN = auto()
+    EMPTY = auto()
     TENSOR_FROM_SEQUENCE = auto()
     # Probability distribution-related ops
     MULTINOMIAL = auto()
     # Reshaping and permuting prims
     BROADCAST_IN_DIM = auto()
     CAT = auto()
     FLIP = auto()
@@ -567,15 +570,15 @@
     tags=(OpTags.DONT_DCE,),
 )
 
 
 def _check_number_type_and_value_meta(n: NumberProxy, value: Number, /) -> None:
     # Validates types
     baseutils.check_type(n, NumberProxy)
-    baseutils.check_type(value, Number)
+    baseutils.check_type(value, (Number, NumberProxy))
     baseutils.check(pytype(n) == pytype(value), lambda: f"Different types for {n} and {value}")
 
 
 check_number_type_and_value = make_prim(
     PrimIDs.CHECK_NUMBER_TYPE_AND_VALUE,
     "check_number_type_and_value",
     meta=_check_number_type_and_value_meta,
@@ -767,15 +770,15 @@
 
 # TODO Restore const criteria
 def unpack_sequence_meta(x: Sequence | CollectionProxy, l: int, /) -> list:
     if isinstance(x, CollectionProxy):
         x = x.collection()
 
     utils.check_type(x, Sequence)
-    utils.check_type(l, int)
+    utils.check_type(l, (int, IntegerProxy))
     baseutils.check(len(x) == l, lambda x=x, l=l: f"Expected the length of {x=} to be {l=}")
 
     return list(_collectify(y) for y in x)
 
 
 def _make_parts_into_line_or_lines(parts: list[str], out: list[str] | None = None) -> list[str]:
     if out is None:
@@ -1109,14 +1112,57 @@
     "unpack_buffer",
     meta=unpack_buffer_meta,
     python_printer=unpack_buffer_printer,
     python_impl=unpack_buffer_impl,
 )
 
 
+# NOTE PACK_BUFFER is intended only to be bound to directly, and not called
+def pack_buffer_meta(o: Any, key: Any, value: Any) -> Any:
+    raise NotImplementedError
+
+
+def pack_buffer_printer(
+    bsym: BoundSymbol, out_printables: Any, arg_printables: Sequence[Printable], kwarg_printables: dict[str, Printable]
+):
+    utils.check(
+        len(arg_printables) == 3,
+        lambda: f"Expected three arguments for pack_buffer but got {arg_printables}",
+        exception_type=AssertionError,
+    )
+    utils.check(
+        len(kwarg_printables) == 0,
+        lambda: f"Expected no kwargs for pack_buffer but got {kwarg_printables}",
+        exception_type=AssertionError,
+    )
+
+    # Converts printables to strings
+    obj, key, value = arg_printables
+    obj_str = codeutils.prettyprint(obj)
+    key_str = codeutils.prettyprint(key)
+    value_str = codeutils.prettyprint(value)
+    return f"{obj_str}.set_buffer({key_str}, {value_str})"
+
+
+def pack_buffer_impl(o: Any, key: Any, v: Any) -> None:
+    # o[key] = v
+    XXX
+    return None
+
+
+pack_buffer = make_prim(
+    PrimIDs.PACK_BUFFER,
+    "unpack_buffer",
+    meta=pack_buffer_meta,
+    python_printer=pack_buffer_printer,
+    python_impl=pack_buffer_impl,
+    tags=(OpTags.DONT_DCE,),
+)
+
+
 # NOTE PACK_SETITEM is intended only to be bound to directly, and not called
 def pack_setitem_meta(o: Any, key: Any, value: Any) -> Any:
     raise NotImplementedError
 
 
 def pack_setitem_printer(
     bsym: BoundSymbol, out_printables: Any, arg_printables: Sequence[Printable], kwarg_printables: dict[str, Printable]
@@ -1591,16 +1637,16 @@
 
 #
 # Prims related to transforms (like grad)
 #
 
 
 # TODO Review number grad handling with dynamic constraints
-def _get_grad_meta(a: Number | TensorProxy, /) -> Number | TensorProxy:
-    utils.check_type(a, (Number, TensorProxy))
+def _get_grad_meta(a: Number | NumberProxy | TensorProxy, /) -> Number | TensorProxy:
+    utils.check_type(a, (Number, NumberProxy, TensorProxy))
 
     if isinstance(a, TensorProxy):
         return TensorProxy(like=a)
 
     # NOTE a is a Number in this branch
     return numberproxy(pytype(a), 0)
 
@@ -1608,30 +1654,30 @@
 get_grad = make_prim(
     PrimIDs.GET_GRAD,
     "get_grad",
     meta=_get_grad_meta,
 )
 
 
-def _put_grad_meta(grad_for: Number | TensorProxy, grad: Number | TensorProxy) -> None:
-    utils.check_type(grad_for, (Number, TensorProxy))
-    utils.check_type(grad, (Number, TensorProxy))
+def _put_grad_meta(grad_for: Number | NumberProxy | TensorProxy, grad: Number | NumberProxy | TensorProxy) -> None:
+    utils.check_type(grad_for, (Number, NumberProxy, TensorProxy))
+    utils.check_type(grad, (Number, NumberProxy, TensorProxy))
 
     # Attempts to put a grad for a number or tensor with an exact dtype are ignored
     if dtypes.is_exact_dtype(dtypes.to_dtype(grad_for)):
         return None
 
     if isinstance(grad, TensorProxy):
         utils.check_type(grad_for, TensorProxy)
         utils.check_same_shape(grad_for, grad)
         utils.check_same_device(grad_for, grad)
         utils.check_same_dtype(grad_for, grad)
     else:
-        # NOTE isinstance(grad, Number) == True in this branch
-        utils.check_type(grad_for, Number)
+        # NOTE isinstance(grad, (Number, NumberProxy)) == True in this branch
+        utils.check_type(grad_for, (Number, NumberProxy))
         # TODO Add number grad support
 
     return None
 
 
 put_grad = make_prim(
     PrimIDs.PUT_GRAD,
@@ -1644,20 +1690,20 @@
 #
 # TODO create an expected type helper for consistent error formatting
 # TODO: consider supporting number subclasses
 
 
 # TODO Require the datatype of the conversion be constant
 def _convert_element_type_meta(a: Number | TensorProxy, /, dtype: type | dtypes.dtype) -> Number | TensorProxy:
-    utils.check_type(a, (Number, TensorProxy))
+    utils.check_type(a, (Number, NumberProxy, TensorProxy))
     utils.check_type(dtype, (type, dtypes.dtype))
 
     # NOTE Python numbers are constants, and this will return another Python number when given one because
     #   The conversion is constant
-    if isinstance(a, Number):
+    if isinstance(a, (Number, NumberProxy)):
         utils.check(utils.is_numbertype(dtype), lambda: f"Trying to convert a number to non-numbertype object {dtype}")
 
         if isinstance(a, NumberProxy):
             return numberproxy(dtype, dtype(utils.get_numberlike_value(a)))
 
         number_result = dtype(a)
         return number_result
@@ -1700,27 +1746,29 @@
 #
 
 
 # NOTE Elementwise primitives always accept inputs with a common datatype, and they
 #   usually produce an output with that same datatype (SAME).
 #   Sometimes, however, elementwise operations can produce an output with a different
 #   datatype than the inputs. For example, comparison operations like eq and lt always
-#   produce boolean results (ALWAYS_BOOL), and other operations, like abs, map
+#   produce boolean results (ALWAYS_BOOL), math.ceil/math.floor produces integer outputs for number inputs while preserves datatype for tensor inputs, and other operations, like abs, map
 #   complex numbers to floats (COMPLEX_TO_FLOAT).
 #   The ELEMENTWISE_PRIM_OUTPUT_DTYPE_KIND enum describes these three behaviors so that
 #   elementwise operations can rely on helper functions to implement this behavior.
 class ELEMENTWISE_PRIM_OUTPUT_DTYPE_KIND(Enum):
     SAME = auto()
     ALWAYS_BOOL = auto()
+    INT_FOR_NUMBER = auto()
     COMPLEX_TO_FLOAT = auto()
 
 
 math_dtypes = dtypes.all_dtypes_and_numbertypes - dtypes.low_precision_dtypes
 fp_math_dtypes = math_dtypes - dtypes.exact_dtypes
 comparison_dtypes = dtypes.all_dtypes_and_numbertypes - dtypes.complex_dtypes
+ceil_floor_math_dtypes = dtypes.float_dtypes | dtypes.all_numbertypes - {complex}
 
 #
 # Elementwise unary prims
 #
 # TODO Maybe make a helper to construct elementwise unary prims?
 
 
@@ -1731,17 +1779,17 @@
     supported_input_dtypes,
     output_dtype_kind,
     numbers_only: bool,
     number_type_map: dict[type, type] | None,
 ):
     def meta(a: Number | TensorProxy, /) -> Number | TensorProxy:
         # Checks that inputs have an expected type
-        utils.check_type(a, (TensorProxy, Number))
+        utils.check_type(a, (TensorProxy, Number, NumberProxy))
 
-        if isinstance(a, Number):
+        if isinstance(a, (Number, NumberProxy)):
             # Checks that the numbertype is supported
             typ = utils.get_numberlike_type(a)
             val = utils.get_numberlike_value(a)
 
             allowed_types = number_type_map.keys() if number_type_map is not None else supported_input_dtypes
 
             utils.check(typ in allowed_types, lambda: f"Unsupported input dtype {typ}")
@@ -1749,14 +1797,16 @@
             output_type = None
             if number_type_map is not None:
                 output_type = number_type_map[typ]
             elif output_dtype_kind == ELEMENTWISE_PRIM_OUTPUT_DTYPE_KIND.SAME:
                 output_type = typ
             elif output_dtype_kind == ELEMENTWISE_PRIM_OUTPUT_DTYPE_KIND.ALWAYS_BOOL:
                 output_type = bool
+            elif output_dtype_kind == ELEMENTWISE_PRIM_OUTPUT_DTYPE_KIND.INT_FOR_NUMBER:
+                output_type = int
             elif output_dtype_kind == ELEMENTWISE_PRIM_OUTPUT_DTYPE_KIND.COMPLEX_TO_FLOAT:
                 if dtypes.is_complex_dtype(typ):
                     output_type = float
                 else:
                     output_type = typ
             else:
                 utils.check(False, lambda: f"Unknown {output_dtype_kind=}")
@@ -1764,15 +1814,16 @@
             if val is None or number_fn is None:
                 utils.check(
                     isinstance(a, NumberProxy),
                     lambda: f"Trying to call an elementwise unary operation {name} on a number, but the operation is not eagerly defined",
                 )
                 return numberproxy(output_type, None)
 
-            value = number_fn(val)
+            # need to cast val to python_type in order to properly propagate output dtype.
+            value = number_fn(typ(val))
             utils.check(
                 type(value) is output_type,
                 lambda: f"Unexpected number output type {type(value)}, expected {output_type}, for input type {typ} (value={val})",
             )
 
             # Only returns a proxy if the input is a proxy
             if isinstance(a, Proxy):
@@ -1784,15 +1835,18 @@
             not numbers_only,
             lambda: f"Trying to call a primitive ({name}) that only supports numbers with a tensor input",
         )
 
         # Checks that dtype is supported
         utils.check(a.dtype in supported_input_dtypes, lambda: f"Unsupported input dtype {a.dtype}")
 
-        if output_dtype_kind == ELEMENTWISE_PRIM_OUTPUT_DTYPE_KIND.SAME:
+        if (
+            output_dtype_kind == ELEMENTWISE_PRIM_OUTPUT_DTYPE_KIND.SAME
+            or output_dtype_kind == ELEMENTWISE_PRIM_OUTPUT_DTYPE_KIND.INT_FOR_NUMBER
+        ):
             return TensorProxy(like=a)
         if output_dtype_kind == ELEMENTWISE_PRIM_OUTPUT_DTYPE_KIND.ALWAYS_BOOL:
             return TensorProxy(like=a, dtype=dtypes.bool8)
         if output_dtype_kind == ELEMENTWISE_PRIM_OUTPUT_DTYPE_KIND.COMPLEX_TO_FLOAT:
             if dtypes.is_complex_dtype(a.dtype):
                 return TensorProxy(like=a, dtype=dtypes.corresponding_real_dtype(a.true_dtype))
             return TensorProxy(like=a)
@@ -1900,15 +1954,16 @@
 # NOTE This primitive preserves the input's dtype for tensors
 #   but returns numbers as integers to be consistent with
 #   Python's math.ceil
 ceil = _make_elementwise_unary_prim(
     PrimIDs.CEIL,
     "ceil",
     number_fn=math.ceil,
-    supported_input_dtypes=dtypes.float_dtypes,
+    supported_input_dtypes=ceil_floor_math_dtypes,
+    output_dtype_kind=ELEMENTWISE_PRIM_OUTPUT_DTYPE_KIND.INT_FOR_NUMBER,
 )
 
 cos = _make_elementwise_unary_prim(
     PrimIDs.COS,
     "cos",
     supported_input_dtypes=fp_math_dtypes,
 )
@@ -1965,15 +2020,16 @@
 # TODO Should floor accept float16 and bfloat16 types?
 # NOTE This preserves the input's dtype for tensors, but is consistent
 #   with math.floor for numbers (always returning an integer)
 floor = _make_elementwise_unary_prim(
     PrimIDs.FLOOR,
     "floor",
     number_fn=math.floor,
-    supported_input_dtypes=dtypes.float_dtypes,
+    supported_input_dtypes=ceil_floor_math_dtypes,
+    output_dtype_kind=ELEMENTWISE_PRIM_OUTPUT_DTYPE_KIND.INT_FOR_NUMBER,
 )
 
 isfinite = _make_elementwise_unary_prim(
     PrimIDs.ISFINITE,
     "isfinite",
     supported_input_dtypes=dtypes.inexact_dtypes,
     output_dtype_kind=ELEMENTWISE_PRIM_OUTPUT_DTYPE_KIND.ALWAYS_BOOL,
@@ -2149,28 +2205,28 @@
 ):
     def meta(
         a: Number | TensorProxy,
         b: Number | TensorProxy,
         /,
     ) -> Number | TensorProxy:
         # Checks that inputs have an expected type
-        utils.check_type(a, (TensorProxy, Number))
-        utils.check_type(b, (TensorProxy, Number))
+        utils.check_type(a, (TensorProxy, Number, NumberProxy))
+        utils.check_type(b, (TensorProxy, Number, NumberProxy))
 
         # Checks same dtype
         numbertype, dtype = utils.check_same_dtype(a, b)
 
         # Checks that dtype is supported
         utils.check(
             numbertype is None or numbertype in supported_input_dtypes, lambda: f"Unsupported number type {numbertype}"
         )
         utils.check(dtype is None or dtype in supported_input_dtypes, lambda: f"Unsupported input dtype {dtype}")
 
         # Special-cases number x number inputs
-        if isinstance(a, Number) and isinstance(b, Number):
+        if isinstance(a, (Number, NumberProxy)) and isinstance(b, (Number, NumberProxy)):
             aval, bval = utils.get_numberlike_value(a), utils.get_numberlike_value(b)
 
             # Handles the case where a number has an indeterminate value, or the operation has
             #   no number handler, by returning another indeterminate value
             if aval is None or bval is None or number_fn is None:
                 utils.check(
                     isinstance(a, NumberProxy) or isinstance(b, NumberProxy),
@@ -2455,23 +2511,27 @@
 #
 
 
 # TODO Restore Number x Number x Number support
 def _where_meta(pred: Number | TensorProxy, a: Number | TensorProxy, b: Number | TensorProxy, /) -> TensorProxy:
     # Checks types
     # NOTE pred must be a bool tensor or bool (this is checked later)
-    utils.check_type(pred, (TensorProxy, Number))
-    utils.check_type(a, (TensorProxy, Number))
-    utils.check_type(b, (TensorProxy, Number))
+    utils.check_type(pred, (TensorProxy, Number, NumberProxy))
+    utils.check_type(a, (TensorProxy, Number, NumberProxy))
+    utils.check_type(b, (TensorProxy, Number, NumberProxy))
 
-    if isinstance(pred, Number) and isinstance(a, Number) and isinstance(b, Number):
+    if (
+        isinstance(pred, (Number, NumberProxy))
+        and isinstance(a, (Number, NumberProxy))
+        and isinstance(b, (Number, NumberProxy))
+    ):
         raise NotImplementedError
 
     # Checks pred dtype (bool or bool tensor)
-    if isinstance(pred, Number):
+    if isinstance(pred, (Number, NumberProxy)):
         utils.check(
             pytype(pred) is bool,
             lambda: f"Expected pred to be a boolean number, but found a number of type {pytype(pred)}",
         )
 
     if isinstance(pred, TensorProxy):
         utils.check(
@@ -2547,15 +2607,15 @@
 
 # TODO Review always setting requires_grad=False
 #   Logically these tensors are constructed intermediate to a trace, so there's no mechanism for a user to
 #   extract their grad, but we could support compiling forward and backward and accessing grad attributes
 #   in the future
 def _full_meta(shape: Sequence[int], fill_value: Number, *, device: devices.Device, dtype: dtypes.dtype) -> TensorProxy:
     # Checks inputs
-    utils.check_type(fill_value, Number)
+    utils.check_type(fill_value, (Number, NumberProxy))
 
     # Ensures the requested fill_value can be safely cast to the dtype
     fill_value_dtype = dtypes.to_dtype(fill_value)
     utils.check(
         utils.can_safe_cast_number_to(fill_value, dtype),
         lambda: f"Can't safely cast fill_value of numbertype {fill_value_dtype} to dtype {dtype}",
     )
@@ -2571,17 +2631,17 @@
 
 
 def _iota_meta(
     length: Number, *, start: Number, step: Number, device: devices.Device, dtype: dtypes.dtype
 ) -> TensorProxy:
     # Checks types
     # NOTE that device and dtype types will be checked by TensorProxy, below
-    utils.check_type(length, Number)
-    utils.check_type(start, Number)
-    utils.check_type(step, Number)
+    utils.check_type(length, (Number, NumberProxy))
+    utils.check_type(start, (Number, NumberProxy))
+    utils.check_type(step, (Number, NumberProxy))
 
     # Checks input properties
     utils.check(utils.is_exact_dtype(dtype), lambda: f"dtype={dtype} was not an exact dtype")
     utils.check(not utils.is_boolean_dtype(dtype), lambda: f"dtype={dtype} was not a non-boolean dtype")
     utils.check(length >= 0, lambda: f"length={length} was not weakly positive")
 
     shape = () if length == 0 else (length,)
@@ -2597,16 +2657,16 @@
 #   Logically these tensors are constructed intermediate to a trace, so there's no mechanism for a user to
 #   extract their grad, but we could support compiling forward and backward and accessing grad attributes
 #   in the future
 def _uniform_meta(
     shape: Sequence[int], minval: Number, maxval: Number, *, device: devices.Device, dtype: dtypes.dtype
 ) -> TensorProxy:
     # Checks inputs
-    utils.check_type(minval, Number)
-    utils.check_type(maxval, Number)
+    utils.check_type(minval, (Number, NumberProxy))
+    utils.check_type(maxval, (Number, NumberProxy))
     utils.check_type(device, devices.Device)
     utils.check_type(dtype, dtypes.dtype)
 
     return TensorProxy(shape=shape, device=device, dtype=dtype, requires_grad=False)
 
 
 uniform = make_prim(
@@ -2631,19 +2691,19 @@
     utils.check_type(minval, float)
     utils.check_type(maxval, float)
     utils.check_type(device, devices.Device)
     utils.check_type(dtype, dtypes.dtype)
     utils.check_type(seed, (int, TensorProxy))
     utils.check_type(offset, (int, TensorProxy))
     utils.check(
-        isinstance(seed, int) or seed.dtype is dtypes.int64,
+        isinstance(seed, (int, IntegerProxy)) or seed.dtype is dtypes.int64,
         lambda: f"Expected {seed=} to be an integer or an int64 tensor",
     )
     utils.check(
-        isinstance(offset, int) or seed.dtype is dtypes.int64,
+        isinstance(offset, (int, IntegerProxy)) or seed.dtype is dtypes.int64,
         lambda: f"Expected {offset=} to be an integer or an int64 tensor",
     )
     utils.check(minval < maxval, lambda: f"`minval` must be less than `maxval` but {minval=}, {maxval=}")
     utils.check_valid_shape(shape)
 
     utils.check_same_shape(shape, seed, offset)
     utils.check_same_device(device, seed, offset)
@@ -2670,14 +2730,30 @@
     utils.check_valid_shape(shape)
     return TensorProxy(shape=shape, device=device, dtype=dtype, requires_grad=False)
 
 
 randn = make_prim(PrimIDs.RANDN, "randn", meta=_randn_meta)
 
 
+def _empty_meta(
+    shape: tuple[int, ...],
+    *,
+    device: devices.Device,
+    dtype: dtypes.dtype,
+):
+    utils.check_type(device, devices.Device)
+    utils.check_type(dtype, dtypes.dtype)
+    utils.check_type(shape, tuple)
+    utils.check_valid_shape(shape)
+    return TensorProxy(shape=shape, device=device, dtype=dtype, requires_grad=False)
+
+
+empty = make_prim(PrimIDs.EMPTY, "empty", meta=_empty_meta)
+
+
 # Prim to construct a Tensor from sequence/nested sequence of Numbers.
 def _tensor_from_sequence_meta(
     seq: Sequence[Number | Sequence], *, dtype: None | dtypes.dtype, device: devices.Device
 ) -> TensorProxy:
     utils.check_type(dtype, (dtypes.dtype, NoneType))
     utils.check_type(device, devices.Device)
     utils.check_type(seq, Sequence)
@@ -2753,15 +2829,15 @@
 def _multinomial_meta(
     input: TensorProxy,
     num_samples: int,
     replacement: bool,
     seed: int | None = None,
 ) -> TensorProxy:
     utils.check_type(input, TensorProxy)
-    utils.check_type(num_samples, int)
+    utils.check_type(num_samples, (int, IntegerProxy))
     utils.check(pytype(replacement) is bool, f"Expected boolean {replacement=}")
     utils.check_type(seed, (int, type(None)))
 
     utils.check(
         input.numel != 0,
         lambda: f"Expected probability weights to be non-empty",
     )
@@ -2905,30 +2981,37 @@
 
 
 def flip_meta(a: TensorProxy, /, dims: Sequence[int]) -> TensorProxy:
     # Check types
     utils.check_type(a, TensorProxy)
     utils.check_type(dims, Sequence)
     utils.check(
-        all(isinstance(d, int) and 0 <= d < a.ndim for d in dims),
+        all(
+            (
+                0 <= d < a.ndim
+                if isinstance(d, (int, IntegerProxy))
+                else isinstance(d, IntegerProxy) and 0 <= pyval(d) < a.ndim
+            )
+            for d in dims
+        ),
         lambda: f"Expected {dims=} to be a sequence of integers in [0, {a.ndim} - 1]",
     )
 
     utils.check_no_duplicates(dims)
 
     return TensorProxy(like=a)
 
 
 flip = make_prim(PrimIDs.FLIP, "flip", meta=flip_meta)
 
 
 def pad_meta(a: TensorProxy, /, padding_value: Number, padding_config: Sequence[tuple[int, int, int]]) -> TensorProxy:
     # Validates types
     utils.check_type(a, TensorProxy)
-    utils.check_type(padding_value, Number)
+    utils.check_type(padding_value, (Number, NumberProxy))
     utils.check_type(padding_config, Sequence)
 
     # Validates input properties
     utils.check(a.ndim == len(padding_config), lambda: f"Expected {a.ndim=} to equal {len(padding_config)=}")
     utils.check_same_dtype(a, padding_value)
 
     shape = []
@@ -3054,15 +3137,15 @@
 
 squeeze = make_prim(PrimIDs.SQUEEZE, "squeeze", meta=squeeze_meta, tags=(OpTags.SHAPE_OP,))
 
 
 def take_meta(a: TensorProxy, /, index: TensorProxy, dim: int) -> TensorProxy:
     utils.check_type(a, TensorProxy)
     utils.check_type(index, TensorProxy)
-    utils.check_type(dim, int)
+    utils.check_type(dim, (int, IntegerProxy))
     utils.check_same_device(a, index)
     utils.check(utils.is_integer_dtype(index.dtype), lambda: f"index dtype={index.dtype} was not an integer dtype")
     utils.check(index.ndim <= 1, lambda: f"Expected index to a 1-D or 0-D tensor, but index.ndim={index.ndim}!")
     utils.validate_idx(a.ndim, dim)
 
     utils.check(
         not (a.shape[dim] == 0 and index.numel > 0),
@@ -3079,15 +3162,15 @@
 
 
 # TODO We should be consistent using 'index' or 'indices'
 def index_add_meta(a: TensorProxy, /, index: TensorProxy, value: TensorProxy, dim: int) -> TensorProxy:
     utils.check_type(a, TensorProxy)
     utils.check_type(index, TensorProxy)
     utils.check_type(value, TensorProxy)
-    utils.check_type(dim, int)
+    utils.check_type(dim, (int, IntegerProxy))
     utils.check_same_device(a, index, value)
     utils.check_same_dtype(a, value)
     utils.check(utils.is_integer_dtype(index.dtype), lambda: f"index dtype={index.dtype} was not an integer dtype")
     utils.check(
         value.ndim == a.ndim, lambda: f"Expected index (rank={value.ndim}) to have the same rank as a (rank={a.ndim})"
     )
     utils.check(index.ndim <= 1, lambda: f"Expected index to a 1-D or 0-D tensor, but index.ndim={index.ndim}!")
@@ -3140,15 +3223,15 @@
 
 index_put = make_prim(PrimIDs.INDEX_PUT, "index_put", meta=index_put_meta)
 
 
 def take_along_axis_meta(a: TensorProxy, /, index: TensorProxy, dim: int) -> TensorProxy:
     utils.check_type(a, TensorProxy)
     utils.check_type(index, TensorProxy)
-    utils.check_type(dim, int)
+    utils.check_type(dim, (int, IntegerProxy))
     utils.check_same_device(a, index)
     utils.check(utils.is_integer_dtype(index.dtype), lambda: f"index dtype={dtype} was not an integer dtype")
     utils.check(
         index.ndim == a.ndim, lambda: f"Expected index (rank={index.ndim}) to have the same rank as a (rank={a.ndim})"
     )
     utils.validate_idx(a.ndim, dim)
 
@@ -3162,15 +3245,15 @@
 
 take_along_axis = make_prim(PrimIDs.TAKE_ALONG_AXIS, "take_along_axis", meta=take_along_axis_meta)
 
 
 def gather_meta(a: TensorProxy, /, index: TensorProxy, dim: int) -> TensorProxy:
     utils.check_type(a, TensorProxy)
     utils.check_type(index, TensorProxy)
-    utils.check_type(dim, int)
+    utils.check_type(dim, (int, IntegerProxy))
     utils.check_same_device(a, index)
     utils.check(utils.is_integer_dtype(index.dtype), lambda: f"index dtype={index.dtype} was not an integer dtype")
     utils.check(
         index.ndim == a.ndim, lambda: f"Expected index (rank={index.ndim}) to have the same rank as a (rank={a.ndim})"
     )
     utils.validate_idx(a.ndim, dim)
 
@@ -3186,15 +3269,15 @@
 gather = make_prim(PrimIDs.GATHER, "gather", meta=gather_meta)
 
 
 def scatter_add_meta(a: TensorProxy, /, index: TensorProxy, value: TensorProxy, dim: int) -> TensorProxy:
     utils.check_type(a, TensorProxy)
     utils.check_type(index, TensorProxy)
     utils.check_type(value, TensorProxy)
-    utils.check_type(dim, int)
+    utils.check_type(dim, (int, IntegerProxy))
     utils.check_same_device(a, index, value)
     utils.check_same_dtype(a, value)
     utils.check(utils.is_integer_dtype(index.dtype), lambda: f"index dtype={index.dtype} was not an integer dtype")
     utils.check(
         index.ndim == a.ndim, lambda: f"Expected index (rank={index.ndim}) to have the same rank as a (rank={a.ndim})"
     )
     utils.check(
@@ -3225,16 +3308,16 @@
 ) -> (TensorProxy, TensorProxy):
     utils.check(
         out is None,
         lambda: "Only `out` which is None is currently supported",
     )
 
     utils.check_type(a, TensorProxy)
-    utils.check_type(k, int)
-    utils.check_type(dim, int)
+    utils.check_type(k, (int, IntegerProxy))
+    utils.check_type(dim, (int, IntegerProxy))
     utils.check(pytype(largest) is bool, lambda: f"Expected {largest=} to be a boolean value")
     utils.check(pytype(sorted) is bool, lambda: f"Expected {sorted=} to be a boolean value")
 
     utils.check(k >= 0 and k <= (a.shape[dim] if a.ndim > 0 else 1), lambda: f"selected index {k=} is out of range")
 
     new_shape = a.shape
     if a.ndim > 0:
@@ -3366,15 +3449,15 @@
 #       to return co-ordinate indices which can actually be used for indexing.
 #       For now, we stick to reducing over only 1 dimension like other frameworks.
 def _argmin_argmax_meta(a: TensorProxy, /, dim: int | None) -> TensorProxy:
     """Meta function for argmax and argmin."""
 
     # Validates types
     utils.check_type(a, TensorProxy)
-    utils.check_type(dim, (int, NoneType))
+    utils.check_type(dim, (int, IntegerProxy, NoneType))
 
     if a.numel == 0:
         utils.check(dim is not None, lambda: f"Expected reduction dim to be specified for a.numel() == 0.")
 
     if dim is not None and a.ndim > 0:
         utils.check(a.shape[dim], lambda: f"Expected reduction dim {dim} to have non-zero size.")
 
@@ -3394,15 +3477,15 @@
 # NOTE var doesn't use _reduction_meta because it has the correction parameter
 # TODO Add output_dtype?
 # TODO Check that dims is a sequence of integers
 def _var_meta(a: TensorProxy, /, dims: Sequence[int], *, correction: Number) -> TensorProxy:
     # Checks input types
     utils.check_type(a, TensorProxy)
     utils.check_type(dims, Sequence)
-    utils.check_type(correction, Number)
+    utils.check_type(correction, (Number, NumberProxy))
 
     output_dtype = None
     if utils.is_complex_dtype(a.dtype):
         output_dtype = utils.corresponding_real_dtype(a.true_dtype)
     else:
         output_dtype = a.true_dtype
 
@@ -3577,15 +3660,15 @@
 ) -> TensorProxy:
     # Validate types {
     utils.check_type(a, TensorProxy)
     utils.check_type(weight, TensorProxy)
     utils.check_type(bias, (TensorProxy, type(None)))
     utils.check_same_dtype(a, weight, *([bias] if bias is not None else []))
     utils.check(pytype(transposed) is bool, lambda: f"Expected {transposed=} to be a boolean value")
-    utils.check_type(groups, int)
+    utils.check_type(groups, (int, IntegerProxy))
     # }
 
     # Validate device {
     utils.check_same_device(a, weight, *([bias] if bias is not None else []))
     # }
 
     # TODO: add support for these later {
@@ -3639,29 +3722,29 @@
         utils.check_type(seq, Sequence)
 
         utils.check(len(seq) == 1 or len(seq) == rank, lambda: f"len({seq_str_name}) should be either 1 or {rank}")
 
         # Check all elements are >= min_val
         for i, e in enumerate(seq):
             utils.check(
-                isinstance(e, int) and e >= min_val,
+                isinstance(e, (int, IntegerProxy)) and e >= min_val,
                 lambda: f"all elements in {seq_str_name} should be integers at least {min_val}, "
                 f"but {seq_str_name}[{i}]={seq[i]} does not satisfy these requirements",
             )
 
     # stride and dilation should be at least 1
     check_sequence(stride, "stride", features_rank, min_val=1)
     check_sequence(dilation, "dilation", features_rank, min_val=1)
     # paddings should be non-negative
     check_sequence(padding, "padding", features_rank, min_val=0)
     check_sequence(output_padding, "output_padding", features_rank, min_val=0)
 
     # Expand sequences to features_rank len if needed.
     def maybe_expand_seq(seq, ndim):
-        if isinstance(seq, int):
+        if isinstance(seq, (int, IntegerProxy)):
             return (seq,) * ndim
         elif len(seq) == 1:
             return (seq[0],) * ndim
         else:
             return tuple(seq)
 
     # Let's expand sequence inputs to match features_rank
```

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/core/profile.py` & `lightning_thunder-0.2.0.dev20240519/thunder/core/profile.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/core/proxies.py` & `lightning_thunder-0.2.0.dev20240519/thunder/core/proxies.py`

 * *Files 6% similar despite different names*

```diff
@@ -587,15 +587,15 @@
     #
     # Elementwise unary operators
     #
 
     # name is the name of the operation in the number language context to perform
     # fn is the function to call if executing outside a language context
     @staticmethod
-    def _elementwise_unary_helper(a, name, fn):
+    def _elementwise_unary_helper(a, name, fn, type_promotion_kind=None):
         trace: None | TraceCtx = get_tracectx()
 
         langctx: None | LanguageContext
         try:
             langctx = get_langctx()
         except LookupError as le:
             langctx = None
@@ -622,14 +622,17 @@
         #   in the near future. It fallsback to executing the operation using the Python interpreter
         #   if no method can be found.
         try:
             method = resolve_method(name, a)
         except Exception as e:
             return fn(vala)
 
+        if method is None:
+            return fn(vala)
+
         return method(a)
 
     def __abs__(self):
         return self._elementwise_unary_helper(self, "abs", builtins.abs)
 
     # See https://docs.python.org/3/reference/datamodel.html#object.__ceil__
     def __ceil__(self):
@@ -657,16 +660,16 @@
         return self._elementwise_unary_helper(self, "trunc", math.trunc)
 
     #
     # Elementwise binary operators
     #
 
     @staticmethod
-    def _elementwise_binary_helper(a, b, name, fn):
-        baseutils.check_type(b, (Number, TensorProxy))
+    def _elementwise_binary_helper(a, b, name, fn, type_promotion_kind=None):
+        baseutils.check_type(b, (Number, NumberProxy, TensorProxy))
 
         vala = pyval(a)
         valb = pyval(b) if isinstance(b, NumberProxy) else b
 
         trace: None | TraceCtx = get_tracectx()
         if trace is None:
             # Outside of a trace or language context, binary operations on NumberProxies are
@@ -680,15 +683,23 @@
         # NOTE not using_jit
         #   This is a legacy path to temporarily support developing older components, and will be removed
         #   in the near future
         if isinstance(b, TensorProxy):
             tensor_fn = resolve_method(name, a, b)
             return tensor_fn(a, b)
 
-        return fn(vala, valb)
+        try:
+            method = resolve_method(name, a, b)
+        except Exception as e:
+            return fn(vala, valb)
+
+        if method is None:
+            return fn(vala, valb)
+
+        return method(a, b)
 
     def __add__(self, other):
         return self._elementwise_binary_helper(self, other, "add", operator.add)
 
     def __radd__(self, other):
         return self._elementwise_binary_helper(other, self, "add", operator.add)
 
@@ -745,38 +756,62 @@
 
     def __rand__(self, other):
         return self._elementwise_binary_helper(other, self, "bitwise_and", operator.and_)
 
     def __eq__(self, other):
         # NOTE This short-circuit allows queries like a == (), which is a valid comparison
         #   for a number in Python
-        if not isinstance(other, Number):
+        if not isinstance(other, (Number, NumberProxy)):
             return False
 
-        return self._elementwise_binary_helper(self, other, "eq", operator.eq)
+        from thunder.core.utils import ELEMENTWISE_TYPE_PROMOTION_KIND
+
+        return self._elementwise_binary_helper(
+            self, other, "eq", operator.eq, ELEMENTWISE_TYPE_PROMOTION_KIND.ALWAYS_BOOL
+        )
 
     def __ge__(self, other):
-        return self._elementwise_binary_helper(self, other, "ge", operator.ge)
+        from thunder.core.utils import ELEMENTWISE_TYPE_PROMOTION_KIND
+
+        return self._elementwise_binary_helper(
+            self, other, "ge", operator.ge, ELEMENTWISE_TYPE_PROMOTION_KIND.ALWAYS_BOOL
+        )
 
     def __gt__(self, other):
-        return self._elementwise_binary_helper(self, other, "gt", operator.gt)
+        from thunder.core.utils import ELEMENTWISE_TYPE_PROMOTION_KIND
+
+        return self._elementwise_binary_helper(
+            self, other, "gt", operator.gt, ELEMENTWISE_TYPE_PROMOTION_KIND.ALWAYS_BOOL
+        )
 
     def __le__(self, other):
-        return self._elementwise_binary_helper(self, other, "le", operator.le)
+        from thunder.core.utils import ELEMENTWISE_TYPE_PROMOTION_KIND
+
+        return self._elementwise_binary_helper(
+            self, other, "le", operator.le, ELEMENTWISE_TYPE_PROMOTION_KIND.ALWAYS_BOOL
+        )
 
     def __lt__(self, other):
-        return self._elementwise_binary_helper(self, other, "lt", operator.lt)
+        from thunder.core.utils import ELEMENTWISE_TYPE_PROMOTION_KIND
+
+        return self._elementwise_binary_helper(
+            self, other, "lt", operator.lt, ELEMENTWISE_TYPE_PROMOTION_KIND.ALWAYS_BOOL
+        )
 
     def __ne__(self, other):
         # NOTE This short-circuit allows queries like a != (), which is a valid comparison
         #   for a number in Python
-        if not isinstance(other, Number):
+        if not isinstance(other, (Number, NumberProxy)):
             return True
 
-        return self._elementwise_binary_helper(self, other, "ne", operator.ne)
+        from thunder.core.utils import ELEMENTWISE_TYPE_PROMOTION_KIND
+
+        return self._elementwise_binary_helper(
+            self, other, "ne", operator.ne, ELEMENTWISE_TYPE_PROMOTION_KIND.ALWAYS_BOOL
+        )
 
     # NOTE This is a bitwise or triggered by the | operator
     # See https://docs.python.org/3/reference/datamodel.html#object.__or__
     def __or__(self, other):
         return self._elementwise_binary_helper(self, other, "bitwise_or", operator.or_)
 
     def __ror__(self, other):
@@ -881,78 +916,66 @@
         return NotImplemented
 
     def __ixor__(self, other):
         return NotImplemented
 
 
 def pyval(x: Number | str | AnyProxy) -> Number | str | any:
-    baseutils.check_type(x, (Number, str, AnyProxy))
+    baseutils.check_type(x, (NumberProxy, Number, str, AnyProxy))
 
     if isinstance(x, AnyProxy):
         return x._o
 
     if isinstance(x, (NumberProxy, StringProxy)):
         return x.value
 
     return x
 
 
 def pytype(x: Proxy) -> type | None:
     if isinstance(x, AnyProxy):
         return type(x._o)
 
-    if isinstance(x, complex):
+    if isinstance(x, (complex, ComplexProxy)):
         return complex
-    if isinstance(x, float):
+    if isinstance(x, (float, FloatProxy)):
         return float
     if isinstance(x, bool):
         return bool
     if isinstance(x, IntegerProxy) and x.python_type is bool:
         return bool
-    if isinstance(x, int):
+    if isinstance(x, (int, IntegerProxy)):
         return int
     if isinstance(x, str):
         return str
     if isinstance(x, tuple):
         return tuple
     if isinstance(x, list):
         return list
     if isinstance(x, dict):
         return dict
 
 
 # TODO RC1 Update Proxy number inits to be value, /, *, name, history
-class ComplexProxy(NumberProxy, complex):
-    def __new__(cls, *, name=None, value, history: None | tuple = None):
-        if value is None:
-            value = complex(float("nan"), float("nan"))
-
-        return complex.__new__(cls, value)
-
+class ComplexProxy(NumberProxy):
     def __init__(self, name=None, value=None, history: None | tuple = None):
         NumberProxy.__init__(self, name=name, value=value, python_type=complex, history=history)
 
     def replace_name(self, name):
         """Return a copy of this proxy with the given name."""
         return ComplexProxy(name=name, value=self.value)
 
     def type_string(self):
         value_str = f"{self.value}" if self.value is not None else "?"
         return f"complex {value_str}"
 
 
 # TODO Review dtype conversions
 # TODO Review -9999 as the marker value for unknown values
-class IntegerProxy(NumberProxy, int):
-    def __new__(cls, *, name: str | None = None, value: Number, history: None | tuple = None):
-        if value is None:
-            value = -9999
-
-        return int.__new__(cls, value)
-
+class IntegerProxy(NumberProxy):
     def __init__(self, name: str | None = None, value=None, history: None | tuple = None):
         # NOTE bools are also integers in Python
         python_type = bool if isinstance(value, bool) else int
         NumberProxy.__init__(self, name=name, value=value, python_type=python_type, history=history)
 
     def replace_name(self, name):
         """Return a copy of this proxy with the given name."""
@@ -964,23 +987,20 @@
         return f"{type_str} {value_str}"
 
     def __repr__(self):
         if self.python_type is bool:
             return f"[IntegerProxy (bool type) name={self.name}, value={self.value}]"
         return f"[IntegerProxy name={self.name}, value={self.value}]"
 
+    def __index__(self):
+        return self.value
 
-# TODO Review dtype conversions
-class FloatProxy(NumberProxy, float):
-    def __new__(cls, *, name=None, value, history: None | tuple = None):
-        if value is None:
-            value = float("nan")
-
-        return float.__new__(cls, value)
 
+# TODO Review dtype conversions
+class FloatProxy(NumberProxy):
     def __init__(self, name=None, value=None, history: None | tuple = None):
         NumberProxy.__init__(self, name=name, value=value, python_type=float, history=history)
 
     def replace_name(self, name):
         """Return a copy of this proxy with the given name."""
         return FloatProxy(name=name, value=self.value)
 
@@ -1001,20 +1021,22 @@
 def _infer_tensor_properties(
     like: TensorProxy | FutureTensorProxy | None = None,
     shape: ShapeLike | None = None,
     device: devices.Device | None = None,
     dtype: dtypes.dtype | None = None,
     requires_grad: bool | None = None,
     ddp_type: DDPType | None = None,
+    thunder_fsdp_padding_size: int | None = None,
 ):
     _shape = None
     _device = None
     _dtype = None
     _requires_grad: None | bool = None
     _ddp_type = DDPType.NONE
+    _thunder_fsdp_padding_size = None
 
     if like is not None:
         baseutils.check_type(like, (TensorProxy, FutureTensorProxy))
         _shape = tuple(like.shape)
         _device = like.device
         _dtype = like.true_dtype
         _requires_grad = like.requires_grad
@@ -1026,14 +1048,17 @@
     _shape = tuple(shape) if shape is not None else _shape
     _device = device if device is not None else _device
     _dtype = dtype if dtype is not None else _dtype
     _dtype = dtypes.numbertype_to_dtype(_dtype) if dtypes.is_numbertype(_dtype) else _dtype
     _requires_grad = requires_grad if requires_grad is not None else _requires_grad
     _requires_grad = False if not dtypes.is_inexact_dtype(_dtype) else _requires_grad
     _ddp_type = ddp_type if ddp_type is not None else _ddp_type
+    _thunder_fsdp_padding_size = (
+        thunder_fsdp_padding_size if thunder_fsdp_padding_size is not None else _thunder_fsdp_padding_size
+    )
 
     # Extracts actual values for shape
     # TODO RC1 Enable this
     if using_symbolic_values():
         raise NotImplementedError(
             f"Trying to construct a tensor proxy while using symbolic values, but this is not yet supported"
         )
@@ -1047,21 +1072,30 @@
     _ndim = len(_shape)
 
     # Validates inputs
     baseutils.check_type(_device, devices.Device)
     baseutils.check_type(_dtype, dtypes.dtype)
     baseutils.check_type(_requires_grad, bool)
     baseutils.check_type(_ddp_type, DDPType)
+    if isinstance(_thunder_fsdp_padding_size, int):
+        baseutils.check(
+            _ddp_type == DDPType.FULLY_SHARDED,
+            lambda: f"{_ddp_type = } and {_thunder_fsdp_padding_size = } do not work",
+        )
+        baseutils.check(
+            _thunder_fsdp_padding_size > 0,
+            lambda: f"{_thunder_fsdp_padding_size=} expected to be > 0 or `None`",
+        )
 
     # NOTE for simplicity functions that want to reason about weak dtypes should explicitly request
     #   the true_dtype property
     _true_dtype = _dtype
     _dtype = dtypes.to_strong_dtype(_dtype)
 
-    return _shape, _device, _dtype, _true_dtype, _numel, _ndim, _requires_grad, _ddp_type
+    return _shape, _device, _dtype, _true_dtype, _numel, _ndim, _requires_grad, _ddp_type, _thunder_fsdp_padding_size
 
 
 # NOTE A FutureTensorProxy is intentionally NOT a subclass of TensorProxy
 class FutureTensorProxy(Proxy, TensorProxyInterface):
     def __init__(
         self,
         name: str | None = None,
@@ -1080,15 +1114,16 @@
             self._shape,
             self._device,
             self._dtype,
             self._true_dtype,
             self._numel,
             self._ndim,
             self._requires_grad,
-            _,
+            _,  # ddp_type
+            _,  # thunder_fsdp_padding_size
         ) = _infer_tensor_properties(
             like,
             shape,
             device,
             dtype,
             False,
         )
@@ -1148,27 +1183,29 @@
         shape: ShapeLike | None = None,
         device: devices.Device | None = None,
         dtype: dtypes.dtype | None = None,
         requires_grad: bool | None = None,
         prefix: None | str = None,
         ddp_type: DDPType | None = None,
         history: None | tuple = None,
+        thunder_fsdp_padding_size: int | None = None,
     ):
         super().__init__(name, prefix=prefix, history=history)
 
         (
             self._shape,
             self._device,
             self._dtype,
             self._true_dtype,
             self._numel,
             self._ndim,
             self._requires_grad,
             self._ddp_type,
-        ) = _infer_tensor_properties(like, shape, device, dtype, requires_grad, ddp_type)
+            self._thunder_fsdp_padding_size,
+        ) = _infer_tensor_properties(like, shape, device, dtype, requires_grad, ddp_type, thunder_fsdp_padding_size)
 
     # NOTE The following properties DO NOT depend on the language context or record
     #   themselves into the trace, so they can be used when working with tensor proxies
     #   outside of a trace or language context
     @property
     def shape(self):
         return self._shape
@@ -1193,14 +1230,18 @@
     def requires_grad(self):
         return self._requires_grad
 
     @property
     def ddp_type(self):
         return self._ddp_type
 
+    @property
+    def thunder_fsdp_padding_size(self):
+        return self._thunder_fsdp_padding_size
+
     # We need to implement `__len__` as
     # > In addition to bypassing any instance attributes in the
     # > interest of correctness, implicit special method lookup
     # > generally also bypasses the __getattribute__() method
     # > even of the object’s metaclass
     # Ref: https://docs.python.org/3/reference/datamodel.html#special-method-lookup
     def __len__(self):
@@ -1494,23 +1535,25 @@
 
 
 def tensorproxy(t: torch.Tensor, /, *, name: None | str, history: None | tuple = None) -> TensorProxy:
     device = devices.device_from_string(str(t.device))
     dtype = dtypes.to_dtype(t.dtype)
     # See Note [DistributedDataParallel and ddp_type]
     ddp_type = getattr(t, "ddp_type", None)
+    _thunder_fsdp_padding_size = getattr(t, "_thunder_fsdp_padding_size", None)
     # NOTE Without tuple(t.shape) then the shape would be a torch.Size object
     return TensorProxy(
         name,
         shape=tuple(t.shape),
         device=device,
         dtype=dtype,
         requires_grad=t.requires_grad,
         ddp_type=ddp_type,
         history=history,
+        thunder_fsdp_padding_size=_thunder_fsdp_padding_size,
     )
 
 
 def futuretensorproxy(
     t: torch.Tensor | TensorProxy | FutureTensorProxy, /, *, name: None | str, history: None | tuple = None
 ) -> FutureTensorProxy:
     device = devices.device_from_string(str(t.device))
```

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/core/pytree.py` & `lightning_thunder-0.2.0.dev20240519/thunder/core/pytree.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/core/rematerialization.py` & `lightning_thunder-0.2.0.dev20240519/thunder/core/rematerialization.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/core/symbol.py` & `lightning_thunder-0.2.0.dev20240519/thunder/core/symbol.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/core/trace.py` & `lightning_thunder-0.2.0.dev20240519/thunder/core/trace.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/core/transform_common.py` & `lightning_thunder-0.2.0.dev20240519/thunder/core/transform_common.py`

 * *Files 11% similar despite different names*

```diff
@@ -29,14 +29,60 @@
 
         _remove_noop_subsymbols(sbsym)
         nsbsyms.append(sbsym)
 
     bsym.subsymbols = nsbsyms
 
 
+def _inplace_copy_sanity_check(extrace: Trace):
+    """The sanity check is based on the sharp edge of nvfuser's `add_ouput(output, input)` interface,
+    it makes sure that the `copy_to` argument of `prims.copy_` is not used as input for any of its subsequent operators in a nvFusion fused operator
+
+    Anti-pattern:
+
+    .. code-block:: python
+
+        [t2] = nvFusion0(x, y)
+            # result = prims.mul(x, y)
+            # a = prims.copy_(result, x)
+            # t2 = prims.add(a, y) or t2 = prims.add(x, y)
+
+    Do not use the `copy_to` variable `x` or `a` after it has been updated, use the `copy_from` variable `result` instead to reflect the dependency:
+
+    .. code-block:: python
+
+        [t2] = nvFusion0(x, y)
+            # result = prims.mul(x, y)
+            # a = prims.copy_(result, x)
+            # t2 = prims.add(result, y)
+    """
+
+    from thunder.core.utils import consumers
+
+    nvfuser_symbols = (bsym for bsym in extrace.bound_symbols if bsym.sym.name.startswith("nvFusion"))
+    for bsym in nvfuser_symbols:
+        consumer_dict = consumers(list(bsym.subsymbols), _map_to_numbers=True)
+        inplace_copy_idx = ((idx, sym) for idx, sym in enumerate(bsym.subsymbols) if sym.sym.id == prims.PrimIDs.COPY_)
+        for idx, subbsym in inplace_copy_idx:
+            copy_to_arg = subbsym.flat_args[1]
+            copy_to_out = subbsym.output
+
+            def check(inp, log_str):
+                if inp is not None and inp in consumer_dict:
+                    last_used_idx = max(consumer_dict[inp])
+                    if last_used_idx > idx:
+                        raise NotImplementedError(
+                            f"{bsym.subsymbols[last_used_idx]} trying to use {inp} (the {log_str} of 'prims.copy_') as input, which is not safe."
+                            f" There is a risk of accessing the wrong memory. If you are sure you don't want to use this check, it can be disabled by setting `disable_inplace_copy_check=True` in `thunder.jit`."
+                        )
+
+            check(copy_to_arg, "'copy_to' argument")
+            check(copy_to_out, "output")
+
+
 # TODO This calls variableify(), but we could directly construct Variable objects instead, which might slightly
 #   improve performance
 # Runs a Dead Code Elimination (DCE) pass
 # NOTE Today we are only interested in computations that produce proxies, so this will eliminate operations
 #   that only produce non-proxy objects
 def dce(trace: Trace) -> Trace:
     start_time_ns = time.time_ns()
```

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/core/transforms.py` & `lightning_thunder-0.2.0.dev20240519/thunder/core/transforms.py`

 * *Files 2% similar despite different names*

```diff
@@ -2607,6210 +2607,6237 @@
 0000a2e0: 2046 6c61 7474 656e 7320 7468 6520 6f72   Flattens the or
 0000a2f0: 6967 696e 616c 2074 7261 6365 2066 6f72  iginal trace for
 0000a300: 2074 6865 2067 7261 6420 7472 616e 7366   the grad transf
 0000a310: 6f72 6d20 2d2d 2065 6e73 7569 6e67 2074  orm -- ensuing t
 0000a320: 6861 7420 616c 6c20 746f 702d 6c65 7665  hat all top-leve
 0000a330: 6c20 7379 6d62 6f6c 7320 6861 7665 0a23  l symbols have.#
 0000a340: 2020 2020 2020 2061 2067 7261 6420 6675         a grad fu
-0000a350: 6e63 7469 6f6e 2e0a 6465 6620 6772 6164  nction..def grad
-0000a360: 280a 2020 2020 6366 6e2c 2067 7261 645f  (.    cfn, grad_
-0000a370: 7370 6563 6966 6965 723a 2043 616c 6c61  specifier: Calla
-0000a380: 626c 6520 3d20 5f67 7261 645f 7370 6563  ble = _grad_spec
-0000a390: 6966 6965 725f 6465 6661 756c 742c 2067  ifier_default, g
-0000a3a0: 7261 645f 6f75 745f 7370 6563 6966 6965  rad_out_specifie
-0000a3b0: 723a 2043 616c 6c61 626c 6520 3d20 5f67  r: Callable = _g
-0000a3c0: 7261 645f 6f75 745f 7370 6563 6966 6965  rad_out_specifie
-0000a3d0: 725f 6465 6661 756c 740a 2920 2d3e 2043  r_default.) -> C
-0000a3e0: 616c 6c61 626c 653a 0a20 2020 2023 2043  allable:.    # C
-0000a3f0: 7265 6174 6573 2061 2063 7573 746f 6d20  reates a custom 
-0000a400: 7472 616e 7366 6f72 6d20 6361 6c6c 6162  transform callab
-0000a410: 6c65 2074 6861 7420 6269 6e64 7320 7468  le that binds th
-0000a420: 6520 6164 6469 7469 6f6e 616c 2061 7267  e additional arg
-0000a430: 756d 656e 7473 2074 6f20 7468 6520 6772  uments to the gr
-0000a440: 6164 2074 7261 6e73 666f 726d 0a20 2020  ad transform.   
-0000a450: 2040 6c61 6e67 6374 7828 4c61 6e67 7561   @langctx(Langua
-0000a460: 6765 732e 434c 414e 4729 0a20 2020 2064  ges.CLANG).    d
-0000a470: 6566 205f 6772 6164 5f74 7261 6e73 666f  ef _grad_transfo
-0000a480: 726d 2874 7263 3a20 5472 6163 652c 202a  rm(trc: Trace, *
-0000a490: 2c20 6578 6563 7574 6f72 735f 6c69 7374  , executors_list
-0000a4a0: 3a20 5365 7175 656e 6365 5b41 6e79 5d29  : Sequence[Any])
-0000a4b0: 202d 3e20 5472 6163 653a 0a20 2020 2020   -> Trace:.     
-0000a4c0: 2020 2073 7461 7274 5f74 696d 655f 6e73     start_time_ns
-0000a4d0: 203d 2074 696d 652e 7469 6d65 5f6e 7328   = time.time_ns(
-0000a4e0: 290a 0a20 2020 2020 2020 2023 2053 5445  )..        # STE
-0000a4f0: 5020 4f4e 4520 2d2d 2046 6c61 7474 656e  P ONE -- Flatten
-0000a500: 7320 616e 6420 6463 6573 0a0a 2020 2020  s and dces..    
-0000a510: 2020 2020 2320 5265 7475 726e 7320 5472      # Returns Tr
-0000a520: 7565 2069 6620 7468 6520 6273 796d 2068  ue if the bsym h
-0000a530: 6173 206e 6f20 6772 6164 2066 756e 6374  as no grad funct
-0000a540: 696f 6e2c 2061 6e64 2073 6f20 6d75 7374  ion, and so must
-0000a550: 2062 6520 666c 6174 7465 6e65 6420 666f   be flattened fo
-0000a560: 7220 7468 6520 6772 6164 2074 7261 6e73  r the grad trans
-0000a570: 666f 726d 0a20 2020 2020 2020 206e 6576  form.        nev
-0000a580: 6572 5f66 6c61 7474 656e 3a20 7365 745b  er_flatten: set[
-0000a590: 4861 7368 6162 6c65 5d20 3d20 7b70 7269  Hashable] = {pri
-0000a5a0: 6d73 2e50 7269 6d49 4473 2e52 4554 5552  ms.PrimIDs.RETUR
-0000a5b0: 4e2c 2070 7269 6d73 2e50 7269 6d49 4473  N, prims.PrimIDs
-0000a5c0: 2e55 4e50 4143 4b5f 5452 4956 4941 4c7d  .UNPACK_TRIVIAL}
-0000a5d0: 0a0a 2020 2020 2020 2020 6465 6620 7368  ..        def sh
-0000a5e0: 6f75 6c64 5f66 6c61 7474 656e 5f66 6f72  ould_flatten_for
-0000a5f0: 5f67 7261 6428 6273 796d 3a20 426f 756e  _grad(bsym: Boun
-0000a600: 6453 796d 626f 6c29 202d 3e20 626f 6f6c  dSymbol) -> bool
-0000a610: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
-0000a620: 2062 7379 6d2e 7379 6d2e 6964 2069 6e20   bsym.sym.id in 
-0000a630: 6e65 7665 725f 666c 6174 7465 6e3a 0a20  never_flatten:. 
-0000a640: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-0000a650: 6574 7572 6e20 4661 6c73 650a 0a20 2020  eturn False..   
-0000a660: 2020 2020 2020 2020 2067 7261 6466 6e3a           gradfn:
-0000a670: 204e 6f6e 6520 7c20 4361 6c6c 6162 6c65   None | Callable
-0000a680: 0a20 2020 2020 2020 2020 2020 2067 7261  .            gra
-0000a690: 6466 6e2c 205f 203d 205f 6765 745f 6772  dfn, _ = _get_gr
-0000a6a0: 6164 666e 5f61 6e64 5f65 7865 6375 746f  adfn_and_executo
-0000a6b0: 7228 6273 796d 2c20 6578 6563 7574 6f72  r(bsym, executor
-0000a6c0: 735f 6c69 7374 3d65 7865 6375 746f 7273  s_list=executors
-0000a6d0: 5f6c 6973 7429 0a20 2020 2020 2020 2020  _list).         
-0000a6e0: 2020 2072 6574 7572 6e20 6772 6164 666e     return gradfn
-0000a6f0: 2069 7320 4e6f 6e65 0a0a 2020 2020 2020   is None..      
-0000a700: 2020 2320 544f 444f 2052 4331 3a20 6d61    # TODO RC1: ma
-0000a710: 7962 6520 6d6f 7665 2074 6f20 7072 6f64  ybe move to prod
-0000a720: 7563 6520 7468 6573 6520 616c 7761 7973  uce these always
-0000a730: 206f 6e20 6372 6561 7469 6f6e 0a20 2020   on creation.   
-0000a740: 2020 2020 2069 6620 7472 632e 6b77 6172       if trc.kwar
-0000a750: 6773 2069 7320 4e6f 6e65 3a0a 2020 2020  gs is None:.    
-0000a760: 2020 2020 2020 2020 7472 632e 6b77 6172          trc.kwar
-0000a770: 6773 203d 207b 7d0a 2020 2020 2020 2020  gs = {}.        
-0000a780: 6966 2074 7263 2e66 6e20 6973 204e 6f6e  if trc.fn is Non
-0000a790: 653a 0a20 2020 2020 2020 2020 2020 2074  e:.            t
-0000a7a0: 7263 2e66 6e20 3d20 7472 632e 7079 7468  rc.fn = trc.pyth
-0000a7b0: 6f6e 5f63 616c 6c61 626c 6528 290a 0a20  on_callable().. 
-0000a7c0: 2020 2020 2020 2067 7261 6474 7263 203d         gradtrc =
-0000a7d0: 2066 726f 6d5f 7472 6163 6528 7472 6329   from_trace(trc)
-0000a7e0: 0a20 2020 2020 2020 2066 6c61 7474 656e  .        flatten
-0000a7f0: 6564 5f62 7379 6d73 3a20 6c69 7374 5b42  ed_bsyms: list[B
-0000a800: 6f75 6e64 5379 6d62 6f6c 5d20 3d20 666c  oundSymbol] = fl
-0000a810: 6174 7465 6e5f 666f 725f 7472 616e 7366  atten_for_transf
-0000a820: 6f72 6d28 7368 6f75 6c64 5f66 6c61 7474  orm(should_flatt
-0000a830: 656e 5f66 6f72 5f67 7261 642c 2074 7263  en_for_grad, trc
-0000a840: 2e62 6f75 6e64 5f73 796d 626f 6c73 290a  .bound_symbols).
-0000a850: 2020 2020 2020 2020 6772 6164 7472 632e          gradtrc.
-0000a860: 626f 756e 645f 7379 6d62 6f6c 7320 3d20  bound_symbols = 
-0000a870: 666c 6174 7465 6e65 645f 6273 796d 730a  flattened_bsyms.
-0000a880: 2020 2020 2020 2020 6772 6164 7472 6320          gradtrc 
-0000a890: 3d20 6463 6528 6772 6164 7472 6329 0a0a  = dce(gradtrc)..
-0000a8a0: 2020 2020 2020 2020 2320 5354 4550 2054          # STEP T
-0000a8b0: 574f 202d 2d20 5265 706c 6163 6573 206f  WO -- Replaces o
-0000a8c0: 7269 6769 6e61 6c20 6361 6c6c 7320 7769  riginal calls wi
-0000a8d0: 7468 2067 7261 6420 6361 6c6c 730a 0a20  th grad calls.. 
-0000a8e0: 2020 2020 2020 2023 2044 6566 696e 6573         # Defines
-0000a8f0: 2074 6865 2076 6973 6974 6f72 2070 6174   the visitor pat
-0000a900: 7465 726e 2066 6f72 2074 6865 2066 6972  tern for the fir
-0000a910: 7374 2070 6173 7320 6f66 2074 6865 2067  st pass of the g
-0000a920: 7261 6420 7472 616e 7366 6f72 6d2c 0a20  rad transform,. 
-0000a930: 2020 2020 2020 2023 2020 2077 6869 6368         #   which
-0000a940: 2073 7761 7073 2042 6f75 6e64 5379 6d62   swaps BoundSymb
-0000a950: 6f6c 7320 7769 7468 2074 6865 6972 2067  ols with their g
-0000a960: 7261 6420 6675 6e63 7469 6f6e 730a 2020  rad functions.  
-0000a970: 2020 2020 2020 6465 6620 7669 7369 745f        def visit_
-0000a980: 2862 7379 6d3a 2042 6f75 6e64 5379 6d62  (bsym: BoundSymb
-0000a990: 6f6c 2920 2d3e 2043 616c 6c61 626c 653a  ol) -> Callable:
-0000a9a0: 0a20 2020 2020 2020 2020 2020 2067 7261  .            gra
-0000a9b0: 6466 6e3a 204e 6f6e 6520 7c20 4361 6c6c  dfn: None | Call
-0000a9c0: 6162 6c65 0a20 2020 2020 2020 2020 2020  able.           
-0000a9d0: 2067 7261 6466 6e2c 205f 203d 205f 6765   gradfn, _ = _ge
-0000a9e0: 745f 6772 6164 666e 5f61 6e64 5f65 7865  t_gradfn_and_exe
-0000a9f0: 6375 746f 7228 6273 796d 2c20 6578 6563  cutor(bsym, exec
-0000aa00: 7574 6f72 735f 6c69 7374 3d65 7865 6375  utors_list=execu
-0000aa10: 746f 7273 5f6c 6973 7429 0a20 2020 2020  tors_list).     
-0000aa20: 2020 2020 2020 2063 6865 636b 280a 2020         check(.  
-0000aa30: 2020 2020 2020 2020 2020 2020 2020 6772                gr
-0000aa40: 6164 666e 2069 7320 6e6f 7420 4e6f 6e65  adfn is not None
-0000aa50: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0000aa60: 2020 6c61 6d62 6461 3a20 6622 4661 696c    lambda: f"Fail
-0000aa70: 6564 2074 6f20 6669 6e64 2061 2067 7261  ed to find a gra
-0000aa80: 6466 6e20 666f 7220 7b62 7379 6d3d 7d20  dfn for {bsym=} 
-0000aa90: 6166 7465 7220 666c 6174 7465 6e69 6e67  after flattening
-0000aaa0: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
-0000aab0: 2020 2065 7863 6570 7469 6f6e 5f74 7970     exception_typ
-0000aac0: 653d 4173 7365 7274 696f 6e45 7272 6f72  e=AssertionError
-0000aad0: 2c0a 2020 2020 2020 2020 2020 2020 290a  ,.            ).
-0000aae0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-0000aaf0: 726e 2067 7261 6466 6e0a 0a20 2020 2020  rn gradfn..     
-0000ab00: 2020 2040 7772 6170 7328 7472 632e 666e     @wraps(trc.fn
-0000ab10: 2e6d 6574 6120 6966 2069 7369 6e73 7461  .meta if isinsta
-0000ab20: 6e63 6528 7472 632e 666e 2c20 5379 6d62  nce(trc.fn, Symb
-0000ab30: 6f6c 2920 656c 7365 2074 7263 2e66 6e29  ol) else trc.fn)
-0000ab40: 0a20 2020 2020 2020 2064 6566 2069 6e74  .        def int
-0000ab50: 6572 7072 6574 696e 675f 666e 282a 6172  erpreting_fn(*ar
-0000ab60: 6773 2c20 2a2a 6b77 6172 6773 293a 0a20  gs, **kwargs):. 
-0000ab70: 2020 2020 2020 2020 2020 2072 6573 756c             resul
-0000ab80: 7420 3d20 6576 616c 5f74 7261 6365 2867  t = eval_trace(g
-0000ab90: 7261 6474 7263 2c20 2a61 7267 732c 2073  radtrc, *args, s
-0000aba0: 796d 626f 6c5f 6d61 7070 6572 3d76 6973  ymbol_mapper=vis
-0000abb0: 6974 5f2c 202a 2a6b 7761 7267 7329 0a20  it_, **kwargs). 
-0000abc0: 2020 2020 2020 2020 2020 2023 2053 6574             # Set
-0000abd0: 7320 6772 6164 7320 666f 7220 6f75 7470  s grads for outp
-0000abe0: 7574 0a20 2020 2020 2020 2020 2020 2023  ut.            #
-0000abf0: 2054 4f44 4f20 5468 6973 2065 6666 6563   TODO This effec
-0000ac00: 7469 7665 6c79 2072 756e 7320 696e 2061  tively runs in a
-0000ac10: 206e 6f20 6772 6164 2063 6f6e 7465 7874   no grad context
-0000ac20: 202d 2d20 7368 6f75 6c64 2069 7420 7275   -- should it ru
-0000ac30: 6e20 696e 2061 2067 7261 6420 636f 6e74  n in a grad cont
-0000ac40: 6578 742c 0a20 2020 2020 2020 2020 2020  ext,.           
-0000ac50: 2023 2020 206f 7220 7368 6f75 6c64 2074   #   or should t
-0000ac60: 6865 7265 2062 6520 7468 6520 6f70 7469  here be the opti
-0000ac70: 6f6e 2074 6f20 7275 6e20 6974 2069 6e20  on to run it in 
-0000ac80: 6120 6772 6164 2063 6f6e 7465 7874 3f0a  a grad context?.
-0000ac90: 2020 2020 2020 2020 2020 2020 6772 6164              grad
-0000aca0: 5f73 7065 6369 6669 6572 2872 6573 756c  _specifier(resul
-0000acb0: 7429 0a20 2020 2020 2020 2020 2020 2023  t).            #
-0000acc0: 2043 6f6e 7374 7275 6374 7320 7265 7475   Constructs retu
-0000acd0: 726e 2076 616c 7565 0a20 2020 2020 2020  rn value.       
-0000ace0: 2020 2020 2066 6c61 745f 6772 6164 7320       flat_grads 
-0000acf0: 3d20 6772 6164 5f6f 7574 5f73 7065 6369  = grad_out_speci
-0000ad00: 6669 6572 2828 6172 6773 2c20 6b77 6172  fier((args, kwar
-0000ad10: 6773 2929 0a20 2020 2020 2020 2020 2020  gs)).           
-0000ad20: 2072 6574 7572 6e20 666c 6174 5f67 7261   return flat_gra
-0000ad30: 6473 0a0a 2020 2020 2020 2020 2320 4e4f  ds..        # NO
-0000ad40: 5445 2041 6674 6572 2074 6869 7320 6361  TE After this ca
-0000ad50: 6c6c 2074 6865 2067 7261 6474 7263 2069  ll the gradtrc i
-0000ad60: 7320 696e 7661 6c69 642c 2062 6563 6175  s invalid, becau
-0000ad70: 7365 3a0a 2020 2020 2020 2020 2320 2020  se:.        #   
-0000ad80: 3129 2054 6865 206e 6f6e 2d65 7865 6375  1) The non-execu
-0000ad90: 7461 626c 6520 7075 745f 6772 6164 206f  table put_grad o
-0000ada0: 7065 7261 7469 6f6e 7320 6172 6520 7374  perations are st
-0000adb0: 696c 6c20 696e 2074 6865 2074 7261 6365  ill in the trace
-0000adc0: 2c20 616e 6420 6d75 6c74 6970 6c65 2063  , and multiple c
-0000add0: 616c 6c73 2074 6f20 7075 7420 6772 6164  alls to put grad
-0000ade0: 2061 7265 206e 6f74 2061 6363 756d 756c   are not accumul
-0000adf0: 6174 6564 0a20 2020 2020 2020 2023 2020  ated.        #  
-0000ae00: 2032 2920 5468 6520 6e6f 6e2d 6578 6563   2) The non-exec
-0000ae10: 7574 6162 6c65 2067 6574 5f67 7261 6420  utable get_grad 
-0000ae20: 6f70 6572 6174 696f 6e73 2061 7265 2073  operations are s
-0000ae30: 7469 6c6c 2069 6e20 7468 6520 7472 6163  till in the trac
-0000ae40: 652c 2061 6e64 2074 6865 7920 6d61 7920  e, and they may 
-0000ae50: 7072 6f64 7563 6520 6469 6666 6572 656e  produce differen
-0000ae60: 7420 7072 6f78 6965 7320 7768 656e 0a20  t proxies when. 
-0000ae70: 2020 2020 2020 2023 2020 2020 2020 2063         #       c
-0000ae80: 616c 6c65 6420 6f6e 2074 6865 2073 616d  alled on the sam
-0000ae90: 6520 696e 7075 7473 0a20 2020 2020 2020  e inputs.       
-0000aea0: 2023 2020 2033 2920 5468 6520 6f70 6572   #   3) The oper
-0000aeb0: 6174 696f 6e73 2061 7265 206e 6f74 2069  ations are not i
-0000aec0: 6e20 6120 7661 6c69 6420 6f72 6465 720a  n a valid order.
-0000aed0: 2020 2020 2020 2020 6772 6164 7472 6320          gradtrc 
-0000aee0: 3d20 636f 6e73 7472 7563 745f 7472 6163  = construct_trac
-0000aef0: 6528 0a20 2020 2020 2020 2020 2020 2072  e(.            r
-0000af00: 656e 616d 655f 7072 6f78 6965 733d 4661  ename_proxies=Fa
-0000af10: 6c73 652c 0a20 2020 2020 2020 2020 2020  lse,.           
-0000af20: 2075 7365 5f64 6365 3d46 616c 7365 2c0a   use_dce=False,.
-0000af30: 2020 2020 2020 2020 2928 696e 7465 7270          )(interp
-0000af40: 7265 7469 6e67 5f66 6e2c 202a 6772 6164  reting_fn, *grad
-0000af50: 7472 632e 6172 6773 2c20 2a2a 6772 6164  trc.args, **grad
-0000af60: 7472 632e 6b77 6172 6773 290a 2020 2020  trc.kwargs).    
-0000af70: 2020 2020 6772 6164 7472 632e 7363 6f70      gradtrc.scop
-0000af80: 6573 203d 205b 6772 6164 7472 632e 626f  es = [gradtrc.bo
-0000af90: 756e 645f 7379 6d62 6f6c 735d 0a20 2020  und_symbols].   
-0000afa0: 2020 2020 2067 7261 6474 7263 2e5f 636f       gradtrc._co
-0000afb0: 6d70 6c65 7465 203d 2046 616c 7365 0a0a  mplete = False..
-0000afc0: 2020 2020 2020 2020 2320 5354 4550 2054          # STEP T
-0000afd0: 4852 4545 202d 2d20 4861 6e64 6c65 7320  HREE -- Handles 
-0000afe0: 7075 745f 6772 6164 2061 6e64 2067 6574  put_grad and get
-0000aff0: 5f67 7261 6420 6f70 6572 6174 696f 6e73  _grad operations
-0000b000: 2061 6e64 2061 6363 756d 756c 6174 6573   and accumulates
-0000b010: 2067 7261 6469 656e 7473 0a0a 2020 2020   gradients..    
-0000b020: 2020 2020 2320 4163 6375 6d75 6c61 7465      # Accumulate
-0000b030: 7320 6772 6164 6965 6e74 732c 2063 7265  s gradients, cre
-0000b040: 6174 696e 6720 7468 6520 7072 696d 616c  ating the primal
-0000b050: 202d 3e20 6163 6375 6d75 6c61 7465 6420   -> accumulated 
-0000b060: 6772 6164 206d 6170 7069 6e67 0a20 2020  grad mapping.   
-0000b070: 2020 2020 2023 2053 6574 7320 7468 6520       # Sets the 
-0000b080: 7472 6163 696e 6720 636f 6e74 6578 7420  tracing context 
-0000b090: 736f 2061 6363 756d 756c 6174 696f 6e20  so accumulation 
-0000b0a0: 6f70 6572 6174 696f 6e73 2061 7265 2072  operations are r
-0000b0b0: 6563 6f72 6465 6420 696e 746f 2074 6865  ecorded into the
-0000b0c0: 2074 7261 6365 0a20 2020 2020 2020 2074   trace.        t
-0000b0d0: 7279 3a0a 2020 2020 2020 2020 2020 2020  ry:.            
-0000b0e0: 7472 6163 6563 7478 5f74 6f6b 203d 2073  tracectx_tok = s
-0000b0f0: 6574 5f74 7261 6365 6374 7828 6772 6164  et_tracectx(grad
-0000b100: 7472 6329 0a0a 2020 2020 2020 2020 2020  trc)..          
-0000b110: 2020 2320 4d61 7073 2070 7269 6d61 6c73    # Maps primals
-0000b120: 2074 6f20 7468 6569 7220 6772 6164 6965   to their gradie
-0000b130: 6e74 7320 2877 6869 6368 2061 7265 2072  nts (which are r
-0000b140: 6574 7572 6e65 6420 6672 6f6d 2063 616c  eturned from cal
-0000b150: 6c69 6e67 2067 6574 5f67 7261 6420 6f6e  ling get_grad on
-0000b160: 2074 6865 2070 7269 6d61 6c29 0a20 2020   the primal).   
-0000b170: 2020 2020 2020 2020 2070 7269 6d61 6c73           primals
-0000b180: 5f74 6f5f 6769 6e70 7574 5f6d 6170 3a20  _to_ginput_map: 
-0000b190: 6469 6374 5b56 6172 6961 626c 652c 2054  dict[Variable, T
-0000b1a0: 656e 736f 7250 726f 7879 5d20 3d20 7b7d  ensorProxy] = {}
-0000b1b0: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-0000b1c0: 4861 6e64 6c65 7320 7075 745f 6772 6164  Handles put_grad
-0000b1d0: 206f 7065 7261 7469 6f6e 730a 2020 2020   operations.    
-0000b1e0: 2020 2020 2020 2020 2320 4e4f 5445 2054          # NOTE T
-0000b1f0: 6869 7320 6d6f 6469 6669 6573 2061 206c  his modifies a l
-0000b200: 6973 7420 7468 6174 2069 7320 6265 696e  ist that is bein
-0000b210: 6720 656e 756d 6572 6174 6564 206f 7665  g enumerated ove
-0000b220: 722c 2062 7574 2069 7427 7320 4f4b 2062  r, but it's OK b
-0000b230: 6563 6175 7365 2077 6527 7265 206f 6e6c  ecause we're onl
-0000b240: 790a 2020 2020 2020 2020 2020 2020 2320  y.            # 
-0000b250: 2020 6170 7065 6e64 696e 6720 746f 2074    appending to t
-0000b260: 6865 2065 6e64 206f 6620 7468 6520 6c69  he end of the li
-0000b270: 7374 0a20 2020 2020 2020 2020 2020 2062  st.            b
-0000b280: 7379 6d3a 2042 6f75 6e64 5379 6d62 6f6c  sym: BoundSymbol
-0000b290: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
-0000b2a0: 2062 7379 6d20 696e 2067 7261 6474 7263   bsym in gradtrc
-0000b2b0: 2e62 6f75 6e64 5f73 796d 626f 6c73 3a0a  .bound_symbols:.
-0000b2c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b2d0: 6964 3a20 4861 7368 6162 6c65 203d 2062  id: Hashable = b
-0000b2e0: 7379 6d2e 7379 6d2e 6964 0a20 2020 2020  sym.sym.id.     
-0000b2f0: 2020 2020 2020 2020 2020 2069 6620 6964             if id
-0000b300: 2069 7320 7069 6473 2e50 5554 5f47 5241   is pids.PUT_GRA
-0000b310: 443a 0a20 2020 2020 2020 2020 2020 2020  D:.             
-0000b320: 2020 2020 2020 2070 7269 6d61 6c3a 204e         primal: N
-0000b330: 756d 6265 7220 7c20 5465 6e73 6f72 5072  umber | TensorPr
-0000b340: 6f78 790a 2020 2020 2020 2020 2020 2020  oxy.            
-0000b350: 2020 2020 2020 2020 6772 6164 3a20 4e75          grad: Nu
-0000b360: 6d62 6572 207c 2054 656e 736f 7250 726f  mber | TensorPro
-0000b370: 7879 0a20 2020 2020 2020 2020 2020 2020  xy.             
-0000b380: 2020 2020 2020 2070 7269 6d61 6c2c 2067         primal, g
-0000b390: 7261 6420 3d20 6273 796d 2e66 6c61 745f  rad = bsym.flat_
-0000b3a0: 6172 6773 0a0a 2020 2020 2020 2020 2020  args..          
-0000b3b0: 2020 2020 2020 2020 2020 2320 544f 444f            # TODO
-0000b3c0: 2053 7570 706f 7274 2061 7574 6f67 7261   Support autogra
-0000b3d0: 6420 6f6e 206e 756d 6265 7273 0a20 2020  d on numbers.   
+0000a350: 6e63 7469 6f6e 2e0a 6465 6620 5f5f 6772  nction..def __gr
+0000a360: 6164 280a 2020 2020 6366 6e2c 2067 7261  ad(.    cfn, gra
+0000a370: 645f 7370 6563 6966 6965 723a 2043 616c  d_specifier: Cal
+0000a380: 6c61 626c 6520 3d20 5f67 7261 645f 7370  lable = _grad_sp
+0000a390: 6563 6966 6965 725f 6465 6661 756c 742c  ecifier_default,
+0000a3a0: 2067 7261 645f 6f75 745f 7370 6563 6966   grad_out_specif
+0000a3b0: 6965 723a 2043 616c 6c61 626c 6520 3d20  ier: Callable = 
+0000a3c0: 5f67 7261 645f 6f75 745f 7370 6563 6966  _grad_out_specif
+0000a3d0: 6965 725f 6465 6661 756c 740a 2920 2d3e  ier_default.) ->
+0000a3e0: 2043 616c 6c61 626c 653a 0a20 2020 2023   Callable:.    #
+0000a3f0: 2043 7265 6174 6573 2061 2063 7573 746f   Creates a custo
+0000a400: 6d20 7472 616e 7366 6f72 6d20 6361 6c6c  m transform call
+0000a410: 6162 6c65 2074 6861 7420 6269 6e64 7320  able that binds 
+0000a420: 7468 6520 6164 6469 7469 6f6e 616c 2061  the additional a
+0000a430: 7267 756d 656e 7473 2074 6f20 7468 6520  rguments to the 
+0000a440: 6772 6164 2074 7261 6e73 666f 726d 0a20  grad transform. 
+0000a450: 2020 2040 6c61 6e67 6374 7828 4c61 6e67     @langctx(Lang
+0000a460: 7561 6765 732e 434c 414e 4729 0a20 2020  uages.CLANG).   
+0000a470: 2064 6566 205f 6772 6164 5f74 7261 6e73   def _grad_trans
+0000a480: 666f 726d 2874 7263 3a20 5472 6163 652c  form(trc: Trace,
+0000a490: 202a 2c20 6578 6563 7574 6f72 735f 6c69   *, executors_li
+0000a4a0: 7374 3a20 5365 7175 656e 6365 5b41 6e79  st: Sequence[Any
+0000a4b0: 5d29 202d 3e20 5472 6163 653a 0a20 2020  ]) -> Trace:.   
+0000a4c0: 2020 2020 2073 7461 7274 5f74 696d 655f       start_time_
+0000a4d0: 6e73 203d 2074 696d 652e 7469 6d65 5f6e  ns = time.time_n
+0000a4e0: 7328 290a 0a20 2020 2020 2020 2023 2053  s()..        # S
+0000a4f0: 5445 5020 4f4e 4520 2d2d 2046 6c61 7474  TEP ONE -- Flatt
+0000a500: 656e 7320 616e 6420 6463 6573 0a0a 2020  ens and dces..  
+0000a510: 2020 2020 2020 2320 5265 7475 726e 7320        # Returns 
+0000a520: 5472 7565 2069 6620 7468 6520 6273 796d  True if the bsym
+0000a530: 2068 6173 206e 6f20 6772 6164 2066 756e   has no grad fun
+0000a540: 6374 696f 6e2c 2061 6e64 2073 6f20 6d75  ction, and so mu
+0000a550: 7374 2062 6520 666c 6174 7465 6e65 6420  st be flattened 
+0000a560: 666f 7220 7468 6520 6772 6164 2074 7261  for the grad tra
+0000a570: 6e73 666f 726d 0a20 2020 2020 2020 206e  nsform.        n
+0000a580: 6576 6572 5f66 6c61 7474 656e 3a20 7365  ever_flatten: se
+0000a590: 745b 4861 7368 6162 6c65 5d20 3d20 7b70  t[Hashable] = {p
+0000a5a0: 7269 6d73 2e50 7269 6d49 4473 2e52 4554  rims.PrimIDs.RET
+0000a5b0: 5552 4e2c 2070 7269 6d73 2e50 7269 6d49  URN, prims.PrimI
+0000a5c0: 4473 2e55 4e50 4143 4b5f 5452 4956 4941  Ds.UNPACK_TRIVIA
+0000a5d0: 4c7d 0a0a 2020 2020 2020 2020 6465 6620  L}..        def 
+0000a5e0: 7368 6f75 6c64 5f66 6c61 7474 656e 5f66  should_flatten_f
+0000a5f0: 6f72 5f67 7261 6428 6273 796d 3a20 426f  or_grad(bsym: Bo
+0000a600: 756e 6453 796d 626f 6c29 202d 3e20 626f  undSymbol) -> bo
+0000a610: 6f6c 3a0a 2020 2020 2020 2020 2020 2020  ol:.            
+0000a620: 6966 2062 7379 6d2e 7379 6d2e 6964 2069  if bsym.sym.id i
+0000a630: 6e20 6e65 7665 725f 666c 6174 7465 6e3a  n never_flatten:
+0000a640: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000a650: 2072 6574 7572 6e20 4661 6c73 650a 0a20   return False.. 
+0000a660: 2020 2020 2020 2020 2020 2067 7261 6466             gradf
+0000a670: 6e3a 204e 6f6e 6520 7c20 4361 6c6c 6162  n: None | Callab
+0000a680: 6c65 0a20 2020 2020 2020 2020 2020 2067  le.            g
+0000a690: 7261 6466 6e2c 205f 203d 205f 6765 745f  radfn, _ = _get_
+0000a6a0: 6772 6164 666e 5f61 6e64 5f65 7865 6375  gradfn_and_execu
+0000a6b0: 746f 7228 6273 796d 2c20 6578 6563 7574  tor(bsym, execut
+0000a6c0: 6f72 735f 6c69 7374 3d65 7865 6375 746f  ors_list=executo
+0000a6d0: 7273 5f6c 6973 7429 0a20 2020 2020 2020  rs_list).       
+0000a6e0: 2020 2020 2072 6574 7572 6e20 6772 6164       return grad
+0000a6f0: 666e 2069 7320 4e6f 6e65 0a0a 2020 2020  fn is None..    
+0000a700: 2020 2020 2320 544f 444f 2052 4331 3a20      # TODO RC1: 
+0000a710: 6d61 7962 6520 6d6f 7665 2074 6f20 7072  maybe move to pr
+0000a720: 6f64 7563 6520 7468 6573 6520 616c 7761  oduce these alwa
+0000a730: 7973 206f 6e20 6372 6561 7469 6f6e 0a20  ys on creation. 
+0000a740: 2020 2020 2020 2069 6620 7472 632e 6b77         if trc.kw
+0000a750: 6172 6773 2069 7320 4e6f 6e65 3a0a 2020  args is None:.  
+0000a760: 2020 2020 2020 2020 2020 7472 632e 6b77            trc.kw
+0000a770: 6172 6773 203d 207b 7d0a 2020 2020 2020  args = {}.      
+0000a780: 2020 6966 2074 7263 2e66 6e20 6973 204e    if trc.fn is N
+0000a790: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+0000a7a0: 2074 7263 2e66 6e20 3d20 7472 632e 7079   trc.fn = trc.py
+0000a7b0: 7468 6f6e 5f63 616c 6c61 626c 6528 290a  thon_callable().
+0000a7c0: 0a20 2020 2020 2020 2067 7261 6474 7263  .        gradtrc
+0000a7d0: 203d 2066 726f 6d5f 7472 6163 6528 7472   = from_trace(tr
+0000a7e0: 6329 0a20 2020 2020 2020 2066 6c61 7474  c).        flatt
+0000a7f0: 656e 6564 5f62 7379 6d73 3a20 6c69 7374  ened_bsyms: list
+0000a800: 5b42 6f75 6e64 5379 6d62 6f6c 5d20 3d20  [BoundSymbol] = 
+0000a810: 666c 6174 7465 6e5f 666f 725f 7472 616e  flatten_for_tran
+0000a820: 7366 6f72 6d28 7368 6f75 6c64 5f66 6c61  sform(should_fla
+0000a830: 7474 656e 5f66 6f72 5f67 7261 642c 2074  tten_for_grad, t
+0000a840: 7263 2e62 6f75 6e64 5f73 796d 626f 6c73  rc.bound_symbols
+0000a850: 290a 2020 2020 2020 2020 6772 6164 7472  ).        gradtr
+0000a860: 632e 626f 756e 645f 7379 6d62 6f6c 7320  c.bound_symbols 
+0000a870: 3d20 666c 6174 7465 6e65 645f 6273 796d  = flattened_bsym
+0000a880: 730a 2020 2020 2020 2020 6772 6164 7472  s.        gradtr
+0000a890: 6320 3d20 6463 6528 6772 6164 7472 6329  c = dce(gradtrc)
+0000a8a0: 0a0a 2020 2020 2020 2020 2320 5354 4550  ..        # STEP
+0000a8b0: 2054 574f 202d 2d20 5265 706c 6163 6573   TWO -- Replaces
+0000a8c0: 206f 7269 6769 6e61 6c20 6361 6c6c 7320   original calls 
+0000a8d0: 7769 7468 2067 7261 6420 6361 6c6c 730a  with grad calls.
+0000a8e0: 0a20 2020 2020 2020 2023 2044 6566 696e  .        # Defin
+0000a8f0: 6573 2074 6865 2076 6973 6974 6f72 2070  es the visitor p
+0000a900: 6174 7465 726e 2066 6f72 2074 6865 2066  attern for the f
+0000a910: 6972 7374 2070 6173 7320 6f66 2074 6865  irst pass of the
+0000a920: 2067 7261 6420 7472 616e 7366 6f72 6d2c   grad transform,
+0000a930: 0a20 2020 2020 2020 2023 2020 2077 6869  .        #   whi
+0000a940: 6368 2073 7761 7073 2042 6f75 6e64 5379  ch swaps BoundSy
+0000a950: 6d62 6f6c 7320 7769 7468 2074 6865 6972  mbols with their
+0000a960: 2067 7261 6420 6675 6e63 7469 6f6e 730a   grad functions.
+0000a970: 2020 2020 2020 2020 6465 6620 7669 7369          def visi
+0000a980: 745f 2862 7379 6d3a 2042 6f75 6e64 5379  t_(bsym: BoundSy
+0000a990: 6d62 6f6c 2920 2d3e 2043 616c 6c61 626c  mbol) -> Callabl
+0000a9a0: 653a 0a20 2020 2020 2020 2020 2020 2067  e:.            g
+0000a9b0: 7261 6466 6e3a 204e 6f6e 6520 7c20 4361  radfn: None | Ca
+0000a9c0: 6c6c 6162 6c65 0a20 2020 2020 2020 2020  llable.         
+0000a9d0: 2020 2067 7261 6466 6e2c 205f 203d 205f     gradfn, _ = _
+0000a9e0: 6765 745f 6772 6164 666e 5f61 6e64 5f65  get_gradfn_and_e
+0000a9f0: 7865 6375 746f 7228 6273 796d 2c20 6578  xecutor(bsym, ex
+0000aa00: 6563 7574 6f72 735f 6c69 7374 3d65 7865  ecutors_list=exe
+0000aa10: 6375 746f 7273 5f6c 6973 7429 0a20 2020  cutors_list).   
+0000aa20: 2020 2020 2020 2020 2063 6865 636b 280a           check(.
+0000aa30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000aa40: 6772 6164 666e 2069 7320 6e6f 7420 4e6f  gradfn is not No
+0000aa50: 6e65 2c0a 2020 2020 2020 2020 2020 2020  ne,.            
+0000aa60: 2020 2020 6c61 6d62 6461 3a20 6622 4661      lambda: f"Fa
+0000aa70: 696c 6564 2074 6f20 6669 6e64 2061 2067  iled to find a g
+0000aa80: 7261 6466 6e20 666f 7220 7b62 7379 6d3d  radfn for {bsym=
+0000aa90: 7d20 6166 7465 7220 666c 6174 7465 6e69  } after flatteni
+0000aaa0: 6e67 222c 0a20 2020 2020 2020 2020 2020  ng",.           
+0000aab0: 2020 2020 2065 7863 6570 7469 6f6e 5f74       exception_t
+0000aac0: 7970 653d 4173 7365 7274 696f 6e45 7272  ype=AssertionErr
+0000aad0: 6f72 2c0a 2020 2020 2020 2020 2020 2020  or,.            
+0000aae0: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+0000aaf0: 7475 726e 2067 7261 6466 6e0a 0a20 2020  turn gradfn..   
+0000ab00: 2020 2020 2040 7772 6170 7328 7472 632e       @wraps(trc.
+0000ab10: 666e 2e6d 6574 6120 6966 2069 7369 6e73  fn.meta if isins
+0000ab20: 7461 6e63 6528 7472 632e 666e 2c20 5379  tance(trc.fn, Sy
+0000ab30: 6d62 6f6c 2920 656c 7365 2074 7263 2e66  mbol) else trc.f
+0000ab40: 6e29 0a20 2020 2020 2020 2064 6566 2069  n).        def i
+0000ab50: 6e74 6572 7072 6574 696e 675f 666e 282a  nterpreting_fn(*
+0000ab60: 6172 6773 2c20 2a2a 6b77 6172 6773 293a  args, **kwargs):
+0000ab70: 0a20 2020 2020 2020 2020 2020 2072 6573  .            res
+0000ab80: 756c 7420 3d20 6576 616c 5f74 7261 6365  ult = eval_trace
+0000ab90: 2867 7261 6474 7263 2c20 2a61 7267 732c  (gradtrc, *args,
+0000aba0: 2073 796d 626f 6c5f 6d61 7070 6572 3d76   symbol_mapper=v
+0000abb0: 6973 6974 5f2c 202a 2a6b 7761 7267 7329  isit_, **kwargs)
+0000abc0: 0a20 2020 2020 2020 2020 2020 2023 2053  .            # S
+0000abd0: 6574 7320 6772 6164 7320 666f 7220 6f75  ets grads for ou
+0000abe0: 7470 7574 0a20 2020 2020 2020 2020 2020  tput.           
+0000abf0: 2023 2054 4f44 4f20 5468 6973 2065 6666   # TODO This eff
+0000ac00: 6563 7469 7665 6c79 2072 756e 7320 696e  ectively runs in
+0000ac10: 2061 206e 6f20 6772 6164 2063 6f6e 7465   a no grad conte
+0000ac20: 7874 202d 2d20 7368 6f75 6c64 2069 7420  xt -- should it 
+0000ac30: 7275 6e20 696e 2061 2067 7261 6420 636f  run in a grad co
+0000ac40: 6e74 6578 742c 0a20 2020 2020 2020 2020  ntext,.         
+0000ac50: 2020 2023 2020 206f 7220 7368 6f75 6c64     #   or should
+0000ac60: 2074 6865 7265 2062 6520 7468 6520 6f70   there be the op
+0000ac70: 7469 6f6e 2074 6f20 7275 6e20 6974 2069  tion to run it i
+0000ac80: 6e20 6120 6772 6164 2063 6f6e 7465 7874  n a grad context
+0000ac90: 3f0a 2020 2020 2020 2020 2020 2020 6772  ?.            gr
+0000aca0: 6164 5f73 7065 6369 6669 6572 2872 6573  ad_specifier(res
+0000acb0: 756c 7429 0a20 2020 2020 2020 2020 2020  ult).           
+0000acc0: 2023 2043 6f6e 7374 7275 6374 7320 7265   # Constructs re
+0000acd0: 7475 726e 2076 616c 7565 0a20 2020 2020  turn value.     
+0000ace0: 2020 2020 2020 2066 6c61 745f 6772 6164         flat_grad
+0000acf0: 7320 3d20 6772 6164 5f6f 7574 5f73 7065  s = grad_out_spe
+0000ad00: 6369 6669 6572 2828 6172 6773 2c20 6b77  cifier((args, kw
+0000ad10: 6172 6773 2929 0a20 2020 2020 2020 2020  args)).         
+0000ad20: 2020 2072 6574 7572 6e20 666c 6174 5f67     return flat_g
+0000ad30: 7261 6473 0a0a 2020 2020 2020 2020 2320  rads..        # 
+0000ad40: 4e4f 5445 2041 6674 6572 2074 6869 7320  NOTE After this 
+0000ad50: 6361 6c6c 2074 6865 2067 7261 6474 7263  call the gradtrc
+0000ad60: 2069 7320 696e 7661 6c69 642c 2062 6563   is invalid, bec
+0000ad70: 6175 7365 3a0a 2020 2020 2020 2020 2320  ause:.        # 
+0000ad80: 2020 3129 2054 6865 206e 6f6e 2d65 7865    1) The non-exe
+0000ad90: 6375 7461 626c 6520 7075 745f 6772 6164  cutable put_grad
+0000ada0: 206f 7065 7261 7469 6f6e 7320 6172 6520   operations are 
+0000adb0: 7374 696c 6c20 696e 2074 6865 2074 7261  still in the tra
+0000adc0: 6365 2c20 616e 6420 6d75 6c74 6970 6c65  ce, and multiple
+0000add0: 2063 616c 6c73 2074 6f20 7075 7420 6772   calls to put gr
+0000ade0: 6164 2061 7265 206e 6f74 2061 6363 756d  ad are not accum
+0000adf0: 756c 6174 6564 0a20 2020 2020 2020 2023  ulated.        #
+0000ae00: 2020 2032 2920 5468 6520 6e6f 6e2d 6578     2) The non-ex
+0000ae10: 6563 7574 6162 6c65 2067 6574 5f67 7261  ecutable get_gra
+0000ae20: 6420 6f70 6572 6174 696f 6e73 2061 7265  d operations are
+0000ae30: 2073 7469 6c6c 2069 6e20 7468 6520 7472   still in the tr
+0000ae40: 6163 652c 2061 6e64 2074 6865 7920 6d61  ace, and they ma
+0000ae50: 7920 7072 6f64 7563 6520 6469 6666 6572  y produce differ
+0000ae60: 656e 7420 7072 6f78 6965 7320 7768 656e  ent proxies when
+0000ae70: 0a20 2020 2020 2020 2023 2020 2020 2020  .        #      
+0000ae80: 2063 616c 6c65 6420 6f6e 2074 6865 2073   called on the s
+0000ae90: 616d 6520 696e 7075 7473 0a20 2020 2020  ame inputs.     
+0000aea0: 2020 2023 2020 2033 2920 5468 6520 6f70     #   3) The op
+0000aeb0: 6572 6174 696f 6e73 2061 7265 206e 6f74  erations are not
+0000aec0: 2069 6e20 6120 7661 6c69 6420 6f72 6465   in a valid orde
+0000aed0: 720a 2020 2020 2020 2020 6772 6164 7472  r.        gradtr
+0000aee0: 6320 3d20 636f 6e73 7472 7563 745f 7472  c = construct_tr
+0000aef0: 6163 6528 0a20 2020 2020 2020 2020 2020  ace(.           
+0000af00: 2072 656e 616d 655f 7072 6f78 6965 733d   rename_proxies=
+0000af10: 4661 6c73 652c 0a20 2020 2020 2020 2020  False,.         
+0000af20: 2020 2075 7365 5f64 6365 3d46 616c 7365     use_dce=False
+0000af30: 2c0a 2020 2020 2020 2020 2928 696e 7465  ,.        )(inte
+0000af40: 7270 7265 7469 6e67 5f66 6e2c 202a 6772  rpreting_fn, *gr
+0000af50: 6164 7472 632e 6172 6773 2c20 2a2a 6772  adtrc.args, **gr
+0000af60: 6164 7472 632e 6b77 6172 6773 290a 2020  adtrc.kwargs).  
+0000af70: 2020 2020 2020 6772 6164 7472 632e 7363        gradtrc.sc
+0000af80: 6f70 6573 203d 205b 6772 6164 7472 632e  opes = [gradtrc.
+0000af90: 626f 756e 645f 7379 6d62 6f6c 735d 0a20  bound_symbols]. 
+0000afa0: 2020 2020 2020 2067 7261 6474 7263 2e5f         gradtrc._
+0000afb0: 636f 6d70 6c65 7465 203d 2046 616c 7365  complete = False
+0000afc0: 0a0a 2020 2020 2020 2020 2320 5354 4550  ..        # STEP
+0000afd0: 2054 4852 4545 202d 2d20 4861 6e64 6c65   THREE -- Handle
+0000afe0: 7320 7075 745f 6772 6164 2061 6e64 2067  s put_grad and g
+0000aff0: 6574 5f67 7261 6420 6f70 6572 6174 696f  et_grad operatio
+0000b000: 6e73 2061 6e64 2061 6363 756d 756c 6174  ns and accumulat
+0000b010: 6573 2067 7261 6469 656e 7473 0a0a 2020  es gradients..  
+0000b020: 2020 2020 2020 2320 4163 6375 6d75 6c61        # Accumula
+0000b030: 7465 7320 6772 6164 6965 6e74 732c 2063  tes gradients, c
+0000b040: 7265 6174 696e 6720 7468 6520 7072 696d  reating the prim
+0000b050: 616c 202d 3e20 6163 6375 6d75 6c61 7465  al -> accumulate
+0000b060: 6420 6772 6164 206d 6170 7069 6e67 0a20  d grad mapping. 
+0000b070: 2020 2020 2020 2023 2053 6574 7320 7468         # Sets th
+0000b080: 6520 7472 6163 696e 6720 636f 6e74 6578  e tracing contex
+0000b090: 7420 736f 2061 6363 756d 756c 6174 696f  t so accumulatio
+0000b0a0: 6e20 6f70 6572 6174 696f 6e73 2061 7265  n operations are
+0000b0b0: 2072 6563 6f72 6465 6420 696e 746f 2074   recorded into t
+0000b0c0: 6865 2074 7261 6365 0a20 2020 2020 2020  he trace.       
+0000b0d0: 2074 7279 3a0a 2020 2020 2020 2020 2020   try:.          
+0000b0e0: 2020 7472 6163 6563 7478 5f74 6f6b 203d    tracectx_tok =
+0000b0f0: 2073 6574 5f74 7261 6365 6374 7828 6772   set_tracectx(gr
+0000b100: 6164 7472 6329 0a0a 2020 2020 2020 2020  adtrc)..        
+0000b110: 2020 2020 2320 4d61 7073 2070 7269 6d61      # Maps prima
+0000b120: 6c73 2074 6f20 7468 6569 7220 6772 6164  ls to their grad
+0000b130: 6965 6e74 7320 2877 6869 6368 2061 7265  ients (which are
+0000b140: 2072 6574 7572 6e65 6420 6672 6f6d 2063   returned from c
+0000b150: 616c 6c69 6e67 2067 6574 5f67 7261 6420  alling get_grad 
+0000b160: 6f6e 2074 6865 2070 7269 6d61 6c29 0a20  on the primal). 
+0000b170: 2020 2020 2020 2020 2020 2070 7269 6d61             prima
+0000b180: 6c73 5f74 6f5f 6769 6e70 7574 5f6d 6170  ls_to_ginput_map
+0000b190: 3a20 6469 6374 5b56 6172 6961 626c 652c  : dict[Variable,
+0000b1a0: 2054 656e 736f 7250 726f 7879 5d20 3d20   TensorProxy] = 
+0000b1b0: 7b7d 0a0a 2020 2020 2020 2020 2020 2020  {}..            
+0000b1c0: 2320 4861 6e64 6c65 7320 7075 745f 6772  # Handles put_gr
+0000b1d0: 6164 206f 7065 7261 7469 6f6e 730a 2020  ad operations.  
+0000b1e0: 2020 2020 2020 2020 2020 2320 4e4f 5445            # NOTE
+0000b1f0: 2054 6869 7320 6d6f 6469 6669 6573 2061   This modifies a
+0000b200: 206c 6973 7420 7468 6174 2069 7320 6265   list that is be
+0000b210: 696e 6720 656e 756d 6572 6174 6564 206f  ing enumerated o
+0000b220: 7665 722c 2062 7574 2069 7427 7320 4f4b  ver, but it's OK
+0000b230: 2062 6563 6175 7365 2077 6527 7265 206f   because we're o
+0000b240: 6e6c 790a 2020 2020 2020 2020 2020 2020  nly.            
+0000b250: 2320 2020 6170 7065 6e64 696e 6720 746f  #   appending to
+0000b260: 2074 6865 2065 6e64 206f 6620 7468 6520   the end of the 
+0000b270: 6c69 7374 0a20 2020 2020 2020 2020 2020  list.           
+0000b280: 2062 7379 6d3a 2042 6f75 6e64 5379 6d62   bsym: BoundSymb
+0000b290: 6f6c 0a20 2020 2020 2020 2020 2020 2066  ol.            f
+0000b2a0: 6f72 2062 7379 6d20 696e 2067 7261 6474  or bsym in gradt
+0000b2b0: 7263 2e62 6f75 6e64 5f73 796d 626f 6c73  rc.bound_symbols
+0000b2c0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000b2d0: 2020 6964 3a20 4861 7368 6162 6c65 203d    id: Hashable =
+0000b2e0: 2062 7379 6d2e 7379 6d2e 6964 0a20 2020   bsym.sym.id.   
+0000b2f0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0000b300: 6964 2069 7320 7069 6473 2e50 5554 5f47  id is pids.PUT_G
+0000b310: 5241 443a 0a20 2020 2020 2020 2020 2020  RAD:.           
+0000b320: 2020 2020 2020 2020 2070 7269 6d61 6c3a           primal:
+0000b330: 204e 756d 6265 7220 7c20 5465 6e73 6f72   Number | Tensor
+0000b340: 5072 6f78 790a 2020 2020 2020 2020 2020  Proxy.          
+0000b350: 2020 2020 2020 2020 2020 6772 6164 3a20            grad: 
+0000b360: 4e75 6d62 6572 207c 2054 656e 736f 7250  Number | TensorP
+0000b370: 726f 7879 0a20 2020 2020 2020 2020 2020  roxy.           
+0000b380: 2020 2020 2020 2020 2070 7269 6d61 6c2c           primal,
+0000b390: 2067 7261 6420 3d20 6273 796d 2e66 6c61   grad = bsym.fla
+0000b3a0: 745f 6172 6773 0a0a 2020 2020 2020 2020  t_args..        
+0000b3b0: 2020 2020 2020 2020 2020 2020 2320 544f              # TO
+0000b3c0: 444f 2053 7570 706f 7274 2061 7574 6f67  DO Support autog
+0000b3d0: 7261 6420 6f6e 206e 756d 6265 7273 0a20  rad on numbers. 
 0000b3e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b3f0: 2023 2046 696c 7465 7273 2063 616c 6c73   # Filters calls
-0000b400: 2074 6f20 7075 745f 6772 6164 2074 6861   to put_grad tha
-0000b410: 7420 776f 756c 6420 7075 7420 6120 6772  t would put a gr
-0000b420: 6164 206f 6e20 6120 6e6f 6e2d 7465 6e73  ad on a non-tens
-0000b430: 6f72 206f 7220 6120 7465 6e73 6f72 2074  or or a tensor t
-0000b440: 6861 7420 646f 6573 6e27 7420 7265 7175  hat doesn't requ
-0000b450: 6972 6520 6772 6164 0a20 2020 2020 2020  ire grad.       
-0000b460: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000b470: 6e6f 7420 6973 696e 7374 616e 6365 2870  not isinstance(p
-0000b480: 7269 6d61 6c2c 2054 656e 736f 7250 726f  rimal, TensorPro
-0000b490: 7879 2920 6f72 206e 6f74 2070 7269 6d61  xy) or not prima
-0000b4a0: 6c2e 7265 7175 6972 6573 5f67 7261 643a  l.requires_grad:
-0000b4b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000b4c0: 2020 2020 2020 2020 2063 6f6e 7469 6e75           continu
-0000b4d0: 650a 0a20 2020 2020 2020 2020 2020 2020  e..             
-0000b4e0: 2020 2020 2020 2023 2054 4f44 4f20 5375         # TODO Su
-0000b4f0: 7070 6f72 7420 636f 6d70 6c65 7820 6175  pport complex au
-0000b500: 746f 6772 6164 0a20 2020 2020 2020 2020  tograd.         
-0000b510: 2020 2020 2020 2020 2020 2063 6865 636b             check
-0000b520: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-0000b530: 2020 2020 2020 2020 2020 6e6f 7420 6474            not dt
-0000b540: 7970 6573 2e69 735f 636f 6d70 6c65 785f  ypes.is_complex_
-0000b550: 6474 7970 6528 6474 7970 6573 2e74 6f5f  dtype(dtypes.to_
-0000b560: 6474 7970 6528 7072 696d 616c 2929 2c0a  dtype(primal)),.
-0000b570: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b580: 2020 2020 2020 2020 6c61 6d62 6461 3a20          lambda: 
-0000b590: 6622 436f 6d70 6c65 7820 6772 6164 2069  f"Complex grad i
-0000b5a0: 7320 6e6f 7420 7375 7070 6f72 7465 6420  s not supported 
-0000b5b0: 7965 7422 2c0a 2020 2020 2020 2020 2020  yet",.          
-0000b5c0: 2020 2020 2020 2020 2020 290a 0a20 2020            )..   
+0000b3f0: 2020 2023 2046 696c 7465 7273 2063 616c     # Filters cal
+0000b400: 6c73 2074 6f20 7075 745f 6772 6164 2074  ls to put_grad t
+0000b410: 6861 7420 776f 756c 6420 7075 7420 6120  hat would put a 
+0000b420: 6772 6164 206f 6e20 6120 6e6f 6e2d 7465  grad on a non-te
+0000b430: 6e73 6f72 206f 7220 6120 7465 6e73 6f72  nsor or a tensor
+0000b440: 2074 6861 7420 646f 6573 6e27 7420 7265   that doesn't re
+0000b450: 7175 6972 6520 6772 6164 0a20 2020 2020  quire grad.     
+0000b460: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0000b470: 6620 6e6f 7420 6973 696e 7374 616e 6365  f not isinstance
+0000b480: 2870 7269 6d61 6c2c 2054 656e 736f 7250  (primal, TensorP
+0000b490: 726f 7879 2920 6f72 206e 6f74 2070 7269  roxy) or not pri
+0000b4a0: 6d61 6c2e 7265 7175 6972 6573 5f67 7261  mal.requires_gra
+0000b4b0: 643a 0a20 2020 2020 2020 2020 2020 2020  d:.             
+0000b4c0: 2020 2020 2020 2020 2020 2063 6f6e 7469             conti
+0000b4d0: 6e75 650a 0a20 2020 2020 2020 2020 2020  nue..           
+0000b4e0: 2020 2020 2020 2020 2023 2054 4f44 4f20           # TODO 
+0000b4f0: 5375 7070 6f72 7420 636f 6d70 6c65 7820  Support complex 
+0000b500: 6175 746f 6772 6164 0a20 2020 2020 2020  autograd.       
+0000b510: 2020 2020 2020 2020 2020 2020 2063 6865               che
+0000b520: 636b 280a 2020 2020 2020 2020 2020 2020  ck(.            
+0000b530: 2020 2020 2020 2020 2020 2020 6e6f 7420              not 
+0000b540: 6474 7970 6573 2e69 735f 636f 6d70 6c65  dtypes.is_comple
+0000b550: 785f 6474 7970 6528 6474 7970 6573 2e74  x_dtype(dtypes.t
+0000b560: 6f5f 6474 7970 6528 7072 696d 616c 2929  o_dtype(primal))
+0000b570: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000b580: 2020 2020 2020 2020 2020 6c61 6d62 6461            lambda
+0000b590: 3a20 6622 436f 6d70 6c65 7820 6772 6164  : f"Complex grad
+0000b5a0: 2069 7320 6e6f 7420 7375 7070 6f72 7465   is not supporte
+0000b5b0: 6420 7965 7422 2c0a 2020 2020 2020 2020  d yet",.        
+0000b5c0: 2020 2020 2020 2020 2020 2020 290a 0a20              ).. 
 0000b5d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b5e0: 2076 7072 696d 616c 3a20 5661 7269 6162   vprimal: Variab
-0000b5f0: 6c65 203d 2076 6172 6961 626c 6569 6679  le = variableify
-0000b600: 2870 7269 6d61 6c29 0a20 2020 2020 2020  (primal).       
-0000b610: 2020 2020 2020 2020 2020 2020 2061 6363               acc
-0000b620: 756d 3a20 4e6f 6e65 207c 2054 656e 736f  um: None | Tenso
-0000b630: 7250 726f 7879 203d 2070 7269 6d61 6c73  rProxy = primals
-0000b640: 5f74 6f5f 6769 6e70 7574 5f6d 6170 2e67  _to_ginput_map.g
-0000b650: 6574 2876 7072 696d 616c 2c20 4e6f 6e65  et(vprimal, None
-0000b660: 290a 0a20 2020 2020 2020 2020 2020 2020  )..             
-0000b670: 2020 2020 2020 2069 6620 6163 6375 6d20         if accum 
-0000b680: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
+0000b5e0: 2020 2076 7072 696d 616c 3a20 5661 7269     vprimal: Vari
+0000b5f0: 6162 6c65 203d 2076 6172 6961 626c 6569  able = variablei
+0000b600: 6679 2870 7269 6d61 6c29 0a20 2020 2020  fy(primal).     
+0000b610: 2020 2020 2020 2020 2020 2020 2020 2061                 a
+0000b620: 6363 756d 3a20 4e6f 6e65 207c 2054 656e  ccum: None | Ten
+0000b630: 736f 7250 726f 7879 203d 2070 7269 6d61  sorProxy = prima
+0000b640: 6c73 5f74 6f5f 6769 6e70 7574 5f6d 6170  ls_to_ginput_map
+0000b650: 2e67 6574 2876 7072 696d 616c 2c20 4e6f  .get(vprimal, No
+0000b660: 6e65 290a 0a20 2020 2020 2020 2020 2020  ne)..           
+0000b670: 2020 2020 2020 2020 2069 6620 6163 6375           if accu
+0000b680: 6d20 6973 204e 6f6e 653a 0a20 2020 2020  m is None:.     
 0000b690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b6a0: 2070 7269 6d61 6c73 5f74 6f5f 6769 6e70   primals_to_ginp
-0000b6b0: 7574 5f6d 6170 5b76 7072 696d 616c 5d20  ut_map[vprimal] 
-0000b6c0: 3d20 6772 6164 0a20 2020 2020 2020 2020  = grad.         
-0000b6d0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-0000b6e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000b6f0: 2020 2020 2020 2020 2061 6363 756d 203d           accum =
-0000b700: 2061 6363 756d 202b 2067 7261 640a 2020   accum + grad.  
+0000b6a0: 2020 2070 7269 6d61 6c73 5f74 6f5f 6769     primals_to_gi
+0000b6b0: 6e70 7574 5f6d 6170 5b76 7072 696d 616c  nput_map[vprimal
+0000b6c0: 5d20 3d20 6772 6164 0a20 2020 2020 2020  ] = grad.       
+0000b6d0: 2020 2020 2020 2020 2020 2020 2065 6c73               els
+0000b6e0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0000b6f0: 2020 2020 2020 2020 2020 2061 6363 756d             accum
+0000b700: 203d 2061 6363 756d 202b 2067 7261 640a   = accum + grad.
 0000b710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b720: 2020 2020 2020 7072 696d 616c 735f 746f        primals_to
-0000b730: 5f67 696e 7075 745f 6d61 705b 7670 7269  _ginput_map[vpri
-0000b740: 6d61 6c5d 203d 2061 6363 756d 0a0a 2020  mal] = accum..  
-0000b750: 2020 2020 2020 2020 2020 2320 4861 6e64            # Hand
-0000b760: 6c65 7320 6765 745f 6772 6164 206f 7065  les get_grad ope
-0000b770: 7261 7469 6f6e 730a 0a20 2020 2020 2020  rations..       
-0000b780: 2020 2020 2023 2052 6573 6574 7320 7468       # Resets th
-0000b790: 6520 7377 6170 6d61 7020 666f 7220 6772  e swapmap for gr
-0000b7a0: 6164 730a 2020 2020 2020 2020 2020 2020  ads.            
-0000b7b0: 7377 6170 6d61 703a 2064 6963 745b 5661  swapmap: dict[Va
-0000b7c0: 7269 6162 6c65 2c20 5072 6f78 795d 203d  riable, Proxy] =
-0000b7d0: 207b 7d0a 0a20 2020 2020 2020 2020 2020   {}..           
-0000b7e0: 2066 6f72 2062 7379 6d20 696e 2067 7261   for bsym in gra
-0000b7f0: 6474 7263 2e62 6f75 6e64 5f73 796d 626f  dtrc.bound_symbo
-0000b800: 6c73 3a0a 2020 2020 2020 2020 2020 2020  ls:.            
-0000b810: 2020 2020 6964 3a20 4861 7368 6162 6c65      id: Hashable
-0000b820: 203d 2062 7379 6d2e 7379 6d2e 6964 0a20   = bsym.sym.id. 
-0000b830: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0000b840: 6620 6964 2069 7320 7069 6473 2e47 4554  f id is pids.GET
-0000b850: 5f47 5241 443a 0a20 2020 2020 2020 2020  _GRAD:.         
-0000b860: 2020 2020 2020 2020 2020 2070 7269 6d61             prima
-0000b870: 6c3a 204e 756d 6265 7220 7c20 5465 6e73  l: Number | Tens
-0000b880: 6f72 5072 6f78 790a 2020 2020 2020 2020  orProxy.        
-0000b890: 2020 2020 2020 2020 2020 2020 2870 7269              (pri
-0000b8a0: 6d61 6c2c 2920 3d20 6273 796d 2e66 6c61  mal,) = bsym.fla
-0000b8b0: 745f 6172 6773 0a20 2020 2020 2020 2020  t_args.         
-0000b8c0: 2020 2020 2020 2020 2020 2067 7261 643a             grad:
-0000b8d0: 204e 756d 6265 7220 7c20 5465 6e73 6f72   Number | Tensor
-0000b8e0: 5072 6f78 7920 3d20 6273 796d 2e6f 7574  Proxy = bsym.out
-0000b8f0: 7075 740a 0a20 2020 2020 2020 2020 2020  put..           
-0000b900: 2020 2020 2020 2020 2076 7072 696d 616c           vprimal
-0000b910: 3a20 5661 7269 6162 6c65 0a20 2020 2020  : Variable.     
-0000b920: 2020 2020 2020 2020 2020 2020 2020 2076                 v
-0000b930: 6772 6164 3a20 5661 7269 6162 6c65 0a20  grad: Variable. 
-0000b940: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b950: 2020 2076 7072 696d 616c 2c20 7667 7261     vprimal, vgra
-0000b960: 6420 3d20 7661 7269 6162 6c65 6966 7928  d = variableify(
-0000b970: 7072 696d 616c 292c 2076 6172 6961 626c  primal), variabl
-0000b980: 6569 6679 2867 7261 6429 0a0a 2020 2020  eify(grad)..    
+0000b720: 2020 2020 2020 2020 7072 696d 616c 735f          primals_
+0000b730: 746f 5f67 696e 7075 745f 6d61 705b 7670  to_ginput_map[vp
+0000b740: 7269 6d61 6c5d 203d 2061 6363 756d 0a0a  rimal] = accum..
+0000b750: 2020 2020 2020 2020 2020 2020 2320 4861              # Ha
+0000b760: 6e64 6c65 7320 6765 745f 6772 6164 206f  ndles get_grad o
+0000b770: 7065 7261 7469 6f6e 730a 0a20 2020 2020  perations..     
+0000b780: 2020 2020 2020 2023 2052 6573 6574 7320         # Resets 
+0000b790: 7468 6520 7377 6170 6d61 7020 666f 7220  the swapmap for 
+0000b7a0: 6772 6164 730a 2020 2020 2020 2020 2020  grads.          
+0000b7b0: 2020 7377 6170 6d61 703a 2064 6963 745b    swapmap: dict[
+0000b7c0: 5661 7269 6162 6c65 2c20 5072 6f78 795d  Variable, Proxy]
+0000b7d0: 203d 207b 7d0a 0a20 2020 2020 2020 2020   = {}..         
+0000b7e0: 2020 2066 6f72 2062 7379 6d20 696e 2067     for bsym in g
+0000b7f0: 7261 6474 7263 2e62 6f75 6e64 5f73 796d  radtrc.bound_sym
+0000b800: 626f 6c73 3a0a 2020 2020 2020 2020 2020  bols:.          
+0000b810: 2020 2020 2020 6964 3a20 4861 7368 6162        id: Hashab
+0000b820: 6c65 203d 2062 7379 6d2e 7379 6d2e 6964  le = bsym.sym.id
+0000b830: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000b840: 2069 6620 6964 2069 7320 7069 6473 2e47   if id is pids.G
+0000b850: 4554 5f47 5241 443a 0a20 2020 2020 2020  ET_GRAD:.       
+0000b860: 2020 2020 2020 2020 2020 2020 2070 7269               pri
+0000b870: 6d61 6c3a 204e 756d 6265 7220 7c20 5465  mal: Number | Te
+0000b880: 6e73 6f72 5072 6f78 790a 2020 2020 2020  nsorProxy.      
+0000b890: 2020 2020 2020 2020 2020 2020 2020 2870                (p
+0000b8a0: 7269 6d61 6c2c 2920 3d20 6273 796d 2e66  rimal,) = bsym.f
+0000b8b0: 6c61 745f 6172 6773 0a20 2020 2020 2020  lat_args.       
+0000b8c0: 2020 2020 2020 2020 2020 2020 2067 7261               gra
+0000b8d0: 643a 204e 756d 6265 7220 7c20 5465 6e73  d: Number | Tens
+0000b8e0: 6f72 5072 6f78 7920 3d20 6273 796d 2e6f  orProxy = bsym.o
+0000b8f0: 7574 7075 740a 0a20 2020 2020 2020 2020  utput..         
+0000b900: 2020 2020 2020 2020 2020 2076 7072 696d             vprim
+0000b910: 616c 3a20 5661 7269 6162 6c65 0a20 2020  al: Variable.   
+0000b920: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b930: 2076 6772 6164 3a20 5661 7269 6162 6c65   vgrad: Variable
+0000b940: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000b950: 2020 2020 2076 7072 696d 616c 2c20 7667       vprimal, vg
+0000b960: 7261 6420 3d20 7661 7269 6162 6c65 6966  rad = variableif
+0000b970: 7928 7072 696d 616c 292c 2076 6172 6961  y(primal), varia
+0000b980: 626c 6569 6679 2867 7261 6429 0a0a 2020  bleify(grad)..  
 0000b990: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b9a0: 6163 7475 616c 5f67 7261 643a 204e 6f6e  actual_grad: Non
-0000b9b0: 6520 7c20 5465 6e73 6f72 5072 6f78 7920  e | TensorProxy 
-0000b9c0: 3d20 7072 696d 616c 735f 746f 5f67 696e  = primals_to_gin
-0000b9d0: 7075 745f 6d61 702e 6765 7428 7670 7269  put_map.get(vpri
-0000b9e0: 6d61 6c2c 204e 6f6e 6529 0a0a 2020 2020  mal, None)..    
+0000b9a0: 2020 6163 7475 616c 5f67 7261 643a 204e    actual_grad: N
+0000b9b0: 6f6e 6520 7c20 5465 6e73 6f72 5072 6f78  one | TensorProx
+0000b9c0: 7920 3d20 7072 696d 616c 735f 746f 5f67  y = primals_to_g
+0000b9d0: 696e 7075 745f 6d61 702e 6765 7428 7670  input_map.get(vp
+0000b9e0: 7269 6d61 6c2c 204e 6f6e 6529 0a0a 2020  rimal, None)..  
 0000b9f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ba00: 2320 4e4f 5445 2049 6620 6163 7475 616c  # NOTE If actual
-0000ba10: 5f67 7261 6420 6973 204e 6f6e 6520 7468  _grad is None th
-0000ba20: 656e 2074 6865 7265 2773 2061 2067 6574  en there's a get
-0000ba30: 5f67 7261 6428 2920 7265 7175 6573 7420  _grad() request 
-0000ba40: 666f 7220 6120 7465 6e73 6f72 2077 6869  for a tensor whi
-0000ba50: 6368 0a20 2020 2020 2020 2020 2020 2020  ch.             
-0000ba60: 2020 2020 2020 2023 2020 2068 6173 206e         #   has n
-0000ba70: 6f20 7075 745f 6772 6164 2829 2c20 736f  o put_grad(), so
-0000ba80: 2077 6520 7265 7475 726e 207a 6572 6f73   we return zeros
-0000ba90: 2066 6f72 2074 6865 2067 7261 640a 2020   for the grad.  
+0000ba00: 2020 2320 4e4f 5445 2049 6620 6163 7475    # NOTE If actu
+0000ba10: 616c 5f67 7261 6420 6973 204e 6f6e 6520  al_grad is None 
+0000ba20: 7468 656e 2074 6865 7265 2773 2061 2067  then there's a g
+0000ba30: 6574 5f67 7261 6428 2920 7265 7175 6573  et_grad() reques
+0000ba40: 7420 666f 7220 6120 7465 6e73 6f72 2077  t for a tensor w
+0000ba50: 6869 6368 0a20 2020 2020 2020 2020 2020  hich.           
+0000ba60: 2020 2020 2020 2020 2023 2020 2068 6173           #   has
+0000ba70: 206e 6f20 7075 745f 6772 6164 2829 2c20   no put_grad(), 
+0000ba80: 736f 2077 6520 7265 7475 726e 207a 6572  so we return zer
+0000ba90: 6f73 2066 6f72 2074 6865 2067 7261 640a  os for the grad.
 0000baa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bab0: 2020 2320 544f 444f 2052 6576 6973 6974    # TODO Revisit
-0000bac0: 2074 6869 7320 2d2d 2063 616e 2077 6520   this -- can we 
-0000bad0: 7265 6d6f 7665 2074 6865 7365 2063 6f6d  remove these com
-0000bae0: 7075 7461 7469 6f6e 732c 206f 7220 7573  putations, or us
-0000baf0: 6520 6120 7370 6563 6961 6c20 5a65 726f  e a special Zero
-0000bb00: 5465 6e73 6f72 0a20 2020 2020 2020 2020  Tensor.         
-0000bb10: 2020 2020 2020 2020 2020 2023 2020 2074             #   t
-0000bb20: 6f20 7369 6d70 6c69 6679 2074 6865 6d3f  o simplify them?
-0000bb30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000bb40: 2020 2020 2069 6620 6163 7475 616c 5f67       if actual_g
-0000bb50: 7261 6420 6973 204e 6f6e 653a 0a20 2020  rad is None:.   
+0000bab0: 2020 2020 2320 544f 444f 2052 6576 6973      # TODO Revis
+0000bac0: 6974 2074 6869 7320 2d2d 2063 616e 2077  it this -- can w
+0000bad0: 6520 7265 6d6f 7665 2074 6865 7365 2063  e remove these c
+0000bae0: 6f6d 7075 7461 7469 6f6e 732c 206f 7220  omputations, or 
+0000baf0: 7573 6520 6120 7370 6563 6961 6c20 5a65  use a special Ze
+0000bb00: 726f 5465 6e73 6f72 0a20 2020 2020 2020  roTensor.       
+0000bb10: 2020 2020 2020 2020 2020 2020 2023 2020               #  
+0000bb20: 2074 6f20 7369 6d70 6c69 6679 2074 6865   to simplify the
+0000bb30: 6d3f 0a20 2020 2020 2020 2020 2020 2020  m?.             
+0000bb40: 2020 2020 2020 2069 6620 6163 7475 616c         if actual
+0000bb50: 5f67 7261 6420 6973 204e 6f6e 653a 0a20  _grad is None:. 
 0000bb60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bb70: 2020 2020 2061 6374 7561 6c5f 6772 6164       actual_grad
-0000bb80: 203d 206c 746f 7263 682e 7a65 726f 735f   = ltorch.zeros_
-0000bb90: 6c69 6b65 2870 7269 6d61 6c29 0a20 2020  like(primal).   
+0000bb70: 2020 2020 2020 2061 6374 7561 6c5f 6772         actual_gr
+0000bb80: 6164 203d 206c 746f 7263 682e 7a65 726f  ad = ltorch.zero
+0000bb90: 735f 6c69 6b65 2870 7269 6d61 6c29 0a20  s_like(primal). 
 0000bba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bbb0: 2020 2020 2070 7269 6d61 6c73 5f74 6f5f       primals_to_
-0000bbc0: 6769 6e70 7574 5f6d 6170 5b76 7072 696d  ginput_map[vprim
-0000bbd0: 616c 5d20 3d20 6163 7475 616c 5f67 7261  al] = actual_gra
-0000bbe0: 640a 0a20 2020 2020 2020 2020 2020 2020  d..             
-0000bbf0: 2020 2020 2020 2023 2055 7064 6174 6573         # Updates
-0000bc00: 2074 6865 2067 7261 6420 616c 6961 7320   the grad alias 
-0000bc10: 6d61 700a 2020 2020 2020 2020 2020 2020  map.            
-0000bc20: 2020 2020 2020 2020 7661 6374 7561 6c5f          vactual_
-0000bc30: 6772 6164 3a20 5661 7269 6162 6c65 203d  grad: Variable =
-0000bc40: 2076 6172 6961 626c 6569 6679 2861 6374   variableify(act
-0000bc50: 7561 6c5f 6772 6164 290a 2020 2020 2020  ual_grad).      
-0000bc60: 2020 2020 2020 2020 2020 2020 2020 6966                if
-0000bc70: 2076 6163 7475 616c 5f67 7261 6420 213d   vactual_grad !=
-0000bc80: 2076 6772 6164 3a0a 2020 2020 2020 2020   vgrad:.        
+0000bbb0: 2020 2020 2020 2070 7269 6d61 6c73 5f74         primals_t
+0000bbc0: 6f5f 6769 6e70 7574 5f6d 6170 5b76 7072  o_ginput_map[vpr
+0000bbd0: 696d 616c 5d20 3d20 6163 7475 616c 5f67  imal] = actual_g
+0000bbe0: 7261 640a 0a20 2020 2020 2020 2020 2020  rad..           
+0000bbf0: 2020 2020 2020 2020 2023 2055 7064 6174           # Updat
+0000bc00: 6573 2074 6865 2067 7261 6420 616c 6961  es the grad alia
+0000bc10: 7320 6d61 700a 2020 2020 2020 2020 2020  s map.          
+0000bc20: 2020 2020 2020 2020 2020 7661 6374 7561            vactua
+0000bc30: 6c5f 6772 6164 3a20 5661 7269 6162 6c65  l_grad: Variable
+0000bc40: 203d 2076 6172 6961 626c 6569 6679 2861   = variableify(a
+0000bc50: 6374 7561 6c5f 6772 6164 290a 2020 2020  ctual_grad).    
+0000bc60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bc70: 6966 2076 6163 7475 616c 5f67 7261 6420  if vactual_grad 
+0000bc80: 213d 2076 6772 6164 3a0a 2020 2020 2020  != vgrad:.      
 0000bc90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bca0: 7377 6170 6d61 705b 7667 7261 645d 203d  swapmap[vgrad] =
-0000bcb0: 2061 6374 7561 6c5f 6772 6164 0a0a 2020   actual_grad..  
-0000bcc0: 2020 2020 2020 6669 6e61 6c6c 793a 0a20        finally:. 
-0000bcd0: 2020 2020 2020 2020 2020 2023 2052 6573             # Res
-0000bce0: 746f 7265 7320 7363 6f70 650a 2020 2020  tores scope.    
-0000bcf0: 2020 2020 2020 2020 7265 7365 745f 7472          reset_tr
-0000bd00: 6163 6563 7478 2874 7261 6365 6374 785f  acectx(tracectx_
-0000bd10: 746f 6b29 0a0a 2020 2020 2020 2020 2320  tok)..        # 
-0000bd20: 4669 6c74 6572 7320 7075 745f 6772 6164  Filters put_grad
-0000bd30: 2061 6e64 2067 6574 5f67 7261 6420 6f70   and get_grad op
-0000bd40: 6572 6174 696f 6e73 2061 6e64 2061 7070  erations and app
-0000bd50: 6c69 6573 2074 6865 2073 7761 706d 6170  lies the swapmap
-0000bd60: 0a20 2020 2020 2020 2064 6566 205f 6669  .        def _fi
-0000bd70: 6c74 6572 2862 7379 6d3a 2042 6f75 6e64  lter(bsym: Bound
-0000bd80: 5379 6d62 6f6c 2920 2d3e 2062 6f6f 6c3a  Symbol) -> bool:
-0000bd90: 0a20 2020 2020 2020 2020 2020 2069 643a  .            id:
-0000bda0: 2048 6173 6861 626c 6520 3d20 6273 796d   Hashable = bsym
-0000bdb0: 2e73 796d 2e69 640a 2020 2020 2020 2020  .sym.id.        
-0000bdc0: 2020 2020 7265 7475 726e 2069 6420 696e      return id in
-0000bdd0: 2028 7069 6473 2e50 5554 5f47 5241 442c   (pids.PUT_GRAD,
-0000bde0: 2070 6964 732e 4745 545f 4752 4144 290a   pids.GET_GRAD).
-0000bdf0: 0a20 2020 2020 2020 2067 7261 6474 7263  .        gradtrc
-0000be00: 2e62 6f75 6e64 5f73 796d 626f 6c73 203d  .bound_symbols =
-0000be10: 205b 0a20 2020 2020 2020 2020 2020 2062   [.            b
-0000be20: 7379 6d2e 6672 6f6d 5f62 7379 6d5f 7377  sym.from_bsym_sw
-0000be30: 6170 5f70 726f 7869 6573 2873 7761 706d  ap_proxies(swapm
-0000be40: 6170 2920 666f 7220 6273 796d 2069 6e20  ap) for bsym in 
-0000be50: 6772 6164 7472 632e 626f 756e 645f 7379  gradtrc.bound_sy
-0000be60: 6d62 6f6c 7320 6966 206e 6f74 205f 6669  mbols if not _fi
-0000be70: 6c74 6572 2862 7379 6d29 0a20 2020 2020  lter(bsym).     
-0000be80: 2020 205d 0a0a 2020 2020 2020 2020 2320     ]..        # 
-0000be90: 5354 4550 2046 4f55 5220 2d2d 2d20 4f72  STEP FOUR --- Or
-0000bea0: 6465 7273 2074 6865 206f 7065 7261 7469  ders the operati
-0000beb0: 6f6e 730a 2020 2020 2020 2020 2320 544f  ons.        # TO
-0000bec0: 444f 2043 6f6e 7369 6465 7220 616c 7465  DO Consider alte
-0000bed0: 726e 6174 6976 6520 7363 6865 6475 6c69  rnative scheduli
-0000bee0: 6e67 2061 6c67 6f72 6974 686d 732c 206d  ng algorithms, m
-0000bef0: 6179 6265 2062 7920 7573 696e 6720 6772  aybe by using gr
-0000bf00: 6170 6820 6665 6174 7572 6573 0a20 2020  aph features.   
-0000bf10: 2020 2020 2023 2020 2053 6f6d 6520 6964       #   Some id
-0000bf20: 6561 7320 6172 6520 6c6f 6f6b 696e 6720  eas are looking 
-0000bf30: 6174 206d 656d 6f72 792d 7361 7669 6e67  at memory-saving
-0000bf40: 206e 6f64 6573 2c20 616e 6420 6e6f 6465   nodes, and node
-0000bf50: 7320 7769 7468 2061 2068 6967 6820 696e  s with a high in
-0000bf60: 2d64 6567 7265 6520 6f72 2068 6967 6820  -degree or high 
-0000bf70: 6f75 742d 6465 6772 6565 0a0a 2020 2020  out-degree..    
-0000bf80: 2020 2020 2320 4372 6561 7465 7320 616e      # Creates an
-0000bf90: 2069 6e69 7469 616c 2076 616c 6964 206f   initial valid o
-0000bfa0: 7264 6572 696e 6720 746f 2044 4345 2c20  rdering to DCE, 
-0000bfb0: 736f 2074 6861 7420 6164 6469 7469 6f6e  so that addition
-0000bfc0: 616c 206f 7264 6572 696e 6720 616e 616c  al ordering anal
-0000bfd0: 7973 6973 2064 6f65 736e 2774 206e 6565  ysis doesn't nee
-0000bfe0: 6420 746f 2063 6f6e 7369 6465 7220 616c  d to consider al
-0000bff0: 6c20 7379 6d62 6f6c 730a 2020 2020 2020  l symbols.      
-0000c000: 2020 726f 6f74 732c 206c 6561 7665 7320    roots, leaves 
-0000c010: 3d20 6273 796d 5f6c 6973 745f 746f 5f64  = bsym_list_to_d
-0000c020: 6167 2867 7261 6474 7263 2e62 6f75 6e64  ag(gradtrc.bound
-0000c030: 5f73 796d 626f 6c73 290a 2020 2020 2020  _symbols).      
-0000c040: 2020 6f72 6465 7265 645f 6273 796d 7320    ordered_bsyms 
-0000c050: 3d20 746f 706f 736f 7274 5f62 7379 6d5f  = toposort_bsym_
-0000c060: 6461 6728 726f 6f74 732c 2054 4f50 4f53  dag(roots, TOPOS
-0000c070: 4f52 545f 4f52 4445 522e 544f 505f 444f  ORT_ORDER.TOP_DO
-0000c080: 574e 290a 2020 2020 2020 2020 6772 6164  WN).        grad
-0000c090: 7472 632e 626f 756e 645f 7379 6d62 6f6c  trc.bound_symbol
-0000c0a0: 7320 3d20 6f72 6465 7265 645f 6273 796d  s = ordered_bsym
-0000c0b0: 730a 2020 2020 2020 2020 6772 6164 7472  s.        gradtr
-0000c0c0: 6320 3d20 6463 6528 6772 6164 7472 6329  c = dce(gradtrc)
-0000c0d0: 0a0a 2020 2020 2020 2020 2320 4964 656e  ..        # Iden
-0000c0e0: 7469 6669 6573 2074 6865 206f 7264 6572  tifies the order
-0000c0f0: 206f 6620 426f 756e 6453 796d 626f 6c73   of BoundSymbols
-0000c100: 2075 7369 6e67 2061 2022 4446 5320 616e   using a "DFS an
-0000c110: 6420 6368 6169 6e22 2061 6c67 6f72 6974  d chain" algorit
-0000c120: 686d 0a20 2020 2020 2020 2023 2054 4f44  hm.        # TOD
-0000c130: 4f20 456c 6162 6f72 6174 6520 6f6e 2074  O Elaborate on t
-0000c140: 6869 7320 616c 676f 7269 7468 6d20 616e  his algorithm an
-0000c150: 6420 7468 6520 696d 706c 656d 656e 7461  d the implementa
-0000c160: 7469 6f6e 0a20 2020 2020 2020 2072 6f6f  tion.        roo
-0000c170: 7473 2c20 6c65 6176 6573 203d 2062 7379  ts, leaves = bsy
-0000c180: 6d5f 6c69 7374 5f74 6f5f 6461 6728 6772  m_list_to_dag(gr
-0000c190: 6164 7472 632e 626f 756e 645f 7379 6d62  adtrc.bound_symb
-0000c1a0: 6f6c 7329 0a20 2020 2020 2020 2063 6865  ols).        che
-0000c1b0: 636b 280a 2020 2020 2020 2020 2020 2020  ck(.            
-0000c1c0: 6c65 6e28 6c65 6176 6573 2920 3d3d 2031  len(leaves) == 1
-0000c1d0: 2c0a 2020 2020 2020 2020 2020 2020 6c61  ,.            la
-0000c1e0: 6d62 6461 3a20 6622 4578 7065 6374 6564  mbda: f"Expected
-0000c1f0: 206f 6e6c 7920 6f6e 6520 6c65 6166 206e   only one leaf n
-0000c200: 6f64 6520 7768 656e 2073 6f72 7469 6e67  ode when sorting
-0000c210: 2066 6f72 2067 7261 642c 2066 6f75 6e64   for grad, found
-0000c220: 2074 6865 7265 2077 6572 6520 7b6c 656e   there were {len
-0000c230: 286c 6561 7665 7329 7d20 6c65 6176 6573  (leaves)} leaves
-0000c240: 222c 0a20 2020 2020 2020 2029 0a20 2020  ",.        ).   
-0000c250: 2020 2020 2028 6c65 6166 2c29 203d 206c       (leaf,) = l
-0000c260: 6561 7665 730a 0a20 2020 2020 2020 2023  eaves..        #
-0000c270: 2043 6f6d 7075 7465 7320 7468 6520 7465   Computes the te
-0000c280: 6e73 6f72 206d 656d 6f72 7920 7573 6564  nsor memory used
-0000c290: 2062 7920 7468 6520 6769 7665 6e20 7079   by the given py
-0000c2a0: 7472 6565 0a20 2020 2020 2020 2064 6566  tree.        def
-0000c2b0: 206d 656d 6f72 795f 7573 6564 2870 7974   memory_used(pyt
-0000c2c0: 7265 6529 202d 3e20 696e 743a 0a20 2020  ree) -> int:.   
-0000c2d0: 2020 2020 2020 2020 206d 656d 6f72 795f           memory_
-0000c2e0: 7573 653a 2069 6e74 203d 2030 0a0a 2020  use: int = 0..  
-0000c2f0: 2020 2020 2020 2020 2020 6465 6620 636f            def co
-0000c300: 756e 745f 6d65 6d6f 7279 5f75 7365 2878  unt_memory_use(x
-0000c310: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
-0000c320: 2020 206e 6f6e 6c6f 6361 6c20 6d65 6d6f     nonlocal memo
-0000c330: 7279 5f75 7365 0a20 2020 2020 2020 2020  ry_use.         
-0000c340: 2020 2020 2020 2069 6620 6973 696e 7374         if isinst
-0000c350: 616e 6365 2878 2c20 5465 6e73 6f72 5072  ance(x, TensorPr
-0000c360: 6f78 7929 3a0a 2020 2020 2020 2020 2020  oxy):.          
-0000c370: 2020 2020 2020 2020 2020 6d65 6d6f 7279            memory
-0000c380: 5f75 7365 202b 3d20 782e 6474 7970 652e  _use += x.dtype.
-0000c390: 5f62 7974 6573 202a 2078 2e6e 756d 656c  _bytes * x.numel
-0000c3a0: 0a0a 2020 2020 2020 2020 2020 2020 7472  ..            tr
-0000c3b0: 6565 5f6d 6170 2863 6f75 6e74 5f6d 656d  ee_map(count_mem
-0000c3c0: 6f72 795f 7573 652c 2070 7974 7265 6529  ory_use, pytree)
-0000c3d0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-0000c3e0: 7572 6e20 6d65 6d6f 7279 5f75 7365 0a0a  urn memory_use..
-0000c3f0: 2020 2020 2020 2020 2320 5472 7565 2077          # True w
-0000c400: 6865 6e20 6120 6e6f 6465 2069 7320 6120  hen a node is a 
-0000c410: 226c 696e 6b22 202d 2d20 6120 6e6f 6465  "link" -- a node
-0000c420: 2077 6974 6820 6f6e 6c79 206f 6e65 2063   with only one c
-0000c430: 6869 6c64 2061 6e64 2061 7420 6d6f 7374  hild and at most
-0000c440: 206f 6e65 2070 6172 656e 740a 2020 2020   one parent.    
-0000c450: 2020 2020 2320 2020 436f 6e63 6570 7475      #   Conceptu
-0000c460: 616c 6c79 2074 6865 206e 6f64 6520 6973  ally the node is
-0000c470: 2061 2022 6c69 6e6b 2220 696e 2061 2063   a "link" in a c
-0000c480: 6861 696e 206f 6620 6e6f 6465 7320 6c69  hain of nodes li
-0000c490: 6b65 2041 202d 3e20 4220 2d3e 2043 0a20  ke A -> B -> C. 
-0000c4a0: 2020 2020 2020 2064 6566 2069 735f 6c69         def is_li
-0000c4b0: 6e6b 286e 3a20 4e6f 6465 2920 2d3e 2062  nk(n: Node) -> b
-0000c4c0: 6f6f 6c3a 0a20 2020 2020 2020 2020 2020  ool:.           
-0000c4d0: 205f 6973 5f6c 696e 6b20 3d20 6c65 6e28   _is_link = len(
-0000c4e0: 6e2e 6368 696c 6472 656e 2920 3d3d 2031  n.children) == 1
-0000c4f0: 2061 6e64 206c 656e 286e 2e70 6172 656e   and len(n.paren
-0000c500: 7473 2920 3c3d 2031 0a20 2020 2020 2020  ts) <= 1.       
-0000c510: 2020 2020 2072 6574 7572 6e20 5f69 735f       return _is_
-0000c520: 6c69 6e6b 0a0a 2020 2020 2020 2020 636f  link..        co
-0000c530: 756e 7465 723a 2069 6e74 203d 2030 0a0a  unter: int = 0..
-0000c540: 2020 2020 2020 2020 6465 6620 5f63 6861          def _cha
-0000c550: 696e 2863 3a20 6c69 7374 5b4e 6f64 655d  in(c: list[Node]
-0000c560: 2c20 656e 643a 204e 6f64 6529 202d 3e20  , end: Node) -> 
-0000c570: 6c69 7374 5b4e 6f64 655d 3a0a 2020 2020  list[Node]:.    
-0000c580: 2020 2020 2020 2020 6e6f 6e6c 6f63 616c          nonlocal
-0000c590: 2063 6f75 6e74 6572 0a0a 2020 2020 2020   counter..      
-0000c5a0: 2020 2020 2020 2320 544f 444f 2045 7870        # TODO Exp
-0000c5b0: 6572 696d 656e 7420 7769 7468 206e 6f74  eriment with not
-0000c5c0: 2061 6c77 6179 7320 6675 7369 6e67 2074   always fusing t
-0000c5d0: 6869 7320 696e 746f 2074 6865 2063 6f6e  his into the con
-0000c5e0: 7375 6d65 7220 2d2d 2074 6865 7265 2063  sumer -- there c
-0000c5f0: 6f75 6c64 2062 6520 616e 0a20 2020 2020  ould be an.     
-0000c600: 2020 2020 2020 2023 2020 2069 6e74 6572         #   inter
-0000c610: 6573 7469 6e67 206d 696e 6375 740a 2020  esting mincut.  
-0000c620: 2020 2020 2020 2020 2020 2320 4e4f 5445            # NOTE
-0000c630: 2049 6e20 7468 6973 2063 6173 6520 7468   In this case th
-0000c640: 6520 6368 6169 6e20 6361 6e6e 6f74 2062  e chain cannot b
-0000c650: 6520 6578 7465 6e64 6564 2c20 616e 6420  e extended, and 
-0000c660: 6974 7320 6f72 6967 696e 2069 7320 696e  its origin is in
-0000c670: 7075 7420 746f 2074 6865 2066 756e 6374  put to the funct
-0000c680: 696f 6e0a 2020 2020 2020 2020 2020 2020  ion.            
-0000c690: 2320 2020 736f 2074 6869 7320 6a75 7374  #   so this just
-0000c6a0: 2066 7573 6573 2069 7420 696e 746f 2074   fuses it into t
-0000c6b0: 6865 2063 6f6e 7375 6d65 720a 2020 2020  he consumer.    
-0000c6c0: 2020 2020 2020 2020 6966 206c 656e 2865          if len(e
-0000c6d0: 6e64 2e70 6172 656e 7473 2920 3d3d 2030  nd.parents) == 0
-0000c6e0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000c6f0: 2020 666f 7220 6e20 696e 2063 3a0a 2020    for n in c:.  
+0000bca0: 2020 7377 6170 6d61 705b 7667 7261 645d    swapmap[vgrad]
+0000bcb0: 203d 2061 6374 7561 6c5f 6772 6164 0a0a   = actual_grad..
+0000bcc0: 2020 2020 2020 2020 6669 6e61 6c6c 793a          finally:
+0000bcd0: 0a20 2020 2020 2020 2020 2020 2023 2052  .            # R
+0000bce0: 6573 746f 7265 7320 7363 6f70 650a 2020  estores scope.  
+0000bcf0: 2020 2020 2020 2020 2020 7265 7365 745f            reset_
+0000bd00: 7472 6163 6563 7478 2874 7261 6365 6374  tracectx(tracect
+0000bd10: 785f 746f 6b29 0a0a 2020 2020 2020 2020  x_tok)..        
+0000bd20: 2320 4669 6c74 6572 7320 7075 745f 6772  # Filters put_gr
+0000bd30: 6164 2061 6e64 2067 6574 5f67 7261 6420  ad and get_grad 
+0000bd40: 6f70 6572 6174 696f 6e73 2061 6e64 2061  operations and a
+0000bd50: 7070 6c69 6573 2074 6865 2073 7761 706d  pplies the swapm
+0000bd60: 6170 0a20 2020 2020 2020 2064 6566 205f  ap.        def _
+0000bd70: 6669 6c74 6572 2862 7379 6d3a 2042 6f75  filter(bsym: Bou
+0000bd80: 6e64 5379 6d62 6f6c 2920 2d3e 2062 6f6f  ndSymbol) -> boo
+0000bd90: 6c3a 0a20 2020 2020 2020 2020 2020 2069  l:.            i
+0000bda0: 643a 2048 6173 6861 626c 6520 3d20 6273  d: Hashable = bs
+0000bdb0: 796d 2e73 796d 2e69 640a 2020 2020 2020  ym.sym.id.      
+0000bdc0: 2020 2020 2020 7265 7475 726e 2069 6420        return id 
+0000bdd0: 696e 2028 7069 6473 2e50 5554 5f47 5241  in (pids.PUT_GRA
+0000bde0: 442c 2070 6964 732e 4745 545f 4752 4144  D, pids.GET_GRAD
+0000bdf0: 290a 0a20 2020 2020 2020 2067 7261 6474  )..        gradt
+0000be00: 7263 2e62 6f75 6e64 5f73 796d 626f 6c73  rc.bound_symbols
+0000be10: 203d 205b 0a20 2020 2020 2020 2020 2020   = [.           
+0000be20: 2062 7379 6d2e 6672 6f6d 5f62 7379 6d5f   bsym.from_bsym_
+0000be30: 7377 6170 5f70 726f 7869 6573 2873 7761  swap_proxies(swa
+0000be40: 706d 6170 2920 666f 7220 6273 796d 2069  pmap) for bsym i
+0000be50: 6e20 6772 6164 7472 632e 626f 756e 645f  n gradtrc.bound_
+0000be60: 7379 6d62 6f6c 7320 6966 206e 6f74 205f  symbols if not _
+0000be70: 6669 6c74 6572 2862 7379 6d29 0a20 2020  filter(bsym).   
+0000be80: 2020 2020 205d 0a0a 2020 2020 2020 2020       ]..        
+0000be90: 2320 5354 4550 2046 4f55 5220 2d2d 2d20  # STEP FOUR --- 
+0000bea0: 4f72 6465 7273 2074 6865 206f 7065 7261  Orders the opera
+0000beb0: 7469 6f6e 730a 2020 2020 2020 2020 2320  tions.        # 
+0000bec0: 544f 444f 2043 6f6e 7369 6465 7220 616c  TODO Consider al
+0000bed0: 7465 726e 6174 6976 6520 7363 6865 6475  ternative schedu
+0000bee0: 6c69 6e67 2061 6c67 6f72 6974 686d 732c  ling algorithms,
+0000bef0: 206d 6179 6265 2062 7920 7573 696e 6720   maybe by using 
+0000bf00: 6772 6170 6820 6665 6174 7572 6573 0a20  graph features. 
+0000bf10: 2020 2020 2020 2023 2020 2053 6f6d 6520         #   Some 
+0000bf20: 6964 6561 7320 6172 6520 6c6f 6f6b 696e  ideas are lookin
+0000bf30: 6720 6174 206d 656d 6f72 792d 7361 7669  g at memory-savi
+0000bf40: 6e67 206e 6f64 6573 2c20 616e 6420 6e6f  ng nodes, and no
+0000bf50: 6465 7320 7769 7468 2061 2068 6967 6820  des with a high 
+0000bf60: 696e 2d64 6567 7265 6520 6f72 2068 6967  in-degree or hig
+0000bf70: 6820 6f75 742d 6465 6772 6565 0a0a 2020  h out-degree..  
+0000bf80: 2020 2020 2020 2320 4372 6561 7465 7320        # Creates 
+0000bf90: 616e 2069 6e69 7469 616c 2076 616c 6964  an initial valid
+0000bfa0: 206f 7264 6572 696e 6720 746f 2044 4345   ordering to DCE
+0000bfb0: 2c20 736f 2074 6861 7420 6164 6469 7469  , so that additi
+0000bfc0: 6f6e 616c 206f 7264 6572 696e 6720 616e  onal ordering an
+0000bfd0: 616c 7973 6973 2064 6f65 736e 2774 206e  alysis doesn't n
+0000bfe0: 6565 6420 746f 2063 6f6e 7369 6465 7220  eed to consider 
+0000bff0: 616c 6c20 7379 6d62 6f6c 730a 2020 2020  all symbols.    
+0000c000: 2020 2020 726f 6f74 732c 206c 6561 7665      roots, leave
+0000c010: 7320 3d20 6273 796d 5f6c 6973 745f 746f  s = bsym_list_to
+0000c020: 5f64 6167 2867 7261 6474 7263 2e62 6f75  _dag(gradtrc.bou
+0000c030: 6e64 5f73 796d 626f 6c73 290a 2020 2020  nd_symbols).    
+0000c040: 2020 2020 6f72 6465 7265 645f 6273 796d      ordered_bsym
+0000c050: 7320 3d20 746f 706f 736f 7274 5f62 7379  s = toposort_bsy
+0000c060: 6d5f 6461 6728 726f 6f74 732c 2054 4f50  m_dag(roots, TOP
+0000c070: 4f53 4f52 545f 4f52 4445 522e 544f 505f  OSORT_ORDER.TOP_
+0000c080: 444f 574e 290a 2020 2020 2020 2020 6772  DOWN).        gr
+0000c090: 6164 7472 632e 626f 756e 645f 7379 6d62  adtrc.bound_symb
+0000c0a0: 6f6c 7320 3d20 6f72 6465 7265 645f 6273  ols = ordered_bs
+0000c0b0: 796d 730a 2020 2020 2020 2020 6772 6164  yms.        grad
+0000c0c0: 7472 6320 3d20 6463 6528 6772 6164 7472  trc = dce(gradtr
+0000c0d0: 6329 0a0a 2020 2020 2020 2020 2320 4964  c)..        # Id
+0000c0e0: 656e 7469 6669 6573 2074 6865 206f 7264  entifies the ord
+0000c0f0: 6572 206f 6620 426f 756e 6453 796d 626f  er of BoundSymbo
+0000c100: 6c73 2075 7369 6e67 2061 2022 4446 5320  ls using a "DFS 
+0000c110: 616e 6420 6368 6169 6e22 2061 6c67 6f72  and chain" algor
+0000c120: 6974 686d 0a20 2020 2020 2020 2023 2054  ithm.        # T
+0000c130: 4f44 4f20 456c 6162 6f72 6174 6520 6f6e  ODO Elaborate on
+0000c140: 2074 6869 7320 616c 676f 7269 7468 6d20   this algorithm 
+0000c150: 616e 6420 7468 6520 696d 706c 656d 656e  and the implemen
+0000c160: 7461 7469 6f6e 0a20 2020 2020 2020 2072  tation.        r
+0000c170: 6f6f 7473 2c20 6c65 6176 6573 203d 2062  oots, leaves = b
+0000c180: 7379 6d5f 6c69 7374 5f74 6f5f 6461 6728  sym_list_to_dag(
+0000c190: 6772 6164 7472 632e 626f 756e 645f 7379  gradtrc.bound_sy
+0000c1a0: 6d62 6f6c 7329 0a20 2020 2020 2020 2063  mbols).        c
+0000c1b0: 6865 636b 280a 2020 2020 2020 2020 2020  heck(.          
+0000c1c0: 2020 6c65 6e28 6c65 6176 6573 2920 3d3d    len(leaves) ==
+0000c1d0: 2031 2c0a 2020 2020 2020 2020 2020 2020   1,.            
+0000c1e0: 6c61 6d62 6461 3a20 6622 4578 7065 6374  lambda: f"Expect
+0000c1f0: 6564 206f 6e6c 7920 6f6e 6520 6c65 6166  ed only one leaf
+0000c200: 206e 6f64 6520 7768 656e 2073 6f72 7469   node when sorti
+0000c210: 6e67 2066 6f72 2067 7261 642c 2066 6f75  ng for grad, fou
+0000c220: 6e64 2074 6865 7265 2077 6572 6520 7b6c  nd there were {l
+0000c230: 656e 286c 6561 7665 7329 7d20 6c65 6176  en(leaves)} leav
+0000c240: 6573 222c 0a20 2020 2020 2020 2029 0a20  es",.        ). 
+0000c250: 2020 2020 2020 2028 6c65 6166 2c29 203d         (leaf,) =
+0000c260: 206c 6561 7665 730a 0a20 2020 2020 2020   leaves..       
+0000c270: 2023 2043 6f6d 7075 7465 7320 7468 6520   # Computes the 
+0000c280: 7465 6e73 6f72 206d 656d 6f72 7920 7573  tensor memory us
+0000c290: 6564 2062 7920 7468 6520 6769 7665 6e20  ed by the given 
+0000c2a0: 7079 7472 6565 0a20 2020 2020 2020 2064  pytree.        d
+0000c2b0: 6566 206d 656d 6f72 795f 7573 6564 2870  ef memory_used(p
+0000c2c0: 7974 7265 6529 202d 3e20 696e 743a 0a20  ytree) -> int:. 
+0000c2d0: 2020 2020 2020 2020 2020 206d 656d 6f72             memor
+0000c2e0: 795f 7573 653a 2069 6e74 203d 2030 0a0a  y_use: int = 0..
+0000c2f0: 2020 2020 2020 2020 2020 2020 6465 6620              def 
+0000c300: 636f 756e 745f 6d65 6d6f 7279 5f75 7365  count_memory_use
+0000c310: 2878 293a 0a20 2020 2020 2020 2020 2020  (x):.           
+0000c320: 2020 2020 206e 6f6e 6c6f 6361 6c20 6d65       nonlocal me
+0000c330: 6d6f 7279 5f75 7365 0a20 2020 2020 2020  mory_use.       
+0000c340: 2020 2020 2020 2020 2069 6620 6973 696e           if isin
+0000c350: 7374 616e 6365 2878 2c20 5465 6e73 6f72  stance(x, Tensor
+0000c360: 5072 6f78 7929 3a0a 2020 2020 2020 2020  Proxy):.        
+0000c370: 2020 2020 2020 2020 2020 2020 6d65 6d6f              memo
+0000c380: 7279 5f75 7365 202b 3d20 782e 6474 7970  ry_use += x.dtyp
+0000c390: 652e 5f62 7974 6573 202a 2078 2e6e 756d  e._bytes * x.num
+0000c3a0: 656c 0a0a 2020 2020 2020 2020 2020 2020  el..            
+0000c3b0: 7472 6565 5f6d 6170 2863 6f75 6e74 5f6d  tree_map(count_m
+0000c3c0: 656d 6f72 795f 7573 652c 2070 7974 7265  emory_use, pytre
+0000c3d0: 6529 0a20 2020 2020 2020 2020 2020 2072  e).            r
+0000c3e0: 6574 7572 6e20 6d65 6d6f 7279 5f75 7365  eturn memory_use
+0000c3f0: 0a0a 2020 2020 2020 2020 2320 5472 7565  ..        # True
+0000c400: 2077 6865 6e20 6120 6e6f 6465 2069 7320   when a node is 
+0000c410: 6120 226c 696e 6b22 202d 2d20 6120 6e6f  a "link" -- a no
+0000c420: 6465 2077 6974 6820 6f6e 6c79 206f 6e65  de with only one
+0000c430: 2063 6869 6c64 2061 6e64 2061 7420 6d6f   child and at mo
+0000c440: 7374 206f 6e65 2070 6172 656e 740a 2020  st one parent.  
+0000c450: 2020 2020 2020 2320 2020 436f 6e63 6570        #   Concep
+0000c460: 7475 616c 6c79 2074 6865 206e 6f64 6520  tually the node 
+0000c470: 6973 2061 2022 6c69 6e6b 2220 696e 2061  is a "link" in a
+0000c480: 2063 6861 696e 206f 6620 6e6f 6465 7320   chain of nodes 
+0000c490: 6c69 6b65 2041 202d 3e20 4220 2d3e 2043  like A -> B -> C
+0000c4a0: 0a20 2020 2020 2020 2064 6566 2069 735f  .        def is_
+0000c4b0: 6c69 6e6b 286e 3a20 4e6f 6465 2920 2d3e  link(n: Node) ->
+0000c4c0: 2062 6f6f 6c3a 0a20 2020 2020 2020 2020   bool:.         
+0000c4d0: 2020 205f 6973 5f6c 696e 6b20 3d20 6c65     _is_link = le
+0000c4e0: 6e28 6e2e 6368 696c 6472 656e 2920 3d3d  n(n.children) ==
+0000c4f0: 2031 2061 6e64 206c 656e 286e 2e70 6172   1 and len(n.par
+0000c500: 656e 7473 2920 3c3d 2031 0a20 2020 2020  ents) <= 1.     
+0000c510: 2020 2020 2020 2072 6574 7572 6e20 5f69         return _i
+0000c520: 735f 6c69 6e6b 0a0a 2020 2020 2020 2020  s_link..        
+0000c530: 636f 756e 7465 723a 2069 6e74 203d 2030  counter: int = 0
+0000c540: 0a0a 2020 2020 2020 2020 6465 6620 5f63  ..        def _c
+0000c550: 6861 696e 2863 3a20 6c69 7374 5b4e 6f64  hain(c: list[Nod
+0000c560: 655d 2c20 656e 643a 204e 6f64 6529 202d  e], end: Node) -
+0000c570: 3e20 6c69 7374 5b4e 6f64 655d 3a0a 2020  > list[Node]:.  
+0000c580: 2020 2020 2020 2020 2020 6e6f 6e6c 6f63            nonloc
+0000c590: 616c 2063 6f75 6e74 6572 0a0a 2020 2020  al counter..    
+0000c5a0: 2020 2020 2020 2020 2320 544f 444f 2045          # TODO E
+0000c5b0: 7870 6572 696d 656e 7420 7769 7468 206e  xperiment with n
+0000c5c0: 6f74 2061 6c77 6179 7320 6675 7369 6e67  ot always fusing
+0000c5d0: 2074 6869 7320 696e 746f 2074 6865 2063   this into the c
+0000c5e0: 6f6e 7375 6d65 7220 2d2d 2074 6865 7265  onsumer -- there
+0000c5f0: 2063 6f75 6c64 2062 6520 616e 0a20 2020   could be an.   
+0000c600: 2020 2020 2020 2020 2023 2020 2069 6e74           #   int
+0000c610: 6572 6573 7469 6e67 206d 696e 6375 740a  eresting mincut.
+0000c620: 2020 2020 2020 2020 2020 2020 2320 4e4f              # NO
+0000c630: 5445 2049 6e20 7468 6973 2063 6173 6520  TE In this case 
+0000c640: 7468 6520 6368 6169 6e20 6361 6e6e 6f74  the chain cannot
+0000c650: 2062 6520 6578 7465 6e64 6564 2c20 616e   be extended, an
+0000c660: 6420 6974 7320 6f72 6967 696e 2069 7320  d its origin is 
+0000c670: 696e 7075 7420 746f 2074 6865 2066 756e  input to the fun
+0000c680: 6374 696f 6e0a 2020 2020 2020 2020 2020  ction.          
+0000c690: 2020 2320 2020 736f 2074 6869 7320 6a75    #   so this ju
+0000c6a0: 7374 2066 7573 6573 2069 7420 696e 746f  st fuses it into
+0000c6b0: 2074 6865 2063 6f6e 7375 6d65 720a 2020   the consumer.  
+0000c6c0: 2020 2020 2020 2020 2020 6966 206c 656e            if len
+0000c6d0: 2865 6e64 2e70 6172 656e 7473 2920 3d3d  (end.parents) ==
+0000c6e0: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
+0000c6f0: 2020 2020 666f 7220 6e20 696e 2063 3a0a      for n in c:.
 0000c700: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c710: 2020 6e2e 6e75 6d62 6572 203d 2063 6f75    n.number = cou
-0000c720: 6e74 6572 0a20 2020 2020 2020 2020 2020  nter.           
-0000c730: 2020 2020 2020 2020 2063 6f75 6e74 6572           counter
-0000c740: 202b 3d20 310a 2020 2020 2020 2020 2020   += 1.          
-0000c750: 2020 2020 2020 7265 7475 726e 205b 5d0a        return [].
-0000c760: 0a20 2020 2020 2020 2020 2020 2023 204e  .            # N
-0000c770: 4f54 4520 6c65 6e28 656e 642e 7061 7265  OTE len(end.pare
-0000c780: 6e74 7329 203d 3d20 3120 6f6e 2074 6869  nts) == 1 on thi
-0000c790: 7320 7061 7468 0a20 2020 2020 2020 2020  s path.         
-0000c7a0: 2020 2028 7061 7265 6e74 2c29 203d 2065     (parent,) = e
-0000c7b0: 6e64 2e70 6172 656e 7473 0a0a 2020 2020  nd.parents..    
-0000c7c0: 2020 2020 2020 2020 2320 4578 7465 6e64          # Extend
-0000c7d0: 7320 7468 6520 6368 6169 6e20 6966 2074  s the chain if t
-0000c7e0: 6865 2070 6172 656e 7420 6973 2061 206c  he parent is a l
-0000c7f0: 696e 6b0a 2020 2020 2020 2020 2020 2020  ink.            
-0000c800: 6966 2069 735f 6c69 6e6b 2870 6172 656e  if is_link(paren
-0000c810: 7429 3a0a 2020 2020 2020 2020 2020 2020  t):.            
-0000c820: 2020 2020 632e 6170 7065 6e64 2870 6172      c.append(par
-0000c830: 656e 7429 0a20 2020 2020 2020 2020 2020  ent).           
-0000c840: 2020 2020 2072 6574 7572 6e20 5f63 6861       return _cha
-0000c850: 696e 2863 2c20 7061 7265 6e74 290a 0a20  in(c, parent).. 
-0000c860: 2020 2020 2020 2020 2020 2023 204e 4f54             # NOT
-0000c870: 4520 496e 2074 6869 7320 6361 7365 2074  E In this case t
-0000c880: 6865 2063 6861 696e 2068 6173 2061 2070  he chain has a p
-0000c890: 6172 656e 7420 7468 6174 2069 7320 6e6f  arent that is no
-0000c8a0: 7420 6120 6c69 6e6b 0a20 2020 2020 2020  t a link.       
-0000c8b0: 2020 2020 2023 2046 696e 6473 2074 6865       # Finds the
-0000c8c0: 206d 696e 6375 740a 2020 2020 2020 2020   mincut.        
-0000c8d0: 2020 2020 6d69 6e63 7574 5f69 6478 3a20      mincut_idx: 
-0000c8e0: 696e 7420 3d20 6c65 6e28 6329 0a20 2020  int = len(c).   
-0000c8f0: 2020 2020 2020 2020 206d 696e 5f6d 656d           min_mem
-0000c900: 6f72 795f 7573 6167 653a 2069 6e74 203d  ory_usage: int =
-0000c910: 206d 656d 6f72 795f 7573 6564 2870 6172   memory_used(par
-0000c920: 656e 742e 6273 796d 2e6f 7574 7075 7429  ent.bsym.output)
-0000c930: 0a0a 2020 2020 2020 2020 2020 2020 666f  ..            fo
-0000c940: 7220 6964 782c 206e 2069 6e20 656e 756d  r idx, n in enum
-0000c950: 6572 6174 6528 6329 3a0a 2020 2020 2020  erate(c):.      
-0000c960: 2020 2020 2020 2020 2020 6d65 6d20 3d20            mem = 
-0000c970: 6d65 6d6f 7279 5f75 7365 6428 6e2e 6273  memory_used(n.bs
-0000c980: 796d 2e6f 7574 7075 7429 0a20 2020 2020  ym.output).     
-0000c990: 2020 2020 2020 2020 2020 2069 6620 6d65             if me
-0000c9a0: 6d20 3c20 6d69 6e5f 6d65 6d6f 7279 5f75  m < min_memory_u
-0000c9b0: 7361 6765 3a0a 2020 2020 2020 2020 2020  sage:.          
-0000c9c0: 2020 2020 2020 2020 2020 6d69 6e63 7574            mincut
-0000c9d0: 5f69 6478 203d 2069 6478 0a20 2020 2020  _idx = idx.     
-0000c9e0: 2020 2020 2020 2020 2020 2020 2020 206d                 m
-0000c9f0: 696e 5f6d 656d 6f72 795f 7573 6167 6520  in_memory_usage 
-0000ca00: 3d20 6d65 6d0a 0a20 2020 2020 2020 2020  = mem..         
-0000ca10: 2020 2066 6f72 2069 6478 2c20 6e20 696e     for idx, n in
-0000ca20: 2065 6e75 6d65 7261 7465 2863 293a 0a20   enumerate(c):. 
-0000ca30: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0000ca40: 6620 6964 7820 3c20 6d69 6e63 7574 5f69  f idx < mincut_i
-0000ca50: 6478 3a0a 2020 2020 2020 2020 2020 2020  dx:.            
-0000ca60: 2020 2020 2020 2020 6e2e 6e75 6d62 6572          n.number
-0000ca70: 203d 2063 6f75 6e74 6572 0a20 2020 2020   = counter.     
-0000ca80: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-0000ca90: 6f75 6e74 6572 202b 3d20 310a 0a20 2020  ounter += 1..   
-0000caa0: 2020 2020 2020 2020 2023 2052 6574 7572           # Retur
-0000cab0: 6e73 2074 6865 2070 726f 6475 6365 722d  ns the producer-
-0000cac0: 7369 6465 2063 6861 696e 2063 7574 2069  side chain cut i
-0000cad0: 6620 6974 2065 7869 7374 730a 2020 2020  f it exists.    
-0000cae0: 2020 2020 2020 2020 6966 206d 696e 6375          if mincu
-0000caf0: 745f 6964 7820 3c20 6c65 6e28 6329 3a0a  t_idx < len(c):.
-0000cb00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cb10: 7265 7475 726e 205b 635b 6d69 6e63 7574  return [c[mincut
-0000cb20: 5f69 6478 5d5d 0a20 2020 2020 2020 2020  _idx]].         
-0000cb30: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-0000cb40: 2020 2020 2020 2020 2061 7373 6572 7420           assert 
-0000cb50: 6d69 6e63 7574 5f69 6478 203d 3d20 6c65  mincut_idx == le
-0000cb60: 6e28 6329 0a20 2020 2020 2020 2020 2020  n(c).           
-0000cb70: 2020 2020 2072 6574 7572 6e20 656e 642e       return end.
-0000cb80: 7061 7265 6e74 730a 0a20 2020 2020 2020  parents..       
-0000cb90: 2064 6566 2063 6861 696e 5f6f 7574 286e   def chain_out(n
-0000cba0: 3a20 4e6f 6465 2c20 7374 6163 6b3a 206c  : Node, stack: l
-0000cbb0: 6973 745b 4e6f 6465 5d29 202d 3e20 4e6f  ist[Node]) -> No
-0000cbc0: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
-0000cbd0: 2320 5368 6f72 742d 6369 7263 7569 7473  # Short-circuits
-0000cbe0: 2069 6620 7468 6520 6f72 6967 696e 616c   if the original
-0000cbf0: 206e 6f64 6520 6e20 6361 6e6e 6f74 2062   node n cannot b
-0000cc00: 6520 7061 7274 206f 6620 6120 6368 6169  e part of a chai
-0000cc10: 6e0a 2020 2020 2020 2020 2020 2020 6966  n.            if
-0000cc20: 206e 6f74 2069 735f 6c69 6e6b 286e 293a   not is_link(n):
-0000cc30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000cc40: 2073 7461 636b 2e61 7070 656e 6428 6e29   stack.append(n)
-0000cc50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000cc60: 2072 6574 7572 6e0a 0a20 2020 2020 2020   return..       
-0000cc70: 2020 2020 2023 204e 4f54 4520 6973 5f6c       # NOTE is_l
-0000cc80: 696e 6b28 6e29 203d 3d20 5472 7565 0a20  ink(n) == True. 
-0000cc90: 2020 2020 2020 2020 2020 2070 6f73 745f             post_
-0000cca0: 6368 6169 6e3a 206c 6973 745b 4e6f 6465  chain: list[Node
-0000ccb0: 5d20 3d20 5f63 6861 696e 285b 6e5d 2c20  ] = _chain([n], 
-0000ccc0: 6e29 0a0a 2020 2020 2020 2020 2020 2020  n)..            
-0000ccd0: 666f 7220 7063 2069 6e20 706f 7374 5f63  for pc in post_c
-0000cce0: 6861 696e 3a0a 2020 2020 2020 2020 2020  hain:.          
-0000ccf0: 2020 2020 2020 7374 6163 6b2e 6170 7065        stack.appe
-0000cd00: 6e64 2870 6329 0a0a 2020 2020 2020 2020  nd(pc)..        
-0000cd10: 7374 6163 6b3a 206c 6973 745b 4e6f 6465  stack: list[Node
-0000cd20: 5d20 3d20 5b6c 6561 665d 0a20 2020 2020  ] = [leaf].     
-0000cd30: 2020 2077 6869 6c65 206c 656e 2873 7461     while len(sta
-0000cd40: 636b 2920 3e20 303a 0a20 2020 2020 2020  ck) > 0:.       
-0000cd50: 2020 2020 206e 3a20 4e6f 6465 203d 2073       n: Node = s
-0000cd60: 7461 636b 2e70 6f70 2829 0a0a 2020 2020  tack.pop()..    
-0000cd70: 2020 2020 2020 2020 6966 206e 2e6e 756d          if n.num
-0000cd80: 6265 7220 6973 206e 6f74 204e 6f6e 653a  ber is not None:
-0000cd90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000cda0: 2063 6f6e 7469 6e75 650a 0a20 2020 2020   continue..     
-0000cdb0: 2020 2020 2020 206e 2e6e 756d 6265 7220         n.number 
-0000cdc0: 3d20 636f 756e 7465 720a 2020 2020 2020  = counter.      
-0000cdd0: 2020 2020 2020 636f 756e 7465 7220 2b3d        counter +=
-0000cde0: 2031 0a0a 2020 2020 2020 2020 2020 2020   1..            
-0000cdf0: 666f 7220 7020 696e 206e 2e70 6172 656e  for p in n.paren
-0000ce00: 7473 3a0a 2020 2020 2020 2020 2020 2020  ts:.            
-0000ce10: 2020 2020 6368 6169 6e5f 6f75 7428 702c      chain_out(p,
-0000ce20: 2073 7461 636b 290a 0a20 2020 2020 2020   stack)..       
-0000ce30: 2064 6566 205f 7365 6c65 6374 6f72 2865   def _selector(e
-0000ce40: 6c69 6769 626c 655f 6e6f 6465 733a 206c  ligible_nodes: l
-0000ce50: 6973 745b 4e6f 6465 5d29 202d 3e20 696e  ist[Node]) -> in
-0000ce60: 743a 0a20 2020 2020 2020 2020 2020 206d  t:.            m
-0000ce70: 696e 5f69 6478 3a20 696e 7420 3d20 300a  in_idx: int = 0.
-0000ce80: 2020 2020 2020 2020 2020 2020 6d69 6e5f              min_
-0000ce90: 6e75 6d62 6572 3a20 696e 7420 3d20 656c  number: int = el
-0000cea0: 6967 6962 6c65 5f6e 6f64 6573 5b30 5d2e  igible_nodes[0].
-0000ceb0: 6e75 6d62 6572 0a0a 2020 2020 2020 2020  number..        
-0000cec0: 2020 2020 2320 4e4f 5445 2041 6c74 686f      # NOTE Altho
-0000ced0: 7567 6820 7765 2776 6520 616c 7265 6164  ugh we've alread
-0000cee0: 7920 7072 6f63 6573 7365 6420 7468 6520  y processed the 
-0000cef0: 6669 7273 7420 656c 656d 656e 7420 6865  first element he
-0000cf00: 7265 2c20 7468 6973 2073 7469 6c6c 0a20  re, this still. 
-0000cf10: 2020 2020 2020 2020 2020 2023 2020 2065             #   e
-0000cf20: 6e75 6d65 7261 7465 7320 7468 6520 656e  numerates the en
-0000cf30: 7469 7265 206c 6973 7420 6320 746f 2061  tire list c to a
-0000cf40: 6c69 676e 2074 6865 2065 6e75 6d65 7261  lign the enumera
-0000cf50: 7469 6f6e 2069 6478 2070 726f 7065 726c  tion idx properl
-0000cf60: 790a 2020 2020 2020 2020 2020 2020 666f  y.            fo
-0000cf70: 7220 6964 782c 206e 2069 6e20 656e 756d  r idx, n in enum
-0000cf80: 6572 6174 6528 656c 6967 6962 6c65 5f6e  erate(eligible_n
-0000cf90: 6f64 6573 293a 0a20 2020 2020 2020 2020  odes):.         
-0000cfa0: 2020 2020 2020 2063 6865 636b 286e 2e6e         check(n.n
-0000cfb0: 756d 6265 7220 6973 206e 6f74 204e 6f6e  umber is not Non
-0000cfc0: 652c 206c 616d 6264 613a 2066 2245 7870  e, lambda: f"Exp
-0000cfd0: 6563 7465 6420 6561 6368 206e 6f64 6520  ected each node 
-0000cfe0: 746f 2062 6520 6e75 6d62 6572 6564 2c20  to be numbered, 
-0000cff0: 6275 7420 7b6e 7d20 7761 7320 6e6f 7422  but {n} was not"
-0000d000: 290a 0a20 2020 2020 2020 2020 2020 2020  )..             
-0000d010: 2020 2069 6620 6e2e 6e75 6d62 6572 203c     if n.number <
-0000d020: 206d 696e 5f6e 756d 6265 723a 0a20 2020   min_number:.   
+0000c710: 2020 2020 6e2e 6e75 6d62 6572 203d 2063      n.number = c
+0000c720: 6f75 6e74 6572 0a20 2020 2020 2020 2020  ounter.         
+0000c730: 2020 2020 2020 2020 2020 2063 6f75 6e74             count
+0000c740: 6572 202b 3d20 310a 2020 2020 2020 2020  er += 1.        
+0000c750: 2020 2020 2020 2020 7265 7475 726e 205b          return [
+0000c760: 5d0a 0a20 2020 2020 2020 2020 2020 2023  ]..            #
+0000c770: 204e 4f54 4520 6c65 6e28 656e 642e 7061   NOTE len(end.pa
+0000c780: 7265 6e74 7329 203d 3d20 3120 6f6e 2074  rents) == 1 on t
+0000c790: 6869 7320 7061 7468 0a20 2020 2020 2020  his path.       
+0000c7a0: 2020 2020 2028 7061 7265 6e74 2c29 203d       (parent,) =
+0000c7b0: 2065 6e64 2e70 6172 656e 7473 0a0a 2020   end.parents..  
+0000c7c0: 2020 2020 2020 2020 2020 2320 4578 7465            # Exte
+0000c7d0: 6e64 7320 7468 6520 6368 6169 6e20 6966  nds the chain if
+0000c7e0: 2074 6865 2070 6172 656e 7420 6973 2061   the parent is a
+0000c7f0: 206c 696e 6b0a 2020 2020 2020 2020 2020   link.          
+0000c800: 2020 6966 2069 735f 6c69 6e6b 2870 6172    if is_link(par
+0000c810: 656e 7429 3a0a 2020 2020 2020 2020 2020  ent):.          
+0000c820: 2020 2020 2020 632e 6170 7065 6e64 2870        c.append(p
+0000c830: 6172 656e 7429 0a20 2020 2020 2020 2020  arent).         
+0000c840: 2020 2020 2020 2072 6574 7572 6e20 5f63         return _c
+0000c850: 6861 696e 2863 2c20 7061 7265 6e74 290a  hain(c, parent).
+0000c860: 0a20 2020 2020 2020 2020 2020 2023 204e  .            # N
+0000c870: 4f54 4520 496e 2074 6869 7320 6361 7365  OTE In this case
+0000c880: 2074 6865 2063 6861 696e 2068 6173 2061   the chain has a
+0000c890: 2070 6172 656e 7420 7468 6174 2069 7320   parent that is 
+0000c8a0: 6e6f 7420 6120 6c69 6e6b 0a20 2020 2020  not a link.     
+0000c8b0: 2020 2020 2020 2023 2046 696e 6473 2074         # Finds t
+0000c8c0: 6865 206d 696e 6375 740a 2020 2020 2020  he mincut.      
+0000c8d0: 2020 2020 2020 6d69 6e63 7574 5f69 6478        mincut_idx
+0000c8e0: 3a20 696e 7420 3d20 6c65 6e28 6329 0a20  : int = len(c). 
+0000c8f0: 2020 2020 2020 2020 2020 206d 696e 5f6d             min_m
+0000c900: 656d 6f72 795f 7573 6167 653a 2069 6e74  emory_usage: int
+0000c910: 203d 206d 656d 6f72 795f 7573 6564 2870   = memory_used(p
+0000c920: 6172 656e 742e 6273 796d 2e6f 7574 7075  arent.bsym.outpu
+0000c930: 7429 0a0a 2020 2020 2020 2020 2020 2020  t)..            
+0000c940: 666f 7220 6964 782c 206e 2069 6e20 656e  for idx, n in en
+0000c950: 756d 6572 6174 6528 6329 3a0a 2020 2020  umerate(c):.    
+0000c960: 2020 2020 2020 2020 2020 2020 6d65 6d20              mem 
+0000c970: 3d20 6d65 6d6f 7279 5f75 7365 6428 6e2e  = memory_used(n.
+0000c980: 6273 796d 2e6f 7574 7075 7429 0a20 2020  bsym.output).   
+0000c990: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0000c9a0: 6d65 6d20 3c20 6d69 6e5f 6d65 6d6f 7279  mem < min_memory
+0000c9b0: 5f75 7361 6765 3a0a 2020 2020 2020 2020  _usage:.        
+0000c9c0: 2020 2020 2020 2020 2020 2020 6d69 6e63              minc
+0000c9d0: 7574 5f69 6478 203d 2069 6478 0a20 2020  ut_idx = idx.   
+0000c9e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c9f0: 206d 696e 5f6d 656d 6f72 795f 7573 6167   min_memory_usag
+0000ca00: 6520 3d20 6d65 6d0a 0a20 2020 2020 2020  e = mem..       
+0000ca10: 2020 2020 2066 6f72 2069 6478 2c20 6e20       for idx, n 
+0000ca20: 696e 2065 6e75 6d65 7261 7465 2863 293a  in enumerate(c):
+0000ca30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000ca40: 2069 6620 6964 7820 3c20 6d69 6e63 7574   if idx < mincut
+0000ca50: 5f69 6478 3a0a 2020 2020 2020 2020 2020  _idx:.          
+0000ca60: 2020 2020 2020 2020 2020 6e2e 6e75 6d62            n.numb
+0000ca70: 6572 203d 2063 6f75 6e74 6572 0a20 2020  er = counter.   
+0000ca80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ca90: 2063 6f75 6e74 6572 202b 3d20 310a 0a20   counter += 1.. 
+0000caa0: 2020 2020 2020 2020 2020 2023 2052 6574             # Ret
+0000cab0: 7572 6e73 2074 6865 2070 726f 6475 6365  urns the produce
+0000cac0: 722d 7369 6465 2063 6861 696e 2063 7574  r-side chain cut
+0000cad0: 2069 6620 6974 2065 7869 7374 730a 2020   if it exists.  
+0000cae0: 2020 2020 2020 2020 2020 6966 206d 696e            if min
+0000caf0: 6375 745f 6964 7820 3c20 6c65 6e28 6329  cut_idx < len(c)
+0000cb00: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000cb10: 2020 7265 7475 726e 205b 635b 6d69 6e63    return [c[minc
+0000cb20: 7574 5f69 6478 5d5d 0a20 2020 2020 2020  ut_idx]].       
+0000cb30: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+0000cb40: 2020 2020 2020 2020 2020 2061 7373 6572             asser
+0000cb50: 7420 6d69 6e63 7574 5f69 6478 203d 3d20  t mincut_idx == 
+0000cb60: 6c65 6e28 6329 0a20 2020 2020 2020 2020  len(c).         
+0000cb70: 2020 2020 2020 2072 6574 7572 6e20 656e         return en
+0000cb80: 642e 7061 7265 6e74 730a 0a20 2020 2020  d.parents..     
+0000cb90: 2020 2064 6566 2063 6861 696e 5f6f 7574     def chain_out
+0000cba0: 286e 3a20 4e6f 6465 2c20 7374 6163 6b3a  (n: Node, stack:
+0000cbb0: 206c 6973 745b 4e6f 6465 5d29 202d 3e20   list[Node]) -> 
+0000cbc0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+0000cbd0: 2020 2320 5368 6f72 742d 6369 7263 7569    # Short-circui
+0000cbe0: 7473 2069 6620 7468 6520 6f72 6967 696e  ts if the origin
+0000cbf0: 616c 206e 6f64 6520 6e20 6361 6e6e 6f74  al node n cannot
+0000cc00: 2062 6520 7061 7274 206f 6620 6120 6368   be part of a ch
+0000cc10: 6169 6e0a 2020 2020 2020 2020 2020 2020  ain.            
+0000cc20: 6966 206e 6f74 2069 735f 6c69 6e6b 286e  if not is_link(n
+0000cc30: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+0000cc40: 2020 2073 7461 636b 2e61 7070 656e 6428     stack.append(
+0000cc50: 6e29 0a20 2020 2020 2020 2020 2020 2020  n).             
+0000cc60: 2020 2072 6574 7572 6e0a 0a20 2020 2020     return..     
+0000cc70: 2020 2020 2020 2023 204e 4f54 4520 6973         # NOTE is
+0000cc80: 5f6c 696e 6b28 6e29 203d 3d20 5472 7565  _link(n) == True
+0000cc90: 0a20 2020 2020 2020 2020 2020 2070 6f73  .            pos
+0000cca0: 745f 6368 6169 6e3a 206c 6973 745b 4e6f  t_chain: list[No
+0000ccb0: 6465 5d20 3d20 5f63 6861 696e 285b 6e5d  de] = _chain([n]
+0000ccc0: 2c20 6e29 0a0a 2020 2020 2020 2020 2020  , n)..          
+0000ccd0: 2020 666f 7220 7063 2069 6e20 706f 7374    for pc in post
+0000cce0: 5f63 6861 696e 3a0a 2020 2020 2020 2020  _chain:.        
+0000ccf0: 2020 2020 2020 2020 7374 6163 6b2e 6170          stack.ap
+0000cd00: 7065 6e64 2870 6329 0a0a 2020 2020 2020  pend(pc)..      
+0000cd10: 2020 7374 6163 6b3a 206c 6973 745b 4e6f    stack: list[No
+0000cd20: 6465 5d20 3d20 5b6c 6561 665d 0a20 2020  de] = [leaf].   
+0000cd30: 2020 2020 2077 6869 6c65 206c 656e 2873       while len(s
+0000cd40: 7461 636b 2920 3e20 303a 0a20 2020 2020  tack) > 0:.     
+0000cd50: 2020 2020 2020 206e 3a20 4e6f 6465 203d         n: Node =
+0000cd60: 2073 7461 636b 2e70 6f70 2829 0a0a 2020   stack.pop()..  
+0000cd70: 2020 2020 2020 2020 2020 6966 206e 2e6e            if n.n
+0000cd80: 756d 6265 7220 6973 206e 6f74 204e 6f6e  umber is not Non
+0000cd90: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0000cda0: 2020 2063 6f6e 7469 6e75 650a 0a20 2020     continue..   
+0000cdb0: 2020 2020 2020 2020 206e 2e6e 756d 6265           n.numbe
+0000cdc0: 7220 3d20 636f 756e 7465 720a 2020 2020  r = counter.    
+0000cdd0: 2020 2020 2020 2020 636f 756e 7465 7220          counter 
+0000cde0: 2b3d 2031 0a0a 2020 2020 2020 2020 2020  += 1..          
+0000cdf0: 2020 666f 7220 7020 696e 206e 2e70 6172    for p in n.par
+0000ce00: 656e 7473 3a0a 2020 2020 2020 2020 2020  ents:.          
+0000ce10: 2020 2020 2020 6368 6169 6e5f 6f75 7428        chain_out(
+0000ce20: 702c 2073 7461 636b 290a 0a20 2020 2020  p, stack)..     
+0000ce30: 2020 2064 6566 205f 7365 6c65 6374 6f72     def _selector
+0000ce40: 2865 6c69 6769 626c 655f 6e6f 6465 733a  (eligible_nodes:
+0000ce50: 206c 6973 745b 4e6f 6465 5d29 202d 3e20   list[Node]) -> 
+0000ce60: 696e 743a 0a20 2020 2020 2020 2020 2020  int:.           
+0000ce70: 206d 696e 5f69 6478 3a20 696e 7420 3d20   min_idx: int = 
+0000ce80: 300a 2020 2020 2020 2020 2020 2020 6d69  0.            mi
+0000ce90: 6e5f 6e75 6d62 6572 3a20 696e 7420 3d20  n_number: int = 
+0000cea0: 656c 6967 6962 6c65 5f6e 6f64 6573 5b30  eligible_nodes[0
+0000ceb0: 5d2e 6e75 6d62 6572 0a0a 2020 2020 2020  ].number..      
+0000cec0: 2020 2020 2020 2320 4e4f 5445 2041 6c74        # NOTE Alt
+0000ced0: 686f 7567 6820 7765 2776 6520 616c 7265  hough we've alre
+0000cee0: 6164 7920 7072 6f63 6573 7365 6420 7468  ady processed th
+0000cef0: 6520 6669 7273 7420 656c 656d 656e 7420  e first element 
+0000cf00: 6865 7265 2c20 7468 6973 2073 7469 6c6c  here, this still
+0000cf10: 0a20 2020 2020 2020 2020 2020 2023 2020  .            #  
+0000cf20: 2065 6e75 6d65 7261 7465 7320 7468 6520   enumerates the 
+0000cf30: 656e 7469 7265 206c 6973 7420 6320 746f  entire list c to
+0000cf40: 2061 6c69 676e 2074 6865 2065 6e75 6d65   align the enume
+0000cf50: 7261 7469 6f6e 2069 6478 2070 726f 7065  ration idx prope
+0000cf60: 726c 790a 2020 2020 2020 2020 2020 2020  rly.            
+0000cf70: 666f 7220 6964 782c 206e 2069 6e20 656e  for idx, n in en
+0000cf80: 756d 6572 6174 6528 656c 6967 6962 6c65  umerate(eligible
+0000cf90: 5f6e 6f64 6573 293a 0a20 2020 2020 2020  _nodes):.       
+0000cfa0: 2020 2020 2020 2020 2063 6865 636b 286e           check(n
+0000cfb0: 2e6e 756d 6265 7220 6973 206e 6f74 204e  .number is not N
+0000cfc0: 6f6e 652c 206c 616d 6264 613a 2066 2245  one, lambda: f"E
+0000cfd0: 7870 6563 7465 6420 6561 6368 206e 6f64  xpected each nod
+0000cfe0: 6520 746f 2062 6520 6e75 6d62 6572 6564  e to be numbered
+0000cff0: 2c20 6275 7420 7b6e 7d20 7761 7320 6e6f  , but {n} was no
+0000d000: 7422 290a 0a20 2020 2020 2020 2020 2020  t")..           
+0000d010: 2020 2020 2069 6620 6e2e 6e75 6d62 6572       if n.number
+0000d020: 203c 206d 696e 5f6e 756d 6265 723a 0a20   < min_number:. 
 0000d030: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d040: 206d 696e 5f69 6478 203d 2069 6478 0a20   min_idx = idx. 
-0000d050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d060: 2020 206d 696e 5f6e 756d 6265 7220 3d20     min_number = 
-0000d070: 6e2e 6e75 6d62 6572 0a0a 2020 2020 2020  n.number..      
-0000d080: 2020 2020 2020 7265 7475 726e 206d 696e        return min
-0000d090: 5f69 6478 0a0a 2020 2020 2020 2020 736f  _idx..        so
-0000d0a0: 7274 6564 5f62 7379 6d73 203d 2074 6f70  rted_bsyms = top
-0000d0b0: 6f73 6f72 745f 6273 796d 5f64 6167 286c  osort_bsym_dag(l
-0000d0c0: 6561 7665 732c 2074 6f70 6f73 6f72 745f  eaves, toposort_
-0000d0d0: 6f72 6465 723d 544f 504f 534f 5254 5f4f  order=TOPOSORT_O
-0000d0e0: 5244 4552 2e42 4f54 544f 4d5f 5550 2c20  RDER.BOTTOM_UP, 
-0000d0f0: 7365 6c65 6374 6f72 3d5f 7365 6c65 6374  selector=_select
-0000d100: 6f72 290a 2020 2020 2020 2020 6772 6164  or).        grad
-0000d110: 7472 632e 626f 756e 645f 7379 6d62 6f6c  trc.bound_symbol
-0000d120: 7320 3d20 736f 7274 6564 5f62 7379 6d73  s = sorted_bsyms
-0000d130: 0a20 2020 2020 2020 2067 7261 6474 7263  .        gradtrc
-0000d140: 203d 2064 6365 2867 7261 6474 7263 290a   = dce(gradtrc).
-0000d150: 0a20 2020 2020 2020 2023 2054 4f44 4f20  .        # TODO 
-0000d160: 436f 6e73 6964 6572 2068 6f77 2074 6f20  Consider how to 
-0000d170: 6861 6e64 6c65 2067 7261 6420 772e 722e  handle grad w.r.
-0000d180: 742e 206f 6e6c 7920 736f 6d65 206f 7574  t. only some out
-0000d190: 7075 7473 202d 2d20 7368 6f75 6c64 2061  puts -- should a
-0000d1a0: 6c6c 2067 7261 640a 2020 2020 2020 2020  ll grad.        
-0000d1b0: 2320 2020 6f70 6572 6174 696f 6e73 2075  #   operations u
-0000d1c0: 7369 6e67 2074 6865 206f 7468 6572 206f  sing the other o
-0000d1d0: 7574 7075 7420 6265 2072 656d 6f76 6564  utput be removed
-0000d1e0: 3f20 5768 6174 206b 696e 6420 6f66 2061  ? What kind of a
-0000d1f0: 7373 756d 7074 696f 6e20 646f 6573 2074  ssumption does t
-0000d200: 6861 740a 2020 2020 2020 2020 2320 2020  hat.        #   
-0000d210: 6d61 6b65 2061 626f 7574 2074 6865 2067  make about the g
-0000d220: 7261 6420 7374 7275 6374 7572 653f 2050  rad structure? P
-0000d230: 726f 6261 626c 7920 736f 6d65 206b 696e  robably some kin
-0000d240: 6420 6f66 2069 6e64 6570 656e 6465 6e63  d of independenc
-0000d250: 6520 6173 7375 6d70 7469 6f6e 3f20 4172  e assumption? Ar
-0000d260: 650a 2020 2020 2020 2020 2320 2020 7468  e.        #   th
-0000d270: 6572 6520 7072 6163 7469 6361 6c20 6578  ere practical ex
-0000d280: 616d 706c 6573 2077 6865 7265 2074 6861  amples where tha
-0000d290: 7427 7320 616e 2069 7373 7565 3f0a 0a20  t's an issue?.. 
-0000d2a0: 2020 2020 2020 2065 6e64 5f74 696d 655f         end_time_
-0000d2b0: 6e73 203d 2074 696d 652e 7469 6d65 5f6e  ns = time.time_n
-0000d2c0: 7328 290a 2020 2020 2020 2020 656c 6170  s().        elap
-0000d2d0: 7365 645f 7469 6d65 5f6e 7320 3d20 656e  sed_time_ns = en
-0000d2e0: 645f 7469 6d65 5f6e 7320 2d20 7374 6172  d_time_ns - star
-0000d2f0: 745f 7469 6d65 5f6e 730a 2020 2020 2020  t_time_ns.      
-0000d300: 2020 656c 6170 7365 645f 7469 6d65 5f6d    elapsed_time_m
-0000d310: 696c 6c69 7320 3d20 656c 6170 7365 645f  illis = elapsed_
-0000d320: 7469 6d65 5f6e 7320 2f2f 2031 3030 3030  time_ns // 10000
-0000d330: 3030 0a20 2020 2020 2020 2067 7261 6474  00.        gradt
-0000d340: 7263 2e73 6574 5f70 726f 7665 6e61 6e63  rc.set_provenanc
-0000d350: 6528 5472 6163 6550 726f 7665 6e61 6e63  e(TraceProvenanc
-0000d360: 6528 6622 4772 6164 2028 746f 6f6b 207b  e(f"Grad (took {
-0000d370: 656c 6170 7365 645f 7469 6d65 5f6d 696c  elapsed_time_mil
-0000d380: 6c69 737d 206d 696c 6c69 7365 636f 6e64  lis} millisecond
-0000d390: 7329 2229 290a 0a20 2020 2020 2020 2072  s)"))..        r
-0000d3a0: 6574 7572 6e20 6772 6164 7472 630a 0a20  eturn gradtrc.. 
-0000d3b0: 2020 2023 204e 4f54 4520 5468 6973 2069     # NOTE This i
-0000d3c0: 7320 6120 6b6c 7564 6765 2074 6f20 696e  s a kludge to in
-0000d3d0: 6469 6361 7465 2074 6861 7420 7765 2073  dicate that we s
-0000d3e0: 686f 756c 646e 2774 2075 7365 2050 7954  houldn't use PyT
-0000d3f0: 6f72 6368 2773 2061 7574 6f67 7261 6420  orch's autograd 
-0000d400: 6265 6361 7573 650a 2020 2020 2320 2020  because.    #   
-0000d410: 7765 2772 6520 7573 696e 6720 6f75 7220  we're using our 
-0000d420: 6f77 6e20 6175 746f 6772 6164 2074 7261  own autograd tra
-0000d430: 6e73 666f 726d 0a20 2020 2063 666e 2e5f  nsform.    cfn._
-0000d440: 7573 696e 675f 6772 6164 5f74 7261 6e73  using_grad_trans
-0000d450: 666f 726d 203d 2054 7275 650a 0a20 2020  form = True..   
-0000d460: 2072 6574 7572 6e20 6164 645f 7472 616e   return add_tran
-0000d470: 7366 6f72 6d28 6366 6e2c 2074 7261 6e73  sform(cfn, trans
-0000d480: 666f 726d 3d5f 6772 6164 5f74 7261 6e73  form=_grad_trans
-0000d490: 666f 726d 2c20 6469 7361 626c 655f 746f  form, disable_to
-0000d4a0: 7263 685f 6175 746f 6772 6164 5f73 7570  rch_autograd_sup
-0000d4b0: 706f 7274 3d54 7275 6529 0a0a 0a64 6566  port=True)...def
-0000d4c0: 2067 7261 645f 7631 280a 2020 2020 6366   grad_v1(.    cf
-0000d4d0: 6e2c 0a29 202d 3e20 4361 6c6c 6162 6c65  n,.) -> Callable
-0000d4e0: 3a0a 2020 2020 6465 6620 6772 6164 2866  :.    def grad(f
-0000d4f0: 756e 6329 3a0a 2020 2020 2020 2020 6465  unc):.        de
-0000d500: 6620 6772 6164 5f66 756e 6328 2a61 7267  f grad_func(*arg
-0000d510: 732c 202a 2a6b 7761 7267 7329 3a0a 2020  s, **kwargs):.  
-0000d520: 2020 2020 2020 2020 2020 5f2c 2067 7261            _, gra
-0000d530: 6473 203d 2076 616c 7565 5f61 6e64 5f67  ds = value_and_g
-0000d540: 7261 6428 6675 6e63 2928 2a61 7267 732c  rad(func)(*args,
-0000d550: 202a 2a6b 7761 7267 7329 0a20 2020 2020   **kwargs).     
-0000d560: 2020 2020 2020 2067 7261 6473 203d 205b         grads = [
-0000d570: 6720 666f 7220 6720 696e 2067 7261 6473  g for g in grads
-0000d580: 2069 6620 6720 6973 206e 6f74 204e 6f6e   if g is not Non
-0000d590: 655d 0a20 2020 2020 2020 2020 2020 2072  e].            r
-0000d5a0: 6574 7572 6e20 6772 6164 730a 0a20 2020  eturn grads..   
-0000d5b0: 2020 2020 2072 6574 7572 6e20 6772 6164       return grad
-0000d5c0: 5f66 756e 630a 0a20 2020 2064 6566 205f  _func..    def _
-0000d5d0: 6772 6164 5f74 7261 6e73 666f 726d 2874  grad_transform(t
-0000d5e0: 7263 3a20 5472 6163 652c 202a 2c20 6578  rc: Trace, *, ex
-0000d5f0: 6563 7574 6f72 735f 6c69 7374 3a20 5365  ecutors_list: Se
-0000d600: 7175 656e 6365 5b41 6e79 5d29 202d 3e20  quence[Any]) -> 
-0000d610: 5472 6163 653a 0a20 2020 2020 2020 2067  Trace:.        g
-0000d620: 7261 6474 7263 203d 2063 6f6e 7374 7275  radtrc = constru
-0000d630: 6374 5f74 7261 6365 2829 2867 7261 6428  ct_trace()(grad(
-0000d640: 7472 632e 7079 7468 6f6e 5f63 616c 6c61  trc.python_calla
-0000d650: 626c 6528 2929 2c20 2a74 7263 2e61 7267  ble()), *trc.arg
-0000d660: 732c 202a 2a74 7263 2e6b 7761 7267 7329  s, **trc.kwargs)
-0000d670: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-0000d680: 6772 6164 7472 630a 0a20 2020 2063 666e  gradtrc..    cfn
-0000d690: 2e5f 7573 696e 675f 6772 6164 5f74 7261  ._using_grad_tra
-0000d6a0: 6e73 666f 726d 203d 2054 7275 650a 2020  nsform = True.  
-0000d6b0: 2020 7265 7475 726e 2061 6464 5f74 7261    return add_tra
-0000d6c0: 6e73 666f 726d 2863 666e 2c20 7472 616e  nsform(cfn, tran
-0000d6d0: 7366 6f72 6d3d 5f67 7261 645f 7472 616e  sform=_grad_tran
-0000d6e0: 7366 6f72 6d2c 2064 6973 6162 6c65 5f74  sform, disable_t
-0000d6f0: 6f72 6368 5f61 7574 6f67 7261 645f 7375  orch_autograd_su
-0000d700: 7070 6f72 743d 5472 7565 290a 0a0a 636c  pport=True)...cl
-0000d710: 6173 7320 5472 616e 7366 6f72 6d73 2845  ass Transforms(E
-0000d720: 6e75 6d29 3a0a 2020 2020 4964 656e 7469  num):.    Identi
-0000d730: 7479 4f70 203d 2061 7574 6f28 290a 2020  tyOp = auto().  
-0000d740: 2020 566d 6170 4f70 203d 2061 7574 6f28    VmapOp = auto(
-0000d750: 290a 2020 2020 4a76 704f 7020 3d20 6175  ).    JvpOp = au
-0000d760: 746f 2829 0a20 2020 2056 6a70 4f70 203d  to().    VjpOp =
-0000d770: 2061 7574 6f28 290a 0a0a 406c 7275 5f63   auto()...@lru_c
-0000d780: 6163 6865 286d 6178 7369 7a65 3d4e 6f6e  ache(maxsize=Non
-0000d790: 6529 0a64 6566 2073 796d 626f 6c5f 746f  e).def symbol_to
-0000d7a0: 5f65 7661 6c28 626f 756e 645f 7379 6d62  _eval(bound_symb
-0000d7b0: 6f6c 293a 0a20 2020 2022 2222 4d61 7020  ol):.    """Map 
-0000d7c0: 6120 426f 756e 6453 796d 626f 6c20 746f  a BoundSymbol to
-0000d7d0: 2061 2066 756e 6374 696f 6e20 7468 6174   a function that
-0000d7e0: 2065 7661 6c75 6174 6573 2069 742e 0a0a   evaluates it...
-0000d7f0: 2020 2020 4172 6773 3a0a 2020 2020 2020      Args:.      
-0000d800: 2020 626f 756e 645f 7379 6d62 6f6c 3a20    bound_symbol: 
-0000d810: 426f 756e 6453 796d 626f 6c20 746f 206d  BoundSymbol to m
-0000d820: 6170 0a20 2020 2022 2222 0a20 2020 2023  ap.    """.    #
-0000d830: 2053 796d 626f 6c20 6973 2063 616c 6c61   Symbol is calla
-0000d840: 626c 650a 2020 2020 7265 7475 726e 2062  ble.    return b
-0000d850: 6f75 6e64 5f73 796d 626f 6c2e 7379 6d0a  ound_symbol.sym.
-0000d860: 0a0a 2320 544f 444f 3a20 4375 7272 656e  ..# TODO: Curren
-0000d870: 746c 7920 7765 2075 7365 2074 7261 6365  tly we use trace
-0000d880: 2e61 7267 7320 616e 6420 7472 6163 652e  .args and trace.
-0000d890: 6b77 6172 6773 2074 6f20 6765 7420 7468  kwargs to get th
-0000d8a0: 6520 6172 6775 6d65 6e74 730a 2320 4d61  e arguments.# Ma
-0000d8b0: 7962 6520 7765 2073 686f 756c 6420 7573  ybe we should us
-0000d8c0: 6520 7468 6573 6520 696e 7374 6561 640a  e these instead.
-0000d8d0: 7472 616e 7366 6f72 6d5f 736b 6970 5f6c  transform_skip_l
-0000d8e0: 6973 7420 3d20 280a 2020 2020 7072 696d  ist = (.    prim
-0000d8f0: 732e 5072 696d 4944 732e 554e 5041 434b  s.PrimIDs.UNPACK
-0000d900: 5f45 4d50 5459 5f44 4943 542c 0a20 2020  _EMPTY_DICT,.   
-0000d910: 2070 7269 6d73 2e50 7269 6d49 4473 2e55   prims.PrimIDs.U
-0000d920: 4e50 4143 4b5f 4b45 592c 0a20 2020 2070  NPACK_KEY,.    p
-0000d930: 7269 6d73 2e50 7269 6d49 4473 2e55 4e50  rims.PrimIDs.UNP
-0000d940: 4143 4b5f 5345 5155 454e 4345 2c0a 2020  ACK_SEQUENCE,.  
-0000d950: 2020 7072 696d 732e 5072 696d 4944 732e    prims.PrimIDs.
-0000d960: 554e 5041 434b 5f54 5249 5649 414c 2c0a  UNPACK_TRIVIAL,.
-0000d970: 2020 2020 7072 696d 732e 5072 696d 4944      prims.PrimID
-0000d980: 732e 5245 5455 524e 2c0a 290a 0a0a 6465  s.RETURN,.)...de
-0000d990: 6620 6576 616c 5f74 7261 6365 2874 7261  f eval_trace(tra
-0000d9a0: 6365 2c20 2a61 7267 732c 2073 796d 626f  ce, *args, symbo
-0000d9b0: 6c5f 6d61 7070 6572 3d73 796d 626f 6c5f  l_mapper=symbol_
-0000d9c0: 746f 5f65 7661 6c2c 2077 6974 685f 656e  to_eval, with_en
-0000d9d0: 763d 4661 6c73 652c 202a 2a6b 7761 7267  v=False, **kwarg
-0000d9e0: 7329 3a0a 2020 2020 2222 2245 7661 6c75  s):.    """Evalu
-0000d9f0: 6174 6520 6120 7472 6163 652e 0a0a 2020  ate a trace...  
-0000da00: 2020 4172 6773 3a0a 2020 2020 2020 2020    Args:.        
-0000da10: 7472 6163 653a 2074 7261 6365 2074 6f20  trace: trace to 
-0000da20: 6576 616c 7561 7465 0a20 2020 2020 2020  evaluate.       
-0000da30: 202a 6172 6773 3a20 6172 6775 6d65 6e74   *args: argument
-0000da40: 7320 746f 2065 7661 6c75 6174 6520 7468  s to evaluate th
-0000da50: 6520 7472 6163 6520 7769 7468 0a20 2020  e trace with.   
-0000da60: 2020 2020 2073 796d 626f 6c5f 6d61 7070       symbol_mapp
-0000da70: 6572 3a20 6675 6e63 7469 6f6e 2074 6861  er: function tha
-0000da80: 7420 6d61 7073 2061 2073 796d 626f 6c20  t maps a symbol 
-0000da90: 746f 2061 2066 756e 6374 696f 6e20 7468  to a function th
-0000daa0: 6174 2065 7661 6c75 6174 6573 2069 740a  at evaluates it.
-0000dab0: 2020 2020 2020 2020 2a2a 6b77 6172 6773          **kwargs
-0000dac0: 3a20 6b65 7977 6f72 6420 6172 6775 6d65  : keyword argume
-0000dad0: 6e74 7320 746f 2065 7661 6c75 6174 6520  nts to evaluate 
-0000dae0: 7468 6520 7472 6163 6520 7769 7468 0a0a  the trace with..
-0000daf0: 2020 2020 5265 7475 726e 733a 0a20 2020      Returns:.   
-0000db00: 2020 2020 2072 6573 756c 7420 6f66 2065       result of e
-0000db10: 7661 6c75 6174 696e 6720 7468 6520 7472  valuating the tr
-0000db20: 6163 650a 2020 2020 2222 220a 2020 2020  ace.    """.    
-0000db30: 656e 7620 3d20 7b7d 0a0a 2020 2020 6465  env = {}..    de
-0000db40: 6620 7265 6164 2878 3a20 5661 7269 6162  f read(x: Variab
-0000db50: 6c65 293a 0a20 2020 2020 2020 2069 6620  le):.        if 
-0000db60: 6973 696e 7374 616e 6365 2878 2c20 5661  isinstance(x, Va
-0000db70: 7269 6162 6c65 293a 0a20 2020 2020 2020  riable):.       
-0000db80: 2020 2020 2072 6574 7572 6e20 656e 765b       return env[
-0000db90: 782e 6e61 6d65 5d0a 2020 2020 2020 2020  x.name].        
-0000dba0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-0000dbb0: 2020 7265 7475 726e 2078 0a0a 2020 2020    return x..    
-0000dbc0: 6465 6620 7772 6974 6528 763a 2056 6172  def write(v: Var
-0000dbd0: 6961 626c 652c 2076 616c 3a20 416e 792c  iable, val: Any,
-0000dbe0: 2061 6c6c 6f77 5f64 7570 6c69 6361 7465   allow_duplicate
-0000dbf0: 733d 4661 6c73 6529 202d 3e20 4e6f 6e65  s=False) -> None
-0000dc00: 3a0a 2020 2020 2020 2020 6966 206e 6f74  :.        if not
-0000dc10: 2069 7369 6e73 7461 6e63 6528 762c 2056   isinstance(v, V
-0000dc20: 6172 6961 626c 6529 3a0a 2020 2020 2020  ariable):.      
-0000dc30: 2020 2020 2020 7265 7475 726e 0a20 2020        return.   
-0000dc40: 2020 2020 2023 2044 7570 6c69 6361 7465       # Duplicate
-0000dc50: 7320 6172 6520 616c 6c6f 7765 6420 616e  s are allowed an
-0000dc60: 6420 6f76 6572 7772 6974 7465 6e0a 2020  d overwritten.  
-0000dc70: 2020 2020 2020 6966 2076 2e6e 616d 6520        if v.name 
-0000dc80: 696e 2065 6e76 3a0a 2020 2020 2020 2020  in env:.        
-0000dc90: 2020 2020 6966 2061 6c6c 6f77 5f64 7570      if allow_dup
-0000dca0: 6c69 6361 7465 733a 0a20 2020 2020 2020  licates:.       
-0000dcb0: 2020 2020 2020 2020 2072 6574 7572 6e0a           return.
-0000dcc0: 2020 2020 2020 2020 2020 2020 7261 6973              rais
-0000dcd0: 6520 5661 6c75 6545 7272 6f72 2866 2256  e ValueError(f"V
-0000dce0: 6172 6961 626c 6520 7b76 2e6e 616d 657d  ariable {v.name}
-0000dcf0: 2069 7320 6265 696e 6720 6f76 6572 7772   is being overwr
-0000dd00: 6974 7465 6e20 7468 6973 2069 7320 6e6f  itten this is no
-0000dd10: 7420 616c 6c6f 7765 6422 290a 2020 2020  t allowed").    
-0000dd20: 2020 2020 656e 765b 762e 6e61 6d65 5d20      env[v.name] 
-0000dd30: 3d20 7661 6c0a 0a20 2020 2073 6166 655f  = val..    safe_
-0000dd40: 6d61 705f 666c 6174 2877 7269 7465 2c20  map_flat(write, 
-0000dd50: 6c69 7374 2874 7261 6365 2e61 7267 7329  list(trace.args)
-0000dd60: 2c20 6c69 7374 2861 7267 7329 290a 2020  , list(args)).  
-0000dd70: 2020 7361 6665 5f6d 6170 5f66 6c61 7428    safe_map_flat(
-0000dd80: 7772 6974 652c 206c 6973 7428 7472 6163  write, list(trac
-0000dd90: 652e 6b77 6172 6773 2e76 616c 7565 7328  e.kwargs.values(
-0000dda0: 2929 2c20 6c69 7374 286b 7761 7267 732e  )), list(kwargs.
-0000ddb0: 7661 6c75 6573 2829 2929 0a0a 2020 2020  values()))..    
-0000ddc0: 666f 7220 7379 6d62 6f6c 2069 6e20 7472  for symbol in tr
-0000ddd0: 6163 652e 626f 756e 645f 7379 6d62 6f6c  ace.bound_symbol
-0000dde0: 733a 0a20 2020 2020 2020 2069 6620 7379  s:.        if sy
-0000ddf0: 6d62 6f6c 2e73 796d 2e69 6420 696e 2074  mbol.sym.id in t
-0000de00: 7261 6e73 666f 726d 5f73 6b69 705f 6c69  ransform_skip_li
-0000de10: 7374 3a0a 2020 2020 2020 2020 2020 2020  st:.            
-0000de20: 636f 6e74 696e 7565 0a20 2020 2020 2020  continue.       
-0000de30: 2061 7267 7320 3d20 7472 6565 5f6d 6170   args = tree_map
-0000de40: 2872 6561 642c 2073 796d 626f 6c2e 6172  (read, symbol.ar
-0000de50: 6773 290a 2020 2020 2020 2020 6b77 6172  gs).        kwar
-0000de60: 6773 203d 2074 7265 655f 6d61 7028 7265  gs = tree_map(re
-0000de70: 6164 2c20 7379 6d62 6f6c 2e6b 7761 7267  ad, symbol.kwarg
-0000de80: 7329 0a20 2020 2020 2020 2070 7269 6d5f  s).        prim_
-0000de90: 6675 6e63 203d 2073 796d 626f 6c5f 6d61  func = symbol_ma
-0000dea0: 7070 6572 2873 796d 626f 6c29 0a20 2020  pper(symbol).   
-0000deb0: 2020 2020 2069 6620 7072 696d 5f66 756e       if prim_fun
-0000dec0: 6320 6973 204e 6f6e 653a 0a20 2020 2020  c is None:.     
-0000ded0: 2020 2020 2020 2063 6f6e 7469 6e75 650a         continue.
-0000dee0: 2020 2020 2020 2020 7265 7375 6c74 203d          result =
-0000def0: 2070 7269 6d5f 6675 6e63 282a 6172 6773   prim_func(*args
-0000df00: 2c20 2a2a 6b77 6172 6773 290a 2020 2020  , **kwargs).    
-0000df10: 2020 2020 7361 6665 5f6d 6170 5f66 6c61      safe_map_fla
-0000df20: 7428 7772 6974 652c 206c 6973 7428 7365  t(write, list(se
-0000df30: 7175 656e 6369 6679 2873 796d 626f 6c2e  quencify(symbol.
-0000df40: 6f75 7470 7574 2929 2c20 6c69 7374 2873  output)), list(s
-0000df50: 6571 7565 6e63 6966 7928 7265 7375 6c74  equencify(result
-0000df60: 2929 290a 0a20 2020 2069 6620 7769 7468  )))..    if with
-0000df70: 5f65 6e76 3a0a 2020 2020 2020 2020 7265  _env:.        re
-0000df80: 7475 726e 2074 7265 655f 6d61 7028 7265  turn tree_map(re
-0000df90: 6164 2c20 7472 6163 652e 6f75 7470 7574  ad, trace.output
-0000dfa0: 292c 2065 6e76 0a0a 2020 2020 7265 7475  ), env..    retu
-0000dfb0: 726e 2074 7265 655f 6d61 7028 7265 6164  rn tree_map(read
-0000dfc0: 2c20 7472 6163 652e 6f75 7470 7574 290a  , trace.output).
-0000dfd0: 0a0a 6465 6620 5f69 6465 6e74 6974 795f  ..def _identity_
-0000dfe0: 6361 6c6c 5f6d 6574 6166 756e 6328 2a61  call_metafunc(*a
-0000dff0: 7267 732c 2074 7261 6365 3a20 5472 6163  rgs, trace: Trac
-0000e000: 652c 202a 2a6b 7761 7267 7329 3a0a 2020  e, **kwargs):.  
-0000e010: 2020 7769 7468 2064 6574 6163 6865 645f    with detached_
-0000e020: 7472 6163 6528 293a 0a20 2020 2020 2020  trace():.       
-0000e030: 2072 6574 7572 6e20 6576 616c 5f74 7261   return eval_tra
-0000e040: 6365 2874 7261 6365 2c20 2a61 7267 732c  ce(trace, *args,
-0000e050: 202a 2a6b 7761 7267 7329 0a0a 0a69 6465   **kwargs)...ide
-0000e060: 6e74 6974 795f 6361 6c6c 203d 2053 796d  ntity_call = Sym
-0000e070: 626f 6c28 6964 3d54 7261 6e73 666f 726d  bol(id=Transform
-0000e080: 732e 4964 656e 7469 7479 4f70 2c20 6e61  s.IdentityOp, na
-0000e090: 6d65 3d22 6964 656e 7469 7479 5f63 616c  me="identity_cal
-0000e0a0: 6c22 2c20 6d65 7461 3d5f 6964 656e 7469  l", meta=_identi
-0000e0b0: 7479 5f63 616c 6c5f 6d65 7461 6675 6e63  ty_call_metafunc
-0000e0c0: 290a 0a0a 6465 6620 6964 656e 7469 7479  )...def identity
-0000e0d0: 2866 756e 6329 3a0a 2020 2020 2222 2249  (func):.    """I
-0000e0e0: 6465 6e74 6974 7920 7472 616e 7366 6f72  dentity transfor
-0000e0f0: 6d20 666f 7220 6120 5468 756e 6465 7220  m for a Thunder 
-0000e100: 6675 6e63 7469 6f6e 2e0a 0a20 2020 2041  function...    A
-0000e110: 7267 733a 0a20 2020 2020 2020 2066 756e  rgs:.        fun
-0000e120: 6320 2843 616c 6c61 626c 6529 3a20 4120  c (Callable): A 
-0000e130: 5468 756e 6465 7220 6675 6e63 7469 6f6e  Thunder function
-0000e140: 2074 6f20 6265 2074 7261 6e73 666f 726d   to be transform
-0000e150: 6564 2e0a 2020 2020 2222 220a 0a20 2020  ed..    """..   
-0000e160: 2064 6566 2077 7261 7070 6572 282a 6172   def wrapper(*ar
-0000e170: 6773 2c20 2a2a 6b77 6172 6773 293a 0a20  gs, **kwargs):. 
-0000e180: 2020 2020 2020 2074 7261 6365 203d 2063         trace = c
-0000e190: 6f6e 7374 7275 6374 5f74 7261 6365 2829  onstruct_trace()
-0000e1a0: 2866 756e 632c 202a 6172 6773 2c20 2a2a  (func, *args, **
-0000e1b0: 6b77 6172 6773 290a 2020 2020 2020 2020  kwargs).        
-0000e1c0: 7265 7475 726e 2069 6465 6e74 6974 795f  return identity_
-0000e1d0: 6361 6c6c 282a 6172 6773 2c20 2a2a 6b77  call(*args, **kw
-0000e1e0: 6172 6773 2c20 7472 6163 653d 7472 6163  args, trace=trac
-0000e1f0: 6529 0a0a 2020 2020 7265 7475 726e 2077  e)..    return w
-0000e200: 7261 7070 6572 0a0a 0a64 6566 205f 6964  rapper...def _id
-0000e210: 656e 7469 7479 5f63 616c 6c5f 7079 746f  entity_call_pyto
-0000e220: 7263 6828 2a61 7267 732c 2074 7261 6365  rch(*args, trace
-0000e230: 3a20 5472 6163 652c 202a 2a6b 7761 7267  : Trace, **kwarg
-0000e240: 7329 3a0a 2020 2020 696d 706f 7274 2074  s):.    import t
-0000e250: 6f72 6368 0a0a 2020 2020 6465 6620 7379  orch..    def sy
-0000e260: 6d62 6f6c 5f6d 6170 7065 7228 6f70 293a  mbol_mapper(op):
-0000e270: 0a20 2020 2020 2020 2069 6620 6f70 2e6f  .        if op.o
-0000e280: 7020 3d3d 2054 7261 6e73 666f 726d 732e  p == Transforms.
-0000e290: 4964 656e 7469 7479 4f70 3a0a 2020 2020  IdentityOp:.    
-0000e2a0: 2020 2020 2020 2020 7265 7475 726e 205f          return _
-0000e2b0: 6964 656e 7469 7479 5f63 616c 6c5f 7079  identity_call_py
-0000e2c0: 746f 7263 680a 0a20 2020 2020 2020 2074  torch..        t
-0000e2d0: 6f72 6368 5f6f 7020 3d20 6f70 735f 746f  orch_op = ops_to
-0000e2e0: 5f74 6f72 6368 5f6f 7073 5f6d 6170 5b6f  _torch_ops_map[o
-0000e2f0: 702e 6f70 5d0a 2020 2020 2020 2020 6966  p.op].        if
-0000e300: 2069 7369 6e73 7461 6e63 6528 746f 7263   isinstance(torc
-0000e310: 685f 6f70 2c20 7374 7229 3a0a 2020 2020  h_op, str):.    
-0000e320: 2020 2020 2020 2020 7265 7475 726e 2067          return g
-0000e330: 6574 6174 7472 2874 6f72 6368 2c20 746f  etattr(torch, to
-0000e340: 7263 685f 6f70 2e73 7472 6970 2822 7079  rch_op.strip("py
-0000e350: 746f 7263 682e 2229 290a 2020 2020 2020  torch.")).      
-0000e360: 2020 7265 7475 726e 2074 6f72 6368 5f6f    return torch_o
-0000e370: 700a 0a20 2020 2077 6974 6820 6465 7461  p..    with deta
-0000e380: 6368 6564 5f74 7261 6365 2829 3a0a 2020  ched_trace():.  
-0000e390: 2020 2020 2020 7265 7475 726e 2065 7661        return eva
-0000e3a0: 6c5f 7472 6163 6528 7472 6163 652c 202a  l_trace(trace, *
-0000e3b0: 6172 6773 2c20 2a2a 6b77 6172 6773 2c20  args, **kwargs, 
-0000e3c0: 7379 6d62 6f6c 5f6d 6170 7065 723d 7379  symbol_mapper=sy
-0000e3d0: 6d62 6f6c 5f6d 6170 7065 7229 0a0a 0a23  mbol_mapper)...#
-0000e3e0: 2052 6567 6973 7465 7220 7468 6520 6964   Register the id
-0000e3f0: 656e 7469 7479 2063 616c 6c20 666f 7220  entity call for 
-0000e400: 5079 546f 7263 6820 6578 6563 7574 6f72  PyTorch executor
-0000e410: 2e0a 2320 6f70 735f 746f 5f74 6f72 6368  ..# ops_to_torch
-0000e420: 5f6f 7073 5f6d 6170 5b54 7261 6e73 666f  _ops_map[Transfo
-0000e430: 726d 732e 4964 656e 7469 7479 4f70 5d20  rms.IdentityOp] 
-0000e440: 3d20 5f69 6465 6e74 6974 795f 6361 6c6c  = _identity_call
-0000e450: 5f70 7974 6f72 6368 0a0a 0a23 2056 4d41  _pytorch...# VMA
-0000e460: 5020 7472 616e 7366 6f72 6d0a 2320 2d2d  P transform.# --
-0000e470: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 0a0a 636c  -----------...cl
-0000e480: 6173 7320 4e6f 744d 6170 7065 643a 0a20  ass NotMapped:. 
-0000e490: 2020 2022 2222 5265 7072 6573 656e 7473     """Represents
-0000e4a0: 2061 206e 6f6e 2d62 6174 6368 6564 2064   a non-batched d
-0000e4b0: 696d 656e 7369 6f6e 2e22 2222 0a0a 2020  imension."""..  
-0000e4c0: 2020 6465 6620 5f5f 7265 7072 5f5f 2873    def __repr__(s
-0000e4d0: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
-0000e4e0: 7475 726e 2022 6e6f 745f 6d61 7070 6564  turn "not_mapped
-0000e4f0: 220a 0a0a 4064 6174 6163 6c61 7373 2866  "...@dataclass(f
-0000e500: 726f 7a65 6e3d 5472 7565 290a 636c 6173  rozen=True).clas
-0000e510: 7320 4261 7463 6865 6456 616c 7565 3a0a  s BatchedValue:.
-0000e520: 2020 2020 2222 2242 6174 6368 6564 2076      """Batched v
-0000e530: 616c 7565 2066 6f72 2074 6865 2076 6d61  alue for the vma
-0000e540: 7020 7472 616e 7366 6f72 6d2e 0a0a 2020  p transform...  
-0000e550: 2020 4174 7472 6962 7574 6573 3a0a 2020    Attributes:.  
-0000e560: 2020 2020 2020 7661 6c75 653a 2042 6174        value: Bat
-0000e570: 6368 6564 2076 616c 7565 2e0a 2020 2020  ched value..    
-0000e580: 2020 2020 6261 7463 685f 6469 6d3a 2042      batch_dim: B
-0000e590: 6174 6368 696e 6720 6469 6d65 6e73 696f  atching dimensio
-0000e5a0: 6e20 6f72 206e 6f74 5f6d 6170 7065 640a  n or not_mapped.
-0000e5b0: 2020 2020 2222 220a 0a20 2020 2076 616c      """..    val
-0000e5c0: 7565 3a20 416e 790a 2020 2020 6261 7463  ue: Any.    batc
-0000e5d0: 685f 6469 6d3a 2069 6e74 207c 204e 6f74  h_dim: int | Not
-0000e5e0: 4d61 7070 6564 0a0a 2020 2020 6465 6620  Mapped..    def 
-0000e5f0: 5f5f 6974 6572 5f5f 2873 656c 6629 3a0a  __iter__(self):.
-0000e600: 2020 2020 2020 2020 7969 656c 6420 7365          yield se
-0000e610: 6c66 2e76 616c 7565 0a20 2020 2020 2020  lf.value.       
-0000e620: 2079 6965 6c64 2073 656c 662e 6261 7463   yield self.batc
-0000e630: 685f 6469 6d0a 0a0a 6465 6620 7061 6972  h_dim...def pair
-0000e640: 5f74 6f5f 6261 7463 6865 645f 7661 6c75  _to_batched_valu
-0000e650: 6528 7061 6972 293a 0a20 2020 2022 2222  e(pair):.    """
-0000e660: 436f 6e76 6572 7473 2061 2070 6169 7220  Converts a pair 
-0000e670: 746f 2061 2042 6174 6368 6564 5661 6c75  to a BatchedValu
-0000e680: 652e 0a0a 2020 2020 4172 6773 3a0a 2020  e...    Args:.  
-0000e690: 2020 2020 2020 7061 6972 2028 5365 7175        pair (Sequ
-0000e6a0: 656e 6365 293a 2050 6169 7220 746f 2063  ence): Pair to c
-0000e6b0: 6f6e 7665 7274 2e0a 0a20 2020 2052 6574  onvert...    Ret
-0000e6c0: 7572 6e73 3a0a 2020 2020 2020 2020 4261  urns:.        Ba
-0000e6d0: 7463 6865 6456 616c 7565 3a20 4261 7463  tchedValue: Batc
-0000e6e0: 6865 6456 616c 7565 2072 6570 7265 7365  hedValue represe
-0000e6f0: 6e74 6174 696f 6e20 6f66 2074 6865 2070  ntation of the p
-0000e700: 6169 722e 0a20 2020 2022 2222 0a20 2020  air..    """.   
-0000e710: 2069 6620 6973 696e 7374 616e 6365 2870   if isinstance(p
-0000e720: 6169 722c 2042 6174 6368 6564 5661 6c75  air, BatchedValu
-0000e730: 6529 3a0a 2020 2020 2020 2020 7265 7475  e):.        retu
-0000e740: 726e 2070 6169 720a 2020 2020 656c 7365  rn pair.    else
-0000e750: 3a0a 2020 2020 2020 2020 6173 7365 7274  :.        assert
-0000e760: 2069 7369 6e73 7461 6e63 6528 7061 6972   isinstance(pair
-0000e770: 2c20 5365 7175 656e 6365 2920 616e 6420  , Sequence) and 
-0000e780: 6c65 6e28 7061 6972 2920 3d3d 2032 0a20  len(pair) == 2. 
-0000e790: 2020 2020 2020 2072 6574 7572 6e20 4261         return Ba
-0000e7a0: 7463 6865 6456 616c 7565 282a 7061 6972  tchedValue(*pair
-0000e7b0: 290a 0a0a 6465 6620 7665 6374 6f72 697a  )...def vectoriz
-0000e7c0: 6564 5f62 6174 6368 6572 2870 7269 6d2c  ed_batcher(prim,
-0000e7d0: 2061 7869 735f 7369 7a65 2c20 6261 7463   axis_size, batc
-0000e7e0: 6865 645f 7661 6c75 6573 2c20 2a2a 6b77  hed_values, **kw
-0000e7f0: 6172 6773 293a 0a20 2020 2062 6174 6368  args):.    batch
-0000e800: 5f64 696d 203d 2062 6174 6368 6564 5f76  _dim = batched_v
-0000e810: 616c 7565 735b 305d 2e62 6174 6368 5f64  alues[0].batch_d
-0000e820: 696d 0a20 2020 2061 7373 6572 7420 616c  im.    assert al
-0000e830: 6c28 0a20 2020 2020 2020 2062 6174 6368  l(.        batch
-0000e840: 5f64 696d 203d 3d20 6276 2e62 6174 6368  _dim == bv.batch
-0000e850: 5f64 696d 2066 6f72 2062 7620 696e 2062  _dim for bv in b
-0000e860: 6174 6368 6564 5f76 616c 7565 735b 313a  atched_values[1:
-0000e870: 5d0a 2020 2020 292c 2066 2260 7665 6374  ].    ), f"`vect
-0000e880: 6f72 697a 6564 5f62 6174 6368 6572 6020  orized_batcher` 
-0000e890: 676f 7420 6469 6666 6572 656e 7420 6261  got different ba
-0000e8a0: 7463 6865 6420 6469 6d65 6e73 696f 6e73  tched dimensions
-0000e8b0: 207b 5b62 762e 6261 7463 685f 6469 6d20   {[bv.batch_dim 
-0000e8c0: 666f 7220 6276 2069 6e20 6261 7463 6865  for bv in batche
-0000e8d0: 645f 7661 6c75 6573 5d7d 220a 2020 2020  d_values]}".    
-0000e8e0: 7265 7475 726e 2042 6174 6368 6564 5661  return BatchedVa
-0000e8f0: 6c75 6528 7072 696d 282a 5b62 762e 7661  lue(prim(*[bv.va
-0000e900: 6c75 6520 666f 7220 6276 2069 6e20 6261  lue for bv in ba
-0000e910: 7463 6865 645f 7661 6c75 6573 5d2c 202a  tched_values], *
-0000e920: 2a6b 7761 7267 7329 2c20 6261 7463 685f  *kwargs), batch_
-0000e930: 6469 6d29 0a0a 0a6e 6f74 5f6d 6170 7065  dim)...not_mappe
-0000e940: 6420 3d20 4e6f 744d 6170 7065 6428 290a  d = NotMapped().
-0000e950: 0a0a 6465 6620 6d6f 7665 6469 6d28 782c  ..def movedim(x,
-0000e960: 2073 7263 3a20 696e 742c 2064 7374 3a20   src: int, dst: 
-0000e970: 696e 7429 3a0a 2020 2020 7065 726d 203d  int):.    perm =
-0000e980: 205b 6920 666f 7220 6920 696e 2072 616e   [i for i in ran
-0000e990: 6765 2878 2e6e 6469 6d29 2069 6620 6920  ge(x.ndim) if i 
-0000e9a0: 213d 2073 7263 5d0a 2020 2020 7065 726d  != src].    perm
-0000e9b0: 2e69 6e73 6572 7428 6473 742c 2073 7263  .insert(dst, src
-0000e9c0: 290a 2020 2020 7265 7475 726e 2070 7269  ).    return pri
-0000e9d0: 6d73 2e74 7261 6e73 706f 7365 2878 2c20  ms.transpose(x, 
-0000e9e0: 7475 706c 6528 7065 726d 2929 0a0a 0a64  tuple(perm))...d
-0000e9f0: 6566 206d 6f76 655f 6261 7463 685f 6469  ef move_batch_di
-0000ea00: 6d28 6178 6973 5f73 697a 652c 2073 7263  m(axis_size, src
-0000ea10: 2c20 6473 742c 2078 293a 0a20 2020 2069  , dst, x):.    i
-0000ea20: 6620 7372 6320 6973 206e 6f74 5f6d 6170  f src is not_map
-0000ea30: 7065 643a 0a20 2020 2020 2020 2069 6620  ped:.        if 
-0000ea40: 6973 696e 7374 616e 6365 2878 2c20 4e75  isinstance(x, Nu
-0000ea50: 6d62 6572 293a 0a20 2020 2020 2020 2020  mber):.         
-0000ea60: 2020 2072 6574 7572 6e20 780a 2020 2020     return x.    
-0000ea70: 2020 2020 7461 7267 6574 5f73 6861 7065      target_shape
-0000ea80: 203d 206c 6973 7428 782e 7368 6170 6529   = list(x.shape)
-0000ea90: 0a20 2020 2020 2020 2074 6172 6765 745f  .        target_
-0000eaa0: 7368 6170 652e 696e 7365 7274 2864 7374  shape.insert(dst
-0000eab0: 2c20 6178 6973 5f73 697a 6529 0a20 2020  , axis_size).   
-0000eac0: 2020 2020 2062 6361 7374 5f64 696d 7320       bcast_dims 
-0000ead0: 3d20 6c69 7374 2872 616e 6765 286c 656e  = list(range(len
-0000eae0: 2874 6172 6765 745f 7368 6170 6529 2929  (target_shape)))
-0000eaf0: 0a20 2020 2020 2020 2062 6361 7374 5f64  .        bcast_d
-0000eb00: 696d 732e 706f 7028 6473 7429 0a20 2020  ims.pop(dst).   
-0000eb10: 2020 2020 2072 6574 7572 6e20 7072 696d       return prim
-0000eb20: 732e 6272 6f61 6463 6173 745f 696e 5f64  s.broadcast_in_d
-0000eb30: 696d 2878 2c20 7461 7267 6574 5f73 6861  im(x, target_sha
-0000eb40: 7065 2c20 6263 6173 745f 6469 6d73 290a  pe, bcast_dims).
-0000eb50: 2020 2020 656c 6966 2073 7263 203d 3d20      elif src == 
-0000eb60: 6473 743a 0a20 2020 2020 2020 2072 6574  dst:.        ret
-0000eb70: 7572 6e20 780a 2020 2020 656c 7365 3a0a  urn x.    else:.
-0000eb80: 2020 2020 2020 2020 7265 7475 726e 206d          return m
-0000eb90: 6f76 6564 696d 2878 2c20 7372 632c 2064  ovedim(x, src, d
-0000eba0: 7374 290a 0a0a 6465 6620 6269 6e61 7279  st)...def binary
-0000ebb0: 5f6f 705f 6261 7463 6869 6e67 5f72 756c  _op_batching_rul
-0000ebc0: 6528 6f70 3a20 7072 696d 732e 5072 696d  e(op: prims.Prim
-0000ebd0: 4944 732c 2061 7869 735f 7369 7a65 3a20  IDs, axis_size: 
-0000ebe0: 696e 742c 2076 616c 735f 696e 3a20 4261  int, vals_in: Ba
-0000ebf0: 7463 6865 6456 616c 7565 293a 0a20 2020  tchedValue):.   
-0000ec00: 2028 2878 2c20 785f 6264 696d 292c 2028   ((x, x_bdim), (
-0000ec10: 792c 2079 5f62 6469 6d29 2920 3d20 7661  y, y_bdim)) = va
-0000ec20: 6c73 5f69 6e0a 2020 2020 6966 2078 5f62  ls_in.    if x_b
-0000ec30: 6469 6d20 213d 2079 5f62 6469 6d3a 0a20  dim != y_bdim:. 
-0000ec40: 2020 2020 2020 2069 6620 785f 6264 696d         if x_bdim
-0000ec50: 2069 7320 6e6f 745f 6d61 7070 6564 3a0a   is not_mapped:.
-0000ec60: 2020 2020 2020 2020 2020 2020 7820 3d20              x = 
-0000ec70: 6d6f 7665 5f62 6174 6368 5f64 696d 2861  move_batch_dim(a
-0000ec80: 7869 735f 7369 7a65 2c20 785f 6264 696d  xis_size, x_bdim
-0000ec90: 2c20 795f 6264 696d 2c20 7829 0a20 2020  , y_bdim, x).   
-0000eca0: 2020 2020 2020 2020 2078 5f62 6469 6d20           x_bdim 
-0000ecb0: 3d20 795f 6264 696d 0a20 2020 2020 2020  = y_bdim.       
-0000ecc0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-0000ecd0: 2020 2079 203d 206d 6f76 655f 6261 7463     y = move_batc
-0000ece0: 685f 6469 6d28 6178 6973 5f73 697a 652c  h_dim(axis_size,
-0000ecf0: 2079 5f62 6469 6d2c 2078 5f62 6469 6d2c   y_bdim, x_bdim,
-0000ed00: 2079 290a 2020 2020 7265 7475 726e 2042   y).    return B
-0000ed10: 6174 6368 6564 5661 6c75 6528 6f70 2878  atchedValue(op(x
-0000ed20: 2c20 7929 2c20 785f 6264 696d 290a 0a0a  , y), x_bdim)...
-0000ed30: 6465 6620 7369 6e5f 766d 6170 2861 7869  def sin_vmap(axi
-0000ed40: 735f 7369 7a65 3a20 696e 742c 2061 3a20  s_size: int, a: 
-0000ed50: 4261 7463 6865 6456 616c 7565 2920 2d3e  BatchedValue) ->
-0000ed60: 2042 6174 6368 6564 5661 6c75 653a 0a20   BatchedValue:. 
-0000ed70: 2020 2072 6574 7572 6e20 7665 6374 6f72     return vector
-0000ed80: 697a 6564 5f62 6174 6368 6572 2870 7269  ized_batcher(pri
-0000ed90: 6d73 2e73 696e 2c20 6178 6973 5f73 697a  ms.sin, axis_siz
-0000eda0: 652c 2028 612c 2929 0a0a 0a64 6566 2063  e, (a,))...def c
-0000edb0: 6f73 5f76 6d61 7028 6178 6973 5f73 697a  os_vmap(axis_siz
-0000edc0: 653a 2069 6e74 2c20 613a 2042 6174 6368  e: int, a: Batch
-0000edd0: 6564 5661 6c75 6529 202d 3e20 4261 7463  edValue) -> Batc
-0000ede0: 6865 6456 616c 7565 3a0a 2020 2020 7265  hedValue:.    re
-0000edf0: 7475 726e 2076 6563 746f 7269 7a65 645f  turn vectorized_
-0000ee00: 6261 7463 6865 7228 7072 696d 732e 636f  batcher(prims.co
-0000ee10: 732c 2061 7869 735f 7369 7a65 2c20 2861  s, axis_size, (a
-0000ee20: 2c29 290a 0a0a 6465 6620 6d75 6c5f 766d  ,))...def mul_vm
-0000ee30: 6170 2861 7869 735f 7369 7a65 3a20 696e  ap(axis_size: in
-0000ee40: 742c 2061 3a20 4261 7463 6865 6456 616c  t, a: BatchedVal
-0000ee50: 7565 2c20 623a 2042 6174 6368 6564 5661  ue, b: BatchedVa
-0000ee60: 6c75 6529 202d 3e20 4261 7463 6865 6456  lue) -> BatchedV
-0000ee70: 616c 7565 3a0a 2020 2020 7265 7475 726e  alue:.    return
-0000ee80: 2062 696e 6172 795f 6f70 5f62 6174 6368   binary_op_batch
-0000ee90: 696e 675f 7275 6c65 2870 7269 6d73 2e6d  ing_rule(prims.m
-0000eea0: 756c 2c20 6178 6973 5f73 697a 652c 2028  ul, axis_size, (
-0000eeb0: 612c 2062 2929 0a0a 0a64 6566 2061 6464  a, b))...def add
-0000eec0: 5f76 6d61 7028 6178 6973 5f73 697a 653a  _vmap(axis_size:
-0000eed0: 2069 6e74 2c20 613a 2042 6174 6368 6564   int, a: Batched
-0000eee0: 5661 6c75 652c 2062 3a20 4261 7463 6865  Value, b: Batche
+0000d040: 2020 206d 696e 5f69 6478 203d 2069 6478     min_idx = idx
+0000d050: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000d060: 2020 2020 206d 696e 5f6e 756d 6265 7220       min_number 
+0000d070: 3d20 6e2e 6e75 6d62 6572 0a0a 2020 2020  = n.number..    
+0000d080: 2020 2020 2020 2020 7265 7475 726e 206d          return m
+0000d090: 696e 5f69 6478 0a0a 2020 2020 2020 2020  in_idx..        
+0000d0a0: 736f 7274 6564 5f62 7379 6d73 203d 2074  sorted_bsyms = t
+0000d0b0: 6f70 6f73 6f72 745f 6273 796d 5f64 6167  oposort_bsym_dag
+0000d0c0: 286c 6561 7665 732c 2074 6f70 6f73 6f72  (leaves, toposor
+0000d0d0: 745f 6f72 6465 723d 544f 504f 534f 5254  t_order=TOPOSORT
+0000d0e0: 5f4f 5244 4552 2e42 4f54 544f 4d5f 5550  _ORDER.BOTTOM_UP
+0000d0f0: 2c20 7365 6c65 6374 6f72 3d5f 7365 6c65  , selector=_sele
+0000d100: 6374 6f72 290a 2020 2020 2020 2020 6772  ctor).        gr
+0000d110: 6164 7472 632e 626f 756e 645f 7379 6d62  adtrc.bound_symb
+0000d120: 6f6c 7320 3d20 736f 7274 6564 5f62 7379  ols = sorted_bsy
+0000d130: 6d73 0a20 2020 2020 2020 2067 7261 6474  ms.        gradt
+0000d140: 7263 203d 2064 6365 2867 7261 6474 7263  rc = dce(gradtrc
+0000d150: 290a 0a20 2020 2020 2020 2023 2054 4f44  )..        # TOD
+0000d160: 4f20 436f 6e73 6964 6572 2068 6f77 2074  O Consider how t
+0000d170: 6f20 6861 6e64 6c65 2067 7261 6420 772e  o handle grad w.
+0000d180: 722e 742e 206f 6e6c 7920 736f 6d65 206f  r.t. only some o
+0000d190: 7574 7075 7473 202d 2d20 7368 6f75 6c64  utputs -- should
+0000d1a0: 2061 6c6c 2067 7261 640a 2020 2020 2020   all grad.      
+0000d1b0: 2020 2320 2020 6f70 6572 6174 696f 6e73    #   operations
+0000d1c0: 2075 7369 6e67 2074 6865 206f 7468 6572   using the other
+0000d1d0: 206f 7574 7075 7420 6265 2072 656d 6f76   output be remov
+0000d1e0: 6564 3f20 5768 6174 206b 696e 6420 6f66  ed? What kind of
+0000d1f0: 2061 7373 756d 7074 696f 6e20 646f 6573   assumption does
+0000d200: 2074 6861 740a 2020 2020 2020 2020 2320   that.        # 
+0000d210: 2020 6d61 6b65 2061 626f 7574 2074 6865    make about the
+0000d220: 2067 7261 6420 7374 7275 6374 7572 653f   grad structure?
+0000d230: 2050 726f 6261 626c 7920 736f 6d65 206b   Probably some k
+0000d240: 696e 6420 6f66 2069 6e64 6570 656e 6465  ind of independe
+0000d250: 6e63 6520 6173 7375 6d70 7469 6f6e 3f20  nce assumption? 
+0000d260: 4172 650a 2020 2020 2020 2020 2320 2020  Are.        #   
+0000d270: 7468 6572 6520 7072 6163 7469 6361 6c20  there practical 
+0000d280: 6578 616d 706c 6573 2077 6865 7265 2074  examples where t
+0000d290: 6861 7427 7320 616e 2069 7373 7565 3f0a  hat's an issue?.
+0000d2a0: 0a20 2020 2020 2020 2065 6e64 5f74 696d  .        end_tim
+0000d2b0: 655f 6e73 203d 2074 696d 652e 7469 6d65  e_ns = time.time
+0000d2c0: 5f6e 7328 290a 2020 2020 2020 2020 656c  _ns().        el
+0000d2d0: 6170 7365 645f 7469 6d65 5f6e 7320 3d20  apsed_time_ns = 
+0000d2e0: 656e 645f 7469 6d65 5f6e 7320 2d20 7374  end_time_ns - st
+0000d2f0: 6172 745f 7469 6d65 5f6e 730a 2020 2020  art_time_ns.    
+0000d300: 2020 2020 656c 6170 7365 645f 7469 6d65      elapsed_time
+0000d310: 5f6d 696c 6c69 7320 3d20 656c 6170 7365  _millis = elapse
+0000d320: 645f 7469 6d65 5f6e 7320 2f2f 2031 3030  d_time_ns // 100
+0000d330: 3030 3030 0a20 2020 2020 2020 2067 7261  0000.        gra
+0000d340: 6474 7263 2e73 6574 5f70 726f 7665 6e61  dtrc.set_provena
+0000d350: 6e63 6528 5472 6163 6550 726f 7665 6e61  nce(TraceProvena
+0000d360: 6e63 6528 6622 4772 6164 2028 746f 6f6b  nce(f"Grad (took
+0000d370: 207b 656c 6170 7365 645f 7469 6d65 5f6d   {elapsed_time_m
+0000d380: 696c 6c69 737d 206d 696c 6c69 7365 636f  illis} milliseco
+0000d390: 6e64 7329 2229 290a 0a20 2020 2020 2020  nds)"))..       
+0000d3a0: 2072 6574 7572 6e20 6772 6164 7472 630a   return gradtrc.
+0000d3b0: 0a20 2020 2023 204e 4f54 4520 5468 6973  .    # NOTE This
+0000d3c0: 2069 7320 6120 6b6c 7564 6765 2074 6f20   is a kludge to 
+0000d3d0: 696e 6469 6361 7465 2074 6861 7420 7765  indicate that we
+0000d3e0: 2073 686f 756c 646e 2774 2075 7365 2050   shouldn't use P
+0000d3f0: 7954 6f72 6368 2773 2061 7574 6f67 7261  yTorch's autogra
+0000d400: 6420 6265 6361 7573 650a 2020 2020 2320  d because.    # 
+0000d410: 2020 7765 2772 6520 7573 696e 6720 6f75    we're using ou
+0000d420: 7220 6f77 6e20 6175 746f 6772 6164 2074  r own autograd t
+0000d430: 7261 6e73 666f 726d 0a20 2020 2063 666e  ransform.    cfn
+0000d440: 2e5f 7573 696e 675f 6772 6164 5f74 7261  ._using_grad_tra
+0000d450: 6e73 666f 726d 203d 2054 7275 650a 0a20  nsform = True.. 
+0000d460: 2020 2072 6574 7572 6e20 6164 645f 7472     return add_tr
+0000d470: 616e 7366 6f72 6d28 6366 6e2c 2074 7261  ansform(cfn, tra
+0000d480: 6e73 666f 726d 3d5f 6772 6164 5f74 7261  nsform=_grad_tra
+0000d490: 6e73 666f 726d 2c20 6469 7361 626c 655f  nsform, disable_
+0000d4a0: 746f 7263 685f 6175 746f 6772 6164 5f73  torch_autograd_s
+0000d4b0: 7570 706f 7274 3d54 7275 6529 0a0a 0a64  upport=True)...d
+0000d4c0: 6566 2067 7261 6428 0a20 2020 2063 666e  ef grad(.    cfn
+0000d4d0: 2c0a 2920 2d3e 2043 616c 6c61 626c 653a  ,.) -> Callable:
+0000d4e0: 0a20 2020 2064 6566 2067 7261 6428 6675  .    def grad(fu
+0000d4f0: 6e63 293a 0a0a 2020 2020 2020 2020 4077  nc):..        @w
+0000d500: 7261 7073 2866 756e 6329 0a20 2020 2020  raps(func).     
+0000d510: 2020 2064 6566 2067 7261 645f 6675 6e63     def grad_func
+0000d520: 282a 6172 6773 2c20 2a2a 6b77 6172 6773  (*args, **kwargs
+0000d530: 293a 0a20 2020 2020 2020 2020 2020 205f  ):.            _
+0000d540: 2c20 6772 6164 7320 3d20 7661 6c75 655f  , grads = value_
+0000d550: 616e 645f 6772 6164 2866 756e 6329 282a  and_grad(func)(*
+0000d560: 6172 6773 2c20 2a2a 6b77 6172 6773 290a  args, **kwargs).
+0000d570: 2020 2020 2020 2020 2020 2020 6772 6164              grad
+0000d580: 7320 3d20 7472 6565 5f66 6c61 7474 656e  s = tree_flatten
+0000d590: 2867 7261 6473 295b 305d 0a20 2020 2020  (grads)[0].     
+0000d5a0: 2020 2020 2020 2067 7261 6473 203d 205b         grads = [
+0000d5b0: 6720 666f 7220 6720 696e 2067 7261 6473  g for g in grads
+0000d5c0: 2069 6620 6720 6973 206e 6f74 204e 6f6e   if g is not Non
+0000d5d0: 655d 0a20 2020 2020 2020 2020 2020 2072  e].            r
+0000d5e0: 6574 7572 6e20 6772 6164 730a 0a20 2020  eturn grads..   
+0000d5f0: 2020 2020 2072 6574 7572 6e20 6772 6164       return grad
+0000d600: 5f66 756e 630a 0a20 2020 2064 6566 205f  _func..    def _
+0000d610: 6772 6164 5f74 7261 6e73 666f 726d 2874  grad_transform(t
+0000d620: 7263 3a20 5472 6163 652c 202a 2c20 6578  rc: Trace, *, ex
+0000d630: 6563 7574 6f72 735f 6c69 7374 3a20 5365  ecutors_list: Se
+0000d640: 7175 656e 6365 5b41 6e79 5d29 202d 3e20  quence[Any]) -> 
+0000d650: 5472 6163 653a 0a20 2020 2020 2020 2023  Trace:.        #
+0000d660: 2055 7369 6e67 2074 7263 2e70 7974 686f   Using trc.pytho
+0000d670: 6e5f 6361 6c6c 6162 6c65 2829 206d 616b  n_callable() mak
+0000d680: 6573 2069 7420 696d 706f 7373 6962 6c65  es it impossible
+0000d690: 2074 6f20 7265 7472 6163 6520 7468 650a   to retrace the.
+0000d6a0: 2020 2020 2020 2020 2320 6675 6e63 7469          # functi
+0000d6b0: 6f6e 2062 6563 6175 7365 2074 6865 2070  on because the p
+0000d6c0: 7974 686f 6e5f 6361 6c6c 6162 6c65 2075  ython_callable u
+0000d6d0: 7365 7320 7079 7468 6f6e 5f63 7478 2077  ses python_ctx w
+0000d6e0: 6869 6368 2072 6570 6c61 6365 730a 2020  hich replaces.  
+0000d6f0: 2020 2020 2020 2320 7379 6d62 6f6c 206f        # symbol o
+0000d700: 6363 7572 7265 6e63 6573 2077 6974 6820  ccurrences with 
+0000d710: 6974 7320 7379 6d62 6f6c 2e5f 6361 6c6c  its symbol._call
+0000d720: 5f63 7478 2066 756e 6374 696f 6e0a 2020  _ctx function.  
+0000d730: 2020 2020 2020 4077 7261 7073 2874 7263        @wraps(trc
+0000d740: 2e70 7974 686f 6e5f 6361 6c6c 6162 6c65  .python_callable
+0000d750: 2829 290a 2020 2020 2020 2020 6465 6620  ()).        def 
+0000d760: 7079 7468 6f6e 5f63 616c 6c61 626c 6528  python_callable(
+0000d770: 2a61 7267 732c 202a 2a6b 7761 7267 7329  *args, **kwargs)
+0000d780: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+0000d790: 7475 726e 2065 7661 6c5f 7472 6163 6528  turn eval_trace(
+0000d7a0: 7472 632c 202a 6172 6773 2c20 2a2a 6b77  trc, *args, **kw
+0000d7b0: 6172 6773 290a 0a20 2020 2020 2020 2067  args)..        g
+0000d7c0: 7261 6474 7263 203d 2063 6f6e 7374 7275  radtrc = constru
+0000d7d0: 6374 5f74 7261 6365 2829 2867 7261 6428  ct_trace()(grad(
+0000d7e0: 7079 7468 6f6e 5f63 616c 6c61 626c 6529  python_callable)
+0000d7f0: 2c20 2a74 7263 2e61 7267 732c 202a 2a74  , *trc.args, **t
+0000d800: 7263 2e6b 7761 7267 7329 0a20 2020 2020  rc.kwargs).     
+0000d810: 2020 2072 6574 7572 6e20 6772 6164 7472     return gradtr
+0000d820: 630a 0a20 2020 2063 666e 2e5f 7573 696e  c..    cfn._usin
+0000d830: 675f 6772 6164 5f74 7261 6e73 666f 726d  g_grad_transform
+0000d840: 203d 2054 7275 650a 2020 2020 7265 7475   = True.    retu
+0000d850: 726e 2061 6464 5f74 7261 6e73 666f 726d  rn add_transform
+0000d860: 2863 666e 2c20 7472 616e 7366 6f72 6d3d  (cfn, transform=
+0000d870: 5f67 7261 645f 7472 616e 7366 6f72 6d2c  _grad_transform,
+0000d880: 2064 6973 6162 6c65 5f74 6f72 6368 5f61   disable_torch_a
+0000d890: 7574 6f67 7261 645f 7375 7070 6f72 743d  utograd_support=
+0000d8a0: 5472 7565 290a 0a0a 636c 6173 7320 5472  True)...class Tr
+0000d8b0: 616e 7366 6f72 6d73 2845 6e75 6d29 3a0a  ansforms(Enum):.
+0000d8c0: 2020 2020 4964 656e 7469 7479 4f70 203d      IdentityOp =
+0000d8d0: 2061 7574 6f28 290a 2020 2020 566d 6170   auto().    Vmap
+0000d8e0: 4f70 203d 2061 7574 6f28 290a 2020 2020  Op = auto().    
+0000d8f0: 4a76 704f 7020 3d20 6175 746f 2829 0a20  JvpOp = auto(). 
+0000d900: 2020 2056 6a70 4f70 203d 2061 7574 6f28     VjpOp = auto(
+0000d910: 290a 0a0a 406c 7275 5f63 6163 6865 286d  )...@lru_cache(m
+0000d920: 6178 7369 7a65 3d4e 6f6e 6529 0a64 6566  axsize=None).def
+0000d930: 2073 796d 626f 6c5f 746f 5f65 7661 6c28   symbol_to_eval(
+0000d940: 626f 756e 645f 7379 6d62 6f6c 293a 0a20  bound_symbol):. 
+0000d950: 2020 2022 2222 4d61 7020 6120 426f 756e     """Map a Boun
+0000d960: 6453 796d 626f 6c20 746f 2061 2066 756e  dSymbol to a fun
+0000d970: 6374 696f 6e20 7468 6174 2065 7661 6c75  ction that evalu
+0000d980: 6174 6573 2069 742e 0a0a 2020 2020 4172  ates it...    Ar
+0000d990: 6773 3a0a 2020 2020 2020 2020 626f 756e  gs:.        boun
+0000d9a0: 645f 7379 6d62 6f6c 3a20 426f 756e 6453  d_symbol: BoundS
+0000d9b0: 796d 626f 6c20 746f 206d 6170 0a20 2020  ymbol to map.   
+0000d9c0: 2022 2222 0a20 2020 2023 2053 796d 626f   """.    # Symbo
+0000d9d0: 6c20 6973 2063 616c 6c61 626c 650a 2020  l is callable.  
+0000d9e0: 2020 7265 7475 726e 2062 6f75 6e64 5f73    return bound_s
+0000d9f0: 796d 626f 6c2e 7379 6d0a 0a0a 2320 544f  ymbol.sym...# TO
+0000da00: 444f 3a20 4375 7272 656e 746c 7920 7765  DO: Currently we
+0000da10: 2075 7365 2074 7261 6365 2e61 7267 7320   use trace.args 
+0000da20: 616e 6420 7472 6163 652e 6b77 6172 6773  and trace.kwargs
+0000da30: 2074 6f20 6765 7420 7468 6520 6172 6775   to get the argu
+0000da40: 6d65 6e74 730a 2320 4d61 7962 6520 7765  ments.# Maybe we
+0000da50: 2073 686f 756c 6420 7573 6520 7468 6573   should use thes
+0000da60: 6520 696e 7374 6561 640a 7472 616e 7366  e instead.transf
+0000da70: 6f72 6d5f 736b 6970 5f6c 6973 7420 3d20  orm_skip_list = 
+0000da80: 280a 2020 2020 7072 696d 732e 5072 696d  (.    prims.Prim
+0000da90: 4944 732e 554e 5041 434b 5f45 4d50 5459  IDs.UNPACK_EMPTY
+0000daa0: 5f44 4943 542c 0a20 2020 2070 7269 6d73  _DICT,.    prims
+0000dab0: 2e50 7269 6d49 4473 2e55 4e50 4143 4b5f  .PrimIDs.UNPACK_
+0000dac0: 4b45 592c 0a20 2020 2070 7269 6d73 2e50  KEY,.    prims.P
+0000dad0: 7269 6d49 4473 2e55 4e50 4143 4b5f 5345  rimIDs.UNPACK_SE
+0000dae0: 5155 454e 4345 2c0a 2020 2020 7072 696d  QUENCE,.    prim
+0000daf0: 732e 5072 696d 4944 732e 554e 5041 434b  s.PrimIDs.UNPACK
+0000db00: 5f54 5249 5649 414c 2c0a 2020 2020 7072  _TRIVIAL,.    pr
+0000db10: 696d 732e 5072 696d 4944 732e 5245 5455  ims.PrimIDs.RETU
+0000db20: 524e 2c0a 290a 0a0a 6465 6620 6576 616c  RN,.)...def eval
+0000db30: 5f74 7261 6365 2874 7261 6365 2c20 2a61  _trace(trace, *a
+0000db40: 7267 732c 2073 796d 626f 6c5f 6d61 7070  rgs, symbol_mapp
+0000db50: 6572 3d73 796d 626f 6c5f 746f 5f65 7661  er=symbol_to_eva
+0000db60: 6c2c 2077 6974 685f 656e 763d 4661 6c73  l, with_env=Fals
+0000db70: 652c 202a 2a6b 7761 7267 7329 3a0a 2020  e, **kwargs):.  
+0000db80: 2020 2222 2245 7661 6c75 6174 6520 6120    """Evaluate a 
+0000db90: 7472 6163 652e 0a0a 2020 2020 4172 6773  trace...    Args
+0000dba0: 3a0a 2020 2020 2020 2020 7472 6163 653a  :.        trace:
+0000dbb0: 2074 7261 6365 2074 6f20 6576 616c 7561   trace to evalua
+0000dbc0: 7465 0a20 2020 2020 2020 202a 6172 6773  te.        *args
+0000dbd0: 3a20 6172 6775 6d65 6e74 7320 746f 2065  : arguments to e
+0000dbe0: 7661 6c75 6174 6520 7468 6520 7472 6163  valuate the trac
+0000dbf0: 6520 7769 7468 0a20 2020 2020 2020 2073  e with.        s
+0000dc00: 796d 626f 6c5f 6d61 7070 6572 3a20 6675  ymbol_mapper: fu
+0000dc10: 6e63 7469 6f6e 2074 6861 7420 6d61 7073  nction that maps
+0000dc20: 2061 2073 796d 626f 6c20 746f 2061 2066   a symbol to a f
+0000dc30: 756e 6374 696f 6e20 7468 6174 2065 7661  unction that eva
+0000dc40: 6c75 6174 6573 2069 740a 2020 2020 2020  luates it.      
+0000dc50: 2020 2a2a 6b77 6172 6773 3a20 6b65 7977    **kwargs: keyw
+0000dc60: 6f72 6420 6172 6775 6d65 6e74 7320 746f  ord arguments to
+0000dc70: 2065 7661 6c75 6174 6520 7468 6520 7472   evaluate the tr
+0000dc80: 6163 6520 7769 7468 0a0a 2020 2020 5265  ace with..    Re
+0000dc90: 7475 726e 733a 0a20 2020 2020 2020 2072  turns:.        r
+0000dca0: 6573 756c 7420 6f66 2065 7661 6c75 6174  esult of evaluat
+0000dcb0: 696e 6720 7468 6520 7472 6163 650a 2020  ing the trace.  
+0000dcc0: 2020 2222 220a 2020 2020 656e 7620 3d20    """.    env = 
+0000dcd0: 7b7d 0a0a 2020 2020 6465 6620 7265 6164  {}..    def read
+0000dce0: 2878 3a20 5661 7269 6162 6c65 293a 0a20  (x: Variable):. 
+0000dcf0: 2020 2020 2020 2069 6620 6973 696e 7374         if isinst
+0000dd00: 616e 6365 2878 2c20 5661 7269 6162 6c65  ance(x, Variable
+0000dd10: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
+0000dd20: 6574 7572 6e20 656e 765b 782e 6e61 6d65  eturn env[x.name
+0000dd30: 5d0a 2020 2020 2020 2020 656c 7365 3a0a  ].        else:.
+0000dd40: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0000dd50: 726e 2078 0a0a 2020 2020 6465 6620 7772  rn x..    def wr
+0000dd60: 6974 6528 763a 2056 6172 6961 626c 652c  ite(v: Variable,
+0000dd70: 2076 616c 3a20 416e 792c 2061 6c6c 6f77   val: Any, allow
+0000dd80: 5f64 7570 6c69 6361 7465 733d 4661 6c73  _duplicates=Fals
+0000dd90: 6529 202d 3e20 4e6f 6e65 3a0a 2020 2020  e) -> None:.    
+0000dda0: 2020 2020 6966 206e 6f74 2069 7369 6e73      if not isins
+0000ddb0: 7461 6e63 6528 762c 2056 6172 6961 626c  tance(v, Variabl
+0000ddc0: 6529 3a0a 2020 2020 2020 2020 2020 2020  e):.            
+0000ddd0: 7265 7475 726e 0a20 2020 2020 2020 2023  return.        #
+0000dde0: 2044 7570 6c69 6361 7465 7320 6172 6520   Duplicates are 
+0000ddf0: 616c 6c6f 7765 6420 616e 6420 6f76 6572  allowed and over
+0000de00: 7772 6974 7465 6e0a 2020 2020 2020 2020  written.        
+0000de10: 6966 2076 2e6e 616d 6520 696e 2065 6e76  if v.name in env
+0000de20: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
+0000de30: 2061 6c6c 6f77 5f64 7570 6c69 6361 7465   allow_duplicate
+0000de40: 733a 0a20 2020 2020 2020 2020 2020 2020  s:.             
+0000de50: 2020 2072 6574 7572 6e0a 2020 2020 2020     return.      
+0000de60: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
+0000de70: 6545 7272 6f72 2866 2256 6172 6961 626c  eError(f"Variabl
+0000de80: 6520 7b76 2e6e 616d 657d 2069 7320 6265  e {v.name} is be
+0000de90: 696e 6720 6f76 6572 7772 6974 7465 6e20  ing overwritten 
+0000dea0: 7468 6973 2069 7320 6e6f 7420 616c 6c6f  this is not allo
+0000deb0: 7765 6422 290a 2020 2020 2020 2020 656e  wed").        en
+0000dec0: 765b 762e 6e61 6d65 5d20 3d20 7661 6c0a  v[v.name] = val.
+0000ded0: 0a20 2020 2073 6166 655f 6d61 705f 666c  .    safe_map_fl
+0000dee0: 6174 2877 7269 7465 2c20 6c69 7374 2874  at(write, list(t
+0000def0: 7261 6365 2e61 7267 7329 2c20 6c69 7374  race.args), list
+0000df00: 2861 7267 7329 290a 2020 2020 7361 6665  (args)).    safe
+0000df10: 5f6d 6170 5f66 6c61 7428 7772 6974 652c  _map_flat(write,
+0000df20: 206c 6973 7428 7472 6163 652e 6b77 6172   list(trace.kwar
+0000df30: 6773 2e76 616c 7565 7328 2929 2c20 6c69  gs.values()), li
+0000df40: 7374 286b 7761 7267 732e 7661 6c75 6573  st(kwargs.values
+0000df50: 2829 2929 0a0a 2020 2020 666f 7220 7379  ()))..    for sy
+0000df60: 6d62 6f6c 2069 6e20 7472 6163 652e 626f  mbol in trace.bo
+0000df70: 756e 645f 7379 6d62 6f6c 733a 0a20 2020  und_symbols:.   
+0000df80: 2020 2020 2069 6620 7379 6d62 6f6c 2e73       if symbol.s
+0000df90: 796d 2e69 6420 696e 2074 7261 6e73 666f  ym.id in transfo
+0000dfa0: 726d 5f73 6b69 705f 6c69 7374 3a0a 2020  rm_skip_list:.  
+0000dfb0: 2020 2020 2020 2020 2020 636f 6e74 696e            contin
+0000dfc0: 7565 0a20 2020 2020 2020 2061 7267 7320  ue.        args 
+0000dfd0: 3d20 7472 6565 5f6d 6170 2872 6561 642c  = tree_map(read,
+0000dfe0: 2073 796d 626f 6c2e 6172 6773 290a 2020   symbol.args).  
+0000dff0: 2020 2020 2020 6b77 6172 6773 203d 2074        kwargs = t
+0000e000: 7265 655f 6d61 7028 7265 6164 2c20 7379  ree_map(read, sy
+0000e010: 6d62 6f6c 2e6b 7761 7267 7329 0a20 2020  mbol.kwargs).   
+0000e020: 2020 2020 2070 7269 6d5f 6675 6e63 203d       prim_func =
+0000e030: 2073 796d 626f 6c5f 6d61 7070 6572 2873   symbol_mapper(s
+0000e040: 796d 626f 6c29 0a20 2020 2020 2020 2069  ymbol).        i
+0000e050: 6620 7072 696d 5f66 756e 6320 6973 204e  f prim_func is N
+0000e060: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+0000e070: 2063 6f6e 7469 6e75 650a 2020 2020 2020   continue.      
+0000e080: 2020 7265 7375 6c74 203d 2070 7269 6d5f    result = prim_
+0000e090: 6675 6e63 282a 6172 6773 2c20 2a2a 6b77  func(*args, **kw
+0000e0a0: 6172 6773 290a 2020 2020 2020 2020 7361  args).        sa
+0000e0b0: 6665 5f6d 6170 5f66 6c61 7428 7772 6974  fe_map_flat(writ
+0000e0c0: 652c 206c 6973 7428 7365 7175 656e 6369  e, list(sequenci
+0000e0d0: 6679 2873 796d 626f 6c2e 6f75 7470 7574  fy(symbol.output
+0000e0e0: 2929 2c20 6c69 7374 2873 6571 7565 6e63  )), list(sequenc
+0000e0f0: 6966 7928 7265 7375 6c74 2929 290a 0a20  ify(result))).. 
+0000e100: 2020 2069 6620 7769 7468 5f65 6e76 3a0a     if with_env:.
+0000e110: 2020 2020 2020 2020 7265 7475 726e 2074          return t
+0000e120: 7265 655f 6d61 7028 7265 6164 2c20 7472  ree_map(read, tr
+0000e130: 6163 652e 6f75 7470 7574 292c 2065 6e76  ace.output), env
+0000e140: 0a0a 2020 2020 7265 7475 726e 2074 7265  ..    return tre
+0000e150: 655f 6d61 7028 7265 6164 2c20 7472 6163  e_map(read, trac
+0000e160: 652e 6f75 7470 7574 290a 0a0a 6465 6620  e.output)...def 
+0000e170: 5f69 6465 6e74 6974 795f 6361 6c6c 5f6d  _identity_call_m
+0000e180: 6574 6166 756e 6328 2a61 7267 732c 2074  etafunc(*args, t
+0000e190: 7261 6365 3a20 5472 6163 652c 202a 2a6b  race: Trace, **k
+0000e1a0: 7761 7267 7329 3a0a 2020 2020 7769 7468  wargs):.    with
+0000e1b0: 2064 6574 6163 6865 645f 7472 6163 6528   detached_trace(
+0000e1c0: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+0000e1d0: 6e20 6576 616c 5f74 7261 6365 2874 7261  n eval_trace(tra
+0000e1e0: 6365 2c20 2a61 7267 732c 202a 2a6b 7761  ce, *args, **kwa
+0000e1f0: 7267 7329 0a0a 0a69 6465 6e74 6974 795f  rgs)...identity_
+0000e200: 6361 6c6c 203d 2053 796d 626f 6c28 6964  call = Symbol(id
+0000e210: 3d54 7261 6e73 666f 726d 732e 4964 656e  =Transforms.Iden
+0000e220: 7469 7479 4f70 2c20 6e61 6d65 3d22 6964  tityOp, name="id
+0000e230: 656e 7469 7479 5f63 616c 6c22 2c20 6d65  entity_call", me
+0000e240: 7461 3d5f 6964 656e 7469 7479 5f63 616c  ta=_identity_cal
+0000e250: 6c5f 6d65 7461 6675 6e63 290a 0a0a 6465  l_metafunc)...de
+0000e260: 6620 6964 656e 7469 7479 2866 756e 6329  f identity(func)
+0000e270: 3a0a 2020 2020 2222 2249 6465 6e74 6974  :.    """Identit
+0000e280: 7920 7472 616e 7366 6f72 6d20 666f 7220  y transform for 
+0000e290: 6120 5468 756e 6465 7220 6675 6e63 7469  a Thunder functi
+0000e2a0: 6f6e 2e0a 0a20 2020 2041 7267 733a 0a20  on...    Args:. 
+0000e2b0: 2020 2020 2020 2066 756e 6320 2843 616c         func (Cal
+0000e2c0: 6c61 626c 6529 3a20 4120 5468 756e 6465  lable): A Thunde
+0000e2d0: 7220 6675 6e63 7469 6f6e 2074 6f20 6265  r function to be
+0000e2e0: 2074 7261 6e73 666f 726d 6564 2e0a 2020   transformed..  
+0000e2f0: 2020 2222 220a 0a20 2020 2064 6566 2077    """..    def w
+0000e300: 7261 7070 6572 282a 6172 6773 2c20 2a2a  rapper(*args, **
+0000e310: 6b77 6172 6773 293a 0a20 2020 2020 2020  kwargs):.       
+0000e320: 2074 7261 6365 203d 2063 6f6e 7374 7275   trace = constru
+0000e330: 6374 5f74 7261 6365 2829 2866 756e 632c  ct_trace()(func,
+0000e340: 202a 6172 6773 2c20 2a2a 6b77 6172 6773   *args, **kwargs
+0000e350: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+0000e360: 2069 6465 6e74 6974 795f 6361 6c6c 282a   identity_call(*
+0000e370: 6172 6773 2c20 2a2a 6b77 6172 6773 2c20  args, **kwargs, 
+0000e380: 7472 6163 653d 7472 6163 6529 0a0a 2020  trace=trace)..  
+0000e390: 2020 7265 7475 726e 2077 7261 7070 6572    return wrapper
+0000e3a0: 0a0a 0a64 6566 205f 6964 656e 7469 7479  ...def _identity
+0000e3b0: 5f63 616c 6c5f 7079 746f 7263 6828 2a61  _call_pytorch(*a
+0000e3c0: 7267 732c 2074 7261 6365 3a20 5472 6163  rgs, trace: Trac
+0000e3d0: 652c 202a 2a6b 7761 7267 7329 3a0a 2020  e, **kwargs):.  
+0000e3e0: 2020 696d 706f 7274 2074 6f72 6368 0a0a    import torch..
+0000e3f0: 2020 2020 6465 6620 7379 6d62 6f6c 5f6d      def symbol_m
+0000e400: 6170 7065 7228 6f70 293a 0a20 2020 2020  apper(op):.     
+0000e410: 2020 2069 6620 6f70 2e6f 7020 3d3d 2054     if op.op == T
+0000e420: 7261 6e73 666f 726d 732e 4964 656e 7469  ransforms.Identi
+0000e430: 7479 4f70 3a0a 2020 2020 2020 2020 2020  tyOp:.          
+0000e440: 2020 7265 7475 726e 205f 6964 656e 7469    return _identi
+0000e450: 7479 5f63 616c 6c5f 7079 746f 7263 680a  ty_call_pytorch.
+0000e460: 0a20 2020 2020 2020 2074 6f72 6368 5f6f  .        torch_o
+0000e470: 7020 3d20 6f70 735f 746f 5f74 6f72 6368  p = ops_to_torch
+0000e480: 5f6f 7073 5f6d 6170 5b6f 702e 6f70 5d0a  _ops_map[op.op].
+0000e490: 2020 2020 2020 2020 6966 2069 7369 6e73          if isins
+0000e4a0: 7461 6e63 6528 746f 7263 685f 6f70 2c20  tance(torch_op, 
+0000e4b0: 7374 7229 3a0a 2020 2020 2020 2020 2020  str):.          
+0000e4c0: 2020 7265 7475 726e 2067 6574 6174 7472    return getattr
+0000e4d0: 2874 6f72 6368 2c20 746f 7263 685f 6f70  (torch, torch_op
+0000e4e0: 2e73 7472 6970 2822 7079 746f 7263 682e  .strip("pytorch.
+0000e4f0: 2229 290a 2020 2020 2020 2020 7265 7475  ")).        retu
+0000e500: 726e 2074 6f72 6368 5f6f 700a 0a20 2020  rn torch_op..   
+0000e510: 2077 6974 6820 6465 7461 6368 6564 5f74   with detached_t
+0000e520: 7261 6365 2829 3a0a 2020 2020 2020 2020  race():.        
+0000e530: 7265 7475 726e 2065 7661 6c5f 7472 6163  return eval_trac
+0000e540: 6528 7472 6163 652c 202a 6172 6773 2c20  e(trace, *args, 
+0000e550: 2a2a 6b77 6172 6773 2c20 7379 6d62 6f6c  **kwargs, symbol
+0000e560: 5f6d 6170 7065 723d 7379 6d62 6f6c 5f6d  _mapper=symbol_m
+0000e570: 6170 7065 7229 0a0a 0a23 2052 6567 6973  apper)...# Regis
+0000e580: 7465 7220 7468 6520 6964 656e 7469 7479  ter the identity
+0000e590: 2063 616c 6c20 666f 7220 5079 546f 7263   call for PyTorc
+0000e5a0: 6820 6578 6563 7574 6f72 2e0a 2320 6f70  h executor..# op
+0000e5b0: 735f 746f 5f74 6f72 6368 5f6f 7073 5f6d  s_to_torch_ops_m
+0000e5c0: 6170 5b54 7261 6e73 666f 726d 732e 4964  ap[Transforms.Id
+0000e5d0: 656e 7469 7479 4f70 5d20 3d20 5f69 6465  entityOp] = _ide
+0000e5e0: 6e74 6974 795f 6361 6c6c 5f70 7974 6f72  ntity_call_pytor
+0000e5f0: 6368 0a0a 0a23 2056 4d41 5020 7472 616e  ch...# VMAP tran
+0000e600: 7366 6f72 6d0a 2320 2d2d 2d2d 2d2d 2d2d  sform.# --------
+0000e610: 2d2d 2d2d 2d0a 0a0a 636c 6173 7320 4e6f  -----...class No
+0000e620: 744d 6170 7065 643a 0a20 2020 2022 2222  tMapped:.    """
+0000e630: 5265 7072 6573 656e 7473 2061 206e 6f6e  Represents a non
+0000e640: 2d62 6174 6368 6564 2064 696d 656e 7369  -batched dimensi
+0000e650: 6f6e 2e22 2222 0a0a 2020 2020 6465 6620  on."""..    def 
+0000e660: 5f5f 7265 7072 5f5f 2873 656c 6629 3a0a  __repr__(self):.
+0000e670: 2020 2020 2020 2020 7265 7475 726e 2022          return "
+0000e680: 6e6f 745f 6d61 7070 6564 220a 0a0a 4064  not_mapped"...@d
+0000e690: 6174 6163 6c61 7373 2866 726f 7a65 6e3d  ataclass(frozen=
+0000e6a0: 5472 7565 290a 636c 6173 7320 4261 7463  True).class Batc
+0000e6b0: 6865 6456 616c 7565 3a0a 2020 2020 2222  hedValue:.    ""
+0000e6c0: 2242 6174 6368 6564 2076 616c 7565 2066  "Batched value f
+0000e6d0: 6f72 2074 6865 2076 6d61 7020 7472 616e  or the vmap tran
+0000e6e0: 7366 6f72 6d2e 0a0a 2020 2020 4174 7472  sform...    Attr
+0000e6f0: 6962 7574 6573 3a0a 2020 2020 2020 2020  ibutes:.        
+0000e700: 7661 6c75 653a 2042 6174 6368 6564 2076  value: Batched v
+0000e710: 616c 7565 2e0a 2020 2020 2020 2020 6261  alue..        ba
+0000e720: 7463 685f 6469 6d3a 2042 6174 6368 696e  tch_dim: Batchin
+0000e730: 6720 6469 6d65 6e73 696f 6e20 6f72 206e  g dimension or n
+0000e740: 6f74 5f6d 6170 7065 640a 2020 2020 2222  ot_mapped.    ""
+0000e750: 220a 0a20 2020 2076 616c 7565 3a20 416e  "..    value: An
+0000e760: 790a 2020 2020 6261 7463 685f 6469 6d3a  y.    batch_dim:
+0000e770: 2069 6e74 207c 204e 6f74 4d61 7070 6564   int | NotMapped
+0000e780: 0a0a 2020 2020 6465 6620 5f5f 6974 6572  ..    def __iter
+0000e790: 5f5f 2873 656c 6629 3a0a 2020 2020 2020  __(self):.      
+0000e7a0: 2020 7969 656c 6420 7365 6c66 2e76 616c    yield self.val
+0000e7b0: 7565 0a20 2020 2020 2020 2079 6965 6c64  ue.        yield
+0000e7c0: 2073 656c 662e 6261 7463 685f 6469 6d0a   self.batch_dim.
+0000e7d0: 0a0a 6465 6620 7061 6972 5f74 6f5f 6261  ..def pair_to_ba
+0000e7e0: 7463 6865 645f 7661 6c75 6528 7061 6972  tched_value(pair
+0000e7f0: 293a 0a20 2020 2022 2222 436f 6e76 6572  ):.    """Conver
+0000e800: 7473 2061 2070 6169 7220 746f 2061 2042  ts a pair to a B
+0000e810: 6174 6368 6564 5661 6c75 652e 0a0a 2020  atchedValue...  
+0000e820: 2020 4172 6773 3a0a 2020 2020 2020 2020    Args:.        
+0000e830: 7061 6972 2028 5365 7175 656e 6365 293a  pair (Sequence):
+0000e840: 2050 6169 7220 746f 2063 6f6e 7665 7274   Pair to convert
+0000e850: 2e0a 0a20 2020 2052 6574 7572 6e73 3a0a  ...    Returns:.
+0000e860: 2020 2020 2020 2020 4261 7463 6865 6456          BatchedV
+0000e870: 616c 7565 3a20 4261 7463 6865 6456 616c  alue: BatchedVal
+0000e880: 7565 2072 6570 7265 7365 6e74 6174 696f  ue representatio
+0000e890: 6e20 6f66 2074 6865 2070 6169 722e 0a20  n of the pair.. 
+0000e8a0: 2020 2022 2222 0a20 2020 2069 6620 6973     """.    if is
+0000e8b0: 696e 7374 616e 6365 2870 6169 722c 2042  instance(pair, B
+0000e8c0: 6174 6368 6564 5661 6c75 6529 3a0a 2020  atchedValue):.  
+0000e8d0: 2020 2020 2020 7265 7475 726e 2070 6169        return pai
+0000e8e0: 720a 2020 2020 656c 7365 3a0a 2020 2020  r.    else:.    
+0000e8f0: 2020 2020 6173 7365 7274 2069 7369 6e73      assert isins
+0000e900: 7461 6e63 6528 7061 6972 2c20 5365 7175  tance(pair, Sequ
+0000e910: 656e 6365 2920 616e 6420 6c65 6e28 7061  ence) and len(pa
+0000e920: 6972 2920 3d3d 2032 0a20 2020 2020 2020  ir) == 2.       
+0000e930: 2072 6574 7572 6e20 4261 7463 6865 6456   return BatchedV
+0000e940: 616c 7565 282a 7061 6972 290a 0a0a 6465  alue(*pair)...de
+0000e950: 6620 7665 6374 6f72 697a 6564 5f62 6174  f vectorized_bat
+0000e960: 6368 6572 2870 7269 6d2c 2061 7869 735f  cher(prim, axis_
+0000e970: 7369 7a65 2c20 6261 7463 6865 645f 7661  size, batched_va
+0000e980: 6c75 6573 2c20 2a2a 6b77 6172 6773 293a  lues, **kwargs):
+0000e990: 0a20 2020 2062 6174 6368 5f64 696d 203d  .    batch_dim =
+0000e9a0: 2062 6174 6368 6564 5f76 616c 7565 735b   batched_values[
+0000e9b0: 305d 2e62 6174 6368 5f64 696d 0a20 2020  0].batch_dim.   
+0000e9c0: 2061 7373 6572 7420 616c 6c28 0a20 2020   assert all(.   
+0000e9d0: 2020 2020 2062 6174 6368 5f64 696d 203d       batch_dim =
+0000e9e0: 3d20 6276 2e62 6174 6368 5f64 696d 2066  = bv.batch_dim f
+0000e9f0: 6f72 2062 7620 696e 2062 6174 6368 6564  or bv in batched
+0000ea00: 5f76 616c 7565 735b 313a 5d0a 2020 2020  _values[1:].    
+0000ea10: 292c 2066 2260 7665 6374 6f72 697a 6564  ), f"`vectorized
+0000ea20: 5f62 6174 6368 6572 6020 676f 7420 6469  _batcher` got di
+0000ea30: 6666 6572 656e 7420 6261 7463 6865 6420  fferent batched 
+0000ea40: 6469 6d65 6e73 696f 6e73 207b 5b62 762e  dimensions {[bv.
+0000ea50: 6261 7463 685f 6469 6d20 666f 7220 6276  batch_dim for bv
+0000ea60: 2069 6e20 6261 7463 6865 645f 7661 6c75   in batched_valu
+0000ea70: 6573 5d7d 220a 2020 2020 7265 7475 726e  es]}".    return
+0000ea80: 2042 6174 6368 6564 5661 6c75 6528 7072   BatchedValue(pr
+0000ea90: 696d 282a 5b62 762e 7661 6c75 6520 666f  im(*[bv.value fo
+0000eaa0: 7220 6276 2069 6e20 6261 7463 6865 645f  r bv in batched_
+0000eab0: 7661 6c75 6573 5d2c 202a 2a6b 7761 7267  values], **kwarg
+0000eac0: 7329 2c20 6261 7463 685f 6469 6d29 0a0a  s), batch_dim)..
+0000ead0: 0a6e 6f74 5f6d 6170 7065 6420 3d20 4e6f  .not_mapped = No
+0000eae0: 744d 6170 7065 6428 290a 0a0a 6465 6620  tMapped()...def 
+0000eaf0: 6d6f 7665 6469 6d28 782c 2073 7263 3a20  movedim(x, src: 
+0000eb00: 696e 742c 2064 7374 3a20 696e 7429 3a0a  int, dst: int):.
+0000eb10: 2020 2020 7065 726d 203d 205b 6920 666f      perm = [i fo
+0000eb20: 7220 6920 696e 2072 616e 6765 2878 2e6e  r i in range(x.n
+0000eb30: 6469 6d29 2069 6620 6920 213d 2073 7263  dim) if i != src
+0000eb40: 5d0a 2020 2020 7065 726d 2e69 6e73 6572  ].    perm.inser
+0000eb50: 7428 6473 742c 2073 7263 290a 2020 2020  t(dst, src).    
+0000eb60: 7265 7475 726e 2070 7269 6d73 2e74 7261  return prims.tra
+0000eb70: 6e73 706f 7365 2878 2c20 7475 706c 6528  nspose(x, tuple(
+0000eb80: 7065 726d 2929 0a0a 0a64 6566 206d 6f76  perm))...def mov
+0000eb90: 655f 6261 7463 685f 6469 6d28 6178 6973  e_batch_dim(axis
+0000eba0: 5f73 697a 652c 2073 7263 2c20 6473 742c  _size, src, dst,
+0000ebb0: 2078 293a 0a20 2020 2069 6620 7372 6320   x):.    if src 
+0000ebc0: 6973 206e 6f74 5f6d 6170 7065 643a 0a20  is not_mapped:. 
+0000ebd0: 2020 2020 2020 2069 6620 6973 696e 7374         if isinst
+0000ebe0: 616e 6365 2878 2c20 4e75 6d62 6572 293a  ance(x, Number):
+0000ebf0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+0000ec00: 7572 6e20 780a 2020 2020 2020 2020 7461  urn x.        ta
+0000ec10: 7267 6574 5f73 6861 7065 203d 206c 6973  rget_shape = lis
+0000ec20: 7428 782e 7368 6170 6529 0a20 2020 2020  t(x.shape).     
+0000ec30: 2020 2074 6172 6765 745f 7368 6170 652e     target_shape.
+0000ec40: 696e 7365 7274 2864 7374 2c20 6178 6973  insert(dst, axis
+0000ec50: 5f73 697a 6529 0a20 2020 2020 2020 2062  _size).        b
+0000ec60: 6361 7374 5f64 696d 7320 3d20 6c69 7374  cast_dims = list
+0000ec70: 2872 616e 6765 286c 656e 2874 6172 6765  (range(len(targe
+0000ec80: 745f 7368 6170 6529 2929 0a20 2020 2020  t_shape))).     
+0000ec90: 2020 2062 6361 7374 5f64 696d 732e 706f     bcast_dims.po
+0000eca0: 7028 6473 7429 0a20 2020 2020 2020 2072  p(dst).        r
+0000ecb0: 6574 7572 6e20 7072 696d 732e 6272 6f61  eturn prims.broa
+0000ecc0: 6463 6173 745f 696e 5f64 696d 2878 2c20  dcast_in_dim(x, 
+0000ecd0: 7461 7267 6574 5f73 6861 7065 2c20 6263  target_shape, bc
+0000ece0: 6173 745f 6469 6d73 290a 2020 2020 656c  ast_dims).    el
+0000ecf0: 6966 2073 7263 203d 3d20 6473 743a 0a20  if src == dst:. 
+0000ed00: 2020 2020 2020 2072 6574 7572 6e20 780a         return x.
+0000ed10: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0000ed20: 2020 7265 7475 726e 206d 6f76 6564 696d    return movedim
+0000ed30: 2878 2c20 7372 632c 2064 7374 290a 0a0a  (x, src, dst)...
+0000ed40: 6465 6620 6269 6e61 7279 5f6f 705f 6261  def binary_op_ba
+0000ed50: 7463 6869 6e67 5f72 756c 6528 6f70 3a20  tching_rule(op: 
+0000ed60: 7072 696d 732e 5072 696d 4944 732c 2061  prims.PrimIDs, a
+0000ed70: 7869 735f 7369 7a65 3a20 696e 742c 2076  xis_size: int, v
+0000ed80: 616c 735f 696e 3a20 4261 7463 6865 6456  als_in: BatchedV
+0000ed90: 616c 7565 293a 0a20 2020 2028 2878 2c20  alue):.    ((x, 
+0000eda0: 785f 6264 696d 292c 2028 792c 2079 5f62  x_bdim), (y, y_b
+0000edb0: 6469 6d29 2920 3d20 7661 6c73 5f69 6e0a  dim)) = vals_in.
+0000edc0: 2020 2020 6966 2078 5f62 6469 6d20 213d      if x_bdim !=
+0000edd0: 2079 5f62 6469 6d3a 0a20 2020 2020 2020   y_bdim:.       
+0000ede0: 2069 6620 785f 6264 696d 2069 7320 6e6f   if x_bdim is no
+0000edf0: 745f 6d61 7070 6564 3a0a 2020 2020 2020  t_mapped:.      
+0000ee00: 2020 2020 2020 7820 3d20 6d6f 7665 5f62        x = move_b
+0000ee10: 6174 6368 5f64 696d 2861 7869 735f 7369  atch_dim(axis_si
+0000ee20: 7a65 2c20 785f 6264 696d 2c20 795f 6264  ze, x_bdim, y_bd
+0000ee30: 696d 2c20 7829 0a20 2020 2020 2020 2020  im, x).         
+0000ee40: 2020 2078 5f62 6469 6d20 3d20 795f 6264     x_bdim = y_bd
+0000ee50: 696d 0a20 2020 2020 2020 2065 6c73 653a  im.        else:
+0000ee60: 0a20 2020 2020 2020 2020 2020 2079 203d  .            y =
+0000ee70: 206d 6f76 655f 6261 7463 685f 6469 6d28   move_batch_dim(
+0000ee80: 6178 6973 5f73 697a 652c 2079 5f62 6469  axis_size, y_bdi
+0000ee90: 6d2c 2078 5f62 6469 6d2c 2079 290a 2020  m, x_bdim, y).  
+0000eea0: 2020 7265 7475 726e 2042 6174 6368 6564    return Batched
+0000eeb0: 5661 6c75 6528 6f70 2878 2c20 7929 2c20  Value(op(x, y), 
+0000eec0: 785f 6264 696d 290a 0a0a 6465 6620 7369  x_bdim)...def si
+0000eed0: 6e5f 766d 6170 2861 7869 735f 7369 7a65  n_vmap(axis_size
+0000eee0: 3a20 696e 742c 2061 3a20 4261 7463 6865  : int, a: Batche
 0000eef0: 6456 616c 7565 2920 2d3e 2042 6174 6368  dValue) -> Batch
 0000ef00: 6564 5661 6c75 653a 0a20 2020 2072 6574  edValue:.    ret
-0000ef10: 7572 6e20 6269 6e61 7279 5f6f 705f 6261  urn binary_op_ba
-0000ef20: 7463 6869 6e67 5f72 756c 6528 7072 696d  tching_rule(prim
-0000ef30: 732e 6164 642c 2061 7869 735f 7369 7a65  s.add, axis_size
-0000ef40: 2c20 2861 2c20 6229 290a 0a0a 6465 6620  , (a, b))...def 
-0000ef50: 7375 6d5f 766d 6170 2861 7869 735f 7369  sum_vmap(axis_si
-0000ef60: 7a65 3a20 696e 742c 2061 3a20 4261 7463  ze: int, a: Batc
-0000ef70: 6865 6456 616c 7565 2c20 6469 6d73 3a20  hedValue, dims: 
-0000ef80: 5365 7175 656e 6365 5b69 6e74 5d2c 202a  Sequence[int], *
-0000ef90: 2a6b 7761 7267 7329 202d 3e20 4261 7463  *kwargs) -> Batc
-0000efa0: 6865 6456 616c 7565 3a0a 2020 2020 6264  hedValue:.    bd
-0000efb0: 696d 203d 2061 2e62 6174 6368 5f64 696d  im = a.batch_dim
-0000efc0: 0a20 2020 2023 2054 4f44 4f3a 2072 656d  .    # TODO: rem
-0000efd0: 6f76 6520 7468 6973 2077 6865 6e20 6469  ove this when di
-0000efe0: 6d73 2062 6563 6f6d 6573 2061 206d 616e  ms becomes a man
-0000eff0: 6461 746f 7279 206b 7761 7267 0a20 2020  datory kwarg.   
-0000f000: 2069 6620 6c65 6e28 6469 6d73 2920 3e20   if len(dims) > 
-0000f010: 303a 0a20 2020 2020 2020 2064 696d 732c  0:.        dims,
-0000f020: 205f 203d 2073 6166 655f 7a69 7028 2a64   _ = safe_zip(*d
-0000f030: 696d 7329 0a20 2020 2064 696d 735f 6265  ims).    dims_be
-0000f040: 666f 7265 203d 2074 7570 6c65 2865 6c20  fore = tuple(el 
-0000f050: 666f 7220 656c 2069 6e20 6469 6d73 2069  for el in dims i
-0000f060: 6620 656c 203c 2062 6469 6d29 0a20 2020  f el < bdim).   
-0000f070: 2064 696d 735f 6166 7465 7220 3d20 7475   dims_after = tu
-0000f080: 706c 6528 656c 202b 2031 2066 6f72 2065  ple(el + 1 for e
-0000f090: 6c20 696e 2064 696d 7320 6966 2065 6c20  l in dims if el 
-0000f0a0: 3e3d 2062 6469 6d29 0a20 2020 2062 6174  >= bdim).    bat
-0000f0b0: 6368 6564 5f64 696d 7320 3d20 6469 6d73  ched_dims = dims
-0000f0c0: 5f62 6566 6f72 6520 2b20 6469 6d73 5f61  _before + dims_a
-0000f0d0: 6674 6572 0a20 2020 2072 6574 7572 6e20  fter.    return 
-0000f0e0: 7665 6374 6f72 697a 6564 5f62 6174 6368  vectorized_batch
-0000f0f0: 6572 2870 7269 6d73 2e73 756d 2c20 6178  er(prims.sum, ax
-0000f100: 6973 5f73 697a 652c 2028 612c 292c 2064  is_size, (a,), d
-0000f110: 696d 733d 6261 7463 6865 645f 6469 6d73  ims=batched_dims
-0000f120: 2c20 2a2a 6b77 6172 6773 290a 0a0a 2320  , **kwargs)...# 
-0000f130: 544f 444f 3a20 506c 6561 7365 2074 6573  TODO: Please tes
-0000f140: 7420 7468 6973 2065 7874 656e 7369 7665  t this extensive
-0000f150: 6c79 0a64 6566 2062 726f 6164 6361 7374  ly.def broadcast
-0000f160: 5f69 6e5f 6469 6d5f 766d 6170 280a 2020  _in_dim_vmap(.  
-0000f170: 2020 6178 6973 5f73 697a 653a 2069 6e74    axis_size: int
-0000f180: 2c20 613a 2042 6174 6368 6564 5661 6c75  , a: BatchedValu
-0000f190: 652c 2073 6861 7065 3a20 5365 7175 656e  e, shape: Sequen
-0000f1a0: 6365 5b42 6174 6368 6564 5661 6c75 655d  ce[BatchedValue]
-0000f1b0: 2c20 6272 6f61 6463 6173 745f 6469 6d65  , broadcast_dime
-0000f1c0: 6e73 696f 6e73 3a20 5365 7175 656e 6365  nsions: Sequence
-0000f1d0: 5b42 6174 6368 6564 5661 6c75 655d 0a29  [BatchedValue].)
-0000f1e0: 202d 3e20 4261 7463 6865 6456 616c 7565   -> BatchedValue
-0000f1f0: 3a0a 2020 2020 6264 696d 203d 2061 2e62  :.    bdim = a.b
-0000f200: 6174 6368 5f64 696d 0a20 2020 2023 2054  atch_dim.    # T
-0000f210: 4f44 4f3a 2072 656d 6f76 6520 7468 6973  ODO: remove this
-0000f220: 2077 6865 6e20 7368 6170 6520 616e 6420   when shape and 
-0000f230: 6272 6f61 6463 6173 745f 6469 6d65 6e73  broadcast_dimens
-0000f240: 696f 6e73 2062 6563 6f6d 6520 6d61 6e64  ions become mand
-0000f250: 6174 6f72 7920 6b77 6172 6773 0a20 2020  atory kwargs.   
-0000f260: 2073 6861 7065 2c20 5f20 3d20 7361 6665   shape, _ = safe
-0000f270: 5f7a 6970 282a 7368 6170 6529 0a20 2020  _zip(*shape).   
-0000f280: 2069 6620 6c65 6e28 6272 6f61 6463 6173   if len(broadcas
-0000f290: 745f 6469 6d65 6e73 696f 6e73 2920 3e20  t_dimensions) > 
-0000f2a0: 303a 0a20 2020 2020 2020 2062 726f 6164  0:.        broad
-0000f2b0: 6361 7374 5f64 696d 656e 7369 6f6e 732c  cast_dimensions,
-0000f2c0: 205f 203d 2073 6166 655f 7a69 7028 2a62   _ = safe_zip(*b
-0000f2d0: 726f 6164 6361 7374 5f64 696d 656e 7369  roadcast_dimensi
-0000f2e0: 6f6e 7329 0a20 2020 2069 6620 6264 696d  ons).    if bdim
-0000f2f0: 2069 7320 6e6f 745f 6d61 7070 6564 3a0a   is not_mapped:.
-0000f300: 2020 2020 2020 2020 7265 7475 726e 2042          return B
-0000f310: 6174 6368 6564 5661 6c75 6528 7072 696d  atchedValue(prim
-0000f320: 732e 6272 6f61 6463 6173 745f 696e 5f64  s.broadcast_in_d
-0000f330: 696d 2861 2e76 616c 7565 2c20 7368 6170  im(a.value, shap
-0000f340: 652c 2062 726f 6164 6361 7374 5f64 696d  e, broadcast_dim
-0000f350: 656e 7369 6f6e 7329 2c20 6264 696d 290a  ensions), bdim).
-0000f360: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-0000f370: 2020 6e65 775f 6264 696d 203d 2062 6469    new_bdim = bdi
-0000f380: 6d20 2b20 7375 6d28 3120 666f 7220 6469  m + sum(1 for di
-0000f390: 6d20 696e 2062 726f 6164 6361 7374 5f64  m in broadcast_d
-0000f3a0: 696d 656e 7369 6f6e 7320 6966 2064 696d  imensions if dim
-0000f3b0: 203c 2062 6469 6d29 0a20 2020 2020 2020   < bdim).       
-0000f3c0: 206e 6577 5f73 6861 7065 203d 206c 6973   new_shape = lis
-0000f3d0: 7428 7368 6170 6529 0a20 2020 2020 2020  t(shape).       
-0000f3e0: 206e 6577 5f73 6861 7065 2e69 6e73 6572   new_shape.inser
-0000f3f0: 7428 6e65 775f 6264 696d 2c20 6178 6973  t(new_bdim, axis
-0000f400: 5f73 697a 6529 0a20 2020 2020 2020 206e  _size).        n
-0000f410: 6577 5f62 726f 6164 6361 7374 5f64 696d  ew_broadcast_dim
-0000f420: 656e 7369 6f6e 7320 3d20 2830 2c29 202b  ensions = (0,) +
-0000f430: 2074 7570 6c65 2864 696d 202b 2031 2069   tuple(dim + 1 i
-0000f440: 6620 6469 6d20 3e3d 2062 6469 6d20 656c  f dim >= bdim el
-0000f450: 7365 2064 696d 2066 6f72 2064 696d 2069  se dim for dim i
-0000f460: 6e20 6272 6f61 6463 6173 745f 6469 6d65  n broadcast_dime
-0000f470: 6e73 696f 6e73 290a 2020 2020 2020 2020  nsions).        
-0000f480: 6966 2062 726f 6164 6361 7374 5f64 696d  if broadcast_dim
-0000f490: 656e 7369 6f6e 7320 3d3d 2028 293a 0a20  ensions == ():. 
-0000f4a0: 2020 2020 2020 2020 2020 206e 6577 5f62             new_b
-0000f4b0: 726f 6164 6361 7374 5f64 696d 656e 7369  roadcast_dimensi
-0000f4c0: 6f6e 7320 3d20 2829 0a20 2020 2020 2020  ons = ().       
-0000f4d0: 2072 6574 7572 6e20 4261 7463 6865 6456   return BatchedV
-0000f4e0: 616c 7565 2870 7269 6d73 2e62 726f 6164  alue(prims.broad
-0000f4f0: 6361 7374 5f69 6e5f 6469 6d28 612e 7661  cast_in_dim(a.va
-0000f500: 6c75 652c 206e 6577 5f73 6861 7065 2c20  lue, new_shape, 
-0000f510: 6e65 775f 6272 6f61 6463 6173 745f 6469  new_broadcast_di
-0000f520: 6d65 6e73 696f 6e73 292c 206e 6577 5f62  mensions), new_b
-0000f530: 6469 6d29 0a0a 0a76 6d61 705f 696d 706c  dim)...vmap_impl
-0000f540: 733a 2064 6963 745b 7072 696d 732e 5379  s: dict[prims.Sy
-0000f550: 6d62 6f6c 2c20 4361 6c6c 6162 6c65 5d20  mbol, Callable] 
-0000f560: 3d20 6469 6374 2829 0a0a 0a64 6566 2075  = dict()...def u
-0000f570: 6e77 7261 705f 6f6e 655f 6c65 7665 6c5f  nwrap_one_level_
-0000f580: 6f66 5f73 7562 7379 6d62 6f6c 7328 7472  of_subsymbols(tr
-0000f590: 6163 6529 3a0a 2020 2020 6e65 775f 7379  ace):.    new_sy
-0000f5a0: 6d62 6f6c 735f 6974 6572 203d 2028 0a20  mbols_iter = (. 
-0000f5b0: 2020 2020 2020 2062 6f75 6e64 5f73 796d         bound_sym
-0000f5c0: 626f 6c2e 7375 6273 796d 626f 6c73 2069  bol.subsymbols i
-0000f5d0: 6620 6c65 6e28 626f 756e 645f 7379 6d62  f len(bound_symb
-0000f5e0: 6f6c 2e73 7562 7379 6d62 6f6c 7329 203e  ol.subsymbols) >
-0000f5f0: 2030 2065 6c73 6520 5b62 6f75 6e64 5f73   0 else [bound_s
-0000f600: 796d 626f 6c5d 0a20 2020 2020 2020 2066  ymbol].        f
-0000f610: 6f72 2062 6f75 6e64 5f73 796d 626f 6c20  or bound_symbol 
-0000f620: 696e 2074 7261 6365 2e62 6f75 6e64 5f73  in trace.bound_s
-0000f630: 796d 626f 6c73 0a20 2020 2029 0a20 2020  ymbols.    ).   
-0000f640: 206e 6577 5f73 796d 626f 6c73 203d 206c   new_symbols = l
-0000f650: 6973 7428 6368 6169 6e2e 6672 6f6d 5f69  ist(chain.from_i
-0000f660: 7465 7261 626c 6528 6e65 775f 7379 6d62  terable(new_symb
-0000f670: 6f6c 735f 6974 6572 2929 0a20 2020 2074  ols_iter)).    t
-0000f680: 7261 6365 2e62 6f75 6e64 5f73 796d 626f  race.bound_symbo
-0000f690: 6c73 203d 206e 6577 5f73 796d 626f 6c73  ls = new_symbols
-0000f6a0: 0a20 2020 2072 6574 7572 6e20 7472 6163  .    return trac
-0000f6b0: 650a 0a0a 6465 6620 6465 636f 6d70 6f73  e...def decompos
-0000f6c0: 6564 5f66 6e5f 766d 6170 5f72 756c 6528  ed_fn_vmap_rule(
-0000f6d0: 6178 6973 5f73 697a 652c 202a 6172 6773  axis_size, *args
-0000f6e0: 2c20 666e 2c20 2a2a 6b77 6172 6773 293a  , fn, **kwargs):
-0000f6f0: 0a20 2020 2061 7267 732c 2069 6e5f 6469  .    args, in_di
-0000f700: 6d73 203d 2075 6e7a 6970 3228 6172 6773  ms = unzip2(args
-0000f710: 290a 2020 2020 756e 6261 7463 6865 645f  ).    unbatched_
-0000f720: 6172 6773 203d 2074 7265 655f 6d61 7028  args = tree_map(
-0000f730: 6c61 6d62 6461 2078 3a20 7265 6d6f 7665  lambda x: remove
-0000f740: 5f62 6174 6368 5f64 696d 2878 2920 6966  _batch_dim(x) if
-0000f750: 2069 7369 6e73 7461 6e63 6528 782c 2054   isinstance(x, T
-0000f760: 656e 736f 7250 726f 7879 2920 656c 7365  ensorProxy) else
-0000f770: 2078 2c20 6172 6773 290a 2020 2020 7472   x, args).    tr
-0000f780: 6163 6520 3d20 636f 6e73 7472 7563 745f  ace = construct_
-0000f790: 7472 6163 6528 2928 666e 2c20 2a75 6e62  trace()(fn, *unb
-0000f7a0: 6174 6368 6564 5f61 7267 732c 202a 2a6b  atched_args, **k
-0000f7b0: 7761 7267 7329 0a20 2020 2074 7261 6365  wargs).    trace
-0000f7c0: 203d 2075 6e77 7261 705f 6f6e 655f 6c65   = unwrap_one_le
-0000f7d0: 7665 6c5f 6f66 5f73 7562 7379 6d62 6f6c  vel_of_subsymbol
-0000f7e0: 7328 7472 6163 6529 0a20 2020 206f 7574  s(trace).    out
-0000f7f0: 7320 3d20 5f76 6d61 705f 6361 6c6c 5f6d  s = _vmap_call_m
-0000f800: 6574 6166 756e 6328 4661 6c73 652c 2061  etafunc(False, a
-0000f810: 7267 732c 2069 6e5f 6469 6d73 2c20 302c  rgs, in_dims, 0,
-0000f820: 2061 7869 735f 7369 7a65 2c20 6675 6e63   axis_size, func
-0000f830: 7469 6f6e 5f74 7261 6365 3d74 7261 6365  tion_trace=trace
-0000f840: 2c20 2a2a 6b77 6172 6773 290a 2020 2020  , **kwargs).    
-0000f850: 6966 2069 7369 6e73 7461 6e63 6528 6f75  if isinstance(ou
-0000f860: 7473 2c20 5365 7175 656e 6365 293a 0a20  ts, Sequence):. 
-0000f870: 2020 2020 2020 206f 7574 5f64 696d 7320         out_dims 
-0000f880: 3d20 2830 2c29 202a 206c 656e 286f 7574  = (0,) * len(out
-0000f890: 7329 0a20 2020 2020 2020 2072 6574 7572  s).        retur
-0000f8a0: 6e20 7361 6665 5f6d 6170 2870 6169 725f  n safe_map(pair_
-0000f8b0: 746f 5f62 6174 6368 6564 5f76 616c 7565  to_batched_value
-0000f8c0: 2c20 7361 6665 5f7a 6970 286f 7574 732c  , safe_zip(outs,
-0000f8d0: 206f 7574 5f64 696d 7329 290a 2020 2020   out_dims)).    
-0000f8e0: 7265 7475 726e 2042 6174 6368 6564 5661  return BatchedVa
-0000f8f0: 6c75 6528 6f75 7473 2c20 3029 0a0a 0a76  lue(outs, 0)...v
-0000f900: 6d61 705f 696d 706c 735b 7072 696d 732e  map_impls[prims.
-0000f910: 5072 696d 4944 732e 5349 4e5d 203d 2073  PrimIDs.SIN] = s
-0000f920: 696e 5f76 6d61 700a 766d 6170 5f69 6d70  in_vmap.vmap_imp
-0000f930: 6c73 5b70 7269 6d73 2e50 7269 6d49 4473  ls[prims.PrimIDs
-0000f940: 2e43 4f53 5d20 3d20 636f 735f 766d 6170  .COS] = cos_vmap
-0000f950: 0a76 6d61 705f 696d 706c 735b 7072 696d  .vmap_impls[prim
-0000f960: 732e 5072 696d 4944 732e 4d55 4c5d 203d  s.PrimIDs.MUL] =
-0000f970: 206d 756c 5f76 6d61 700a 766d 6170 5f69   mul_vmap.vmap_i
-0000f980: 6d70 6c73 5b70 7269 6d73 2e50 7269 6d49  mpls[prims.PrimI
-0000f990: 4473 2e41 4444 5d20 3d20 6164 645f 766d  Ds.ADD] = add_vm
-0000f9a0: 6170 0a76 6d61 705f 696d 706c 735b 7072  ap.vmap_impls[pr
-0000f9b0: 696d 732e 5072 696d 4944 732e 5355 4d5d  ims.PrimIDs.SUM]
-0000f9c0: 203d 2073 756d 5f76 6d61 700a 766d 6170   = sum_vmap.vmap
-0000f9d0: 5f69 6d70 6c73 5b70 7269 6d73 2e50 7269  _impls[prims.Pri
-0000f9e0: 6d49 4473 2e42 524f 4144 4341 5354 5f49  mIDs.BROADCAST_I
-0000f9f0: 4e5f 4449 4d5d 203d 2062 726f 6164 6361  N_DIM] = broadca
-0000fa00: 7374 5f69 6e5f 6469 6d5f 766d 6170 0a0a  st_in_dim_vmap..
-0000fa10: 0a64 6566 2076 6d61 705f 7379 6d62 6f6c  .def vmap_symbol
-0000fa20: 5f6d 6170 7065 7228 7379 6d62 6f6c 3a20  _mapper(symbol: 
-0000fa30: 7072 696d 732e 5379 6d62 6f6c 2c20 2a2c  prims.Symbol, *,
-0000fa40: 2061 7869 735f 7369 7a65 3a20 696e 7429   axis_size: int)
-0000fa50: 3a0a 2020 2020 2222 224d 6170 7320 6120  :.    """Maps a 
-0000fa60: 7379 6d62 6f6c 2074 6f20 6120 766d 6170  symbol to a vmap
-0000fa70: 2066 756e 6374 696f 6e20 7468 6174 2065   function that e
-0000fa80: 7661 6c75 6174 6573 2069 742e 0a0a 2020  valuates it...  
-0000fa90: 2020 4172 6773 3a0a 2020 2020 2020 2020    Args:.        
-0000faa0: 7379 6d62 6f6c 2028 7072 696d 732e 5379  symbol (prims.Sy
-0000fab0: 6d62 6f6c 293a 2053 796d 626f 6c20 746f  mbol): Symbol to
-0000fac0: 2065 7661 6c75 6174 652e 0a0a 2020 2020   evaluate...    
-0000fad0: 5261 6973 6573 3a0a 2020 2020 2020 2020  Raises:.        
-0000fae0: 4e6f 7449 6d70 6c65 6d65 6e74 6564 4572  NotImplementedEr
-0000faf0: 726f 723a 2049 6620 7468 6520 766d 6170  ror: If the vmap
-0000fb00: 2066 6f72 2074 6865 2073 796d 626f 6c20   for the symbol 
-0000fb10: 6973 206e 6f74 2069 6d70 6c65 6d65 6e74  is not implement
-0000fb20: 6564 2e0a 0a20 2020 2052 6574 7572 6e73  ed...    Returns
-0000fb30: 3a0a 2020 2020 2020 2020 4361 6c6c 6162  :.        Callab
-0000fb40: 6c65 3a20 766d 6170 2066 756e 6374 696f  le: vmap functio
-0000fb50: 6e20 7468 6174 2065 7661 6c75 6174 6573  n that evaluates
-0000fb60: 2074 6865 2073 796d 626f 6c2e 0a20 2020   the symbol..   
-0000fb70: 2022 2222 0a0a 2020 2020 6465 6620 7772   """..    def wr
-0000fb80: 6170 5f61 7267 2878 293a 0a20 2020 2020  ap_arg(x):.     
-0000fb90: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
-0000fba0: 2878 2c20 4261 7463 6865 6456 616c 7565  (x, BatchedValue
-0000fbb0: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
-0000fbc0: 6574 7572 6e20 780a 2020 2020 2020 2020  eturn x.        
-0000fbd0: 656c 6966 2069 7369 6e73 7461 6e63 6528  elif isinstance(
-0000fbe0: 782c 204e 756d 6265 7229 3a0a 2020 2020  x, Number):.    
-0000fbf0: 2020 2020 2020 2020 7265 7475 726e 2042          return B
-0000fc00: 6174 6368 6564 5661 6c75 6528 782c 206e  atchedValue(x, n
-0000fc10: 6f74 5f6d 6170 7065 6429 0a20 2020 2020  ot_mapped).     
-0000fc20: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-0000fc30: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
-0000fc40: 4572 726f 7228 6622 766d 6170 2077 7261  Error(f"vmap wra
-0000fc50: 705f 6172 6720 676f 7420 616e 2075 6e73  p_arg got an uns
-0000fc60: 7570 706f 7274 6564 2074 7970 6520 7b74  upported type {t
-0000fc70: 7970 6528 7829 7d22 290a 0a20 2020 2069  ype(x)}")..    i
-0000fc80: 6620 7379 6d62 6f6c 2e61 7265 5f61 6c6c  f symbol.are_all
-0000fc90: 5f61 7267 735f 636f 6e73 7461 6e74 3a0a  _args_constant:.
-0000fca0: 0a20 2020 2020 2020 2064 6566 205f 766d  .        def _vm
-0000fcb0: 6170 5f69 6d70 6c5f 636f 6e73 7428 7379  ap_impl_const(sy
-0000fcc0: 6d62 6f6c 2c20 2a61 7267 732c 202a 2a6b  mbol, *args, **k
-0000fcd0: 7761 7267 7329 3a0a 2020 2020 2020 2020  wargs):.        
-0000fce0: 2020 2020 6f75 7420 3d20 7379 6d62 6f6c      out = symbol
-0000fcf0: 5f74 6f5f 6576 616c 2873 796d 626f 6c29  _to_eval(symbol)
-0000fd00: 282a 6172 6773 2c20 2a2a 6b77 6172 6773  (*args, **kwargs
-0000fd10: 290a 0a20 2020 2020 2020 2020 2020 2069  )..            i
-0000fd20: 6620 6973 696e 7374 616e 6365 286f 7574  f isinstance(out
-0000fd30: 2c20 5365 7175 656e 6365 293a 0a20 2020  , Sequence):.   
-0000fd40: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-0000fd50: 7572 6e20 7361 6665 5f6d 6170 2870 6169  urn safe_map(pai
-0000fd60: 725f 746f 5f62 6174 6368 6564 5f76 616c  r_to_batched_val
-0000fd70: 7565 2c20 7361 6665 5f7a 6970 2861 7267  ue, safe_zip(arg
-0000fd80: 732c 205b 6e6f 745f 6d61 7070 6564 5d20  s, [not_mapped] 
-0000fd90: 2a20 6c65 6e28 6f75 7429 2929 0a0a 2020  * len(out)))..  
-0000fda0: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0000fdb0: 2042 6174 6368 6564 5661 6c75 6528 6f75   BatchedValue(ou
-0000fdc0: 742c 206e 6f74 5f6d 6170 7065 6429 0a0a  t, not_mapped)..
-0000fdd0: 2020 2020 2020 2020 7265 7475 726e 2070          return p
-0000fde0: 6172 7469 616c 285f 766d 6170 5f69 6d70  artial(_vmap_imp
-0000fdf0: 6c5f 636f 6e73 742c 2073 796d 626f 6c29  l_const, symbol)
-0000fe00: 0a0a 2020 2020 766d 6170 5f69 6d70 6c20  ..    vmap_impl 
-0000fe10: 3d20 766d 6170 5f69 6d70 6c73 2e67 6574  = vmap_impls.get
-0000fe20: 2873 796d 626f 6c2e 7379 6d2e 6964 290a  (symbol.sym.id).
-0000fe30: 2020 2020 6966 2076 6d61 705f 696d 706c      if vmap_impl
-0000fe40: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
-0000fe50: 2020 6966 206c 656e 2873 796d 626f 6c2e    if len(symbol.
-0000fe60: 7375 6273 796d 626f 6c73 2920 3e20 303a  subsymbols) > 0:
-0000fe70: 0a20 2020 2020 2020 2020 2020 2076 6d61  .            vma
-0000fe80: 705f 696d 706c 203d 2070 6172 7469 616c  p_impl = partial
-0000fe90: 2864 6563 6f6d 706f 7365 645f 666e 5f76  (decomposed_fn_v
-0000fea0: 6d61 705f 7275 6c65 2c20 666e 3d73 796d  map_rule, fn=sym
-0000feb0: 626f 6c2e 7379 6d29 0a20 2020 2020 2020  bol.sym).       
-0000fec0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-0000fed0: 2020 2072 6169 7365 204e 6f74 496d 706c     raise NotImpl
-0000fee0: 656d 656e 7465 6445 7272 6f72 2866 2276  ementedError(f"v
-0000fef0: 6d61 7020 666f 7220 7b73 796d 626f 6c2e  map for {symbol.
-0000ff00: 7379 6d2e 6964 7d20 6973 206e 6f74 2069  sym.id} is not i
-0000ff10: 6d70 6c65 6d65 6e74 6564 2229 0a0a 2020  mplemented")..  
-0000ff20: 2020 6465 6620 5f76 6d61 705f 696d 706c    def _vmap_impl
-0000ff30: 282a 6172 6773 2c20 2a2a 6b77 6172 6773  (*args, **kwargs
-0000ff40: 293a 0a20 2020 2020 2020 2061 7267 7320  ):.        args 
-0000ff50: 3d20 7472 6565 5f6d 6170 2877 7261 705f  = tree_map(wrap_
-0000ff60: 6172 672c 2061 7267 7329 0a20 2020 2020  arg, args).     
-0000ff70: 2020 2061 7373 6572 7420 616c 6c28 6973     assert all(is
-0000ff80: 696e 7374 616e 6365 2861 7267 2c20 4261  instance(arg, Ba
-0000ff90: 7463 6865 6456 616c 7565 2920 666f 7220  tchedValue) for 
-0000ffa0: 6172 6720 696e 2074 7265 655f 666c 6174  arg in tree_flat
-0000ffb0: 7465 6e28 6172 6773 295b 305d 290a 2020  ten(args)[0]).  
-0000ffc0: 2020 2020 2020 7265 7475 726e 2076 6d61        return vma
-0000ffd0: 705f 696d 706c 2861 7869 735f 7369 7a65  p_impl(axis_size
-0000ffe0: 2c20 2a61 7267 732c 202a 2a6b 7761 7267  , *args, **kwarg
-0000fff0: 7329 0a0a 2020 2020 7265 7475 726e 205f  s)..    return _
-00010000: 766d 6170 5f69 6d70 6c0a 0a0a 6465 6620  vmap_impl...def 
-00010010: 7265 6d6f 7665 5f62 6174 6368 5f64 696d  remove_batch_dim
-00010020: 2874 656e 736f 723a 2054 656e 736f 7250  (tensor: TensorP
-00010030: 726f 7879 2c20 6261 7463 685f 6469 6d3a  roxy, batch_dim:
-00010040: 2069 6e74 203d 2030 2920 2d3e 2054 656e   int = 0) -> Ten
-00010050: 736f 7250 726f 7879 3a0a 2020 2020 2222  sorProxy:.    ""
-00010060: 2252 656d 6f76 6573 2074 6865 2062 6174  "Removes the bat
-00010070: 6368 2064 696d 656e 7369 6f6e 2066 726f  ch dimension fro
-00010080: 6d20 6120 7465 6e73 6f72 2e0a 0a20 2020  m a tensor...   
-00010090: 2041 7267 733a 0a20 2020 2020 2020 2074   Args:.        t
-000100a0: 656e 736f 7220 2854 656e 736f 7250 726f  ensor (TensorPro
-000100b0: 7879 293a 2054 656e 736f 7220 746f 2072  xy): Tensor to r
-000100c0: 656d 6f76 6520 7468 6520 6261 7463 6820  emove the batch 
-000100d0: 6469 6d65 6e73 696f 6e20 6672 6f6d 2e0a  dimension from..
-000100e0: 0a20 2020 2052 6574 7572 6e73 3a0a 2020  .    Returns:.  
-000100f0: 2020 2020 2020 5465 6e73 6f72 5072 6f78        TensorProx
-00010100: 793a 2054 656e 736f 7220 7769 7468 2074  y: Tensor with t
-00010110: 6865 2062 6174 6368 2064 696d 656e 7369  he batch dimensi
-00010120: 6f6e 2072 656d 6f76 6564 2e0a 2020 2020  on removed..    
-00010130: 2222 220a 2020 2020 6e65 775f 7368 6170  """.    new_shap
-00010140: 6520 3d20 7465 6e73 6f72 2e73 6861 7065  e = tensor.shape
-00010150: 5b3a 6261 7463 685f 6469 6d5d 202b 2074  [:batch_dim] + t
-00010160: 656e 736f 722e 7368 6170 655b 6261 7463  ensor.shape[batc
-00010170: 685f 6469 6d20 2b20 3120 3a5d 0a20 2020  h_dim + 1 :].   
-00010180: 2072 6574 7572 6e20 5465 6e73 6f72 5072   return TensorPr
-00010190: 6f78 7928 6c69 6b65 3d74 656e 736f 722c  oxy(like=tensor,
-000101a0: 2073 6861 7065 3d6e 6577 5f73 6861 7065   shape=new_shape
-000101b0: 290a 0a0a 2320 544f 444f 3a20 696e 204a  )...# TODO: in J
-000101c0: 4158 2061 7267 732c 2069 6e5f 6469 6d73  AX args, in_dims
-000101d0: 2061 7265 2066 6c61 7474 656e 6564 2074   are flattened t
-000101e0: 6865 2073 616d 6520 7761 790a 2320 544f  he same way.# TO
-000101f0: 444f 3a20 696e 204a 4158 206f 7574 5f64  DO: in JAX out_d
-00010200: 696d 7320 6172 6520 666c 6174 7465 6e65  ims are flattene
-00010210: 6420 6173 2077 656c 6c0a 6465 6620 5f76  d as well.def _v
-00010220: 6d61 705f 6361 6c6c 5f6d 6574 6166 756e  map_call_metafun
-00010230: 6328 6465 7461 6368 6564 3a20 626f 6f6c  c(detached: bool
-00010240: 2c20 6172 6773 2c20 696e 5f64 696d 732c  , args, in_dims,
-00010250: 206f 7574 5f64 696d 732c 2061 7869 735f   out_dims, axis_
-00010260: 7369 7a65 2c20 6675 6e63 7469 6f6e 5f74  size, function_t
-00010270: 7261 6365 3a20 5472 6163 652c 202a 2a6b  race: Trace, **k
-00010280: 7761 7267 7329 3a0a 2020 2020 2222 224d  wargs):.    """M
-00010290: 6574 6166 756e 6374 696f 6e20 666f 7220  etafunction for 
-000102a0: 766d 6170 2063 616c 6c2e 0a0a 2020 2020  vmap call...    
-000102b0: 4172 6773 3a0a 2020 2020 2020 2020 6465  Args:.        de
-000102c0: 7461 6368 6564 2028 626f 6f6c 293a 2057  tached (bool): W
-000102d0: 6865 7468 6572 2074 6f20 6465 7461 6368  hether to detach
-000102e0: 2074 6865 2074 7261 6365 2e0a 2020 2020   the trace..    
-000102f0: 2020 2020 6172 6773 2028 5475 706c 655b      args (Tuple[
-00010300: 5072 6f78 795d 293a 2041 7267 756d 656e  Proxy]): Argumen
-00010310: 7473 2074 6f20 7468 6520 6675 6e63 7469  ts to the functi
-00010320: 6f6e 2e0a 2020 2020 2020 2020 696e 5f64  on..        in_d
-00010330: 696d 7320 2854 7570 6c65 5b69 6e74 5d29  ims (Tuple[int])
-00010340: 3a20 4261 7463 6820 6469 6d65 6e73 696f  : Batch dimensio
-00010350: 6e20 666f 7220 6561 6368 2061 7267 756d  n for each argum
-00010360: 656e 742e 0a20 2020 2020 2020 206f 7574  ent..        out
-00010370: 5f64 696d 7320 2854 7570 6c65 5b69 6e74  _dims (Tuple[int
-00010380: 5d29 3a20 4261 7463 6820 6469 6d65 6e73  ]): Batch dimens
-00010390: 696f 6e20 666f 7220 7265 7475 726e 2076  ion for return v
-000103a0: 616c 7565 732e 0a20 2020 2020 2020 2066  alues..        f
-000103b0: 756e 6374 696f 6e5f 7472 6163 6520 2854  unction_trace (T
-000103c0: 7261 6365 293a 2054 7261 6365 2074 6f20  race): Trace to 
-000103d0: 7573 6520 666f 7220 7468 6520 6675 6e63  use for the func
-000103e0: 7469 6f6e 2e0a 2020 2020 2020 2020 6b77  tion..        kw
-000103f0: 6172 6773 3a20 4b65 7977 6f72 6420 6172  args: Keyword ar
-00010400: 6775 6d65 6e74 732e 0a0a 2020 2020 5261  guments...    Ra
-00010410: 6973 6573 3a0a 2020 2020 2020 2020 4173  ises:.        As
-00010420: 7365 7274 696f 6e45 7272 6f72 3a20 4966  sertionError: If
-00010430: 2074 6865 2076 6d61 7020 666f 7220 6b65   the vmap for ke
-00010440: 7977 6f72 6420 6172 6775 6d65 6e74 7320  yword arguments 
-00010450: 6973 206e 6f74 2069 6d70 6c65 6d65 6e74  is not implement
-00010460: 6564 2e0a 0a20 2020 2052 6574 7572 6e73  ed...    Returns
-00010470: 3a0a 2020 2020 2020 2020 5265 7375 6c74  :.        Result
-00010480: 206f 6620 7468 6520 766d 6170 2074 7261   of the vmap tra
-00010490: 6e73 666f 726d 2e0a 2020 2020 2222 220a  nsform..    """.
-000104a0: 2020 2020 636f 6d6d 6f6e 5f64 6576 6963      common_devic
-000104b0: 6520 3d20 7b78 2e64 6576 6963 6520 666f  e = {x.device fo
-000104c0: 7220 7820 696e 2061 7267 7320 6966 2069  r x in args if i
-000104d0: 7369 6e73 7461 6e63 6528 782c 2054 656e  sinstance(x, Ten
-000104e0: 736f 7250 726f 7879 297d 0a20 2020 2061  sorProxy)}.    a
-000104f0: 7373 6572 7420 6c65 6e28 636f 6d6d 6f6e  ssert len(common
-00010500: 5f64 6576 6963 6529 203c 3d20 312c 2022  _device) <= 1, "
-00010510: 766d 6170 2066 6f72 206d 756c 7469 706c  vmap for multipl
-00010520: 6520 6465 7669 6365 7320 6973 206e 6f74  e devices is not
-00010530: 2069 6d70 6c65 6d65 6e74 6564 220a 2020   implemented".  
-00010540: 2020 2863 6f6d 6d6f 6e5f 6465 7669 6365    (common_device
-00010550: 2c29 203d 2063 6f6d 6d6f 6e5f 6465 7669  ,) = common_devi
-00010560: 6365 2069 6620 6c65 6e28 636f 6d6d 6f6e  ce if len(common
-00010570: 5f64 6576 6963 6529 203d 3d20 3120 656c  _device) == 1 el
-00010580: 7365 2028 6370 752c 290a 0a20 2020 2069  se (cpu,)..    i
-00010590: 6620 6178 6973 5f73 697a 6520 6973 204e  f axis_size is N
-000105a0: 6f6e 653a 0a20 2020 2020 2020 2028 6178  one:.        (ax
-000105b0: 6973 5f73 697a 652c 2920 3d20 7b78 2e73  is_size,) = {x.s
-000105c0: 6861 7065 5b61 785d 2066 6f72 2078 2c20  hape[ax] for x, 
-000105d0: 6178 2069 6e20 7a69 7028 6172 6773 2c20  ax in zip(args, 
-000105e0: 696e 5f64 696d 7329 2069 6620 6178 2069  in_dims) if ax i
-000105f0: 7320 6e6f 7420 6e6f 745f 6d61 7070 6564  s not not_mapped
-00010600: 7d0a 2020 2020 696e 5f64 696d 7320 3d20  }.    in_dims = 
-00010610: 696e 5f64 696d 7320 6966 2069 7369 6e73  in_dims if isins
-00010620: 7461 6e63 6528 696e 5f64 696d 732c 2053  tance(in_dims, S
-00010630: 6571 7565 6e63 6529 2065 6c73 6520 2869  equence) else (i
-00010640: 6e5f 6469 6d73 2c29 0a20 2020 2069 6e5f  n_dims,).    in_
-00010650: 6469 6d73 203d 2074 7570 6c65 286e 6f74  dims = tuple(not
-00010660: 5f6d 6170 7065 6420 6966 2069 7369 6e73  _mapped if isins
-00010670: 7461 6e63 6528 612c 204e 756d 6265 7229  tance(a, Number)
-00010680: 2065 6c73 6520 6420 666f 7220 612c 2064   else d for a, d
-00010690: 2069 6e20 7361 6665 5f7a 6970 2861 7267   in safe_zip(arg
-000106a0: 732c 2069 6e5f 6469 6d73 2929 0a20 2020  s, in_dims)).   
-000106b0: 206f 7574 5f64 696d 7320 3d20 6f75 745f   out_dims = out_
-000106c0: 6469 6d73 2069 6620 6973 696e 7374 616e  dims if isinstan
-000106d0: 6365 286f 7574 5f64 696d 732c 2053 6571  ce(out_dims, Seq
-000106e0: 7565 6e63 6529 2065 6c73 6520 286f 7574  uence) else (out
-000106f0: 5f64 696d 732c 290a 0a20 2020 2063 7478  _dims,)..    ctx
-00010700: 203d 2064 6574 6163 6865 645f 7472 6163   = detached_trac
-00010710: 6528 2920 6966 2064 6574 6163 6865 6420  e() if detached 
-00010720: 656c 7365 206e 756c 6c63 6f6e 7465 7874  else nullcontext
-00010730: 2829 0a20 2020 2077 6974 6820 6374 783a  ().    with ctx:
-00010740: 0a20 2020 2020 2020 2023 2057 6520 7072  .        # We pr
-00010750: 6f70 6167 6174 6520 7468 6520 4261 7463  opagate the Batc
-00010760: 6856 616c 7565 2074 6872 6f75 6768 2074  hValue through t
-00010770: 6865 2074 7261 6365 2c20 616e 6420 7468  he trace, and th
-00010780: 656e 2075 6e77 7261 7020 6974 2061 7420  en unwrap it at 
-00010790: 7468 6520 656e 640a 2020 2020 2020 2020  the end.        
-000107a0: 6261 7463 6865 645f 6172 6773 203d 2073  batched_args = s
-000107b0: 6166 655f 6d61 7028 7061 6972 5f74 6f5f  afe_map(pair_to_
-000107c0: 6261 7463 6865 645f 7661 6c75 652c 2073  batched_value, s
-000107d0: 6166 655f 7a69 7028 6172 6773 2c20 696e  afe_zip(args, in
-000107e0: 5f64 696d 7329 290a 2020 2020 2020 2020  _dims)).        
-000107f0: 7265 7375 6c74 203d 2065 7661 6c5f 7472  result = eval_tr
-00010800: 6163 6528 0a20 2020 2020 2020 2020 2020  ace(.           
-00010810: 2066 756e 6374 696f 6e5f 7472 6163 652c   function_trace,
-00010820: 202a 6261 7463 6865 645f 6172 6773 2c20   *batched_args, 
-00010830: 7379 6d62 6f6c 5f6d 6170 7065 723d 7061  symbol_mapper=pa
-00010840: 7274 6961 6c28 766d 6170 5f73 796d 626f  rtial(vmap_symbo
-00010850: 6c5f 6d61 7070 6572 2c20 6178 6973 5f73  l_mapper, axis_s
-00010860: 697a 653d 6178 6973 5f73 697a 6529 2c20  ize=axis_size), 
-00010870: 2a2a 6b77 6172 6773 0a20 2020 2020 2020  **kwargs.       
-00010880: 2029 0a20 2020 2020 2020 2023 2055 6e77   ).        # Unw
-00010890: 7261 7070 696e 6720 7468 6520 4261 7463  rapping the Batc
-000108a0: 6865 6456 616c 7565 2773 0a20 2020 2020  hedValue's.     
-000108b0: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
-000108c0: 2872 6573 756c 742c 2053 6571 7565 6e63  (result, Sequenc
-000108d0: 6529 3a0a 2020 2020 2020 2020 2020 2020  e):.            
-000108e0: 666c 6174 5f72 6573 756c 742c 2073 7065  flat_result, spe
-000108f0: 6320 3d20 7472 6565 5f66 6c61 7474 656e  c = tree_flatten
-00010900: 2872 6573 756c 7429 0a20 2020 2020 2020  (result).       
-00010910: 2020 2020 2061 7373 6572 7420 616c 6c28       assert all(
-00010920: 6973 696e 7374 616e 6365 2878 2c20 4261  isinstance(x, Ba
-00010930: 7463 6865 6456 616c 7565 2920 666f 7220  tchedValue) for 
-00010940: 7820 696e 2066 6c61 745f 7265 7375 6c74  x in flat_result
-00010950: 290a 2020 2020 2020 2020 2020 2020 6f75  ).            ou
-00010960: 7473 2c20 6264 696d 7320 3d20 756e 7a69  ts, bdims = unzi
-00010970: 7032 2866 6c61 745f 7265 7375 6c74 290a  p2(flat_result).
-00010980: 2020 2020 2020 2020 2020 2020 2320 544f              # TO
-00010990: 444f 3a20 6861 6e64 6c65 2074 6865 2063  DO: handle the c
-000109a0: 6173 6520 7768 6572 6520 6f75 745f 6469  ase where out_di
-000109b0: 6d73 2069 7320 6120 7369 6e67 6c65 2076  ms is a single v
-000109c0: 616c 7565 2062 6574 7465 720a 2020 2020  alue better.    
-000109d0: 2020 2020 2020 2020 6966 206c 656e 286f          if len(o
-000109e0: 7574 5f64 696d 7329 203d 3d20 313a 0a20  ut_dims) == 1:. 
-000109f0: 2020 2020 2020 2020 2020 2020 2020 206f                 o
-00010a00: 7574 5f64 696d 7320 3d20 6f75 745f 6469  ut_dims = out_di
-00010a10: 6d73 202a 206c 656e 286f 7574 7329 0a20  ms * len(outs). 
-00010a20: 2020 2020 2020 2020 2020 206f 7574 7320             outs 
-00010a30: 3d20 7361 6665 5f6d 6170 2870 6172 7469  = safe_map(parti
-00010a40: 616c 286d 6f76 655f 6261 7463 685f 6469  al(move_batch_di
-00010a50: 6d2c 2061 7869 735f 7369 7a65 292c 2062  m, axis_size), b
-00010a60: 6469 6d73 2c20 6f75 745f 6469 6d73 2c20  dims, out_dims, 
-00010a70: 6f75 7473 290a 2020 2020 2020 2020 2020  outs).          
-00010a80: 2020 7265 7475 726e 2074 7265 655f 756e    return tree_un
-00010a90: 666c 6174 7465 6e28 6f75 7473 2c20 7370  flatten(outs, sp
-00010aa0: 6563 290a 2020 2020 2020 2020 6966 2069  ec).        if i
-00010ab0: 7369 6e73 7461 6e63 6528 7265 7375 6c74  sinstance(result
-00010ac0: 2c20 4e75 6d62 6572 2920 616e 6420 6178  , Number) and ax
-00010ad0: 6973 5f73 697a 6520 6973 206e 6f74 204e  is_size is not N
-00010ae0: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
-00010af0: 2023 2054 4f44 4f3a 2066 6574 6368 2074   # TODO: fetch t
-00010b00: 6865 2064 6566 6175 6c74 2064 6576 6963  he default devic
-00010b10: 6520 6672 6f6d 2074 6865 2063 6f6e 7465  e from the conte
-00010b20: 7874 0a20 2020 2020 2020 2020 2020 2072  xt.            r
-00010b30: 6573 756c 7420 3d20 6675 6c6c 2873 6861  esult = full(sha
-00010b40: 7065 3d28 292c 2066 696c 6c5f 7661 6c75  pe=(), fill_valu
-00010b50: 653d 7265 7375 6c74 2c20 6465 7669 6365  e=result, device
-00010b60: 3d63 6f6d 6d6f 6e5f 6465 7669 6365 290a  =common_device).
-00010b70: 2020 2020 2020 2020 2020 2020 7265 7375              resu
-00010b80: 6c74 203d 2042 6174 6368 6564 5661 6c75  lt = BatchedValu
-00010b90: 6528 7265 7375 6c74 2c20 6e6f 745f 6d61  e(result, not_ma
-00010ba0: 7070 6564 290a 2020 2020 2020 2020 656c  pped).        el
-00010bb0: 6966 2069 7369 6e73 7461 6e63 6528 7265  if isinstance(re
-00010bc0: 7375 6c74 2c20 4261 7463 6865 6456 616c  sult, BatchedVal
-00010bd0: 7565 2920 616e 6420 6973 696e 7374 616e  ue) and isinstan
-00010be0: 6365 2872 6573 756c 742e 7661 6c75 652c  ce(result.value,
-00010bf0: 204e 756d 6265 7229 2061 6e64 2061 7869   Number) and axi
-00010c00: 735f 7369 7a65 2069 7320 6e6f 7420 4e6f  s_size is not No
-00010c10: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
-00010c20: 7265 7375 6c74 203d 2042 6174 6368 6564  result = Batched
-00010c30: 5661 6c75 6528 6675 6c6c 2873 6861 7065  Value(full(shape
-00010c40: 3d28 292c 2066 696c 6c5f 7661 6c75 653d  =(), fill_value=
-00010c50: 7265 7375 6c74 2e76 616c 7565 2c20 6465  result.value, de
-00010c60: 7669 6365 3d63 6f6d 6d6f 6e5f 6465 7669  vice=common_devi
-00010c70: 6365 292c 2072 6573 756c 742e 6261 7463  ce), result.batc
-00010c80: 685f 6469 6d29 0a20 2020 2020 2020 2061  h_dim).        a
-00010c90: 7373 6572 7420 6973 696e 7374 616e 6365  ssert isinstance
-00010ca0: 2872 6573 756c 742c 2042 6174 6368 6564  (result, Batched
-00010cb0: 5661 6c75 6529 0a20 2020 2020 2020 206f  Value).        o
-00010cc0: 7574 203d 206d 6f76 655f 6261 7463 685f  ut = move_batch_
-00010cd0: 6469 6d28 6178 6973 5f73 697a 652c 2072  dim(axis_size, r
-00010ce0: 6573 756c 742e 6261 7463 685f 6469 6d2c  esult.batch_dim,
-00010cf0: 206f 7574 5f64 696d 735b 305d 2c20 7265   out_dims[0], re
-00010d00: 7375 6c74 2e76 616c 7565 290a 2020 2020  sult.value).    
-00010d10: 2020 2020 7265 7475 726e 206f 7574 0a0a      return out..
-00010d20: 0a76 6d61 705f 6361 6c6c 203d 2053 796d  .vmap_call = Sym
-00010d30: 626f 6c28 6964 3d54 7261 6e73 666f 726d  bol(id=Transform
-00010d40: 732e 566d 6170 4f70 2c20 6e61 6d65 3d22  s.VmapOp, name="
-00010d50: 766d 6170 5f63 616c 6c22 2c20 6d65 7461  vmap_call", meta
-00010d60: 3d70 6172 7469 616c 285f 766d 6170 5f63  =partial(_vmap_c
-00010d70: 616c 6c5f 6d65 7461 6675 6e63 2c20 4661  all_metafunc, Fa
-00010d80: 6c73 6529 290a 0a0a 2320 544f 444f 3a20  lse))...# TODO: 
-00010d90: 686f 7720 7368 6f75 6c64 2077 6520 6861  how should we ha
-00010da0: 6e64 6c65 206f 7574 5f64 696d 7320 6865  ndle out_dims he
-00010db0: 7265 3f0a 2320 616c 7468 6f75 6768 2068  re?.# although h
-00010dc0: 6572 6520 7765 2061 7265 2063 616c 6c69  ere we are calli
-00010dd0: 6e67 2076 6d61 7020 6f66 2069 6465 6e74  ng vmap of ident
-00010de0: 6974 792c 2073 6f20 7765 2073 686f 756c  ity, so we shoul
-00010df0: 6420 6b6e 6f77 2066 726f 6d20 7468 6520  d know from the 
-00010e00: 6361 6c6c 2074 6f20 766d 6170 0a23 2054  call to vmap.# T
-00010e10: 6869 7320 7368 6f75 6c64 2062 6520 6669  his should be fi
-00010e20: 6e65 2e20 4966 2077 6520 6861 7665 2076  ne. If we have v
-00010e30: 6d61 7028 6964 656e 7469 7479 2866 756e  map(identity(fun
-00010e40: 6329 2c20 6f75 745f 6469 6d73 3d4e 2920  c), out_dims=N) 
-00010e50: 7468 656e 2074 6869 7320 7275 6c65 2069  then this rule i
-00010e60: 7320 6669 7273 7420 7573 6564 0a23 2074  s first used.# t
-00010e70: 6f20 6765 7420 7468 6520 766d 6170 7065  o get the vmappe
-00010e80: 6420 7265 7375 6c74 206f 6620 6964 656e  d result of iden
-00010e90: 7469 7479 2866 756e 6329 2069 6e20 766d  tity(func) in vm
-00010ea0: 6170 5f73 796d 626f 6c5f 6d61 7070 6572  ap_symbol_mapper
-00010eb0: 2c20 616e 6420 6f75 745f 6469 6d73 2069  , and out_dims i
-00010ec0: 7320 6861 6e64 6c65 640a 2320 6166 7465  s handled.# afte
-00010ed0: 7220 7468 6174 2069 6e20 7468 6520 6f75  r that in the ou
-00010ee0: 7465 7220 5f76 6d61 705f 6361 6c6c 5f6d  ter _vmap_call_m
-00010ef0: 6574 6166 756e 632e 0a64 6566 205f 6964  etafunc..def _id
-00010f00: 656e 7469 7479 5f63 616c 6c5f 766d 6170  entity_call_vmap
-00010f10: 2861 7869 735f 7369 7a65 2c20 2a62 6174  (axis_size, *bat
-00010f20: 6368 6564 5f61 7267 732c 2074 7261 6365  ched_args, trace
-00010f30: 3a20 5472 6163 652c 202a 2a6b 7761 7267  : Trace, **kwarg
-00010f40: 7329 3a0a 2020 2020 6172 6773 2c20 696e  s):.    args, in
-00010f50: 5f64 696d 7320 3d20 756e 7a69 7032 2862  _dims = unzip2(b
-00010f60: 6174 6368 6564 5f61 7267 7329 0a20 2020  atched_args).   
-00010f70: 206f 7574 5f64 696d 7320 3d20 3020 2023   out_dims = 0  #
-00010f80: 2046 6978 6d65 0a20 2020 206f 7574 732c   Fixme.    outs,
-00010f90: 206f 7574 5f64 696d 7320 3d20 5f76 6d61   out_dims = _vma
-00010fa0: 705f 6361 6c6c 5f6d 6574 6166 756e 6328  p_call_metafunc(
-00010fb0: 4661 6c73 652c 2061 7267 732c 2069 6e5f  False, args, in_
-00010fc0: 6469 6d73 2c20 6f75 745f 6469 6d73 2c20  dims, out_dims, 
-00010fd0: 6178 6973 5f73 697a 652c 2066 756e 6374  axis_size, funct
-00010fe0: 696f 6e5f 7472 6163 653d 7472 6163 652c  ion_trace=trace,
-00010ff0: 202a 2a6b 7761 7267 7329 0a20 2020 2069   **kwargs).    i
-00011000: 6620 6973 696e 7374 616e 6365 286f 7574  f isinstance(out
-00011010: 732c 2053 6571 7565 6e63 6529 3a0a 2020  s, Sequence):.  
-00011020: 2020 2020 2020 7265 7475 726e 2073 6166        return saf
-00011030: 655f 6d61 7028 7061 6972 5f74 6f5f 6261  e_map(pair_to_ba
-00011040: 7463 6865 645f 7661 6c75 652c 2073 6166  tched_value, saf
-00011050: 655f 7a69 7028 6f75 7473 2c20 6f75 745f  e_zip(outs, out_
-00011060: 6469 6d73 2929 0a20 2020 2072 6574 7572  dims)).    retur
-00011070: 6e20 4261 7463 6865 6456 616c 7565 286f  n BatchedValue(o
-00011080: 7574 732c 206f 7574 5f64 696d 7329 0a0a  uts, out_dims)..
-00011090: 0a76 6d61 705f 696d 706c 735b 5472 616e  .vmap_impls[Tran
-000110a0: 7366 6f72 6d73 2e49 6465 6e74 6974 794f  sforms.IdentityO
-000110b0: 705d 203d 205f 6964 656e 7469 7479 5f63  p] = _identity_c
-000110c0: 616c 6c5f 766d 6170 0a0a 0a64 6566 205f  all_vmap...def _
-000110d0: 6a76 705f 6361 6c6c 5f76 6d61 7028 6178  jvp_call_vmap(ax
-000110e0: 6973 5f73 697a 652c 2062 6174 6368 6564  is_size, batched
-000110f0: 5f70 7269 6d61 6c73 2c20 6261 7463 6865  _primals, batche
-00011100: 645f 7461 6e67 656e 7473 2c20 2a2c 2066  d_tangents, *, f
-00011110: 756e 6374 696f 6e5f 7472 6163 653a 2054  unction_trace: T
-00011120: 7261 6365 2c20 2a2a 6b77 6172 6773 293a  race, **kwargs):
-00011130: 0a20 2020 2070 7269 6d61 6c73 2c20 7072  .    primals, pr
-00011140: 696d 616c 735f 6264 696d 7320 3d20 7361  imals_bdims = sa
-00011150: 6665 5f7a 6970 282a 6261 7463 6865 645f  fe_zip(*batched_
-00011160: 7072 696d 616c 7329 0a20 2020 2074 616e  primals).    tan
-00011170: 6765 6e74 732c 2074 616e 6765 6e74 735f  gents, tangents_
-00011180: 6264 696d 7320 3d20 7361 6665 5f7a 6970  bdims = safe_zip
-00011190: 282a 6261 7463 6865 645f 7461 6e67 656e  (*batched_tangen
-000111a0: 7473 290a 2020 2020 6a76 705f 6675 6e63  ts).    jvp_func
-000111b0: 203d 2070 6172 7469 616c 285f 6a76 705f   = partial(_jvp_
-000111c0: 6361 6c6c 5f6d 6574 6166 756e 632c 2046  call_metafunc, F
-000111d0: 616c 7365 2c20 6675 6e63 7469 6f6e 5f74  alse, function_t
-000111e0: 7261 6365 3d66 756e 6374 696f 6e5f 7472  race=function_tr
-000111f0: 6163 6529 0a20 2020 2076 6d61 7070 6564  ace).    vmapped
-00011200: 5f6a 7670 5f66 756e 6320 3d20 766d 6170  _jvp_func = vmap
-00011210: 286a 7670 5f66 756e 632c 2069 6e5f 6469  (jvp_func, in_di
-00011220: 6d73 3d28 7072 696d 616c 735f 6264 696d  ms=(primals_bdim
-00011230: 732c 2074 616e 6765 6e74 735f 6264 696d  s, tangents_bdim
-00011240: 7329 2c20 6178 6973 5f73 697a 653d 6178  s), axis_size=ax
-00011250: 6973 5f73 697a 6529 0a20 2020 2072 6573  is_size).    res
-00011260: 756c 7420 3d20 766d 6170 7065 645f 6a76  ult = vmapped_jv
-00011270: 705f 6675 6e63 2870 7269 6d61 6c73 2c20  p_func(primals, 
-00011280: 7461 6e67 656e 7473 2c20 2a2a 6b77 6172  tangents, **kwar
-00011290: 6773 290a 2020 2020 7265 7475 726e 2074  gs).    return t
-000112a0: 7265 655f 6d61 7028 6c61 6d62 6461 2078  ree_map(lambda x
-000112b0: 3a20 4261 7463 6865 6456 616c 7565 2878  : BatchedValue(x
-000112c0: 2c20 3029 2c20 7265 7375 6c74 290a 0a0a  , 0), result)...
-000112d0: 766d 6170 5f69 6d70 6c73 5b54 7261 6e73  vmap_impls[Trans
-000112e0: 666f 726d 732e 4a76 704f 705d 203d 205f  forms.JvpOp] = _
-000112f0: 6a76 705f 6361 6c6c 5f76 6d61 700a 0a0a  jvp_call_vmap...
-00011300: 6465 6620 766d 6170 2866 756e 632c 2069  def vmap(func, i
-00011310: 6e5f 6469 6d73 3d30 2c20 6f75 745f 6469  n_dims=0, out_di
-00011320: 6d73 3d30 2c20 6178 6973 5f73 697a 653d  ms=0, axis_size=
-00011330: 4e6f 6e65 293a 0a20 2020 2022 2222 5665  None):.    """Ve
-00011340: 6374 6f72 697a 696e 6720 7472 616e 7366  ctorizing transf
-00011350: 6f72 6d20 666f 7220 6120 5468 756e 6465  orm for a Thunde
-00011360: 7220 6675 6e63 7469 6f6e 2e0a 0a20 2020  r function...   
-00011370: 2041 7267 733a 0a20 2020 2020 2020 2066   Args:.        f
-00011380: 756e 6320 2843 616c 6c61 626c 6529 3a20  unc (Callable): 
-00011390: 4120 5468 756e 6465 7220 6675 6e63 7469  A Thunder functi
-000113a0: 6f6e 2074 6f20 6265 2074 7261 6e73 666f  on to be transfo
-000113b0: 726d 6564 2e0a 0a20 2020 2052 6574 7572  rmed...    Retur
-000113c0: 6e73 3a0a 2020 2020 2020 2020 4361 6c6c  ns:.        Call
-000113d0: 6162 6c65 3a20 4120 766d 6170 7065 6420  able: A vmapped 
-000113e0: 7665 7273 696f 6e20 6f66 2074 6865 2066  version of the f
-000113f0: 756e 6374 696f 6e2e 0a20 2020 2022 2222  unction..    """
-00011400: 0a0a 2020 2020 2320 544f 444f 3a20 666c  ..    # TODO: fl
-00011410: 6174 7465 6e0a 2020 2020 2320 496e 204a  atten.    # In J
-00011420: 4158 2066 6c61 7474 656e 696e 6720 6f66  AX flattening of
-00011430: 2069 6e5f 6469 6d73 2069 7320 7261 7468   in_dims is rath
-00011440: 6572 2063 6f6d 706c 6963 6174 6564 2062  er complicated b
-00011450: 6563 6175 7365 2069 7420 6361 6e20 6f70  ecause it can op
-00011460: 7469 6f6e 616c 6c79 2062 650a 2020 2020  tionally be.    
-00011470: 2320 7370 6563 6966 6965 6420 6173 2061  # specified as a
-00011480: 20e2 809c 7072 6566 6978 e280 9d20 7079   ...prefix... py
-00011490: 7472 6565 2c20 6d65 616e 696e 6720 7468  tree, meaning th
-000114a0: 6174 2061 2073 696e 676c 6520 6c65 6166  at a single leaf
-000114b0: 2076 616c 7565 2063 616e 2062 6520 6170   value can be ap
-000114c0: 706c 6965 640a 2020 2020 2320 746f 2061  plied.    # to a
-000114d0: 6e20 656e 7469 7265 2073 7562 2d70 7974  n entire sub-pyt
-000114e0: 7265 652e 0a0a 2020 2020 6465 6620 666c  ree...    def fl
-000114f0: 6174 7465 6e5f 6675 6e63 5f66 6f72 5f76  atten_func_for_v
-00011500: 6d61 7028 6675 6e63 2c20 6172 6773 2c20  map(func, args, 
-00011510: 6b77 6172 6773 293a 0a20 2020 2020 2020  kwargs):.       
-00011520: 2066 6c61 745f 6172 6773 2c20 7370 6563   flat_args, spec
-00011530: 203d 2074 7265 655f 666c 6174 7465 6e28   = tree_flatten(
-00011540: 2861 7267 732c 206b 7761 7267 7329 290a  (args, kwargs)).
-00011550: 0a20 2020 2020 2020 2064 6566 2066 6c61  .        def fla
-00011560: 745f 6675 6e63 282a 666c 6174 5f61 7267  t_func(*flat_arg
-00011570: 7329 3a0a 2020 2020 2020 2020 2020 2020  s):.            
-00011580: 666e 5f61 7267 732c 2066 6e5f 6b77 6172  fn_args, fn_kwar
-00011590: 6773 203d 2074 7265 655f 756e 666c 6174  gs = tree_unflat
-000115a0: 7465 6e28 666c 6174 5f61 7267 732c 2073  ten(flat_args, s
-000115b0: 7065 6329 0a20 2020 2020 2020 2020 2020  pec).           
-000115c0: 2072 6574 7572 6e20 6675 6e63 282a 666e   return func(*fn
-000115d0: 5f61 7267 732c 202a 2a66 6e5f 6b77 6172  _args, **fn_kwar
-000115e0: 6773 290a 0a20 2020 2020 2020 2072 6574  gs)..        ret
-000115f0: 7572 6e20 666c 6174 5f66 756e 632c 2066  urn flat_func, f
-00011600: 6c61 745f 6172 6773 2c20 7370 6563 0a0a  lat_args, spec..
-00011610: 2020 2020 6465 6620 7772 6170 7065 7228      def wrapper(
-00011620: 2a61 7267 732c 202a 2a6b 7761 7267 7329  *args, **kwargs)
-00011630: 3a0a 2020 2020 2020 2020 6675 6e63 5f66  :.        func_f
-00011640: 6c61 742c 2061 7267 735f 666c 6174 2c20  lat, args_flat, 
-00011650: 6172 6773 5f73 7065 6320 3d20 666c 6174  args_spec = flat
-00011660: 7465 6e5f 6675 6e63 5f66 6f72 5f76 6d61  ten_func_for_vma
-00011670: 7028 6675 6e63 2c20 6172 6773 2c20 6b77  p(func, args, kw
-00011680: 6172 6773 290a 2020 2020 2020 2020 6966  args).        if
-00011690: 2069 7369 6e73 7461 6e63 6528 696e 5f64   isinstance(in_d
-000116a0: 696d 732c 2069 6e74 293a 0a20 2020 2020  ims, int):.     
-000116b0: 2020 2020 2020 2069 6e5f 6469 6d73 5f66         in_dims_f
-000116c0: 6c61 7420 3d20 2869 6e5f 6469 6d73 2c29  lat = (in_dims,)
-000116d0: 202a 206c 656e 2861 7267 735f 666c 6174   * len(args_flat
-000116e0: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
-000116f0: 2020 2020 2020 2020 2020 2020 696e 5f64              in_d
-00011700: 696d 735f 666c 6174 2c20 696e 5f64 696d  ims_flat, in_dim
-00011710: 735f 7370 6563 203d 2074 7265 655f 666c  s_spec = tree_fl
-00011720: 6174 7465 6e28 696e 5f64 696d 7329 0a20  atten(in_dims). 
-00011730: 2020 2020 2020 2020 2020 2061 7373 6572             asser
-00011740: 7420 6c65 6e28 696e 5f64 696d 735f 666c  t len(in_dims_fl
-00011750: 6174 2920 3d3d 206c 656e 2861 7267 735f  at) == len(args_
-00011760: 666c 6174 292c 2022 696e 5f64 696d 7320  flat), "in_dims 
-00011770: 6d75 7374 2068 6176 6520 7468 6520 7361  must have the sa
-00011780: 6d65 206c 656e 6774 6820 6173 2061 7267  me length as arg
-00011790: 732c 206b 7761 7267 7322 0a20 2020 2020  s, kwargs".     
-000117a0: 2020 2075 6e62 6174 6368 6564 5f61 7267     unbatched_arg
-000117b0: 735f 666c 6174 203d 205b 7265 6d6f 7665  s_flat = [remove
-000117c0: 5f62 6174 6368 5f64 696d 2861 7267 2920  _batch_dim(arg) 
-000117d0: 6966 2069 7369 6e73 7461 6e63 6528 6172  if isinstance(ar
-000117e0: 672c 2054 656e 736f 7250 726f 7879 2920  g, TensorProxy) 
-000117f0: 656c 7365 2061 7267 2066 6f72 2061 7267  else arg for arg
-00011800: 2069 6e20 6172 6773 5f66 6c61 745d 0a20   in args_flat]. 
-00011810: 2020 2020 2020 2074 7261 6365 203d 2063         trace = c
-00011820: 6f6e 7374 7275 6374 5f74 7261 6365 2829  onstruct_trace()
-00011830: 2866 756e 635f 666c 6174 2c20 2a75 6e62  (func_flat, *unb
-00011840: 6174 6368 6564 5f61 7267 735f 666c 6174  atched_args_flat
-00011850: 290a 2020 2020 2020 2020 6f75 7473 203d  ).        outs =
-00011860: 2076 6d61 705f 6361 6c6c 2861 7267 735f   vmap_call(args_
-00011870: 666c 6174 2c20 696e 5f64 696d 735f 666c  flat, in_dims_fl
-00011880: 6174 2c20 6f75 745f 6469 6d73 2c20 6178  at, out_dims, ax
-00011890: 6973 5f73 697a 653d 6178 6973 5f73 697a  is_size=axis_siz
-000118a0: 652c 2066 756e 6374 696f 6e5f 7472 6163  e, function_trac
-000118b0: 653d 7472 6163 6529 0a20 2020 2020 2020  e=trace).       
-000118c0: 2072 6574 7572 6e20 6f75 7473 0a0a 2020   return outs..  
-000118d0: 2020 7265 7475 726e 2077 7261 7070 6572    return wrapper
-000118e0: 0a0a 0a23 2054 4f44 4f20 5468 6973 2066  ...# TODO This f
-000118f0: 756e 6374 696f 6e20 636f 6d6d 656e 7465  unction commente
-00011900: 6420 6f75 7420 6265 6361 7573 6520 6974  d out because it
-00011910: 2063 616c 6c73 206d 616b 655f 7472 6163   calls make_trac
-00011920: 6564 2c20 7768 6963 6820 646f 6573 206e  ed, which does n
-00011930: 6f74 2065 7869 7374 0a23 2064 6566 2076  ot exist.# def v
-00011940: 6d61 705f 6561 6765 7228 6675 6e63 2c20  map_eager(func, 
-00011950: 6172 6773 2c20 696e 5f64 696d 733d 302c  args, in_dims=0,
-00011960: 206f 7574 5f64 696d 733d 302c 2061 7869   out_dims=0, axi
-00011970: 735f 7369 7a65 3d4e 6f6e 652c 2065 7865  s_size=None, exe
-00011980: 6375 746f 723d 2274 6f72 6368 2229 3a0a  cutor="torch"):.
-00011990: 2320 2020 2020 2222 2243 6f6d 7075 7465  #     """Compute
-000119a0: 7320 7468 6520 766d 6170 206f 6620 6120  s the vmap of a 
-000119b0: 5468 756e 6465 7220 6675 6e63 7469 6f6e  Thunder function
-000119c0: 2e0a 0a23 2020 2020 2041 7267 733a 0a23  ...#     Args:.#
-000119d0: 2020 2020 2020 2020 2066 756e 6320 2843           func (C
-000119e0: 616c 6c61 626c 6529 3a20 4120 5468 756e  allable): A Thun
-000119f0: 6465 7220 6675 6e63 7469 6f6e 2074 6f20  der function to 
-00011a00: 6265 2074 7261 6e73 666f 726d 6564 2e0a  be transformed..
-00011a10: 2320 2020 2020 2020 2020 6172 6773 2028  #         args (
-00011a20: 5f74 7970 655f 293a 2041 7267 7320 6f66  _type_): Args of
-00011a30: 2074 6865 2066 756e 6374 696f 6e2e 0a23   the function..#
-00011a40: 2020 2020 2020 2020 2065 7865 6375 746f           executo
-00011a50: 7220 2873 7472 2c20 6f70 7469 6f6e 616c  r (str, optional
-00011a60: 293a 2045 7865 6375 746f 7220 746f 2075  ): Executor to u
-00011a70: 7365 2e20 4465 6661 756c 7473 2074 6f20  se. Defaults to 
-00011a80: 2274 6f72 6368 222e 0a0a 2320 2020 2020  "torch"...#     
-00011a90: 5265 7475 726e 733a 0a23 2020 2020 2020  Returns:.#      
-00011aa0: 2020 2054 6865 2072 6573 756c 7420 6f66     The result of
-00011ab0: 2074 6865 2076 6d61 7070 6564 2066 756e   the vmapped fun
-00011ac0: 6374 696f 6e2e 0a23 2020 2020 2022 2222  ction..#     """
-00011ad0: 0a23 2020 2020 2023 2054 4f44 4f3a 2066  .#     # TODO: f
-00011ae0: 6978 2074 6869 7320 2d20 6e6f 7420 616c  ix this - not al
-00011af0: 6c20 6172 6773 206d 6179 2062 6520 6261  l args may be ba
-00011b00: 7463 6865 640a 2320 2020 2020 2320 544f  tched.#     # TO
-00011b10: 444f 3a20 6865 7265 2077 6520 6173 7375  DO: here we assu
-00011b20: 6d65 2062 6174 6368 2061 7869 7320 6973  me batch axis is
-00011b30: 2030 0a23 2020 2020 2076 6d61 705f 7472   0.#     vmap_tr
-00011b40: 6163 6520 3d20 6d61 6b65 5f74 7261 6365  ace = make_trace
-00011b50: 280a 2320 2020 2020 2020 2020 766d 6170  (.#         vmap
-00011b60: 2866 756e 632c 2069 6e5f 6469 6d73 3d69  (func, in_dims=i
-00011b70: 6e5f 6469 6d73 2c20 6f75 745f 6469 6d73  n_dims, out_dims
-00011b80: 3d6f 7574 5f64 696d 732c 2061 7869 735f  =out_dims, axis_
-00011b90: 7369 7a65 3d61 7869 735f 7369 7a65 292c  size=axis_size),
-00011ba0: 2065 7865 6375 746f 723d 6578 6563 7574   executor=execut
-00011bb0: 6f72 2c0a 2320 2020 2020 2020 2020 2a61  or,.#         *a
-00011bc0: 7267 7329 0a23 2020 2020 2076 6d61 705f  rgs).#     vmap_
-00011bd0: 7472 6163 6564 203d 206d 616b 655f 7472  traced = make_tr
-00011be0: 6163 6564 2870 6172 7469 616c 2865 7661  aced(partial(eva
-00011bf0: 6c5f 7472 6163 652c 2076 6d61 705f 7472  l_trace, vmap_tr
-00011c00: 6163 6529 2c20 6578 6563 7574 6f72 3d65  ace), executor=e
-00011c10: 7865 6375 746f 7229 0a23 2020 2020 2072  xecutor).#     r
-00011c20: 6574 7572 6e20 766d 6170 5f74 7261 6365  eturn vmap_trace
-00011c30: 6428 2a61 7267 7329 0a0a 0a23 204a 5650  d(*args)...# JVP
-00011c40: 2074 7261 6e73 666f 726d 0a23 202d 2d2d   transform.# ---
-00011c50: 2d2d 2d2d 2d2d 2d2d 2d2d 0a0a 0a40 6461  ----------...@da
-00011c60: 7461 636c 6173 7328 6672 6f7a 656e 3d54  taclass(frozen=T
-00011c70: 7275 6529 0a63 6c61 7373 204a 5650 4475  rue).class JVPDu
-00011c80: 616c 3a0a 2020 2020 2222 2244 7561 6c20  al:.    """Dual 
-00011c90: 6e75 6d62 6572 2066 6f72 2074 6865 204a  number for the J
-00011ca0: 5650 2074 7261 6e73 666f 726d 2e0a 0a20  VP transform... 
-00011cb0: 2020 2041 7474 7269 6275 7465 733a 0a20     Attributes:. 
-00011cc0: 2020 2020 2020 2070 7269 6d61 6c3a 2050         primal: P
-00011cd0: 7269 6d61 6c20 7661 6c75 652e 0a20 2020  rimal value..   
-00011ce0: 2020 2020 2074 616e 6765 6e74 3a20 5461       tangent: Ta
-00011cf0: 6e67 656e 7420 7661 6c75 652e 0a20 2020  ngent value..   
-00011d00: 2022 2222 0a0a 2020 2020 7072 696d 616c   """..    primal
-00011d10: 3a20 416e 790a 2020 2020 7461 6e67 656e  : Any.    tangen
-00011d20: 743a 2041 6e79 0a0a 2020 2020 6465 6620  t: Any..    def 
-00011d30: 5f5f 6974 6572 5f5f 2873 656c 6629 3a0a  __iter__(self):.
-00011d40: 2020 2020 2020 2020 7969 656c 6420 7365          yield se
-00011d50: 6c66 2e70 7269 6d61 6c0a 2020 2020 2020  lf.primal.      
-00011d60: 2020 7969 656c 6420 7365 6c66 2e74 616e    yield self.tan
-00011d70: 6765 6e74 0a0a 0a64 6566 2070 6169 725f  gent...def pair_
-00011d80: 746f 5f6a 7670 5f64 7561 6c28 7061 6972  to_jvp_dual(pair
-00011d90: 293a 0a20 2020 2022 2222 436f 6e76 6572  ):.    """Conver
-00011da0: 7473 2061 2070 6169 7220 746f 2061 204a  ts a pair to a J
-00011db0: 5650 4475 616c 2e0a 0a20 2020 2041 7267  VPDual...    Arg
-00011dc0: 733a 0a20 2020 2020 2020 2070 6169 7220  s:.        pair 
-00011dd0: 2853 6571 7565 6e63 6529 3a20 5061 6972  (Sequence): Pair
-00011de0: 2074 6f20 636f 6e76 6572 742e 0a0a 2020   to convert...  
-00011df0: 2020 5265 7475 726e 733a 0a20 2020 2020    Returns:.     
-00011e00: 2020 204a 5650 4475 616c 3a20 4a56 5044     JVPDual: JVPD
-00011e10: 7561 6c20 7265 7072 6573 656e 7461 7469  ual representati
-00011e20: 6f6e 206f 6620 7468 6520 7061 6972 2e0a  on of the pair..
-00011e30: 2020 2020 2222 220a 2020 2020 6966 2069      """.    if i
-00011e40: 7369 6e73 7461 6e63 6528 7061 6972 2c20  sinstance(pair, 
-00011e50: 4a56 5044 7561 6c29 3a0a 2020 2020 2020  JVPDual):.      
-00011e60: 2020 7265 7475 726e 2070 6169 720a 2020    return pair.  
-00011e70: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00011e80: 6173 7365 7274 2069 7369 6e73 7461 6e63  assert isinstanc
-00011e90: 6528 7061 6972 2c20 5365 7175 656e 6365  e(pair, Sequence
-00011ea0: 2920 616e 6420 6c65 6e28 7061 6972 2920  ) and len(pair) 
-00011eb0: 3d3d 2032 0a20 2020 2020 2020 2072 6574  == 2.        ret
-00011ec0: 7572 6e20 4a56 5044 7561 6c28 2a70 6169  urn JVPDual(*pai
-00011ed0: 7229 0a0a 0a64 6566 2073 696e 5f6a 7670  r)...def sin_jvp
-00011ee0: 2861 3a20 4a56 5044 7561 6c29 3a0a 2020  (a: JVPDual):.  
-00011ef0: 2020 782c 2078 6420 3d20 610a 2020 2020    x, xd = a.    
-00011f00: 7265 7475 726e 204a 5650 4475 616c 2870  return JVPDual(p
-00011f10: 7269 6d73 2e73 696e 2878 292c 2070 7269  rims.sin(x), pri
-00011f20: 6d73 2e63 6f73 2878 2920 2a20 7864 290a  ms.cos(x) * xd).
-00011f30: 0a0a 6465 6620 6d75 6c5f 6a76 7028 613a  ..def mul_jvp(a:
-00011f40: 204a 5650 4475 616c 2c20 623a 204a 5650   JVPDual, b: JVP
-00011f50: 4475 616c 293a 0a20 2020 2078 2c20 7864  Dual):.    x, xd
-00011f60: 203d 2061 0a20 2020 2079 2c20 7964 203d   = a.    y, yd =
-00011f70: 2062 0a20 2020 2072 6574 7572 6e20 4a56   b.    return JV
-00011f80: 5044 7561 6c28 7820 2a20 792c 2078 202a  PDual(x * y, x *
-00011f90: 2079 6420 2b20 7920 2a20 7864 290a 0a0a   yd + y * xd)...
-00011fa0: 6465 6620 6164 645f 6a76 7028 613a 204a  def add_jvp(a: J
-00011fb0: 5650 4475 616c 2c20 623a 204a 5650 4475  VPDual, b: JVPDu
-00011fc0: 616c 293a 0a20 2020 2078 2c20 7864 203d  al):.    x, xd =
-00011fd0: 2061 0a20 2020 2079 2c20 7964 203d 2062   a.    y, yd = b
-00011fe0: 0a20 2020 2072 6574 7572 6e20 4a56 5044  .    return JVPD
-00011ff0: 7561 6c28 7820 2b20 792c 2078 6420 2b20  ual(x + y, xd + 
-00012000: 7964 290a 0a0a 6465 6620 6272 6f61 6463  yd)...def broadc
-00012010: 6173 745f 696e 5f64 696d 5f6a 7670 2861  ast_in_dim_jvp(a
-00012020: 3a20 4a56 5044 7561 6c2c 2073 6861 7065  : JVPDual, shape
-00012030: 3a20 7475 706c 655b 4a56 5044 7561 6c2c  : tuple[JVPDual,
-00012040: 202e 2e2e 5d2c 2062 726f 6164 6361 7374   ...], broadcast
-00012050: 5f64 696d 656e 7369 6f6e 733a 2074 7570  _dimensions: tup
-00012060: 6c65 5b4a 5650 4475 616c 2c20 2e2e 2e5d  le[JVPDual, ...]
-00012070: 2920 2d3e 204a 5650 4475 616c 3a0a 2020  ) -> JVPDual:.  
-00012080: 2020 782c 2078 6420 3d20 610a 2020 2020    x, xd = a.    
-00012090: 2320 544f 444f 3a20 7368 6170 6520 616e  # TODO: shape an
-000120a0: 6420 6272 6f61 6463 6173 745f 6469 6d65  d broadcast_dime
-000120b0: 6e73 696f 6e73 2073 686f 756c 6420 6265  nsions should be
-000120c0: 2074 7570 6c65 7320 6f66 2069 6e74 730a   tuples of ints.
-000120d0: 2020 2020 2320 6275 7420 666f 7220 6e6f      # but for no
-000120e0: 7720 6974 2773 2061 2074 7570 6c65 206f  w it's a tuple o
-000120f0: 6620 4a56 5044 7561 6c73 0a20 2020 2069  f JVPDuals.    i
-00012100: 6620 6c65 6e28 7368 6170 6529 203e 2030  f len(shape) > 0
-00012110: 2061 6e64 2069 7369 6e73 7461 6e63 6528   and isinstance(
-00012120: 7368 6170 655b 305d 2c20 4a56 5044 7561  shape[0], JVPDua
-00012130: 6c29 3a0a 2020 2020 2020 2020 7368 6170  l):.        shap
-00012140: 652c 205f 203d 2073 6166 655f 7a69 7028  e, _ = safe_zip(
-00012150: 2a73 6861 7065 290a 2020 2020 6966 206c  *shape).    if l
-00012160: 656e 2862 726f 6164 6361 7374 5f64 696d  en(broadcast_dim
-00012170: 656e 7369 6f6e 7329 203e 2030 2061 6e64  ensions) > 0 and
-00012180: 2069 7369 6e73 7461 6e63 6528 6272 6f61   isinstance(broa
-00012190: 6463 6173 745f 6469 6d65 6e73 696f 6e73  dcast_dimensions
-000121a0: 5b30 5d2c 204a 5650 4475 616c 293a 0a20  [0], JVPDual):. 
-000121b0: 2020 2020 2020 2062 726f 6164 6361 7374         broadcast
-000121c0: 5f64 696d 656e 7369 6f6e 732c 205f 203d  _dimensions, _ =
-000121d0: 2073 6166 655f 7a69 7028 2a62 726f 6164   safe_zip(*broad
-000121e0: 6361 7374 5f64 696d 656e 7369 6f6e 7329  cast_dimensions)
-000121f0: 0a20 2020 2072 6574 7572 6e20 4a56 5044  .    return JVPD
-00012200: 7561 6c28 0a20 2020 2020 2020 2070 7269  ual(.        pri
-00012210: 6d73 2e62 726f 6164 6361 7374 5f69 6e5f  ms.broadcast_in_
-00012220: 6469 6d28 782c 2073 6861 7065 2c20 6272  dim(x, shape, br
-00012230: 6f61 6463 6173 745f 6469 6d65 6e73 696f  oadcast_dimensio
-00012240: 6e73 292c 2070 7269 6d73 2e62 726f 6164  ns), prims.broad
-00012250: 6361 7374 5f69 6e5f 6469 6d28 7864 2c20  cast_in_dim(xd, 
-00012260: 7368 6170 652c 2062 726f 6164 6361 7374  shape, broadcast
-00012270: 5f64 696d 656e 7369 6f6e 7329 0a20 2020  _dimensions).   
-00012280: 2029 0a0a 0a64 6566 2075 6e70 6163 6b5f   )...def unpack_
-00012290: 7365 7175 656e 6365 5f6a 7670 2873 6571  sequence_jvp(seq
-000122a0: 7565 6e63 653a 204a 5650 4475 616c 2c20  uence: JVPDual, 
-000122b0: 6c65 6e67 7468 3a20 4a56 5044 7561 6c29  length: JVPDual)
-000122c0: 202d 3e20 4a56 5044 7561 6c3a 0a20 2020   -> JVPDual:.   
-000122d0: 2078 203d 2074 7265 655f 6d61 7028 6c61   x = tree_map(la
-000122e0: 6d62 6461 2078 3a20 782e 7072 696d 616c  mbda x: x.primal
-000122f0: 2c20 7365 7175 656e 6365 290a 2020 2020  , sequence).    
-00012300: 7864 203d 2074 7265 655f 6d61 7028 6c61  xd = tree_map(la
-00012310: 6d62 6461 2078 3a20 782e 7461 6e67 656e  mbda x: x.tangen
-00012320: 742c 2073 6571 7565 6e63 6529 0a20 2020  t, sequence).   
-00012330: 206c 656e 6774 682c 205f 203d 206c 656e   length, _ = len
-00012340: 6774 680a 2020 2020 7072 696d 616c 7320  gth.    primals 
-00012350: 3d20 7072 696d 732e 756e 7061 636b 5f73  = prims.unpack_s
-00012360: 6571 7565 6e63 6528 782c 206c 656e 6774  equence(x, lengt
-00012370: 6829 0a20 2020 2074 616e 6765 6e74 7320  h).    tangents 
-00012380: 3d20 7072 696d 732e 756e 7061 636b 5f73  = prims.unpack_s
-00012390: 6571 7565 6e63 6528 7864 2c20 6c65 6e67  equence(xd, leng
-000123a0: 7468 290a 2020 2020 7265 7475 726e 2073  th).    return s
-000123b0: 6166 655f 6d61 7028 7061 6972 5f74 6f5f  afe_map(pair_to_
-000123c0: 6a76 705f 6475 616c 2c20 7361 6665 5f7a  jvp_dual, safe_z
-000123d0: 6970 2870 7269 6d61 6c73 2c20 7461 6e67  ip(primals, tang
-000123e0: 656e 7473 2929 0a0a 0a64 6566 2075 6e70  ents))...def unp
-000123f0: 6163 6b5f 7472 6976 6961 6c5f 6a76 7028  ack_trivial_jvp(
-00012400: 783a 204a 5650 4475 616c 2920 2d3e 204a  x: JVPDual) -> J
-00012410: 5650 4475 616c 3a0a 2020 2020 7265 7475  VPDual:.    retu
-00012420: 726e 2078 0a0a 0a6a 7670 5f69 6d70 6c73  rn x...jvp_impls
-00012430: 3a20 6469 6374 5b70 7269 6d73 2e53 796d  : dict[prims.Sym
-00012440: 626f 6c2c 2043 616c 6c61 626c 655d 203d  bol, Callable] =
-00012450: 2064 6963 7428 290a 0a6a 7670 5f69 6d70   dict()..jvp_imp
-00012460: 6c73 5b70 7269 6d73 2e50 7269 6d49 4473  ls[prims.PrimIDs
-00012470: 2e53 494e 5d20 3d20 7369 6e5f 6a76 700a  .SIN] = sin_jvp.
-00012480: 6a76 705f 696d 706c 735b 7072 696d 732e  jvp_impls[prims.
-00012490: 5072 696d 4944 732e 4d55 4c5d 203d 206d  PrimIDs.MUL] = m
-000124a0: 756c 5f6a 7670 0a6a 7670 5f69 6d70 6c73  ul_jvp.jvp_impls
-000124b0: 5b70 7269 6d73 2e50 7269 6d49 4473 2e41  [prims.PrimIDs.A
-000124c0: 4444 5d20 3d20 6164 645f 6a76 700a 6a76  DD] = add_jvp.jv
-000124d0: 705f 696d 706c 735b 7072 696d 732e 5072  p_impls[prims.Pr
-000124e0: 696d 4944 732e 4252 4f41 4443 4153 545f  imIDs.BROADCAST_
-000124f0: 494e 5f44 494d 5d20 3d20 6272 6f61 6463  IN_DIM] = broadc
-00012500: 6173 745f 696e 5f64 696d 5f6a 7670 0a23  ast_in_dim_jvp.#
-00012510: 206a 7670 5f69 6d70 6c73 5b70 7269 6d73   jvp_impls[prims
-00012520: 2e50 7269 6d49 4473 2e55 4e50 4143 4b5f  .PrimIDs.UNPACK_
-00012530: 5345 5155 454e 4345 5d20 3d20 756e 7061  SEQUENCE] = unpa
-00012540: 636b 5f73 6571 7565 6e63 655f 6a76 700a  ck_sequence_jvp.
-00012550: 2320 6a76 705f 696d 706c 735b 7072 696d  # jvp_impls[prim
-00012560: 732e 5072 696d 4944 732e 554e 5041 434b  s.PrimIDs.UNPACK
-00012570: 5f54 5249 5649 414c 5d20 3d20 756e 7061  _TRIVIAL] = unpa
-00012580: 636b 5f74 7269 7669 616c 5f6a 7670 0a0a  ck_trivial_jvp..
-00012590: 0a64 6566 206a 7670 5f73 796d 626f 6c5f  .def jvp_symbol_
-000125a0: 6d61 7070 6572 2873 796d 626f 6c3a 2070  mapper(symbol: p
-000125b0: 7269 6d73 2e53 796d 626f 6c29 3a0a 2020  rims.Symbol):.  
-000125c0: 2020 2222 224d 6170 7320 6120 7379 6d62    """Maps a symb
-000125d0: 6f6c 2074 6f20 6120 4a56 5020 6675 6e63  ol to a JVP func
-000125e0: 7469 6f6e 2074 6861 7420 6576 616c 7561  tion that evalua
-000125f0: 7465 7320 6974 2e0a 0a20 2020 2041 7267  tes it...    Arg
-00012600: 733a 0a20 2020 2020 2020 2073 796d 626f  s:.        symbo
-00012610: 6c20 2870 7269 6d73 2e53 796d 626f 6c29  l (prims.Symbol)
-00012620: 3a20 5379 6d62 6f6c 2074 6f20 6576 616c  : Symbol to eval
-00012630: 7561 7465 2e0a 0a20 2020 2052 6169 7365  uate...    Raise
-00012640: 733a 0a20 2020 2020 2020 204e 6f74 496d  s:.        NotIm
-00012650: 706c 656d 656e 7465 6445 7272 6f72 3a20  plementedError: 
-00012660: 4966 2074 6865 204a 5650 2066 6f72 2074  If the JVP for t
-00012670: 6865 2073 796d 626f 6c20 6973 206e 6f74  he symbol is not
-00012680: 2069 6d70 6c65 6d65 6e74 6564 2e0a 0a20   implemented... 
-00012690: 2020 2052 6574 7572 6e73 3a0a 2020 2020     Returns:.    
-000126a0: 2020 2020 4361 6c6c 6162 6c65 3a20 4a56      Callable: JV
-000126b0: 5020 6675 6e63 7469 6f6e 2074 6861 7420  P function that 
-000126c0: 6576 616c 7561 7465 7320 7468 6520 7379  evaluates the sy
-000126d0: 6d62 6f6c 2e0a 2020 2020 2222 220a 0a20  mbol..    """.. 
-000126e0: 2020 2064 6566 2077 7261 705f 6172 6728     def wrap_arg(
-000126f0: 7829 3a0a 2020 2020 2020 2020 6966 2069  x):.        if i
-00012700: 7369 6e73 7461 6e63 6528 782c 204a 5650  sinstance(x, JVP
-00012710: 4475 616c 293a 0a20 2020 2020 2020 2020  Dual):.         
-00012720: 2020 2072 6574 7572 6e20 780a 2020 2020     return x.    
-00012730: 2020 2020 656c 6966 2069 7369 6e73 7461      elif isinsta
-00012740: 6e63 6528 782c 204e 756d 6265 7229 3a0a  nce(x, Number):.
-00012750: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00012760: 726e 204a 5650 4475 616c 2878 2c20 7479  rn JVPDual(x, ty
-00012770: 7065 2878 2928 3029 290a 2020 2020 2020  pe(x)(0)).      
-00012780: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00012790: 2020 2020 7261 6973 6520 5661 6c75 6545      raise ValueE
-000127a0: 7272 6f72 2866 224a 5650 2077 7261 705f  rror(f"JVP wrap_
-000127b0: 6172 6720 676f 7420 616e 2075 6e73 7570  arg got an unsup
-000127c0: 706f 7274 6564 2074 7970 6520 7b74 7970  ported type {typ
-000127d0: 6528 7829 7d22 290a 0a20 2020 2023 2049  e(x)}")..    # I
-000127e0: 6620 7379 6d62 6f6c 2e61 7267 7320 646f  f symbol.args do
-000127f0: 6573 6e27 7420 6861 7665 2073 7562 636c  esn't have subcl
-00012800: 6173 7365 7320 6f66 2056 6172 6961 626c  asses of Variabl
-00012810: 652c 2074 6865 6e20 7765 206e 6565 6420  e, then we need 
-00012820: 746f 2072 6574 7572 6e20 6120 7a65 726f  to return a zero
-00012830: 2074 616e 6765 6e74 0a20 2020 2023 2054   tangent.    # T
-00012840: 4f44 4f3a 2074 6865 7265 206d 6179 2062  ODO: there may b
-00012850: 6520 6120 6265 7474 6572 2077 6179 2074  e a better way t
-00012860: 6f20 6465 7465 6374 2063 6f6e 7374 616e  o detect constan
-00012870: 7473 2069 6e20 7468 6520 7472 6163 650a  ts in the trace.
-00012880: 2020 2020 6966 2073 796d 626f 6c2e 6172      if symbol.ar
-00012890: 655f 616c 6c5f 6172 6773 5f63 6f6e 7374  e_all_args_const
-000128a0: 616e 743a 0a0a 2020 2020 2020 2020 6465  ant:..        de
-000128b0: 6620 7a65 726f 735f 6c69 6b65 2878 293a  f zeros_like(x):
-000128c0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-000128d0: 6973 696e 7374 616e 6365 2878 2c20 5465  isinstance(x, Te
-000128e0: 6e73 6f72 5072 6f78 7929 3a0a 2020 2020  nsorProxy):.    
-000128f0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00012900: 726e 2066 756c 6c5f 6c69 6b65 2878 2c20  rn full_like(x, 
-00012910: 6669 6c6c 5f76 616c 7565 3d30 290a 2020  fill_value=0).  
-00012920: 2020 2020 2020 2020 2020 656c 6966 2069            elif i
-00012930: 7369 6e73 7461 6e63 6528 782c 204e 756d  sinstance(x, Num
-00012940: 6265 7250 726f 7879 293a 0a20 2020 2020  berProxy):.     
-00012950: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00012960: 6e20 7479 7065 2878 2e76 616c 7565 2928  n type(x.value)(
-00012970: 3029 0a20 2020 2020 2020 2020 2020 2065  0).            e
-00012980: 6c69 6620 6973 696e 7374 616e 6365 2878  lif isinstance(x
-00012990: 2c20 4e75 6d62 6572 293a 0a20 2020 2020  , Number):.     
-000129a0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-000129b0: 6e20 7479 7065 2878 2928 3029 0a20 2020  n type(x)(0).   
-000129c0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-000129d0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-000129e0: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
-000129f0: 6622 7a65 726f 735f 6c69 6b65 2069 6e73  f"zeros_like ins
-00012a00: 6964 6520 4a56 5020 676f 7420 616e 2075  ide JVP got an u
-00012a10: 6e73 7570 706f 7274 6564 2074 7970 6520  nsupported type 
-00012a20: 7b74 7970 6528 7829 7d22 290a 0a20 2020  {type(x)}")..   
-00012a30: 2020 2020 2064 6566 206a 7670 5f69 6d70       def jvp_imp
-00012a40: 6c5f 636f 6e73 7428 7379 6d62 6f6c 2c20  l_const(symbol, 
-00012a50: 2a61 7267 732c 202a 2a6b 7761 7267 7329  *args, **kwargs)
-00012a60: 3a0a 2020 2020 2020 2020 2020 2020 7072  :.            pr
-00012a70: 696d 616c 7320 3d20 7379 6d62 6f6c 5f74  imals = symbol_t
-00012a80: 6f5f 6576 616c 2873 796d 626f 6c29 282a  o_eval(symbol)(*
-00012a90: 6172 6773 2c20 2a2a 6b77 6172 6773 290a  args, **kwargs).
-00012aa0: 2020 2020 2020 2020 2020 2020 6966 2069              if i
-00012ab0: 7369 6e73 7461 6e63 6528 7072 696d 616c  sinstance(primal
-00012ac0: 732c 2053 6571 7565 6e63 6529 3a0a 2020  s, Sequence):.  
-00012ad0: 2020 2020 2020 2020 2020 2020 2020 7461                ta
-00012ae0: 6e67 656e 7473 203d 2074 7570 6c65 287a  ngents = tuple(z
-00012af0: 6572 6f73 5f6c 696b 6528 7029 2066 6f72  eros_like(p) for
-00012b00: 2070 2069 6e20 7072 696d 616c 7329 0a20   p in primals). 
-00012b10: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-00012b20: 6574 7572 6e20 7361 6665 5f6d 6170 2870  eturn safe_map(p
-00012b30: 6169 725f 746f 5f6a 7670 5f64 7561 6c2c  air_to_jvp_dual,
-00012b40: 2073 6166 655f 7a69 7028 7072 696d 616c   safe_zip(primal
-00012b50: 732c 2074 616e 6765 6e74 7329 290a 2020  s, tangents)).  
-00012b60: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00012b70: 204a 5650 4475 616c 2870 7269 6d61 6c73   JVPDual(primals
-00012b80: 2c20 7a65 726f 735f 6c69 6b65 2870 7269  , zeros_like(pri
-00012b90: 6d61 6c73 2929 0a0a 2020 2020 2020 2020  mals))..        
-00012ba0: 7265 7475 726e 2070 6172 7469 616c 286a  return partial(j
-00012bb0: 7670 5f69 6d70 6c5f 636f 6e73 742c 2073  vp_impl_const, s
-00012bc0: 796d 626f 6c29 0a0a 2020 2020 2320 4e6f  ymbol)..    # No
-00012bd0: 726d 616c 2063 6173 652c 2077 6520 6861  rmal case, we ha
-00012be0: 7665 2061 2070 726f 7879 2074 616e 6765  ve a proxy tange
-00012bf0: 6e74 0a20 2020 206a 7670 5f69 6d70 6c20  nt.    jvp_impl 
-00012c00: 3d20 6a76 705f 696d 706c 732e 6765 7428  = jvp_impls.get(
-00012c10: 7379 6d62 6f6c 2e73 796d 2e69 6429 0a20  symbol.sym.id). 
-00012c20: 2020 2069 6620 6a76 705f 696d 706c 2069     if jvp_impl i
-00012c30: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
-00012c40: 7261 6973 6520 4e6f 7449 6d70 6c65 6d65  raise NotImpleme
-00012c50: 6e74 6564 4572 726f 7228 6622 4a56 5020  ntedError(f"JVP 
-00012c60: 666f 7220 7b73 796d 626f 6c2e 7379 6d2e  for {symbol.sym.
-00012c70: 6964 7d20 6973 206e 6f74 2069 6d70 6c65  id} is not imple
-00012c80: 6d65 6e74 6564 2229 0a0a 2020 2020 6465  mented")..    de
-00012c90: 6620 5f6a 7670 5f69 6d70 6c28 2a61 7267  f _jvp_impl(*arg
-00012ca0: 732c 202a 2a6b 7761 7267 7329 3a0a 2020  s, **kwargs):.  
-00012cb0: 2020 2020 2020 6172 6773 203d 2074 7265        args = tre
-00012cc0: 655f 6d61 7028 7772 6170 5f61 7267 2c20  e_map(wrap_arg, 
-00012cd0: 6172 6773 290a 2020 2020 2020 2020 2320  args).        # 
-00012ce0: 4578 7065 6374 696e 6720 4a56 5044 7561  Expecting JVPDua
-00012cf0: 6c73 2077 7261 7070 696e 6720 7061 6972  ls wrapping pair
-00012d00: 7320 6f66 2070 7269 6d61 6c73 2061 6e64  s of primals and
-00012d10: 2074 616e 6765 6e74 730a 2020 2020 2020   tangents.      
-00012d20: 2020 6173 7365 7274 2061 6c6c 2869 7369    assert all(isi
-00012d30: 6e73 7461 6e63 6528 6172 672c 204a 5650  nstance(arg, JVP
-00012d40: 4475 616c 2920 666f 7220 6172 6720 696e  Dual) for arg in
-00012d50: 2074 7265 655f 666c 6174 7465 6e28 6172   tree_flatten(ar
-00012d60: 6773 295b 305d 290a 2020 2020 2020 2020  gs)[0]).        
-00012d70: 7265 7475 726e 206a 7670 5f69 6d70 6c28  return jvp_impl(
-00012d80: 2a61 7267 732c 202a 2a6b 7761 7267 7329  *args, **kwargs)
-00012d90: 0a0a 2020 2020 7265 7475 726e 205f 6a76  ..    return _jv
-00012da0: 705f 696d 706c 0a0a 0a64 6566 205f 6a76  p_impl...def _jv
-00012db0: 705f 6361 6c6c 5f6d 6574 6166 756e 6328  p_call_metafunc(
-00012dc0: 6465 7461 6368 6564 3a20 626f 6f6c 2c20  detached: bool, 
-00012dd0: 7072 696d 616c 732c 2074 616e 6765 6e74  primals, tangent
-00012de0: 732c 202a 2c20 6675 6e63 7469 6f6e 5f74  s, *, function_t
-00012df0: 7261 6365 3a20 5472 6163 652c 202a 2a6b  race: Trace, **k
-00012e00: 7761 7267 7329 3a0a 2020 2020 2222 224d  wargs):.    """M
-00012e10: 6574 6166 756e 6374 696f 6e20 666f 7220  etafunction for 
-00012e20: 7468 6520 4a56 5020 7472 616e 7366 6f72  the JVP transfor
-00012e30: 6d2e 0a0a 2020 2020 4172 6773 3a0a 2020  m...    Args:.  
-00012e40: 2020 2020 2020 6465 7461 6368 6564 2028        detached (
-00012e50: 626f 6f6c 293a 2057 6865 7468 6572 2074  bool): Whether t
-00012e60: 6f20 6465 7461 6368 2074 6865 2074 7261  o detach the tra
-00012e70: 6365 2e0a 2020 2020 2020 2020 7072 696d  ce..        prim
-00012e80: 616c 7320 2854 7570 6c65 5b50 726f 7879  als (Tuple[Proxy
-00012e90: 5d29 3a20 5072 696d 616c 2076 616c 7565  ]): Primal value
-00012ea0: 732e 0a20 2020 2020 2020 2074 616e 6765  s..        tange
-00012eb0: 6e74 7320 2854 7570 6c65 5b50 726f 7879  nts (Tuple[Proxy
-00012ec0: 5d29 3a20 5461 6e67 656e 7420 7661 6c75  ]): Tangent valu
-00012ed0: 6573 2e0a 2020 2020 2020 2020 6675 6e63  es..        func
-00012ee0: 7469 6f6e 5f74 7261 6365 2028 5472 6163  tion_trace (Trac
-00012ef0: 6529 3a20 5472 6163 6520 6f66 2074 6865  e): Trace of the
-00012f00: 2066 756e 6374 696f 6e20 746f 2062 6520   function to be 
-00012f10: 7472 616e 7366 6f72 6d65 642e 0a20 2020  transformed..   
-00012f20: 2020 2020 206b 7761 7267 733a 204b 6579       kwargs: Key
-00012f30: 776f 7264 2061 7267 756d 656e 7473 2e0a  word arguments..
-00012f40: 0a20 2020 2052 6169 7365 733a 0a20 2020  .    Raises:.   
-00012f50: 2020 2020 2041 7373 6572 7469 6f6e 4572       AssertionEr
-00012f60: 726f 723a 2049 6620 7468 6520 4a56 5020  ror: If the JVP 
-00012f70: 666f 7220 6b65 7977 6f72 6420 6172 6775  for keyword argu
-00012f80: 6d65 6e74 7320 6973 206e 6f74 2069 6d70  ments is not imp
-00012f90: 6c65 6d65 6e74 6564 2e0a 0a20 2020 2052  lemented...    R
-00012fa0: 6574 7572 6e73 3a0a 2020 2020 2020 2020  eturns:.        
-00012fb0: 5265 7375 6c74 206f 6620 7468 6520 4a56  Result of the JV
-00012fc0: 5020 7472 616e 7366 6f72 6d2e 0a20 2020  P transform..   
-00012fd0: 2022 2222 0a20 2020 2061 7373 6572 7420   """.    assert 
-00012fe0: 6c65 6e28 6b77 6172 6773 2920 3d3d 2030  len(kwargs) == 0
-00012ff0: 2c20 224a 5650 2066 6f72 206b 7761 7267  , "JVP for kwarg
-00013000: 7320 6973 206e 6f74 2069 6d70 6c65 6d65  s is not impleme
-00013010: 6e74 6564 220a 0a20 2020 2063 7478 203d  nted"..    ctx =
-00013020: 2064 6574 6163 6865 645f 7472 6163 6528   detached_trace(
-00013030: 2920 6966 2064 6574 6163 6865 6420 656c  ) if detached el
-00013040: 7365 206e 756c 6c63 6f6e 7465 7874 2829  se nullcontext()
-00013050: 0a20 2020 2077 6974 6820 6374 783a 0a20  .    with ctx:. 
-00013060: 2020 2020 2020 2023 2057 7261 7070 696e         # Wrappin
-00013070: 6720 7468 6520 7072 696d 616c 7320 616e  g the primals an
-00013080: 6420 7461 6e67 656e 7473 2069 6e20 4a56  d tangents in JV
-00013090: 5044 7561 6c73 2069 7320 6e6f 7420 7374  PDuals is not st
-000130a0: 7269 6374 6c79 206e 6563 6573 7361 7279  rictly necessary
-000130b0: 2c20 6275 7420 6974 206d 616b 6573 0a20  , but it makes. 
-000130c0: 2020 2020 2020 2023 2074 6865 2063 6f64         # the cod
-000130d0: 6520 6d6f 7265 2072 6561 6461 626c 650a  e more readable.
-000130e0: 2020 2020 2020 2020 2320 5765 2070 726f          # We pro
-000130f0: 7061 6761 7465 2074 6865 204a 5650 4475  pagate the JVPDu
-00013100: 616c 7320 7468 726f 7567 6820 7468 6520  als through the 
-00013110: 7472 6163 652c 2061 6e64 2074 6865 6e20  trace, and then 
-00013120: 756e 7772 6170 2074 6865 6d20 6174 2074  unwrap them at t
-00013130: 6865 2065 6e64 0a20 2020 2020 2020 2070  he end.        p
-00013140: 7269 6d61 6c73 5f74 616e 6765 6e74 735f  rimals_tangents_
-00013150: 6475 616c 7320 3d20 7361 6665 5f6d 6170  duals = safe_map
-00013160: 2870 6169 725f 746f 5f6a 7670 5f64 7561  (pair_to_jvp_dua
-00013170: 6c2c 2073 6166 655f 7a69 7028 7072 696d  l, safe_zip(prim
-00013180: 616c 732c 2074 616e 6765 6e74 7329 290a  als, tangents)).
-00013190: 2020 2020 2020 2020 7265 7375 6c74 203d          result =
-000131a0: 2065 7661 6c5f 7472 6163 6528 6675 6e63   eval_trace(func
-000131b0: 7469 6f6e 5f74 7261 6365 2c20 2a70 7269  tion_trace, *pri
-000131c0: 6d61 6c73 5f74 616e 6765 6e74 735f 6475  mals_tangents_du
-000131d0: 616c 732c 2073 796d 626f 6c5f 6d61 7070  als, symbol_mapp
-000131e0: 6572 3d6a 7670 5f73 796d 626f 6c5f 6d61  er=jvp_symbol_ma
-000131f0: 7070 6572 290a 2020 2020 2020 2020 2320  pper).        # 
-00013200: 556e 7772 6170 7069 6e67 2074 6865 204a  Unwrapping the J
-00013210: 5650 4475 616c 730a 2020 2020 2020 2020  VPDuals.        
-00013220: 6966 2069 7369 6e73 7461 6e63 6528 7265  if isinstance(re
-00013230: 7375 6c74 2c20 5365 7175 656e 6365 293a  sult, Sequence):
-00013240: 0a20 2020 2020 2020 2020 2020 2061 7373  .            ass
-00013250: 6572 7420 616c 6c28 6973 696e 7374 616e  ert all(isinstan
-00013260: 6365 2878 2c20 4a56 5044 7561 6c29 2066  ce(x, JVPDual) f
-00013270: 6f72 2078 2069 6e20 7265 7375 6c74 290a  or x in result).
-00013280: 2020 2020 2020 2020 2020 2020 7072 696d              prim
-00013290: 616c 732c 2074 616e 6765 6e74 7320 3d20  als, tangents = 
-000132a0: 756e 7a69 7032 2872 6573 756c 7429 0a20  unzip2(result). 
-000132b0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-000132c0: 6e20 7072 696d 616c 732c 2074 616e 6765  n primals, tange
-000132d0: 6e74 730a 2020 2020 2020 2020 6173 7365  nts.        asse
-000132e0: 7274 2069 7369 6e73 7461 6e63 6528 7265  rt isinstance(re
-000132f0: 7375 6c74 2c20 4a56 5044 7561 6c29 0a20  sult, JVPDual). 
-00013300: 2020 2020 2020 2072 6574 7572 6e20 7265         return re
-00013310: 7375 6c74 2e70 7269 6d61 6c2c 2072 6573  sult.primal, res
-00013320: 756c 742e 7461 6e67 656e 740a 0a0a 6a76  ult.tangent...jv
-00013330: 705f 6361 6c6c 203d 2053 796d 626f 6c28  p_call = Symbol(
-00013340: 6964 3d54 7261 6e73 666f 726d 732e 4a76  id=Transforms.Jv
-00013350: 704f 702c 206e 616d 653d 226a 7670 5f63  pOp, name="jvp_c
-00013360: 616c 6c22 2c20 6d65 7461 3d70 6172 7469  all", meta=parti
-00013370: 616c 285f 6a76 705f 6361 6c6c 5f6d 6574  al(_jvp_call_met
-00013380: 6166 756e 632c 2046 616c 7365 2929 0a0a  afunc, False))..
-00013390: 0a64 6566 205f 6964 656e 7469 7479 5f63  .def _identity_c
-000133a0: 616c 6c5f 6a76 7028 2a61 7267 733a 204a  all_jvp(*args: J
-000133b0: 5650 4475 616c 2c20 7472 6163 653a 2054  VPDual, trace: T
-000133c0: 7261 6365 2c20 2a2a 6b77 6172 6773 293a  race, **kwargs):
-000133d0: 0a20 2020 2070 7269 6d61 6c73 2c20 7461  .    primals, ta
-000133e0: 6e67 656e 7473 203d 2075 6e7a 6970 3228  ngents = unzip2(
-000133f0: 6172 6773 290a 2020 2020 6f75 745f 7072  args).    out_pr
-00013400: 696d 616c 732c 206f 7574 5f74 616e 6765  imals, out_tange
-00013410: 6e74 7320 3d20 5f6a 7670 5f63 616c 6c5f  nts = _jvp_call_
-00013420: 6d65 7461 6675 6e63 2846 616c 7365 2c20  metafunc(False, 
-00013430: 7072 696d 616c 732c 2074 616e 6765 6e74  primals, tangent
-00013440: 732c 2074 7261 6365 2c20 2a2a 6b77 6172  s, trace, **kwar
-00013450: 6773 290a 2020 2020 6966 2069 7369 6e73  gs).    if isins
-00013460: 7461 6e63 6528 6f75 745f 7072 696d 616c  tance(out_primal
-00013470: 732c 2053 6571 7565 6e63 6529 3a0a 2020  s, Sequence):.  
-00013480: 2020 2020 2020 7265 7475 726e 2073 6166        return saf
-00013490: 655f 6d61 7028 7061 6972 5f74 6f5f 6a76  e_map(pair_to_jv
-000134a0: 705f 6475 616c 2c20 7361 6665 5f7a 6970  p_dual, safe_zip
-000134b0: 286f 7574 5f70 7269 6d61 6c73 2c20 6f75  (out_primals, ou
-000134c0: 745f 7461 6e67 656e 7473 2929 0a20 2020  t_tangents)).   
-000134d0: 2072 6574 7572 6e20 4a56 5044 7561 6c28   return JVPDual(
-000134e0: 6f75 745f 7072 696d 616c 732c 206f 7574  out_primals, out
-000134f0: 5f74 616e 6765 6e74 7329 0a0a 0a6a 7670  _tangents)...jvp
-00013500: 5f69 6d70 6c73 5b54 7261 6e73 666f 726d  _impls[Transform
-00013510: 732e 4964 656e 7469 7479 4f70 5d20 3d20  s.IdentityOp] = 
-00013520: 5f69 6465 6e74 6974 795f 6361 6c6c 5f6a  _identity_call_j
-00013530: 7670 0a0a 0a64 6566 205f 766d 6170 5f63  vp...def _vmap_c
-00013540: 616c 6c5f 6a76 7028 6172 6773 3a20 4a56  all_jvp(args: JV
-00013550: 5044 7561 6c2c 2069 6e5f 6469 6d73 2c20  PDual, in_dims, 
-00013560: 6f75 745f 6469 6d73 2c20 6178 6973 5f73  out_dims, axis_s
-00013570: 697a 652c 2074 7261 6365 3a20 5472 6163  ize, trace: Trac
-00013580: 652c 202a 2a6b 7761 7267 7329 3a0a 2020  e, **kwargs):.  
-00013590: 2020 7072 696d 616c 732c 2074 616e 6765    primals, tange
-000135a0: 6e74 7320 3d20 7361 6665 5f7a 6970 282a  nts = safe_zip(*
-000135b0: 6172 6773 290a 2020 2020 696e 5f64 696d  args).    in_dim
-000135c0: 732c 205f 203d 2073 6166 655f 7a69 7028  s, _ = safe_zip(
-000135d0: 2a69 6e5f 6469 6d73 290a 2020 2020 6f75  *in_dims).    ou
-000135e0: 745f 6469 6d73 2c20 5f20 3d20 7361 6665  t_dims, _ = safe
-000135f0: 5f7a 6970 282a 6f75 745f 6469 6d73 290a  _zip(*out_dims).
-00013600: 2020 2020 766d 6170 7065 645f 7472 6163      vmapped_trac
-00013610: 6520 3d20 636f 6e73 7472 7563 745f 7472  e = construct_tr
-00013620: 6163 6528 2928 0a20 2020 2020 2020 2076  ace()(.        v
-00013630: 6d61 7028 7061 7274 6961 6c28 6576 616c  map(partial(eval
-00013640: 5f74 7261 6365 2c20 7472 6163 6529 2c20  _trace, trace), 
-00013650: 696e 5f64 696d 733d 696e 5f64 696d 732c  in_dims=in_dims,
-00013660: 206f 7574 5f64 696d 733d 6f75 745f 6469   out_dims=out_di
-00013670: 6d73 2c20 6178 6973 5f73 697a 653d 6178  ms, axis_size=ax
-00013680: 6973 5f73 697a 6529 2c20 2a70 7269 6d61  is_size), *prima
-00013690: 6c73 0a20 2020 2029 0a20 2020 2076 6d61  ls.    ).    vma
-000136a0: 7070 6564 5f66 756e 6320 3d20 7061 7274  pped_func = part
-000136b0: 6961 6c28 6576 616c 5f74 7261 6365 2c20  ial(eval_trace, 
-000136c0: 766d 6170 7065 645f 7472 6163 6529 0a20  vmapped_trace). 
-000136d0: 2020 206f 7574 5f70 7269 6d61 6c73 2c20     out_primals, 
-000136e0: 6f75 745f 7461 6e67 656e 7473 203d 206a  out_tangents = j
-000136f0: 7670 2876 6d61 7070 6564 5f66 756e 6329  vp(vmapped_func)
-00013700: 2870 7269 6d61 6c73 2c20 7461 6e67 656e  (primals, tangen
-00013710: 7473 2c20 2a2a 6b77 6172 6773 290a 2020  ts, **kwargs).  
-00013720: 2020 6966 2069 7369 6e73 7461 6e63 6528    if isinstance(
-00013730: 6f75 745f 7072 696d 616c 732c 2053 6571  out_primals, Seq
-00013740: 7565 6e63 6529 3a0a 2020 2020 2020 2020  uence):.        
-00013750: 7265 7475 726e 2073 6166 655f 6d61 7028  return safe_map(
-00013760: 7061 6972 5f74 6f5f 6a76 705f 6475 616c  pair_to_jvp_dual
-00013770: 2c20 7361 6665 5f7a 6970 286f 7574 5f70  , safe_zip(out_p
-00013780: 7269 6d61 6c73 2c20 6f75 745f 7461 6e67  rimals, out_tang
-00013790: 656e 7473 2929 0a20 2020 2072 6574 7572  ents)).    retur
-000137a0: 6e20 4a56 5044 7561 6c28 6f75 745f 7072  n JVPDual(out_pr
-000137b0: 696d 616c 732c 206f 7574 5f74 616e 6765  imals, out_tange
-000137c0: 6e74 7329 0a0a 0a6a 7670 5f69 6d70 6c73  nts)...jvp_impls
-000137d0: 5b54 7261 6e73 666f 726d 732e 566d 6170  [Transforms.Vmap
-000137e0: 4f70 5d20 3d20 5f76 6d61 705f 6361 6c6c  Op] = _vmap_call
-000137f0: 5f6a 7670 0a0a 0a64 6566 206a 7670 2866  _jvp...def jvp(f
-00013800: 756e 6329 3a0a 2020 2020 2222 224a 6163  unc):.    """Jac
-00013810: 6f62 6961 6e2d 7665 6374 6f72 2070 726f  obian-vector pro
-00013820: 6475 6374 2074 7261 6e73 666f 726d 2066  duct transform f
-00013830: 6f72 2061 2054 6875 6e64 6572 2066 756e  or a Thunder fun
-00013840: 6374 696f 6e2e 0a0a 2020 2020 4172 6773  ction...    Args
-00013850: 3a0a 2020 2020 2020 2020 6675 6e63 2028  :.        func (
-00013860: 4361 6c6c 6162 6c65 293a 2041 2054 6875  Callable): A Thu
-00013870: 6e64 6572 2066 756e 6374 696f 6e20 746f  nder function to
-00013880: 2062 6520 7472 616e 7366 6f72 6d65 642e   be transformed.
-00013890: 0a0a 2020 2020 5265 7475 726e 733a 0a20  ..    Returns:. 
-000138a0: 2020 2020 2020 2043 616c 6c61 626c 653a         Callable:
-000138b0: 2041 2066 756e 6374 696f 6e20 7468 6174   A function that
-000138c0: 2063 6f6d 7075 7465 7320 7468 6520 4a61   computes the Ja
-000138d0: 636f 6269 616e 2d76 6563 746f 7220 7072  cobian-vector pr
-000138e0: 6f64 7563 740a 2020 2020 2020 2020 2020  oduct.          
-000138f0: 2020 7461 6b69 6e67 2070 7269 6d61 6c73    taking primals
-00013900: 2061 6e64 2074 616e 6765 6e74 7320 6173   and tangents as
-00013910: 2061 7267 756d 656e 7473 2e0a 2020 2020   arguments..    
-00013920: 2222 220a 0a20 2020 2064 6566 2077 7261  """..    def wra
-00013930: 7070 6572 2870 7269 6d61 6c73 2c20 7461  pper(primals, ta
-00013940: 6e67 656e 7473 293a 0a20 2020 2020 2020  ngents):.       
-00013950: 2074 7261 6365 203d 2063 6f6e 7374 7275   trace = constru
-00013960: 6374 5f74 7261 6365 2829 2866 756e 632c  ct_trace()(func,
-00013970: 202a 7072 696d 616c 7329 0a20 2020 2020   *primals).     
-00013980: 2020 2072 6574 7572 6e20 6a76 705f 6361     return jvp_ca
-00013990: 6c6c 2870 7269 6d61 6c73 2c20 7461 6e67  ll(primals, tang
-000139a0: 656e 7473 2c20 6675 6e63 7469 6f6e 5f74  ents, function_t
-000139b0: 7261 6365 3d74 7261 6365 290a 0a20 2020  race=trace)..   
-000139c0: 2072 6574 7572 6e20 7772 6170 7065 720a   return wrapper.
-000139d0: 0a0a 2320 544f 444f 2054 6869 7320 6675  ..# TODO This fu
-000139e0: 6e63 7469 6f6e 2063 6f6d 6d65 6e74 6564  nction commented
-000139f0: 206f 7574 2062 6563 6175 7365 2069 7420   out because it 
-00013a00: 6361 6c6c 7320 6d61 6b65 5f74 7261 6365  calls make_trace
-00013a10: 642c 2077 6869 6368 2064 6f65 7320 6e6f  d, which does no
-00013a20: 7420 6578 6973 740a 2320 6465 6620 6a76  t exist.# def jv
-00013a30: 705f 6561 6765 7228 6675 6e63 2c20 7072  p_eager(func, pr
-00013a40: 696d 616c 732c 2074 616e 6765 6e74 732c  imals, tangents,
-00013a50: 2065 7865 6375 746f 723d 2274 6f72 6368   executor="torch
-00013a60: 2229 3a0a 2320 2020 2020 2222 2243 6f6d  "):.#     """Com
-00013a70: 7075 7465 7320 7468 6520 4a61 636f 6269  putes the Jacobi
-00013a80: 616e 2d76 6563 746f 7220 7072 6f64 7563  an-vector produc
-00013a90: 7420 6f66 2061 2054 6875 6e64 6572 2066  t of a Thunder f
-00013aa0: 756e 6374 696f 6e2e 0a0a 2320 2020 2020  unction...#     
-00013ab0: 4172 6773 3a0a 2320 2020 2020 2020 2020  Args:.#         
-00013ac0: 6675 6e63 2028 4361 6c6c 6162 6c65 293a  func (Callable):
-00013ad0: 2041 2054 6875 6e64 6572 2066 756e 6374   A Thunder funct
-00013ae0: 696f 6e20 746f 2062 6520 7472 616e 7366  ion to be transf
-00013af0: 6f72 6d65 642e 0a23 2020 2020 2020 2020  ormed..#        
-00013b00: 2070 7269 6d61 6c73 2028 5f74 7970 655f   primals (_type_
-00013b10: 293a 2050 7269 6d61 6c73 206f 6620 7468  ): Primals of th
-00013b20: 6520 6675 6e63 7469 6f6e 2e0a 2320 2020  e function..#   
-00013b30: 2020 2020 2020 7461 6e67 656e 7473 2028        tangents (
-00013b40: 5f74 7970 655f 293a 2054 616e 6765 6e74  _type_): Tangent
-00013b50: 7320 6f66 2074 6865 2066 756e 6374 696f  s of the functio
-00013b60: 6e2e 0a23 2020 2020 2020 2020 2065 7865  n..#         exe
-00013b70: 6375 746f 7220 2873 7472 2c20 6f70 7469  cutor (str, opti
-00013b80: 6f6e 616c 293a 2045 7865 6375 746f 7220  onal): Executor 
-00013b90: 746f 2075 7365 2e20 4465 6661 756c 7473  to use. Defaults
-00013ba0: 2074 6f20 2274 6f72 6368 222e 0a0a 2320   to "torch"...# 
-00013bb0: 2020 2020 5265 7475 726e 733a 0a23 2020      Returns:.#  
-00013bc0: 2020 2020 2020 2054 6865 2072 6573 756c         The resul
-00013bd0: 7420 6f66 2074 6865 204a 6163 6f62 6961  t of the Jacobia
-00013be0: 6e2d 7665 6374 6f72 2070 726f 6475 6374  n-vector product
-00013bf0: 2e0a 2320 2020 2020 2222 220a 2320 2020  ..#     """.#   
-00013c00: 2020 7472 6163 6520 3d20 6d61 6b65 5f74    trace = make_t
-00013c10: 7261 6365 2866 756e 632c 2065 7865 6375  race(func, execu
-00013c20: 746f 723d 6578 6563 7574 6f72 2c20 2a70  tor=executor, *p
-00013c30: 7269 6d61 6c73 290a 0a23 2020 2020 2064  rimals)..#     d
-00013c40: 6566 206a 7670 5f66 756e 6328 2a70 7269  ef jvp_func(*pri
-00013c50: 6d61 6c73 5f61 6e64 5f74 616e 6765 6e74  mals_and_tangent
-00013c60: 7329 3a0a 2320 2020 2020 2020 2020 5f70  s):.#         _p
-00013c70: 7269 6d61 6c73 2c20 5f74 616e 6765 6e74  rimals, _tangent
-00013c80: 7320 3d20 7072 696d 616c 735f 616e 645f  s = primals_and_
-00013c90: 7461 6e67 656e 7473 5b3a 206c 656e 2870  tangents[: len(p
-00013ca0: 7269 6d61 6c73 295d 2c20 7072 696d 616c  rimals)], primal
-00013cb0: 735f 616e 645f 7461 6e67 656e 7473 5b6c  s_and_tangents[l
-00013cc0: 656e 2870 7269 6d61 6c73 2920 3a5d 0a23  en(primals) :].#
-00013cd0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00013ce0: 5f6a 7670 5f63 616c 6c5f 6d65 7461 6675  _jvp_call_metafu
-00013cf0: 6e63 285f 7072 696d 616c 732c 205f 7461  nc(_primals, _ta
-00013d00: 6e67 656e 7473 2c20 7472 6163 652c 2064  ngents, trace, d
-00013d10: 6574 6163 6865 643d 4661 6c73 6529 0a0a  etached=False)..
-00013d20: 2320 2020 2020 6a76 705f 7472 6163 6520  #     jvp_trace 
-00013d30: 3d20 6d61 6b65 5f74 7261 6365 286a 7670  = make_trace(jvp
-00013d40: 5f66 756e 632c 2065 7865 6375 746f 723d  _func, executor=
-00013d50: 6578 6563 7574 6f72 2928 2a70 7269 6d61  executor)(*prima
-00013d60: 6c73 2c20 2a74 616e 6765 6e74 7329 0a23  ls, *tangents).#
-00013d70: 2020 2020 206a 7670 5f74 7261 6365 6420       jvp_traced 
-00013d80: 3d20 6d61 6b65 5f74 7261 6365 6428 7061  = make_traced(pa
-00013d90: 7274 6961 6c28 6576 616c 5f74 7261 6365  rtial(eval_trace
-00013da0: 2c20 6a76 705f 7472 6163 6529 2c20 6578  , jvp_trace), ex
-00013db0: 6563 7574 6f72 3d65 7865 6375 746f 7229  ecutor=executor)
-00013dc0: 0a23 2020 2020 2072 6574 7572 6e20 6a76  .#     return jv
-00013dd0: 705f 7472 6163 6564 282a 7072 696d 616c  p_traced(*primal
-00013de0: 732c 202a 7461 6e67 656e 7473 290a 0a0a  s, *tangents)...
-00013df0: 2320 564a 5020 7472 616e 7366 6f72 6d0a  # VJP transform.
-00013e00: 2320 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a  # =============.
-00013e10: 4064 6174 6163 6c61 7373 2866 726f 7a65  @dataclass(froze
-00013e20: 6e3d 5472 7565 290a 636c 6173 7320 564a  n=True).class VJ
-00013e30: 5044 7561 6c3a 0a20 2020 2022 2222 4120  PDual:.    """A 
-00013e40: 7061 6972 206f 6620 7072 696d 616c 2061  pair of primal a
-00013e50: 6e64 2073 6176 6564 2069 6e66 6f72 6d61  nd saved informa
-00013e60: 7469 6f6e 2066 6f72 2062 6163 6b77 6172  tion for backwar
-00013e70: 6420 2872 6573 6964 7561 6c73 292e 0a0a  d (residuals)...
-00013e80: 2020 2020 4172 6773 3a0a 2020 2020 2020      Args:.      
-00013e90: 2020 7072 696d 616c 2028 556e 696f 6e5b    primal (Union[
-00013ea0: 5072 6f78 792c 204e 756d 6265 725d 293a  Proxy, Number]):
-00013eb0: 2050 7269 6d61 6c20 7661 6c75 652c 2069   Primal value, i
-00013ec0: 2e65 2e2c 2074 6865 2076 616c 7565 2062  .e., the value b
-00013ed0: 6569 6e67 2064 6966 6665 7265 6e74 6961  eing differentia
-00013ee0: 7465 642e 0a20 2020 2020 2020 2072 6573  ted..        res
-00013ef0: 6964 7561 6c73 2028 5475 706c 655b 5072  iduals (Tuple[Pr
-00013f00: 6f78 792c 202e 2e2e 5d29 3a20 5265 7369  oxy, ...]): Resi
-00013f10: 6475 616c 732c 2069 2e65 2e2c 2074 6865  duals, i.e., the
-00013f20: 2076 616c 7565 7320 7468 6174 2061 7265   values that are
-00013f30: 0a20 2020 2020 2020 2020 2020 2073 6176  .            sav
-00013f40: 6564 2066 6f72 2074 6865 2062 6163 6b77  ed for the backw
-00013f50: 6172 642e 0a0a 2020 2020 5969 656c 6473  ard...    Yields
-00013f60: 3a0a 2020 2020 2020 2020 5475 706c 655b  :.        Tuple[
-00013f70: 5661 7269 6162 6c65 2c20 5475 706c 655b  Variable, Tuple[
-00013f80: 5661 7269 6162 6c65 2c20 2e2e 2e5d 2c20  Variable, ...], 
-00013f90: 4361 6c6c 6162 6c65 5d3a 2050 7269 6d61  Callable]: Prima
-00013fa0: 6c20 616e 6420 7265 7369 6475 616c 730a  l and residuals.
-00013fb0: 2020 2020 2222 220a 0a20 2020 2070 7269      """..    pri
-00013fc0: 6d61 6c3a 2050 726f 7879 207c 204e 756d  mal: Proxy | Num
-00013fd0: 6265 720a 2020 2020 7265 7369 6475 616c  ber.    residual
-00013fe0: 733a 2074 7570 6c65 5b50 726f 7879 2c20  s: tuple[Proxy, 
-00013ff0: 2e2e 2e5d 0a0a 2020 2020 6465 6620 5f5f  ...]..    def __
-00014000: 6974 6572 5f5f 2873 656c 6629 3a0a 2020  iter__(self):.  
-00014010: 2020 2020 2020 7969 656c 6420 7365 6c66        yield self
-00014020: 2e70 7269 6d61 6c0a 2020 2020 2020 2020  .primal.        
-00014030: 7969 656c 6420 7365 6c66 2e72 6573 6964  yield self.resid
-00014040: 7561 6c73 0a0a 0a63 6c61 7373 204e 6f50  uals...class NoP
-00014050: 756c 6c62 6163 6b3a 0a20 2020 2022 2222  ullback:.    """
-00014060: 4120 6475 6d6d 7920 7075 6c6c 6261 636b  A dummy pullback
-00014070: 2066 756e 6374 696f 6e20 7468 6174 2072   function that r
-00014080: 6574 7572 6e73 204e 6f6e 6520 6f72 2072  eturns None or r
-00014090: 6169 7365 7320 616e 2065 7272 6f72 2e22  aises an error."
-000140a0: 2222 0a0a 2020 2020 6465 6620 5f5f 696e  ""..    def __in
-000140b0: 6974 5f5f 2873 656c 662c 206e 756d 5f61  it__(self, num_a
-000140c0: 7267 733d 3029 3a0a 2020 2020 2020 2020  rgs=0):.        
-000140d0: 7365 6c66 2e6e 756d 5f61 7267 7320 3d20  self.num_args = 
-000140e0: 6e75 6d5f 6172 6773 0a0a 2020 2020 6465  num_args..    de
-000140f0: 6620 5f5f 6361 6c6c 5f5f 2873 656c 662c  f __call__(self,
-00014100: 202a 6172 6773 2c20 2a2a 6b77 6172 6773   *args, **kwargs
-00014110: 293a 0a20 2020 2020 2020 2069 6620 7365  ):.        if se
-00014120: 6c66 2e6e 756d 5f61 7267 7320 3e20 303a  lf.num_args > 0:
-00014130: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00014140: 7572 6e20 284e 6f6e 652c 2920 2a20 7365  urn (None,) * se
-00014150: 6c66 2e6e 756d 5f61 7267 730a 2020 2020  lf.num_args.    
-00014160: 2020 2020 7261 6973 6520 5275 6e74 696d      raise Runtim
-00014170: 6545 7272 6f72 2822 5075 6c6c 6261 636b  eError("Pullback
-00014180: 2063 616c 6c65 6420 6f6e 2061 206e 6f6e   called on a non
-00014190: 2d64 6966 6665 7265 6e74 6961 626c 6520  -differentiable 
-000141a0: 7379 6d62 6f6c 206f 7220 6120 636f 6e73  symbol or a cons
-000141b0: 7461 6e74 2e22 290a 0a0a 636c 6173 7320  tant.")...class 
-000141c0: 5a65 726f 4261 636b 7761 7264 3a0a 2020  ZeroBackward:.  
-000141d0: 2020 2222 2241 2068 656c 7065 7220 6261    """A helper ba
-000141e0: 636b 7761 7264 2066 756e 6374 696f 6e20  ckward function 
-000141f0: 7468 6174 2072 6574 7572 6e73 207a 6572  that returns zer
-00014200: 6f73 2e22 2222 0a0a 2020 2020 6465 6620  os."""..    def 
-00014210: 5f5f 696e 6974 5f5f 2873 656c 662c 206e  __init__(self, n
-00014220: 756d 5f61 7267 7329 3a0a 2020 2020 2020  um_args):.      
-00014230: 2020 7365 6c66 2e6e 756d 5f61 7267 7320    self.num_args 
-00014240: 3d20 6e75 6d5f 6172 6773 0a0a 2020 2020  = num_args..    
-00014250: 6465 6620 5f5f 6361 6c6c 5f5f 2873 656c  def __call__(sel
-00014260: 662c 202a 6172 6773 2c20 2a2a 6b77 6172  f, *args, **kwar
-00014270: 6773 293a 0a20 2020 2020 2020 2023 2041  gs):.        # A
-00014280: 7373 756d 696e 6720 7468 6174 2074 6865  ssuming that the
-00014290: 2066 6972 7374 2061 7267 756d 656e 7473   first arguments
-000142a0: 2061 7265 2074 6865 2066 6f72 7761 7264   are the forward
-000142b0: 2061 7267 756d 656e 7473 0a20 2020 2020   arguments.     
-000142c0: 2020 2066 6f72 7761 7264 5f61 7267 7320     forward_args 
-000142d0: 3d20 6172 6773 5b3a 2073 656c 662e 6e75  = args[: self.nu
-000142e0: 6d5f 6172 6773 5d0a 0a20 2020 2020 2020  m_args]..       
-000142f0: 2064 6566 207a 6572 6f73 5f6c 696b 6528   def zeros_like(
-00014300: 7829 3a0a 2020 2020 2020 2020 2020 2020  x):.            
-00014310: 6966 2069 7369 6e73 7461 6e63 6528 782c  if isinstance(x,
-00014320: 2054 656e 736f 7250 726f 7879 293a 0a20   TensorProxy):. 
-00014330: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-00014340: 6574 7572 6e20 6675 6c6c 5f6c 696b 6528  eturn full_like(
-00014350: 782c 2066 696c 6c5f 7661 6c75 653d 3029  x, fill_value=0)
-00014360: 0a20 2020 2020 2020 2020 2020 2065 6c69  .            eli
-00014370: 6620 6973 696e 7374 616e 6365 2878 2c20  f isinstance(x, 
-00014380: 4e75 6d62 6572 5072 6f78 7929 3a0a 2020  NumberProxy):.  
-00014390: 2020 2020 2020 2020 2020 2020 2020 7265                re
-000143a0: 7475 726e 2074 7970 6528 782e 7661 6c75  turn type(x.valu
-000143b0: 6529 2830 290a 2020 2020 2020 2020 2020  e)(0).          
-000143c0: 2020 656c 6966 2069 7369 6e73 7461 6e63    elif isinstanc
-000143d0: 6528 782c 204e 756d 6265 7229 3a0a 2020  e(x, Number):.  
-000143e0: 2020 2020 2020 2020 2020 2020 2020 7265                re
-000143f0: 7475 726e 2074 7970 6528 7829 2830 290a  turn type(x)(0).
-00014400: 2020 2020 2020 2020 2020 2020 656c 7365              else
-00014410: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00014420: 2020 7261 6973 6520 5661 6c75 6545 7272    raise ValueErr
-00014430: 6f72 2866 227a 6572 6f73 5f6c 696b 6520  or(f"zeros_like 
-00014440: 696e 7369 6465 205a 6572 6f42 6163 6b77  inside ZeroBackw
-00014450: 6172 6420 676f 7420 616e 2075 6e73 7570  ard got an unsup
-00014460: 706f 7274 6564 2074 7970 6520 7b74 7970  ported type {typ
-00014470: 6528 7829 7d22 290a 0a20 2020 2020 2020  e(x)}")..       
-00014480: 2072 6574 7572 6e20 7475 706c 6528 7a65   return tuple(ze
-00014490: 726f 735f 6c69 6b65 2861 7267 2920 666f  ros_like(arg) fo
-000144a0: 7220 6172 6720 696e 2066 6f72 7761 7264  r arg in forward
-000144b0: 5f61 7267 7329 0a0a 0a23 204d 6170 7069  _args)...# Mappi
-000144c0: 6e67 2066 726f 6d20 7379 6d62 6f6c 7320  ng from symbols 
-000144d0: 746f 2061 7567 6d65 6e74 6564 2070 7269  to augmented pri
-000144e0: 6d61 6c20 2866 6f72 7761 7264 2920 6675  mal (forward) fu
-000144f0: 6e63 7469 6f6e 7320 7573 6564 2069 6e20  nctions used in 
-00014500: 564a 500a 2320 5468 6520 6175 676d 656e  VJP.# The augmen
-00014510: 7465 645f 7072 696d 616c 2066 756e 6374  ted_primal funct
-00014520: 696f 6e20 7461 6b65 7320 7468 6520 7072  ion takes the pr
-00014530: 696d 616c 2076 616c 7565 7320 616e 6420  imal values and 
-00014540: 7265 7475 726e 7320 7468 6520 7072 696d  returns the prim
-00014550: 616c 0a23 2072 6573 756c 7420 616e 6420  al.# result and 
-00014560: 7468 6520 7265 7369 6475 616c 7320 2873  the residuals (s
-00014570: 6176 6564 2076 616c 7565 7320 666f 7220  aved values for 
-00014580: 7468 6520 6261 636b 7761 7264 292e 0a61  the backward)..a
-00014590: 7567 6d65 6e74 6564 5f66 6f72 7761 7264  ugmented_forward
-000145a0: 5f69 6d70 6c73 203d 207b 0a20 2020 2070  _impls = {.    p
-000145b0: 7269 6d73 2e50 7269 6d49 4473 2e41 434f  rims.PrimIDs.ACO
-000145c0: 533a 206c 616d 6264 6120 783a 2028 7072  S: lambda x: (pr
-000145d0: 696d 732e 6163 6f73 2878 292c 2028 782c  ims.acos(x), (x,
-000145e0: 2929 2c0a 2020 2020 7072 696d 732e 5072  )),.    prims.Pr
-000145f0: 696d 4944 732e 4143 4f53 483a 206c 616d  imIDs.ACOSH: lam
-00014600: 6264 6120 783a 2028 7072 696d 732e 6163  bda x: (prims.ac
-00014610: 6f73 6828 7829 2c20 2878 2c29 292c 0a20  osh(x), (x,)),. 
-00014620: 2020 2070 7269 6d73 2e50 7269 6d49 4473     prims.PrimIDs
-00014630: 2e41 5349 4e3a 206c 616d 6264 6120 783a  .ASIN: lambda x:
-00014640: 2028 7072 696d 732e 6173 696e 2878 292c   (prims.asin(x),
-00014650: 2028 782c 2929 2c0a 2020 2020 7072 696d   (x,)),.    prim
-00014660: 732e 5072 696d 4944 732e 4153 494e 483a  s.PrimIDs.ASINH:
-00014670: 206c 616d 6264 6120 783a 2028 7072 696d   lambda x: (prim
-00014680: 732e 6173 696e 6828 7829 2c20 2878 2c29  s.asinh(x), (x,)
-00014690: 292c 0a20 2020 2070 7269 6d73 2e50 7269  ),.    prims.Pri
-000146a0: 6d49 4473 2e41 5441 4e3a 206c 616d 6264  mIDs.ATAN: lambd
-000146b0: 6120 783a 2028 7072 696d 732e 6174 616e  a x: (prims.atan
-000146c0: 2878 292c 2028 782c 2929 2c0a 2020 2020  (x), (x,)),.    
-000146d0: 7072 696d 732e 5072 696d 4944 732e 4154  prims.PrimIDs.AT
-000146e0: 414e 483a 206c 616d 6264 6120 783a 2028  ANH: lambda x: (
-000146f0: 7072 696d 732e 6174 616e 6828 7829 2c20  prims.atanh(x), 
-00014700: 2878 2c29 292c 0a20 2020 2070 7269 6d73  (x,)),.    prims
-00014710: 2e50 7269 6d49 4473 2e41 5441 4e32 3a20  .PrimIDs.ATAN2: 
-00014720: 6c61 6d62 6461 2078 2c20 793a 2028 7072  lambda x, y: (pr
-00014730: 696d 732e 6174 616e 3228 782c 2079 292c  ims.atan2(x, y),
-00014740: 2028 782c 2079 2929 2c0a 2020 2020 7072   (x, y)),.    pr
-00014750: 696d 732e 5072 696d 4944 732e 434f 5348  ims.PrimIDs.COSH
-00014760: 3a20 6c61 6d62 6461 2078 3a20 2870 7269  : lambda x: (pri
-00014770: 6d73 2e63 6f73 6828 7829 2c20 2878 2c29  ms.cosh(x), (x,)
-00014780: 292c 0a20 2020 2070 7269 6d73 2e50 7269  ),.    prims.Pri
-00014790: 6d49 4473 2e44 4947 414d 4d41 3a20 6c61  mIDs.DIGAMMA: la
-000147a0: 6d62 6461 2078 3a20 2870 7269 6d73 2e64  mbda x: (prims.d
-000147b0: 6967 616d 6d61 2878 292c 2028 782c 2929  igamma(x), (x,))
-000147c0: 2c0a 2020 2020 7072 696d 732e 5072 696d  ,.    prims.Prim
-000147d0: 4944 732e 4552 4643 3a20 6c61 6d62 6461  IDs.ERFC: lambda
-000147e0: 2078 3a20 2870 7269 6d73 2e65 7266 6328   x: (prims.erfc(
-000147f0: 7829 2c20 2878 2c29 292c 0a20 2020 2070  x), (x,)),.    p
-00014800: 7269 6d73 2e50 7269 6d49 4473 2e45 5246  rims.PrimIDs.ERF
-00014810: 494e 563a 206c 616d 6264 6120 783a 2028  INV: lambda x: (
-00014820: 7072 696d 732e 6572 6669 6e76 2878 292c  prims.erfinv(x),
-00014830: 2028 7072 696d 732e 6572 6669 6e76 2878   (prims.erfinv(x
-00014840: 292c 2929 2c0a 2020 2020 7072 696d 732e  ),)),.    prims.
-00014850: 5072 696d 4944 732e 4552 4643 494e 563a  PrimIDs.ERFCINV:
-00014860: 206c 616d 6264 6120 783a 2028 7072 696d   lambda x: (prim
-00014870: 732e 6572 6663 696e 7628 7829 2c20 2870  s.erfcinv(x), (p
-00014880: 7269 6d73 2e65 7266 6369 6e76 2878 292c  rims.erfcinv(x),
-00014890: 2929 2c0a 2020 2020 7072 696d 732e 5072  )),.    prims.Pr
-000148a0: 696d 4944 732e 4558 5032 3a20 6c61 6d62  imIDs.EXP2: lamb
-000148b0: 6461 2078 3a20 2870 7269 6d73 2e65 7870  da x: (prims.exp
-000148c0: 3228 7829 2c20 2870 7269 6d73 2e65 7870  2(x), (prims.exp
-000148d0: 3228 7829 2c29 292c 0a20 2020 2070 7269  2(x),)),.    pri
-000148e0: 6d73 2e50 7269 6d49 4473 2e45 5850 4d31  ms.PrimIDs.EXPM1
-000148f0: 3a20 6c61 6d62 6461 2078 3a20 2870 7269  : lambda x: (pri
-00014900: 6d73 2e65 7870 6d31 2878 292c 2028 7072  ms.expm1(x), (pr
-00014910: 696d 732e 6578 706d 3128 7829 2c29 292c  ims.expm1(x),)),
-00014920: 0a20 2020 2070 7269 6d73 2e50 7269 6d49  .    prims.PrimI
-00014930: 4473 2e4c 4741 4d4d 413a 206c 616d 6264  Ds.LGAMMA: lambd
-00014940: 6120 783a 2028 7072 696d 732e 6c67 616d  a x: (prims.lgam
-00014950: 6d61 2878 292c 2028 782c 2929 2c0a 2020  ma(x), (x,)),.  
-00014960: 2020 7072 696d 732e 5072 696d 4944 732e    prims.PrimIDs.
-00014970: 4e44 5452 493a 206c 616d 6264 6120 783a  NDTRI: lambda x:
-00014980: 2028 7072 696d 732e 6e64 7472 6928 7829   (prims.ndtri(x)
-00014990: 2c20 2870 7269 6d73 2e6e 6474 7269 2878  , (prims.ndtri(x
-000149a0: 292c 2929 2c0a 2020 2020 7072 696d 732e  ),)),.    prims.
-000149b0: 5072 696d 4944 732e 5349 4e48 3a20 6c61  PrimIDs.SINH: la
-000149c0: 6d62 6461 2078 3a20 2870 7269 6d73 2e73  mbda x: (prims.s
-000149d0: 696e 6828 7829 2c20 2878 2c29 292c 0a20  inh(x), (x,)),. 
-000149e0: 2020 2070 7269 6d73 2e50 7269 6d49 4473     prims.PrimIDs
-000149f0: 2e53 5152 543a 206c 616d 6264 6120 783a  .SQRT: lambda x:
-00014a00: 2028 7072 696d 732e 7371 7274 2878 292c   (prims.sqrt(x),
-00014a10: 2028 7072 696d 732e 7371 7274 2878 292c   (prims.sqrt(x),
-00014a20: 2929 2c0a 2020 2020 7072 696d 732e 5072  )),.    prims.Pr
-00014a30: 696d 4944 732e 4c4f 4731 303a 206c 616d  imIDs.LOG10: lam
-00014a40: 6264 6120 783a 2028 7072 696d 732e 6c6f  bda x: (prims.lo
-00014a50: 6731 3028 7829 2c20 2878 2c29 292c 0a20  g10(x), (x,)),. 
-00014a60: 2020 2070 7269 6d73 2e50 7269 6d49 4473     prims.PrimIDs
-00014a70: 2e4c 4f47 3150 3a20 6c61 6d62 6461 2078  .LOG1P: lambda x
-00014a80: 3a20 2870 7269 6d73 2e6c 6f67 3170 2878  : (prims.log1p(x
-00014a90: 292c 2028 782c 2929 2c0a 2020 2020 7072  ), (x,)),.    pr
-00014aa0: 696d 732e 5072 696d 4944 732e 4c4f 4732  ims.PrimIDs.LOG2
+0000ef10: 7572 6e20 7665 6374 6f72 697a 6564 5f62  urn vectorized_b
+0000ef20: 6174 6368 6572 2870 7269 6d73 2e73 696e  atcher(prims.sin
+0000ef30: 2c20 6178 6973 5f73 697a 652c 2028 612c  , axis_size, (a,
+0000ef40: 2929 0a0a 0a64 6566 2063 6f73 5f76 6d61  ))...def cos_vma
+0000ef50: 7028 6178 6973 5f73 697a 653a 2069 6e74  p(axis_size: int
+0000ef60: 2c20 613a 2042 6174 6368 6564 5661 6c75  , a: BatchedValu
+0000ef70: 6529 202d 3e20 4261 7463 6865 6456 616c  e) -> BatchedVal
+0000ef80: 7565 3a0a 2020 2020 7265 7475 726e 2076  ue:.    return v
+0000ef90: 6563 746f 7269 7a65 645f 6261 7463 6865  ectorized_batche
+0000efa0: 7228 7072 696d 732e 636f 732c 2061 7869  r(prims.cos, axi
+0000efb0: 735f 7369 7a65 2c20 2861 2c29 290a 0a0a  s_size, (a,))...
+0000efc0: 6465 6620 6d75 6c5f 766d 6170 2861 7869  def mul_vmap(axi
+0000efd0: 735f 7369 7a65 3a20 696e 742c 2061 3a20  s_size: int, a: 
+0000efe0: 4261 7463 6865 6456 616c 7565 2c20 623a  BatchedValue, b:
+0000eff0: 2042 6174 6368 6564 5661 6c75 6529 202d   BatchedValue) -
+0000f000: 3e20 4261 7463 6865 6456 616c 7565 3a0a  > BatchedValue:.
+0000f010: 2020 2020 7265 7475 726e 2062 696e 6172      return binar
+0000f020: 795f 6f70 5f62 6174 6368 696e 675f 7275  y_op_batching_ru
+0000f030: 6c65 2870 7269 6d73 2e6d 756c 2c20 6178  le(prims.mul, ax
+0000f040: 6973 5f73 697a 652c 2028 612c 2062 2929  is_size, (a, b))
+0000f050: 0a0a 0a64 6566 2061 6464 5f76 6d61 7028  ...def add_vmap(
+0000f060: 6178 6973 5f73 697a 653a 2069 6e74 2c20  axis_size: int, 
+0000f070: 613a 2042 6174 6368 6564 5661 6c75 652c  a: BatchedValue,
+0000f080: 2062 3a20 4261 7463 6865 6456 616c 7565   b: BatchedValue
+0000f090: 2920 2d3e 2042 6174 6368 6564 5661 6c75  ) -> BatchedValu
+0000f0a0: 653a 0a20 2020 2072 6574 7572 6e20 6269  e:.    return bi
+0000f0b0: 6e61 7279 5f6f 705f 6261 7463 6869 6e67  nary_op_batching
+0000f0c0: 5f72 756c 6528 7072 696d 732e 6164 642c  _rule(prims.add,
+0000f0d0: 2061 7869 735f 7369 7a65 2c20 2861 2c20   axis_size, (a, 
+0000f0e0: 6229 290a 0a0a 6465 6620 7375 6d5f 766d  b))...def sum_vm
+0000f0f0: 6170 2861 7869 735f 7369 7a65 3a20 696e  ap(axis_size: in
+0000f100: 742c 2061 3a20 4261 7463 6865 6456 616c  t, a: BatchedVal
+0000f110: 7565 2c20 6469 6d73 3a20 5365 7175 656e  ue, dims: Sequen
+0000f120: 6365 5b69 6e74 5d2c 202a 2a6b 7761 7267  ce[int], **kwarg
+0000f130: 7329 202d 3e20 4261 7463 6865 6456 616c  s) -> BatchedVal
+0000f140: 7565 3a0a 2020 2020 6264 696d 203d 2061  ue:.    bdim = a
+0000f150: 2e62 6174 6368 5f64 696d 0a20 2020 2023  .batch_dim.    #
+0000f160: 2054 4f44 4f3a 2072 656d 6f76 6520 7468   TODO: remove th
+0000f170: 6973 2077 6865 6e20 6469 6d73 2062 6563  is when dims bec
+0000f180: 6f6d 6573 2061 206d 616e 6461 746f 7279  omes a mandatory
+0000f190: 206b 7761 7267 0a20 2020 2069 6620 6c65   kwarg.    if le
+0000f1a0: 6e28 6469 6d73 2920 3e20 303a 0a20 2020  n(dims) > 0:.   
+0000f1b0: 2020 2020 2064 696d 732c 205f 203d 2073       dims, _ = s
+0000f1c0: 6166 655f 7a69 7028 2a64 696d 7329 0a20  afe_zip(*dims). 
+0000f1d0: 2020 2064 696d 735f 6265 666f 7265 203d     dims_before =
+0000f1e0: 2074 7570 6c65 2865 6c20 666f 7220 656c   tuple(el for el
+0000f1f0: 2069 6e20 6469 6d73 2069 6620 656c 203c   in dims if el <
+0000f200: 2062 6469 6d29 0a20 2020 2064 696d 735f   bdim).    dims_
+0000f210: 6166 7465 7220 3d20 7475 706c 6528 656c  after = tuple(el
+0000f220: 202b 2031 2066 6f72 2065 6c20 696e 2064   + 1 for el in d
+0000f230: 696d 7320 6966 2065 6c20 3e3d 2062 6469  ims if el >= bdi
+0000f240: 6d29 0a20 2020 2062 6174 6368 6564 5f64  m).    batched_d
+0000f250: 696d 7320 3d20 6469 6d73 5f62 6566 6f72  ims = dims_befor
+0000f260: 6520 2b20 6469 6d73 5f61 6674 6572 0a20  e + dims_after. 
+0000f270: 2020 2072 6574 7572 6e20 7665 6374 6f72     return vector
+0000f280: 697a 6564 5f62 6174 6368 6572 2870 7269  ized_batcher(pri
+0000f290: 6d73 2e73 756d 2c20 6178 6973 5f73 697a  ms.sum, axis_siz
+0000f2a0: 652c 2028 612c 292c 2064 696d 733d 6261  e, (a,), dims=ba
+0000f2b0: 7463 6865 645f 6469 6d73 2c20 2a2a 6b77  tched_dims, **kw
+0000f2c0: 6172 6773 290a 0a0a 2320 544f 444f 3a20  args)...# TODO: 
+0000f2d0: 506c 6561 7365 2074 6573 7420 7468 6973  Please test this
+0000f2e0: 2065 7874 656e 7369 7665 6c79 0a64 6566   extensively.def
+0000f2f0: 2062 726f 6164 6361 7374 5f69 6e5f 6469   broadcast_in_di
+0000f300: 6d5f 766d 6170 280a 2020 2020 6178 6973  m_vmap(.    axis
+0000f310: 5f73 697a 653a 2069 6e74 2c20 613a 2042  _size: int, a: B
+0000f320: 6174 6368 6564 5661 6c75 652c 2073 6861  atchedValue, sha
+0000f330: 7065 3a20 5365 7175 656e 6365 5b42 6174  pe: Sequence[Bat
+0000f340: 6368 6564 5661 6c75 655d 2c20 6272 6f61  chedValue], broa
+0000f350: 6463 6173 745f 6469 6d65 6e73 696f 6e73  dcast_dimensions
+0000f360: 3a20 5365 7175 656e 6365 5b42 6174 6368  : Sequence[Batch
+0000f370: 6564 5661 6c75 655d 0a29 202d 3e20 4261  edValue].) -> Ba
+0000f380: 7463 6865 6456 616c 7565 3a0a 2020 2020  tchedValue:.    
+0000f390: 6264 696d 203d 2061 2e62 6174 6368 5f64  bdim = a.batch_d
+0000f3a0: 696d 0a20 2020 2023 2054 4f44 4f3a 2072  im.    # TODO: r
+0000f3b0: 656d 6f76 6520 7468 6973 2077 6865 6e20  emove this when 
+0000f3c0: 7368 6170 6520 616e 6420 6272 6f61 6463  shape and broadc
+0000f3d0: 6173 745f 6469 6d65 6e73 696f 6e73 2062  ast_dimensions b
+0000f3e0: 6563 6f6d 6520 6d61 6e64 6174 6f72 7920  ecome mandatory 
+0000f3f0: 6b77 6172 6773 0a20 2020 2073 6861 7065  kwargs.    shape
+0000f400: 2c20 5f20 3d20 7361 6665 5f7a 6970 282a  , _ = safe_zip(*
+0000f410: 7368 6170 6529 0a20 2020 2069 6620 6c65  shape).    if le
+0000f420: 6e28 6272 6f61 6463 6173 745f 6469 6d65  n(broadcast_dime
+0000f430: 6e73 696f 6e73 2920 3e20 303a 0a20 2020  nsions) > 0:.   
+0000f440: 2020 2020 2062 726f 6164 6361 7374 5f64       broadcast_d
+0000f450: 696d 656e 7369 6f6e 732c 205f 203d 2073  imensions, _ = s
+0000f460: 6166 655f 7a69 7028 2a62 726f 6164 6361  afe_zip(*broadca
+0000f470: 7374 5f64 696d 656e 7369 6f6e 7329 0a20  st_dimensions). 
+0000f480: 2020 2069 6620 6264 696d 2069 7320 6e6f     if bdim is no
+0000f490: 745f 6d61 7070 6564 3a0a 2020 2020 2020  t_mapped:.      
+0000f4a0: 2020 7265 7475 726e 2042 6174 6368 6564    return Batched
+0000f4b0: 5661 6c75 6528 7072 696d 732e 6272 6f61  Value(prims.broa
+0000f4c0: 6463 6173 745f 696e 5f64 696d 2861 2e76  dcast_in_dim(a.v
+0000f4d0: 616c 7565 2c20 7368 6170 652c 2062 726f  alue, shape, bro
+0000f4e0: 6164 6361 7374 5f64 696d 656e 7369 6f6e  adcast_dimension
+0000f4f0: 7329 2c20 6264 696d 290a 2020 2020 656c  s), bdim).    el
+0000f500: 7365 3a0a 2020 2020 2020 2020 6e65 775f  se:.        new_
+0000f510: 6264 696d 203d 2062 6469 6d20 2b20 7375  bdim = bdim + su
+0000f520: 6d28 3120 666f 7220 6469 6d20 696e 2062  m(1 for dim in b
+0000f530: 726f 6164 6361 7374 5f64 696d 656e 7369  roadcast_dimensi
+0000f540: 6f6e 7320 6966 2064 696d 203c 2062 6469  ons if dim < bdi
+0000f550: 6d29 0a20 2020 2020 2020 206e 6577 5f73  m).        new_s
+0000f560: 6861 7065 203d 206c 6973 7428 7368 6170  hape = list(shap
+0000f570: 6529 0a20 2020 2020 2020 206e 6577 5f73  e).        new_s
+0000f580: 6861 7065 2e69 6e73 6572 7428 6e65 775f  hape.insert(new_
+0000f590: 6264 696d 2c20 6178 6973 5f73 697a 6529  bdim, axis_size)
+0000f5a0: 0a20 2020 2020 2020 206e 6577 5f62 726f  .        new_bro
+0000f5b0: 6164 6361 7374 5f64 696d 656e 7369 6f6e  adcast_dimension
+0000f5c0: 7320 3d20 2830 2c29 202b 2074 7570 6c65  s = (0,) + tuple
+0000f5d0: 2864 696d 202b 2031 2069 6620 6469 6d20  (dim + 1 if dim 
+0000f5e0: 3e3d 2062 6469 6d20 656c 7365 2064 696d  >= bdim else dim
+0000f5f0: 2066 6f72 2064 696d 2069 6e20 6272 6f61   for dim in broa
+0000f600: 6463 6173 745f 6469 6d65 6e73 696f 6e73  dcast_dimensions
+0000f610: 290a 2020 2020 2020 2020 6966 2062 726f  ).        if bro
+0000f620: 6164 6361 7374 5f64 696d 656e 7369 6f6e  adcast_dimension
+0000f630: 7320 3d3d 2028 293a 0a20 2020 2020 2020  s == ():.       
+0000f640: 2020 2020 206e 6577 5f62 726f 6164 6361       new_broadca
+0000f650: 7374 5f64 696d 656e 7369 6f6e 7320 3d20  st_dimensions = 
+0000f660: 2829 0a20 2020 2020 2020 2072 6574 7572  ().        retur
+0000f670: 6e20 4261 7463 6865 6456 616c 7565 2870  n BatchedValue(p
+0000f680: 7269 6d73 2e62 726f 6164 6361 7374 5f69  rims.broadcast_i
+0000f690: 6e5f 6469 6d28 612e 7661 6c75 652c 206e  n_dim(a.value, n
+0000f6a0: 6577 5f73 6861 7065 2c20 6e65 775f 6272  ew_shape, new_br
+0000f6b0: 6f61 6463 6173 745f 6469 6d65 6e73 696f  oadcast_dimensio
+0000f6c0: 6e73 292c 206e 6577 5f62 6469 6d29 0a0a  ns), new_bdim)..
+0000f6d0: 0a76 6d61 705f 696d 706c 733a 2064 6963  .vmap_impls: dic
+0000f6e0: 745b 7072 696d 732e 5379 6d62 6f6c 2c20  t[prims.Symbol, 
+0000f6f0: 4361 6c6c 6162 6c65 5d20 3d20 6469 6374  Callable] = dict
+0000f700: 2829 0a0a 0a64 6566 2075 6e77 7261 705f  ()...def unwrap_
+0000f710: 6f6e 655f 6c65 7665 6c5f 6f66 5f73 7562  one_level_of_sub
+0000f720: 7379 6d62 6f6c 7328 7472 6163 6529 3a0a  symbols(trace):.
+0000f730: 2020 2020 6e65 775f 7379 6d62 6f6c 735f      new_symbols_
+0000f740: 6974 6572 203d 2028 0a20 2020 2020 2020  iter = (.       
+0000f750: 2062 6f75 6e64 5f73 796d 626f 6c2e 7375   bound_symbol.su
+0000f760: 6273 796d 626f 6c73 2069 6620 6c65 6e28  bsymbols if len(
+0000f770: 626f 756e 645f 7379 6d62 6f6c 2e73 7562  bound_symbol.sub
+0000f780: 7379 6d62 6f6c 7329 203e 2030 2065 6c73  symbols) > 0 els
+0000f790: 6520 5b62 6f75 6e64 5f73 796d 626f 6c5d  e [bound_symbol]
+0000f7a0: 0a20 2020 2020 2020 2066 6f72 2062 6f75  .        for bou
+0000f7b0: 6e64 5f73 796d 626f 6c20 696e 2074 7261  nd_symbol in tra
+0000f7c0: 6365 2e62 6f75 6e64 5f73 796d 626f 6c73  ce.bound_symbols
+0000f7d0: 0a20 2020 2029 0a20 2020 206e 6577 5f73  .    ).    new_s
+0000f7e0: 796d 626f 6c73 203d 206c 6973 7428 6368  ymbols = list(ch
+0000f7f0: 6169 6e2e 6672 6f6d 5f69 7465 7261 626c  ain.from_iterabl
+0000f800: 6528 6e65 775f 7379 6d62 6f6c 735f 6974  e(new_symbols_it
+0000f810: 6572 2929 0a20 2020 2074 7261 6365 2e62  er)).    trace.b
+0000f820: 6f75 6e64 5f73 796d 626f 6c73 203d 206e  ound_symbols = n
+0000f830: 6577 5f73 796d 626f 6c73 0a20 2020 2072  ew_symbols.    r
+0000f840: 6574 7572 6e20 7472 6163 650a 0a0a 6465  eturn trace...de
+0000f850: 6620 6465 636f 6d70 6f73 6564 5f66 6e5f  f decomposed_fn_
+0000f860: 766d 6170 5f72 756c 6528 6178 6973 5f73  vmap_rule(axis_s
+0000f870: 697a 652c 202a 6172 6773 2c20 666e 2c20  ize, *args, fn, 
+0000f880: 2a2a 6b77 6172 6773 293a 0a20 2020 2061  **kwargs):.    a
+0000f890: 7267 732c 2069 6e5f 6469 6d73 203d 2075  rgs, in_dims = u
+0000f8a0: 6e7a 6970 3228 6172 6773 290a 2020 2020  nzip2(args).    
+0000f8b0: 756e 6261 7463 6865 645f 6172 6773 203d  unbatched_args =
+0000f8c0: 2074 7265 655f 6d61 7028 6c61 6d62 6461   tree_map(lambda
+0000f8d0: 2078 3a20 7265 6d6f 7665 5f62 6174 6368   x: remove_batch
+0000f8e0: 5f64 696d 2878 2920 6966 2069 7369 6e73  _dim(x) if isins
+0000f8f0: 7461 6e63 6528 782c 2054 656e 736f 7250  tance(x, TensorP
+0000f900: 726f 7879 2920 656c 7365 2078 2c20 6172  roxy) else x, ar
+0000f910: 6773 290a 2020 2020 7472 6163 6520 3d20  gs).    trace = 
+0000f920: 636f 6e73 7472 7563 745f 7472 6163 6528  construct_trace(
+0000f930: 2928 666e 2c20 2a75 6e62 6174 6368 6564  )(fn, *unbatched
+0000f940: 5f61 7267 732c 202a 2a6b 7761 7267 7329  _args, **kwargs)
+0000f950: 0a20 2020 2074 7261 6365 203d 2075 6e77  .    trace = unw
+0000f960: 7261 705f 6f6e 655f 6c65 7665 6c5f 6f66  rap_one_level_of
+0000f970: 5f73 7562 7379 6d62 6f6c 7328 7472 6163  _subsymbols(trac
+0000f980: 6529 0a20 2020 206f 7574 7320 3d20 5f76  e).    outs = _v
+0000f990: 6d61 705f 6361 6c6c 5f6d 6574 6166 756e  map_call_metafun
+0000f9a0: 6328 4661 6c73 652c 2061 7267 732c 2069  c(False, args, i
+0000f9b0: 6e5f 6469 6d73 2c20 302c 2061 7869 735f  n_dims, 0, axis_
+0000f9c0: 7369 7a65 2c20 6675 6e63 7469 6f6e 5f74  size, function_t
+0000f9d0: 7261 6365 3d74 7261 6365 2c20 2a2a 6b77  race=trace, **kw
+0000f9e0: 6172 6773 290a 2020 2020 6966 2069 7369  args).    if isi
+0000f9f0: 6e73 7461 6e63 6528 6f75 7473 2c20 5365  nstance(outs, Se
+0000fa00: 7175 656e 6365 293a 0a20 2020 2020 2020  quence):.       
+0000fa10: 206f 7574 5f64 696d 7320 3d20 2830 2c29   out_dims = (0,)
+0000fa20: 202a 206c 656e 286f 7574 7329 0a20 2020   * len(outs).   
+0000fa30: 2020 2020 2072 6574 7572 6e20 7361 6665       return safe
+0000fa40: 5f6d 6170 2870 6169 725f 746f 5f62 6174  _map(pair_to_bat
+0000fa50: 6368 6564 5f76 616c 7565 2c20 7361 6665  ched_value, safe
+0000fa60: 5f7a 6970 286f 7574 732c 206f 7574 5f64  _zip(outs, out_d
+0000fa70: 696d 7329 290a 2020 2020 7265 7475 726e  ims)).    return
+0000fa80: 2042 6174 6368 6564 5661 6c75 6528 6f75   BatchedValue(ou
+0000fa90: 7473 2c20 3029 0a0a 0a76 6d61 705f 696d  ts, 0)...vmap_im
+0000faa0: 706c 735b 7072 696d 732e 5072 696d 4944  pls[prims.PrimID
+0000fab0: 732e 5349 4e5d 203d 2073 696e 5f76 6d61  s.SIN] = sin_vma
+0000fac0: 700a 766d 6170 5f69 6d70 6c73 5b70 7269  p.vmap_impls[pri
+0000fad0: 6d73 2e50 7269 6d49 4473 2e43 4f53 5d20  ms.PrimIDs.COS] 
+0000fae0: 3d20 636f 735f 766d 6170 0a76 6d61 705f  = cos_vmap.vmap_
+0000faf0: 696d 706c 735b 7072 696d 732e 5072 696d  impls[prims.Prim
+0000fb00: 4944 732e 4d55 4c5d 203d 206d 756c 5f76  IDs.MUL] = mul_v
+0000fb10: 6d61 700a 766d 6170 5f69 6d70 6c73 5b70  map.vmap_impls[p
+0000fb20: 7269 6d73 2e50 7269 6d49 4473 2e41 4444  rims.PrimIDs.ADD
+0000fb30: 5d20 3d20 6164 645f 766d 6170 0a76 6d61  ] = add_vmap.vma
+0000fb40: 705f 696d 706c 735b 7072 696d 732e 5072  p_impls[prims.Pr
+0000fb50: 696d 4944 732e 5355 4d5d 203d 2073 756d  imIDs.SUM] = sum
+0000fb60: 5f76 6d61 700a 766d 6170 5f69 6d70 6c73  _vmap.vmap_impls
+0000fb70: 5b70 7269 6d73 2e50 7269 6d49 4473 2e42  [prims.PrimIDs.B
+0000fb80: 524f 4144 4341 5354 5f49 4e5f 4449 4d5d  ROADCAST_IN_DIM]
+0000fb90: 203d 2062 726f 6164 6361 7374 5f69 6e5f   = broadcast_in_
+0000fba0: 6469 6d5f 766d 6170 0a0a 0a64 6566 2076  dim_vmap...def v
+0000fbb0: 6d61 705f 7379 6d62 6f6c 5f6d 6170 7065  map_symbol_mappe
+0000fbc0: 7228 7379 6d62 6f6c 3a20 7072 696d 732e  r(symbol: prims.
+0000fbd0: 5379 6d62 6f6c 2c20 2a2c 2061 7869 735f  Symbol, *, axis_
+0000fbe0: 7369 7a65 3a20 696e 7429 3a0a 2020 2020  size: int):.    
+0000fbf0: 2222 224d 6170 7320 6120 7379 6d62 6f6c  """Maps a symbol
+0000fc00: 2074 6f20 6120 766d 6170 2066 756e 6374   to a vmap funct
+0000fc10: 696f 6e20 7468 6174 2065 7661 6c75 6174  ion that evaluat
+0000fc20: 6573 2069 742e 0a0a 2020 2020 4172 6773  es it...    Args
+0000fc30: 3a0a 2020 2020 2020 2020 7379 6d62 6f6c  :.        symbol
+0000fc40: 2028 7072 696d 732e 5379 6d62 6f6c 293a   (prims.Symbol):
+0000fc50: 2053 796d 626f 6c20 746f 2065 7661 6c75   Symbol to evalu
+0000fc60: 6174 652e 0a0a 2020 2020 5261 6973 6573  ate...    Raises
+0000fc70: 3a0a 2020 2020 2020 2020 4e6f 7449 6d70  :.        NotImp
+0000fc80: 6c65 6d65 6e74 6564 4572 726f 723a 2049  lementedError: I
+0000fc90: 6620 7468 6520 766d 6170 2066 6f72 2074  f the vmap for t
+0000fca0: 6865 2073 796d 626f 6c20 6973 206e 6f74  he symbol is not
+0000fcb0: 2069 6d70 6c65 6d65 6e74 6564 2e0a 0a20   implemented... 
+0000fcc0: 2020 2052 6574 7572 6e73 3a0a 2020 2020     Returns:.    
+0000fcd0: 2020 2020 4361 6c6c 6162 6c65 3a20 766d      Callable: vm
+0000fce0: 6170 2066 756e 6374 696f 6e20 7468 6174  ap function that
+0000fcf0: 2065 7661 6c75 6174 6573 2074 6865 2073   evaluates the s
+0000fd00: 796d 626f 6c2e 0a20 2020 2022 2222 0a0a  ymbol..    """..
+0000fd10: 2020 2020 6465 6620 7772 6170 5f61 7267      def wrap_arg
+0000fd20: 2878 293a 0a20 2020 2020 2020 2069 6620  (x):.        if 
+0000fd30: 6973 696e 7374 616e 6365 2878 2c20 4261  isinstance(x, Ba
+0000fd40: 7463 6865 6456 616c 7565 293a 0a20 2020  tchedValue):.   
+0000fd50: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0000fd60: 780a 2020 2020 2020 2020 656c 6966 2069  x.        elif i
+0000fd70: 7369 6e73 7461 6e63 6528 782c 2028 4e75  sinstance(x, (Nu
+0000fd80: 6d62 6572 2c20 4e75 6d62 6572 5072 6f78  mber, NumberProx
+0000fd90: 7929 293a 0a20 2020 2020 2020 2020 2020  y)):.           
+0000fda0: 2072 6574 7572 6e20 4261 7463 6865 6456   return BatchedV
+0000fdb0: 616c 7565 2878 2c20 6e6f 745f 6d61 7070  alue(x, not_mapp
+0000fdc0: 6564 290a 2020 2020 2020 2020 656c 7365  ed).        else
+0000fdd0: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
+0000fde0: 6973 6520 5661 6c75 6545 7272 6f72 2866  ise ValueError(f
+0000fdf0: 2276 6d61 7020 7772 6170 5f61 7267 2067  "vmap wrap_arg g
+0000fe00: 6f74 2061 6e20 756e 7375 7070 6f72 7465  ot an unsupporte
+0000fe10: 6420 7479 7065 207b 7479 7065 2878 297d  d type {type(x)}
+0000fe20: 2229 0a0a 2020 2020 6966 2073 796d 626f  ")..    if symbo
+0000fe30: 6c2e 6172 655f 616c 6c5f 6172 6773 5f63  l.are_all_args_c
+0000fe40: 6f6e 7374 616e 743a 0a0a 2020 2020 2020  onstant:..      
+0000fe50: 2020 6465 6620 5f76 6d61 705f 696d 706c    def _vmap_impl
+0000fe60: 5f63 6f6e 7374 2873 796d 626f 6c2c 202a  _const(symbol, *
+0000fe70: 6172 6773 2c20 2a2a 6b77 6172 6773 293a  args, **kwargs):
+0000fe80: 0a20 2020 2020 2020 2020 2020 206f 7574  .            out
+0000fe90: 203d 2073 796d 626f 6c5f 746f 5f65 7661   = symbol_to_eva
+0000fea0: 6c28 7379 6d62 6f6c 2928 2a61 7267 732c  l(symbol)(*args,
+0000feb0: 202a 2a6b 7761 7267 7329 0a0a 2020 2020   **kwargs)..    
+0000fec0: 2020 2020 2020 2020 6966 2069 7369 6e73          if isins
+0000fed0: 7461 6e63 6528 6f75 742c 2053 6571 7565  tance(out, Seque
+0000fee0: 6e63 6529 3a0a 2020 2020 2020 2020 2020  nce):.          
+0000fef0: 2020 2020 2020 7265 7475 726e 2073 6166        return saf
+0000ff00: 655f 6d61 7028 7061 6972 5f74 6f5f 6261  e_map(pair_to_ba
+0000ff10: 7463 6865 645f 7661 6c75 652c 2073 6166  tched_value, saf
+0000ff20: 655f 7a69 7028 6172 6773 2c20 5b6e 6f74  e_zip(args, [not
+0000ff30: 5f6d 6170 7065 645d 202a 206c 656e 286f  _mapped] * len(o
+0000ff40: 7574 2929 290a 0a20 2020 2020 2020 2020  ut)))..         
+0000ff50: 2020 2072 6574 7572 6e20 4261 7463 6865     return Batche
+0000ff60: 6456 616c 7565 286f 7574 2c20 6e6f 745f  dValue(out, not_
+0000ff70: 6d61 7070 6564 290a 0a20 2020 2020 2020  mapped)..       
+0000ff80: 2072 6574 7572 6e20 7061 7274 6961 6c28   return partial(
+0000ff90: 5f76 6d61 705f 696d 706c 5f63 6f6e 7374  _vmap_impl_const
+0000ffa0: 2c20 7379 6d62 6f6c 290a 0a20 2020 2076  , symbol)..    v
+0000ffb0: 6d61 705f 696d 706c 203d 2076 6d61 705f  map_impl = vmap_
+0000ffc0: 696d 706c 732e 6765 7428 7379 6d62 6f6c  impls.get(symbol
+0000ffd0: 2e73 796d 2e69 6429 0a20 2020 2069 6620  .sym.id).    if 
+0000ffe0: 766d 6170 5f69 6d70 6c20 6973 204e 6f6e  vmap_impl is Non
+0000fff0: 653a 0a20 2020 2020 2020 2069 6620 6c65  e:.        if le
+00010000: 6e28 7379 6d62 6f6c 2e73 7562 7379 6d62  n(symbol.subsymb
+00010010: 6f6c 7329 203e 2030 3a0a 2020 2020 2020  ols) > 0:.      
+00010020: 2020 2020 2020 766d 6170 5f69 6d70 6c20        vmap_impl 
+00010030: 3d20 7061 7274 6961 6c28 6465 636f 6d70  = partial(decomp
+00010040: 6f73 6564 5f66 6e5f 766d 6170 5f72 756c  osed_fn_vmap_rul
+00010050: 652c 2066 6e3d 7379 6d62 6f6c 2e73 796d  e, fn=symbol.sym
+00010060: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
+00010070: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+00010080: 6520 4e6f 7449 6d70 6c65 6d65 6e74 6564  e NotImplemented
+00010090: 4572 726f 7228 6622 766d 6170 2066 6f72  Error(f"vmap for
+000100a0: 207b 7379 6d62 6f6c 2e73 796d 2e69 647d   {symbol.sym.id}
+000100b0: 2069 7320 6e6f 7420 696d 706c 656d 656e   is not implemen
+000100c0: 7465 6422 290a 0a20 2020 2064 6566 205f  ted")..    def _
+000100d0: 766d 6170 5f69 6d70 6c28 2a61 7267 732c  vmap_impl(*args,
+000100e0: 202a 2a6b 7761 7267 7329 3a0a 2020 2020   **kwargs):.    
+000100f0: 2020 2020 6172 6773 203d 2074 7265 655f      args = tree_
+00010100: 6d61 7028 7772 6170 5f61 7267 2c20 6172  map(wrap_arg, ar
+00010110: 6773 290a 2020 2020 2020 2020 6173 7365  gs).        asse
+00010120: 7274 2061 6c6c 2869 7369 6e73 7461 6e63  rt all(isinstanc
+00010130: 6528 6172 672c 2042 6174 6368 6564 5661  e(arg, BatchedVa
+00010140: 6c75 6529 2066 6f72 2061 7267 2069 6e20  lue) for arg in 
+00010150: 7472 6565 5f66 6c61 7474 656e 2861 7267  tree_flatten(arg
+00010160: 7329 5b30 5d29 0a20 2020 2020 2020 2072  s)[0]).        r
+00010170: 6574 7572 6e20 766d 6170 5f69 6d70 6c28  eturn vmap_impl(
+00010180: 6178 6973 5f73 697a 652c 202a 6172 6773  axis_size, *args
+00010190: 2c20 2a2a 6b77 6172 6773 290a 0a20 2020  , **kwargs)..   
+000101a0: 2072 6574 7572 6e20 5f76 6d61 705f 696d   return _vmap_im
+000101b0: 706c 0a0a 0a64 6566 2072 656d 6f76 655f  pl...def remove_
+000101c0: 6261 7463 685f 6469 6d28 7465 6e73 6f72  batch_dim(tensor
+000101d0: 3a20 5465 6e73 6f72 5072 6f78 792c 2062  : TensorProxy, b
+000101e0: 6174 6368 5f64 696d 3a20 696e 7420 3d20  atch_dim: int = 
+000101f0: 3029 202d 3e20 5465 6e73 6f72 5072 6f78  0) -> TensorProx
+00010200: 793a 0a20 2020 2022 2222 5265 6d6f 7665  y:.    """Remove
+00010210: 7320 7468 6520 6261 7463 6820 6469 6d65  s the batch dime
+00010220: 6e73 696f 6e20 6672 6f6d 2061 2074 656e  nsion from a ten
+00010230: 736f 722e 0a0a 2020 2020 4172 6773 3a0a  sor...    Args:.
+00010240: 2020 2020 2020 2020 7465 6e73 6f72 2028          tensor (
+00010250: 5465 6e73 6f72 5072 6f78 7929 3a20 5465  TensorProxy): Te
+00010260: 6e73 6f72 2074 6f20 7265 6d6f 7665 2074  nsor to remove t
+00010270: 6865 2062 6174 6368 2064 696d 656e 7369  he batch dimensi
+00010280: 6f6e 2066 726f 6d2e 0a0a 2020 2020 5265  on from...    Re
+00010290: 7475 726e 733a 0a20 2020 2020 2020 2054  turns:.        T
+000102a0: 656e 736f 7250 726f 7879 3a20 5465 6e73  ensorProxy: Tens
+000102b0: 6f72 2077 6974 6820 7468 6520 6261 7463  or with the batc
+000102c0: 6820 6469 6d65 6e73 696f 6e20 7265 6d6f  h dimension remo
+000102d0: 7665 642e 0a20 2020 2022 2222 0a20 2020  ved..    """.   
+000102e0: 206e 6577 5f73 6861 7065 203d 2074 656e   new_shape = ten
+000102f0: 736f 722e 7368 6170 655b 3a62 6174 6368  sor.shape[:batch
+00010300: 5f64 696d 5d20 2b20 7465 6e73 6f72 2e73  _dim] + tensor.s
+00010310: 6861 7065 5b62 6174 6368 5f64 696d 202b  hape[batch_dim +
+00010320: 2031 203a 5d0a 2020 2020 7265 7475 726e   1 :].    return
+00010330: 2054 656e 736f 7250 726f 7879 286c 696b   TensorProxy(lik
+00010340: 653d 7465 6e73 6f72 2c20 7368 6170 653d  e=tensor, shape=
+00010350: 6e65 775f 7368 6170 6529 0a0a 0a23 2054  new_shape)...# T
+00010360: 4f44 4f3a 2069 6e20 4a41 5820 6172 6773  ODO: in JAX args
+00010370: 2c20 696e 5f64 696d 7320 6172 6520 666c  , in_dims are fl
+00010380: 6174 7465 6e65 6420 7468 6520 7361 6d65  attened the same
+00010390: 2077 6179 0a23 2054 4f44 4f3a 2069 6e20   way.# TODO: in 
+000103a0: 4a41 5820 6f75 745f 6469 6d73 2061 7265  JAX out_dims are
+000103b0: 2066 6c61 7474 656e 6564 2061 7320 7765   flattened as we
+000103c0: 6c6c 0a64 6566 205f 766d 6170 5f63 616c  ll.def _vmap_cal
+000103d0: 6c5f 6d65 7461 6675 6e63 2864 6574 6163  l_metafunc(detac
+000103e0: 6865 643a 2062 6f6f 6c2c 2061 7267 732c  hed: bool, args,
+000103f0: 2069 6e5f 6469 6d73 2c20 6f75 745f 6469   in_dims, out_di
+00010400: 6d73 2c20 6178 6973 5f73 697a 652c 2066  ms, axis_size, f
+00010410: 756e 6374 696f 6e5f 7472 6163 653a 2054  unction_trace: T
+00010420: 7261 6365 2c20 2a2a 6b77 6172 6773 293a  race, **kwargs):
+00010430: 0a20 2020 2022 2222 4d65 7461 6675 6e63  .    """Metafunc
+00010440: 7469 6f6e 2066 6f72 2076 6d61 7020 6361  tion for vmap ca
+00010450: 6c6c 2e0a 0a20 2020 2041 7267 733a 0a20  ll...    Args:. 
+00010460: 2020 2020 2020 2064 6574 6163 6865 6420         detached 
+00010470: 2862 6f6f 6c29 3a20 5768 6574 6865 7220  (bool): Whether 
+00010480: 746f 2064 6574 6163 6820 7468 6520 7472  to detach the tr
+00010490: 6163 652e 0a20 2020 2020 2020 2061 7267  ace..        arg
+000104a0: 7320 2854 7570 6c65 5b50 726f 7879 5d29  s (Tuple[Proxy])
+000104b0: 3a20 4172 6775 6d65 6e74 7320 746f 2074  : Arguments to t
+000104c0: 6865 2066 756e 6374 696f 6e2e 0a20 2020  he function..   
+000104d0: 2020 2020 2069 6e5f 6469 6d73 2028 5475       in_dims (Tu
+000104e0: 706c 655b 696e 745d 293a 2042 6174 6368  ple[int]): Batch
+000104f0: 2064 696d 656e 7369 6f6e 2066 6f72 2065   dimension for e
+00010500: 6163 6820 6172 6775 6d65 6e74 2e0a 2020  ach argument..  
+00010510: 2020 2020 2020 6f75 745f 6469 6d73 2028        out_dims (
+00010520: 5475 706c 655b 696e 745d 293a 2042 6174  Tuple[int]): Bat
+00010530: 6368 2064 696d 656e 7369 6f6e 2066 6f72  ch dimension for
+00010540: 2072 6574 7572 6e20 7661 6c75 6573 2e0a   return values..
+00010550: 2020 2020 2020 2020 6675 6e63 7469 6f6e          function
+00010560: 5f74 7261 6365 2028 5472 6163 6529 3a20  _trace (Trace): 
+00010570: 5472 6163 6520 746f 2075 7365 2066 6f72  Trace to use for
+00010580: 2074 6865 2066 756e 6374 696f 6e2e 0a20   the function.. 
+00010590: 2020 2020 2020 206b 7761 7267 733a 204b         kwargs: K
+000105a0: 6579 776f 7264 2061 7267 756d 656e 7473  eyword arguments
+000105b0: 2e0a 0a20 2020 2052 6169 7365 733a 0a20  ...    Raises:. 
+000105c0: 2020 2020 2020 2041 7373 6572 7469 6f6e         Assertion
+000105d0: 4572 726f 723a 2049 6620 7468 6520 766d  Error: If the vm
+000105e0: 6170 2066 6f72 206b 6579 776f 7264 2061  ap for keyword a
+000105f0: 7267 756d 656e 7473 2069 7320 6e6f 7420  rguments is not 
+00010600: 696d 706c 656d 656e 7465 642e 0a0a 2020  implemented...  
+00010610: 2020 5265 7475 726e 733a 0a20 2020 2020    Returns:.     
+00010620: 2020 2052 6573 756c 7420 6f66 2074 6865     Result of the
+00010630: 2076 6d61 7020 7472 616e 7366 6f72 6d2e   vmap transform.
+00010640: 0a20 2020 2022 2222 0a20 2020 2063 6f6d  .    """.    com
+00010650: 6d6f 6e5f 6465 7669 6365 203d 207b 782e  mon_device = {x.
+00010660: 6465 7669 6365 2066 6f72 2078 2069 6e20  device for x in 
+00010670: 6172 6773 2069 6620 6973 696e 7374 616e  args if isinstan
+00010680: 6365 2878 2c20 5465 6e73 6f72 5072 6f78  ce(x, TensorProx
+00010690: 7929 7d0a 2020 2020 6173 7365 7274 206c  y)}.    assert l
+000106a0: 656e 2863 6f6d 6d6f 6e5f 6465 7669 6365  en(common_device
+000106b0: 2920 3c3d 2031 2c20 2276 6d61 7020 666f  ) <= 1, "vmap fo
+000106c0: 7220 6d75 6c74 6970 6c65 2064 6576 6963  r multiple devic
+000106d0: 6573 2069 7320 6e6f 7420 696d 706c 656d  es is not implem
+000106e0: 656e 7465 6422 0a20 2020 2028 636f 6d6d  ented".    (comm
+000106f0: 6f6e 5f64 6576 6963 652c 2920 3d20 636f  on_device,) = co
+00010700: 6d6d 6f6e 5f64 6576 6963 6520 6966 206c  mmon_device if l
+00010710: 656e 2863 6f6d 6d6f 6e5f 6465 7669 6365  en(common_device
+00010720: 2920 3d3d 2031 2065 6c73 6520 2863 7075  ) == 1 else (cpu
+00010730: 2c29 0a0a 2020 2020 6966 2061 7869 735f  ,)..    if axis_
+00010740: 7369 7a65 2069 7320 4e6f 6e65 3a0a 2020  size is None:.  
+00010750: 2020 2020 2020 2861 7869 735f 7369 7a65        (axis_size
+00010760: 2c29 203d 207b 782e 7368 6170 655b 6178  ,) = {x.shape[ax
+00010770: 5d20 666f 7220 782c 2061 7820 696e 207a  ] for x, ax in z
+00010780: 6970 2861 7267 732c 2069 6e5f 6469 6d73  ip(args, in_dims
+00010790: 2920 6966 2061 7820 6973 206e 6f74 206e  ) if ax is not n
+000107a0: 6f74 5f6d 6170 7065 647d 0a20 2020 2069  ot_mapped}.    i
+000107b0: 6e5f 6469 6d73 203d 2069 6e5f 6469 6d73  n_dims = in_dims
+000107c0: 2069 6620 6973 696e 7374 616e 6365 2869   if isinstance(i
+000107d0: 6e5f 6469 6d73 2c20 5365 7175 656e 6365  n_dims, Sequence
+000107e0: 2920 656c 7365 2028 696e 5f64 696d 732c  ) else (in_dims,
+000107f0: 290a 2020 2020 696e 5f64 696d 7320 3d20  ).    in_dims = 
+00010800: 7475 706c 6528 6e6f 745f 6d61 7070 6564  tuple(not_mapped
+00010810: 2069 6620 6973 696e 7374 616e 6365 2861   if isinstance(a
+00010820: 2c20 284e 756d 6265 722c 204e 756d 6265  , (Number, Numbe
+00010830: 7250 726f 7879 2929 2065 6c73 6520 6420  rProxy)) else d 
+00010840: 666f 7220 612c 2064 2069 6e20 7361 6665  for a, d in safe
+00010850: 5f7a 6970 2861 7267 732c 2069 6e5f 6469  _zip(args, in_di
+00010860: 6d73 2929 0a20 2020 206f 7574 5f64 696d  ms)).    out_dim
+00010870: 7320 3d20 6f75 745f 6469 6d73 2069 6620  s = out_dims if 
+00010880: 6973 696e 7374 616e 6365 286f 7574 5f64  isinstance(out_d
+00010890: 696d 732c 2053 6571 7565 6e63 6529 2065  ims, Sequence) e
+000108a0: 6c73 6520 286f 7574 5f64 696d 732c 290a  lse (out_dims,).
+000108b0: 0a20 2020 2063 7478 203d 2064 6574 6163  .    ctx = detac
+000108c0: 6865 645f 7472 6163 6528 2920 6966 2064  hed_trace() if d
+000108d0: 6574 6163 6865 6420 656c 7365 206e 756c  etached else nul
+000108e0: 6c63 6f6e 7465 7874 2829 0a20 2020 2077  lcontext().    w
+000108f0: 6974 6820 6374 783a 0a20 2020 2020 2020  ith ctx:.       
+00010900: 2023 2057 6520 7072 6f70 6167 6174 6520   # We propagate 
+00010910: 7468 6520 4261 7463 6856 616c 7565 2074  the BatchValue t
+00010920: 6872 6f75 6768 2074 6865 2074 7261 6365  hrough the trace
+00010930: 2c20 616e 6420 7468 656e 2075 6e77 7261  , and then unwra
+00010940: 7020 6974 2061 7420 7468 6520 656e 640a  p it at the end.
+00010950: 2020 2020 2020 2020 6261 7463 6865 645f          batched_
+00010960: 6172 6773 203d 2073 6166 655f 6d61 7028  args = safe_map(
+00010970: 7061 6972 5f74 6f5f 6261 7463 6865 645f  pair_to_batched_
+00010980: 7661 6c75 652c 2073 6166 655f 7a69 7028  value, safe_zip(
+00010990: 6172 6773 2c20 696e 5f64 696d 7329 290a  args, in_dims)).
+000109a0: 2020 2020 2020 2020 7265 7375 6c74 203d          result =
+000109b0: 2065 7661 6c5f 7472 6163 6528 0a20 2020   eval_trace(.   
+000109c0: 2020 2020 2020 2020 2066 756e 6374 696f           functio
+000109d0: 6e5f 7472 6163 652c 202a 6261 7463 6865  n_trace, *batche
+000109e0: 645f 6172 6773 2c20 7379 6d62 6f6c 5f6d  d_args, symbol_m
+000109f0: 6170 7065 723d 7061 7274 6961 6c28 766d  apper=partial(vm
+00010a00: 6170 5f73 796d 626f 6c5f 6d61 7070 6572  ap_symbol_mapper
+00010a10: 2c20 6178 6973 5f73 697a 653d 6178 6973  , axis_size=axis
+00010a20: 5f73 697a 6529 2c20 2a2a 6b77 6172 6773  _size), **kwargs
+00010a30: 0a20 2020 2020 2020 2029 0a20 2020 2020  .        ).     
+00010a40: 2020 2023 2055 6e77 7261 7070 696e 6720     # Unwrapping 
+00010a50: 7468 6520 4261 7463 6865 6456 616c 7565  the BatchedValue
+00010a60: 2773 0a20 2020 2020 2020 2069 6620 6973  's.        if is
+00010a70: 696e 7374 616e 6365 2872 6573 756c 742c  instance(result,
+00010a80: 2053 6571 7565 6e63 6529 3a0a 2020 2020   Sequence):.    
+00010a90: 2020 2020 2020 2020 666c 6174 5f72 6573          flat_res
+00010aa0: 756c 742c 2073 7065 6320 3d20 7472 6565  ult, spec = tree
+00010ab0: 5f66 6c61 7474 656e 2872 6573 756c 7429  _flatten(result)
+00010ac0: 0a20 2020 2020 2020 2020 2020 2061 7373  .            ass
+00010ad0: 6572 7420 616c 6c28 6973 696e 7374 616e  ert all(isinstan
+00010ae0: 6365 2878 2c20 4261 7463 6865 6456 616c  ce(x, BatchedVal
+00010af0: 7565 2920 666f 7220 7820 696e 2066 6c61  ue) for x in fla
+00010b00: 745f 7265 7375 6c74 290a 2020 2020 2020  t_result).      
+00010b10: 2020 2020 2020 6f75 7473 2c20 6264 696d        outs, bdim
+00010b20: 7320 3d20 756e 7a69 7032 2866 6c61 745f  s = unzip2(flat_
+00010b30: 7265 7375 6c74 290a 2020 2020 2020 2020  result).        
+00010b40: 2020 2020 2320 544f 444f 3a20 6861 6e64      # TODO: hand
+00010b50: 6c65 2074 6865 2063 6173 6520 7768 6572  le the case wher
+00010b60: 6520 6f75 745f 6469 6d73 2069 7320 6120  e out_dims is a 
+00010b70: 7369 6e67 6c65 2076 616c 7565 2062 6574  single value bet
+00010b80: 7465 720a 2020 2020 2020 2020 2020 2020  ter.            
+00010b90: 6966 206c 656e 286f 7574 5f64 696d 7329  if len(out_dims)
+00010ba0: 203d 3d20 313a 0a20 2020 2020 2020 2020   == 1:.         
+00010bb0: 2020 2020 2020 206f 7574 5f64 696d 7320         out_dims 
+00010bc0: 3d20 6f75 745f 6469 6d73 202a 206c 656e  = out_dims * len
+00010bd0: 286f 7574 7329 0a20 2020 2020 2020 2020  (outs).         
+00010be0: 2020 206f 7574 7320 3d20 7361 6665 5f6d     outs = safe_m
+00010bf0: 6170 2870 6172 7469 616c 286d 6f76 655f  ap(partial(move_
+00010c00: 6261 7463 685f 6469 6d2c 2061 7869 735f  batch_dim, axis_
+00010c10: 7369 7a65 292c 2062 6469 6d73 2c20 6f75  size), bdims, ou
+00010c20: 745f 6469 6d73 2c20 6f75 7473 290a 2020  t_dims, outs).  
+00010c30: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00010c40: 2074 7265 655f 756e 666c 6174 7465 6e28   tree_unflatten(
+00010c50: 6f75 7473 2c20 7370 6563 290a 2020 2020  outs, spec).    
+00010c60: 2020 2020 6966 2069 7369 6e73 7461 6e63      if isinstanc
+00010c70: 6528 7265 7375 6c74 2c20 284e 756d 6265  e(result, (Numbe
+00010c80: 722c 204e 756d 6265 7250 726f 7879 2929  r, NumberProxy))
+00010c90: 2061 6e64 2061 7869 735f 7369 7a65 2069   and axis_size i
+00010ca0: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
+00010cb0: 2020 2020 2020 2020 2320 544f 444f 3a20          # TODO: 
+00010cc0: 6665 7463 6820 7468 6520 6465 6661 756c  fetch the defaul
+00010cd0: 7420 6465 7669 6365 2066 726f 6d20 7468  t device from th
+00010ce0: 6520 636f 6e74 6578 740a 2020 2020 2020  e context.      
+00010cf0: 2020 2020 2020 7265 7375 6c74 203d 2066        result = f
+00010d00: 756c 6c28 7368 6170 653d 2829 2c20 6669  ull(shape=(), fi
+00010d10: 6c6c 5f76 616c 7565 3d72 6573 756c 742c  ll_value=result,
+00010d20: 2064 6576 6963 653d 636f 6d6d 6f6e 5f64   device=common_d
+00010d30: 6576 6963 6529 0a20 2020 2020 2020 2020  evice).         
+00010d40: 2020 2072 6573 756c 7420 3d20 4261 7463     result = Batc
+00010d50: 6865 6456 616c 7565 2872 6573 756c 742c  hedValue(result,
+00010d60: 206e 6f74 5f6d 6170 7065 6429 0a20 2020   not_mapped).   
+00010d70: 2020 2020 2065 6c69 6620 280a 2020 2020       elif (.    
+00010d80: 2020 2020 2020 2020 6973 696e 7374 616e          isinstan
+00010d90: 6365 2872 6573 756c 742c 2042 6174 6368  ce(result, Batch
+00010da0: 6564 5661 6c75 6529 0a20 2020 2020 2020  edValue).       
+00010db0: 2020 2020 2061 6e64 2069 7369 6e73 7461       and isinsta
+00010dc0: 6e63 6528 7265 7375 6c74 2e76 616c 7565  nce(result.value
+00010dd0: 2c20 284e 756d 6265 722c 204e 756d 6265  , (Number, Numbe
+00010de0: 7250 726f 7879 2929 0a20 2020 2020 2020  rProxy)).       
+00010df0: 2020 2020 2061 6e64 2061 7869 735f 7369       and axis_si
+00010e00: 7a65 2069 7320 6e6f 7420 4e6f 6e65 0a20  ze is not None. 
+00010e10: 2020 2020 2020 2029 3a0a 2020 2020 2020         ):.      
+00010e20: 2020 2020 2020 7265 7375 6c74 203d 2042        result = B
+00010e30: 6174 6368 6564 5661 6c75 6528 6675 6c6c  atchedValue(full
+00010e40: 2873 6861 7065 3d28 292c 2066 696c 6c5f  (shape=(), fill_
+00010e50: 7661 6c75 653d 7265 7375 6c74 2e76 616c  value=result.val
+00010e60: 7565 2c20 6465 7669 6365 3d63 6f6d 6d6f  ue, device=commo
+00010e70: 6e5f 6465 7669 6365 292c 2072 6573 756c  n_device), resul
+00010e80: 742e 6261 7463 685f 6469 6d29 0a20 2020  t.batch_dim).   
+00010e90: 2020 2020 2061 7373 6572 7420 6973 696e       assert isin
+00010ea0: 7374 616e 6365 2872 6573 756c 742c 2042  stance(result, B
+00010eb0: 6174 6368 6564 5661 6c75 6529 0a20 2020  atchedValue).   
+00010ec0: 2020 2020 206f 7574 203d 206d 6f76 655f       out = move_
+00010ed0: 6261 7463 685f 6469 6d28 6178 6973 5f73  batch_dim(axis_s
+00010ee0: 697a 652c 2072 6573 756c 742e 6261 7463  ize, result.batc
+00010ef0: 685f 6469 6d2c 206f 7574 5f64 696d 735b  h_dim, out_dims[
+00010f00: 305d 2c20 7265 7375 6c74 2e76 616c 7565  0], result.value
+00010f10: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+00010f20: 206f 7574 0a0a 0a76 6d61 705f 6361 6c6c   out...vmap_call
+00010f30: 203d 2053 796d 626f 6c28 6964 3d54 7261   = Symbol(id=Tra
+00010f40: 6e73 666f 726d 732e 566d 6170 4f70 2c20  nsforms.VmapOp, 
+00010f50: 6e61 6d65 3d22 766d 6170 5f63 616c 6c22  name="vmap_call"
+00010f60: 2c20 6d65 7461 3d70 6172 7469 616c 285f  , meta=partial(_
+00010f70: 766d 6170 5f63 616c 6c5f 6d65 7461 6675  vmap_call_metafu
+00010f80: 6e63 2c20 4661 6c73 6529 290a 0a0a 2320  nc, False))...# 
+00010f90: 544f 444f 3a20 686f 7720 7368 6f75 6c64  TODO: how should
+00010fa0: 2077 6520 6861 6e64 6c65 206f 7574 5f64   we handle out_d
+00010fb0: 696d 7320 6865 7265 3f0a 2320 616c 7468  ims here?.# alth
+00010fc0: 6f75 6768 2068 6572 6520 7765 2061 7265  ough here we are
+00010fd0: 2063 616c 6c69 6e67 2076 6d61 7020 6f66   calling vmap of
+00010fe0: 2069 6465 6e74 6974 792c 2073 6f20 7765   identity, so we
+00010ff0: 2073 686f 756c 6420 6b6e 6f77 2066 726f   should know fro
+00011000: 6d20 7468 6520 6361 6c6c 2074 6f20 766d  m the call to vm
+00011010: 6170 0a23 2054 6869 7320 7368 6f75 6c64  ap.# This should
+00011020: 2062 6520 6669 6e65 2e20 4966 2077 6520   be fine. If we 
+00011030: 6861 7665 2076 6d61 7028 6964 656e 7469  have vmap(identi
+00011040: 7479 2866 756e 6329 2c20 6f75 745f 6469  ty(func), out_di
+00011050: 6d73 3d4e 2920 7468 656e 2074 6869 7320  ms=N) then this 
+00011060: 7275 6c65 2069 7320 6669 7273 7420 7573  rule is first us
+00011070: 6564 0a23 2074 6f20 6765 7420 7468 6520  ed.# to get the 
+00011080: 766d 6170 7065 6420 7265 7375 6c74 206f  vmapped result o
+00011090: 6620 6964 656e 7469 7479 2866 756e 6329  f identity(func)
+000110a0: 2069 6e20 766d 6170 5f73 796d 626f 6c5f   in vmap_symbol_
+000110b0: 6d61 7070 6572 2c20 616e 6420 6f75 745f  mapper, and out_
+000110c0: 6469 6d73 2069 7320 6861 6e64 6c65 640a  dims is handled.
+000110d0: 2320 6166 7465 7220 7468 6174 2069 6e20  # after that in 
+000110e0: 7468 6520 6f75 7465 7220 5f76 6d61 705f  the outer _vmap_
+000110f0: 6361 6c6c 5f6d 6574 6166 756e 632e 0a64  call_metafunc..d
+00011100: 6566 205f 6964 656e 7469 7479 5f63 616c  ef _identity_cal
+00011110: 6c5f 766d 6170 2861 7869 735f 7369 7a65  l_vmap(axis_size
+00011120: 2c20 2a62 6174 6368 6564 5f61 7267 732c  , *batched_args,
+00011130: 2074 7261 6365 3a20 5472 6163 652c 202a   trace: Trace, *
+00011140: 2a6b 7761 7267 7329 3a0a 2020 2020 6172  *kwargs):.    ar
+00011150: 6773 2c20 696e 5f64 696d 7320 3d20 756e  gs, in_dims = un
+00011160: 7a69 7032 2862 6174 6368 6564 5f61 7267  zip2(batched_arg
+00011170: 7329 0a20 2020 206f 7574 5f64 696d 7320  s).    out_dims 
+00011180: 3d20 3020 2023 2046 6978 6d65 0a20 2020  = 0  # Fixme.   
+00011190: 206f 7574 732c 206f 7574 5f64 696d 7320   outs, out_dims 
+000111a0: 3d20 5f76 6d61 705f 6361 6c6c 5f6d 6574  = _vmap_call_met
+000111b0: 6166 756e 6328 4661 6c73 652c 2061 7267  afunc(False, arg
+000111c0: 732c 2069 6e5f 6469 6d73 2c20 6f75 745f  s, in_dims, out_
+000111d0: 6469 6d73 2c20 6178 6973 5f73 697a 652c  dims, axis_size,
+000111e0: 2066 756e 6374 696f 6e5f 7472 6163 653d   function_trace=
+000111f0: 7472 6163 652c 202a 2a6b 7761 7267 7329  trace, **kwargs)
+00011200: 0a20 2020 2069 6620 6973 696e 7374 616e  .    if isinstan
+00011210: 6365 286f 7574 732c 2053 6571 7565 6e63  ce(outs, Sequenc
+00011220: 6529 3a0a 2020 2020 2020 2020 7265 7475  e):.        retu
+00011230: 726e 2073 6166 655f 6d61 7028 7061 6972  rn safe_map(pair
+00011240: 5f74 6f5f 6261 7463 6865 645f 7661 6c75  _to_batched_valu
+00011250: 652c 2073 6166 655f 7a69 7028 6f75 7473  e, safe_zip(outs
+00011260: 2c20 6f75 745f 6469 6d73 2929 0a20 2020  , out_dims)).   
+00011270: 2072 6574 7572 6e20 4261 7463 6865 6456   return BatchedV
+00011280: 616c 7565 286f 7574 732c 206f 7574 5f64  alue(outs, out_d
+00011290: 696d 7329 0a0a 0a76 6d61 705f 696d 706c  ims)...vmap_impl
+000112a0: 735b 5472 616e 7366 6f72 6d73 2e49 6465  s[Transforms.Ide
+000112b0: 6e74 6974 794f 705d 203d 205f 6964 656e  ntityOp] = _iden
+000112c0: 7469 7479 5f63 616c 6c5f 766d 6170 0a0a  tity_call_vmap..
+000112d0: 0a64 6566 205f 6a76 705f 6361 6c6c 5f76  .def _jvp_call_v
+000112e0: 6d61 7028 6178 6973 5f73 697a 652c 2062  map(axis_size, b
+000112f0: 6174 6368 6564 5f70 7269 6d61 6c73 2c20  atched_primals, 
+00011300: 6261 7463 6865 645f 7461 6e67 656e 7473  batched_tangents
+00011310: 2c20 2a2c 2066 756e 6374 696f 6e5f 7472  , *, function_tr
+00011320: 6163 653a 2054 7261 6365 2c20 2a2a 6b77  ace: Trace, **kw
+00011330: 6172 6773 293a 0a20 2020 2070 7269 6d61  args):.    prima
+00011340: 6c73 2c20 7072 696d 616c 735f 6264 696d  ls, primals_bdim
+00011350: 7320 3d20 7361 6665 5f7a 6970 282a 6261  s = safe_zip(*ba
+00011360: 7463 6865 645f 7072 696d 616c 7329 0a20  tched_primals). 
+00011370: 2020 2074 616e 6765 6e74 732c 2074 616e     tangents, tan
+00011380: 6765 6e74 735f 6264 696d 7320 3d20 7361  gents_bdims = sa
+00011390: 6665 5f7a 6970 282a 6261 7463 6865 645f  fe_zip(*batched_
+000113a0: 7461 6e67 656e 7473 290a 2020 2020 6a76  tangents).    jv
+000113b0: 705f 6675 6e63 203d 2070 6172 7469 616c  p_func = partial
+000113c0: 285f 6a76 705f 6361 6c6c 5f6d 6574 6166  (_jvp_call_metaf
+000113d0: 756e 632c 2046 616c 7365 2c20 6675 6e63  unc, False, func
+000113e0: 7469 6f6e 5f74 7261 6365 3d66 756e 6374  tion_trace=funct
+000113f0: 696f 6e5f 7472 6163 6529 0a20 2020 2076  ion_trace).    v
+00011400: 6d61 7070 6564 5f6a 7670 5f66 756e 6320  mapped_jvp_func 
+00011410: 3d20 766d 6170 286a 7670 5f66 756e 632c  = vmap(jvp_func,
+00011420: 2069 6e5f 6469 6d73 3d28 7072 696d 616c   in_dims=(primal
+00011430: 735f 6264 696d 732c 2074 616e 6765 6e74  s_bdims, tangent
+00011440: 735f 6264 696d 7329 2c20 6178 6973 5f73  s_bdims), axis_s
+00011450: 697a 653d 6178 6973 5f73 697a 6529 0a20  ize=axis_size). 
+00011460: 2020 2072 6573 756c 7420 3d20 766d 6170     result = vmap
+00011470: 7065 645f 6a76 705f 6675 6e63 2870 7269  ped_jvp_func(pri
+00011480: 6d61 6c73 2c20 7461 6e67 656e 7473 2c20  mals, tangents, 
+00011490: 2a2a 6b77 6172 6773 290a 2020 2020 7265  **kwargs).    re
+000114a0: 7475 726e 2074 7265 655f 6d61 7028 6c61  turn tree_map(la
+000114b0: 6d62 6461 2078 3a20 4261 7463 6865 6456  mbda x: BatchedV
+000114c0: 616c 7565 2878 2c20 3029 2c20 7265 7375  alue(x, 0), resu
+000114d0: 6c74 290a 0a0a 766d 6170 5f69 6d70 6c73  lt)...vmap_impls
+000114e0: 5b54 7261 6e73 666f 726d 732e 4a76 704f  [Transforms.JvpO
+000114f0: 705d 203d 205f 6a76 705f 6361 6c6c 5f76  p] = _jvp_call_v
+00011500: 6d61 700a 0a0a 6465 6620 766d 6170 2866  map...def vmap(f
+00011510: 756e 632c 2069 6e5f 6469 6d73 3d30 2c20  unc, in_dims=0, 
+00011520: 6f75 745f 6469 6d73 3d30 2c20 6178 6973  out_dims=0, axis
+00011530: 5f73 697a 653d 4e6f 6e65 293a 0a20 2020  _size=None):.   
+00011540: 2022 2222 5665 6374 6f72 697a 696e 6720   """Vectorizing 
+00011550: 7472 616e 7366 6f72 6d20 666f 7220 6120  transform for a 
+00011560: 5468 756e 6465 7220 6675 6e63 7469 6f6e  Thunder function
+00011570: 2e0a 0a20 2020 2041 7267 733a 0a20 2020  ...    Args:.   
+00011580: 2020 2020 2066 756e 6320 2843 616c 6c61       func (Calla
+00011590: 626c 6529 3a20 4120 5468 756e 6465 7220  ble): A Thunder 
+000115a0: 6675 6e63 7469 6f6e 2074 6f20 6265 2074  function to be t
+000115b0: 7261 6e73 666f 726d 6564 2e0a 0a20 2020  ransformed...   
+000115c0: 2052 6574 7572 6e73 3a0a 2020 2020 2020   Returns:.      
+000115d0: 2020 4361 6c6c 6162 6c65 3a20 4120 766d    Callable: A vm
+000115e0: 6170 7065 6420 7665 7273 696f 6e20 6f66  apped version of
+000115f0: 2074 6865 2066 756e 6374 696f 6e2e 0a20   the function.. 
+00011600: 2020 2022 2222 0a0a 2020 2020 2320 544f     """..    # TO
+00011610: 444f 3a20 666c 6174 7465 6e0a 2020 2020  DO: flatten.    
+00011620: 2320 496e 204a 4158 2066 6c61 7474 656e  # In JAX flatten
+00011630: 696e 6720 6f66 2069 6e5f 6469 6d73 2069  ing of in_dims i
+00011640: 7320 7261 7468 6572 2063 6f6d 706c 6963  s rather complic
+00011650: 6174 6564 2062 6563 6175 7365 2069 7420  ated because it 
+00011660: 6361 6e20 6f70 7469 6f6e 616c 6c79 2062  can optionally b
+00011670: 650a 2020 2020 2320 7370 6563 6966 6965  e.    # specifie
+00011680: 6420 6173 2061 20e2 809c 7072 6566 6978  d as a ...prefix
+00011690: e280 9d20 7079 7472 6565 2c20 6d65 616e  ... pytree, mean
+000116a0: 696e 6720 7468 6174 2061 2073 696e 676c  ing that a singl
+000116b0: 6520 6c65 6166 2076 616c 7565 2063 616e  e leaf value can
+000116c0: 2062 6520 6170 706c 6965 640a 2020 2020   be applied.    
+000116d0: 2320 746f 2061 6e20 656e 7469 7265 2073  # to an entire s
+000116e0: 7562 2d70 7974 7265 652e 0a0a 2020 2020  ub-pytree...    
+000116f0: 6465 6620 666c 6174 7465 6e5f 6675 6e63  def flatten_func
+00011700: 5f66 6f72 5f76 6d61 7028 6675 6e63 2c20  _for_vmap(func, 
+00011710: 6172 6773 2c20 6b77 6172 6773 293a 0a20  args, kwargs):. 
+00011720: 2020 2020 2020 2066 6c61 745f 6172 6773         flat_args
+00011730: 2c20 7370 6563 203d 2074 7265 655f 666c  , spec = tree_fl
+00011740: 6174 7465 6e28 2861 7267 732c 206b 7761  atten((args, kwa
+00011750: 7267 7329 290a 0a20 2020 2020 2020 2064  rgs))..        d
+00011760: 6566 2066 6c61 745f 6675 6e63 282a 666c  ef flat_func(*fl
+00011770: 6174 5f61 7267 7329 3a0a 2020 2020 2020  at_args):.      
+00011780: 2020 2020 2020 666e 5f61 7267 732c 2066        fn_args, f
+00011790: 6e5f 6b77 6172 6773 203d 2074 7265 655f  n_kwargs = tree_
+000117a0: 756e 666c 6174 7465 6e28 666c 6174 5f61  unflatten(flat_a
+000117b0: 7267 732c 2073 7065 6329 0a20 2020 2020  rgs, spec).     
+000117c0: 2020 2020 2020 2072 6574 7572 6e20 6675         return fu
+000117d0: 6e63 282a 666e 5f61 7267 732c 202a 2a66  nc(*fn_args, **f
+000117e0: 6e5f 6b77 6172 6773 290a 0a20 2020 2020  n_kwargs)..     
+000117f0: 2020 2072 6574 7572 6e20 666c 6174 5f66     return flat_f
+00011800: 756e 632c 2066 6c61 745f 6172 6773 2c20  unc, flat_args, 
+00011810: 7370 6563 0a0a 2020 2020 6465 6620 7772  spec..    def wr
+00011820: 6170 7065 7228 2a61 7267 732c 202a 2a6b  apper(*args, **k
+00011830: 7761 7267 7329 3a0a 2020 2020 2020 2020  wargs):.        
+00011840: 6675 6e63 5f66 6c61 742c 2061 7267 735f  func_flat, args_
+00011850: 666c 6174 2c20 6172 6773 5f73 7065 6320  flat, args_spec 
+00011860: 3d20 666c 6174 7465 6e5f 6675 6e63 5f66  = flatten_func_f
+00011870: 6f72 5f76 6d61 7028 6675 6e63 2c20 6172  or_vmap(func, ar
+00011880: 6773 2c20 6b77 6172 6773 290a 2020 2020  gs, kwargs).    
+00011890: 2020 2020 6966 2069 7369 6e73 7461 6e63      if isinstanc
+000118a0: 6528 696e 5f64 696d 732c 2069 6e74 293a  e(in_dims, int):
+000118b0: 0a20 2020 2020 2020 2020 2020 2069 6e5f  .            in_
+000118c0: 6469 6d73 5f66 6c61 7420 3d20 2869 6e5f  dims_flat = (in_
+000118d0: 6469 6d73 2c29 202a 206c 656e 2861 7267  dims,) * len(arg
+000118e0: 735f 666c 6174 290a 2020 2020 2020 2020  s_flat).        
+000118f0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00011900: 2020 696e 5f64 696d 735f 666c 6174 2c20    in_dims_flat, 
+00011910: 696e 5f64 696d 735f 7370 6563 203d 2074  in_dims_spec = t
+00011920: 7265 655f 666c 6174 7465 6e28 696e 5f64  ree_flatten(in_d
+00011930: 696d 7329 0a20 2020 2020 2020 2020 2020  ims).           
+00011940: 2061 7373 6572 7420 6c65 6e28 696e 5f64   assert len(in_d
+00011950: 696d 735f 666c 6174 2920 3d3d 206c 656e  ims_flat) == len
+00011960: 2861 7267 735f 666c 6174 292c 2022 696e  (args_flat), "in
+00011970: 5f64 696d 7320 6d75 7374 2068 6176 6520  _dims must have 
+00011980: 7468 6520 7361 6d65 206c 656e 6774 6820  the same length 
+00011990: 6173 2061 7267 732c 206b 7761 7267 7322  as args, kwargs"
+000119a0: 0a20 2020 2020 2020 2075 6e62 6174 6368  .        unbatch
+000119b0: 6564 5f61 7267 735f 666c 6174 203d 205b  ed_args_flat = [
+000119c0: 7265 6d6f 7665 5f62 6174 6368 5f64 696d  remove_batch_dim
+000119d0: 2861 7267 2920 6966 2069 7369 6e73 7461  (arg) if isinsta
+000119e0: 6e63 6528 6172 672c 2054 656e 736f 7250  nce(arg, TensorP
+000119f0: 726f 7879 2920 656c 7365 2061 7267 2066  roxy) else arg f
+00011a00: 6f72 2061 7267 2069 6e20 6172 6773 5f66  or arg in args_f
+00011a10: 6c61 745d 0a20 2020 2020 2020 2074 7261  lat].        tra
+00011a20: 6365 203d 2063 6f6e 7374 7275 6374 5f74  ce = construct_t
+00011a30: 7261 6365 2829 2866 756e 635f 666c 6174  race()(func_flat
+00011a40: 2c20 2a75 6e62 6174 6368 6564 5f61 7267  , *unbatched_arg
+00011a50: 735f 666c 6174 290a 2020 2020 2020 2020  s_flat).        
+00011a60: 6f75 7473 203d 2076 6d61 705f 6361 6c6c  outs = vmap_call
+00011a70: 2861 7267 735f 666c 6174 2c20 696e 5f64  (args_flat, in_d
+00011a80: 696d 735f 666c 6174 2c20 6f75 745f 6469  ims_flat, out_di
+00011a90: 6d73 2c20 6178 6973 5f73 697a 653d 6178  ms, axis_size=ax
+00011aa0: 6973 5f73 697a 652c 2066 756e 6374 696f  is_size, functio
+00011ab0: 6e5f 7472 6163 653d 7472 6163 6529 0a20  n_trace=trace). 
+00011ac0: 2020 2020 2020 2072 6574 7572 6e20 6f75         return ou
+00011ad0: 7473 0a0a 2020 2020 7265 7475 726e 2077  ts..    return w
+00011ae0: 7261 7070 6572 0a0a 0a23 2054 4f44 4f20  rapper...# TODO 
+00011af0: 5468 6973 2066 756e 6374 696f 6e20 636f  This function co
+00011b00: 6d6d 656e 7465 6420 6f75 7420 6265 6361  mmented out beca
+00011b10: 7573 6520 6974 2063 616c 6c73 206d 616b  use it calls mak
+00011b20: 655f 7472 6163 6564 2c20 7768 6963 6820  e_traced, which 
+00011b30: 646f 6573 206e 6f74 2065 7869 7374 0a23  does not exist.#
+00011b40: 2064 6566 2076 6d61 705f 6561 6765 7228   def vmap_eager(
+00011b50: 6675 6e63 2c20 6172 6773 2c20 696e 5f64  func, args, in_d
+00011b60: 696d 733d 302c 206f 7574 5f64 696d 733d  ims=0, out_dims=
+00011b70: 302c 2061 7869 735f 7369 7a65 3d4e 6f6e  0, axis_size=Non
+00011b80: 652c 2065 7865 6375 746f 723d 2274 6f72  e, executor="tor
+00011b90: 6368 2229 3a0a 2320 2020 2020 2222 2243  ch"):.#     """C
+00011ba0: 6f6d 7075 7465 7320 7468 6520 766d 6170  omputes the vmap
+00011bb0: 206f 6620 6120 5468 756e 6465 7220 6675   of a Thunder fu
+00011bc0: 6e63 7469 6f6e 2e0a 0a23 2020 2020 2041  nction...#     A
+00011bd0: 7267 733a 0a23 2020 2020 2020 2020 2066  rgs:.#         f
+00011be0: 756e 6320 2843 616c 6c61 626c 6529 3a20  unc (Callable): 
+00011bf0: 4120 5468 756e 6465 7220 6675 6e63 7469  A Thunder functi
+00011c00: 6f6e 2074 6f20 6265 2074 7261 6e73 666f  on to be transfo
+00011c10: 726d 6564 2e0a 2320 2020 2020 2020 2020  rmed..#         
+00011c20: 6172 6773 2028 5f74 7970 655f 293a 2041  args (_type_): A
+00011c30: 7267 7320 6f66 2074 6865 2066 756e 6374  rgs of the funct
+00011c40: 696f 6e2e 0a23 2020 2020 2020 2020 2065  ion..#         e
+00011c50: 7865 6375 746f 7220 2873 7472 2c20 6f70  xecutor (str, op
+00011c60: 7469 6f6e 616c 293a 2045 7865 6375 746f  tional): Executo
+00011c70: 7220 746f 2075 7365 2e20 4465 6661 756c  r to use. Defaul
+00011c80: 7473 2074 6f20 2274 6f72 6368 222e 0a0a  ts to "torch"...
+00011c90: 2320 2020 2020 5265 7475 726e 733a 0a23  #     Returns:.#
+00011ca0: 2020 2020 2020 2020 2054 6865 2072 6573           The res
+00011cb0: 756c 7420 6f66 2074 6865 2076 6d61 7070  ult of the vmapp
+00011cc0: 6564 2066 756e 6374 696f 6e2e 0a23 2020  ed function..#  
+00011cd0: 2020 2022 2222 0a23 2020 2020 2023 2054     """.#     # T
+00011ce0: 4f44 4f3a 2066 6978 2074 6869 7320 2d20  ODO: fix this - 
+00011cf0: 6e6f 7420 616c 6c20 6172 6773 206d 6179  not all args may
+00011d00: 2062 6520 6261 7463 6865 640a 2320 2020   be batched.#   
+00011d10: 2020 2320 544f 444f 3a20 6865 7265 2077    # TODO: here w
+00011d20: 6520 6173 7375 6d65 2062 6174 6368 2061  e assume batch a
+00011d30: 7869 7320 6973 2030 0a23 2020 2020 2076  xis is 0.#     v
+00011d40: 6d61 705f 7472 6163 6520 3d20 6d61 6b65  map_trace = make
+00011d50: 5f74 7261 6365 280a 2320 2020 2020 2020  _trace(.#       
+00011d60: 2020 766d 6170 2866 756e 632c 2069 6e5f    vmap(func, in_
+00011d70: 6469 6d73 3d69 6e5f 6469 6d73 2c20 6f75  dims=in_dims, ou
+00011d80: 745f 6469 6d73 3d6f 7574 5f64 696d 732c  t_dims=out_dims,
+00011d90: 2061 7869 735f 7369 7a65 3d61 7869 735f   axis_size=axis_
+00011da0: 7369 7a65 292c 2065 7865 6375 746f 723d  size), executor=
+00011db0: 6578 6563 7574 6f72 2c0a 2320 2020 2020  executor,.#     
+00011dc0: 2020 2020 2a61 7267 7329 0a23 2020 2020      *args).#    
+00011dd0: 2076 6d61 705f 7472 6163 6564 203d 206d   vmap_traced = m
+00011de0: 616b 655f 7472 6163 6564 2870 6172 7469  ake_traced(parti
+00011df0: 616c 2865 7661 6c5f 7472 6163 652c 2076  al(eval_trace, v
+00011e00: 6d61 705f 7472 6163 6529 2c20 6578 6563  map_trace), exec
+00011e10: 7574 6f72 3d65 7865 6375 746f 7229 0a23  utor=executor).#
+00011e20: 2020 2020 2072 6574 7572 6e20 766d 6170       return vmap
+00011e30: 5f74 7261 6365 6428 2a61 7267 7329 0a0a  _traced(*args)..
+00011e40: 0a23 204a 5650 2074 7261 6e73 666f 726d  .# JVP transform
+00011e50: 0a23 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  .# -------------
+00011e60: 0a0a 0a40 6461 7461 636c 6173 7328 6672  ...@dataclass(fr
+00011e70: 6f7a 656e 3d54 7275 6529 0a63 6c61 7373  ozen=True).class
+00011e80: 204a 5650 4475 616c 3a0a 2020 2020 2222   JVPDual:.    ""
+00011e90: 2244 7561 6c20 6e75 6d62 6572 2066 6f72  "Dual number for
+00011ea0: 2074 6865 204a 5650 2074 7261 6e73 666f   the JVP transfo
+00011eb0: 726d 2e0a 0a20 2020 2041 7474 7269 6275  rm...    Attribu
+00011ec0: 7465 733a 0a20 2020 2020 2020 2070 7269  tes:.        pri
+00011ed0: 6d61 6c3a 2050 7269 6d61 6c20 7661 6c75  mal: Primal valu
+00011ee0: 652e 0a20 2020 2020 2020 2074 616e 6765  e..        tange
+00011ef0: 6e74 3a20 5461 6e67 656e 7420 7661 6c75  nt: Tangent valu
+00011f00: 652e 0a20 2020 2022 2222 0a0a 2020 2020  e..    """..    
+00011f10: 7072 696d 616c 3a20 416e 790a 2020 2020  primal: Any.    
+00011f20: 7461 6e67 656e 743a 2041 6e79 0a0a 2020  tangent: Any..  
+00011f30: 2020 6465 6620 5f5f 6974 6572 5f5f 2873    def __iter__(s
+00011f40: 656c 6629 3a0a 2020 2020 2020 2020 7969  elf):.        yi
+00011f50: 656c 6420 7365 6c66 2e70 7269 6d61 6c0a  eld self.primal.
+00011f60: 2020 2020 2020 2020 7969 656c 6420 7365          yield se
+00011f70: 6c66 2e74 616e 6765 6e74 0a0a 0a64 6566  lf.tangent...def
+00011f80: 2070 6169 725f 746f 5f6a 7670 5f64 7561   pair_to_jvp_dua
+00011f90: 6c28 7061 6972 293a 0a20 2020 2022 2222  l(pair):.    """
+00011fa0: 436f 6e76 6572 7473 2061 2070 6169 7220  Converts a pair 
+00011fb0: 746f 2061 204a 5650 4475 616c 2e0a 0a20  to a JVPDual... 
+00011fc0: 2020 2041 7267 733a 0a20 2020 2020 2020     Args:.       
+00011fd0: 2070 6169 7220 2853 6571 7565 6e63 6529   pair (Sequence)
+00011fe0: 3a20 5061 6972 2074 6f20 636f 6e76 6572  : Pair to conver
+00011ff0: 742e 0a0a 2020 2020 5265 7475 726e 733a  t...    Returns:
+00012000: 0a20 2020 2020 2020 204a 5650 4475 616c  .        JVPDual
+00012010: 3a20 4a56 5044 7561 6c20 7265 7072 6573  : JVPDual repres
+00012020: 656e 7461 7469 6f6e 206f 6620 7468 6520  entation of the 
+00012030: 7061 6972 2e0a 2020 2020 2222 220a 2020  pair..    """.  
+00012040: 2020 6966 2069 7369 6e73 7461 6e63 6528    if isinstance(
+00012050: 7061 6972 2c20 4a56 5044 7561 6c29 3a0a  pair, JVPDual):.
+00012060: 2020 2020 2020 2020 7265 7475 726e 2070          return p
+00012070: 6169 720a 2020 2020 656c 7365 3a0a 2020  air.    else:.  
+00012080: 2020 2020 2020 6173 7365 7274 2069 7369        assert isi
+00012090: 6e73 7461 6e63 6528 7061 6972 2c20 5365  nstance(pair, Se
+000120a0: 7175 656e 6365 2920 616e 6420 6c65 6e28  quence) and len(
+000120b0: 7061 6972 2920 3d3d 2032 0a20 2020 2020  pair) == 2.     
+000120c0: 2020 2072 6574 7572 6e20 4a56 5044 7561     return JVPDua
+000120d0: 6c28 2a70 6169 7229 0a0a 0a64 6566 2073  l(*pair)...def s
+000120e0: 696e 5f6a 7670 2861 3a20 4a56 5044 7561  in_jvp(a: JVPDua
+000120f0: 6c29 3a0a 2020 2020 782c 2078 6420 3d20  l):.    x, xd = 
+00012100: 610a 2020 2020 7265 7475 726e 204a 5650  a.    return JVP
+00012110: 4475 616c 2870 7269 6d73 2e73 696e 2878  Dual(prims.sin(x
+00012120: 292c 2070 7269 6d73 2e63 6f73 2878 2920  ), prims.cos(x) 
+00012130: 2a20 7864 290a 0a0a 6465 6620 6d75 6c5f  * xd)...def mul_
+00012140: 6a76 7028 613a 204a 5650 4475 616c 2c20  jvp(a: JVPDual, 
+00012150: 623a 204a 5650 4475 616c 293a 0a20 2020  b: JVPDual):.   
+00012160: 2078 2c20 7864 203d 2061 0a20 2020 2079   x, xd = a.    y
+00012170: 2c20 7964 203d 2062 0a20 2020 2072 6574  , yd = b.    ret
+00012180: 7572 6e20 4a56 5044 7561 6c28 7820 2a20  urn JVPDual(x * 
+00012190: 792c 2078 202a 2079 6420 2b20 7920 2a20  y, x * yd + y * 
+000121a0: 7864 290a 0a0a 6465 6620 6164 645f 6a76  xd)...def add_jv
+000121b0: 7028 613a 204a 5650 4475 616c 2c20 623a  p(a: JVPDual, b:
+000121c0: 204a 5650 4475 616c 293a 0a20 2020 2078   JVPDual):.    x
+000121d0: 2c20 7864 203d 2061 0a20 2020 2079 2c20  , xd = a.    y, 
+000121e0: 7964 203d 2062 0a20 2020 2072 6574 7572  yd = b.    retur
+000121f0: 6e20 4a56 5044 7561 6c28 7820 2b20 792c  n JVPDual(x + y,
+00012200: 2078 6420 2b20 7964 290a 0a0a 6465 6620   xd + yd)...def 
+00012210: 6272 6f61 6463 6173 745f 696e 5f64 696d  broadcast_in_dim
+00012220: 5f6a 7670 2861 3a20 4a56 5044 7561 6c2c  _jvp(a: JVPDual,
+00012230: 2073 6861 7065 3a20 7475 706c 655b 4a56   shape: tuple[JV
+00012240: 5044 7561 6c2c 202e 2e2e 5d2c 2062 726f  PDual, ...], bro
+00012250: 6164 6361 7374 5f64 696d 656e 7369 6f6e  adcast_dimension
+00012260: 733a 2074 7570 6c65 5b4a 5650 4475 616c  s: tuple[JVPDual
+00012270: 2c20 2e2e 2e5d 2920 2d3e 204a 5650 4475  , ...]) -> JVPDu
+00012280: 616c 3a0a 2020 2020 782c 2078 6420 3d20  al:.    x, xd = 
+00012290: 610a 2020 2020 2320 544f 444f 3a20 7368  a.    # TODO: sh
+000122a0: 6170 6520 616e 6420 6272 6f61 6463 6173  ape and broadcas
+000122b0: 745f 6469 6d65 6e73 696f 6e73 2073 686f  t_dimensions sho
+000122c0: 756c 6420 6265 2074 7570 6c65 7320 6f66  uld be tuples of
+000122d0: 2069 6e74 730a 2020 2020 2320 6275 7420   ints.    # but 
+000122e0: 666f 7220 6e6f 7720 6974 2773 2061 2074  for now it's a t
+000122f0: 7570 6c65 206f 6620 4a56 5044 7561 6c73  uple of JVPDuals
+00012300: 0a20 2020 2069 6620 6c65 6e28 7368 6170  .    if len(shap
+00012310: 6529 203e 2030 2061 6e64 2069 7369 6e73  e) > 0 and isins
+00012320: 7461 6e63 6528 7368 6170 655b 305d 2c20  tance(shape[0], 
+00012330: 4a56 5044 7561 6c29 3a0a 2020 2020 2020  JVPDual):.      
+00012340: 2020 7368 6170 652c 205f 203d 2073 6166    shape, _ = saf
+00012350: 655f 7a69 7028 2a73 6861 7065 290a 2020  e_zip(*shape).  
+00012360: 2020 6966 206c 656e 2862 726f 6164 6361    if len(broadca
+00012370: 7374 5f64 696d 656e 7369 6f6e 7329 203e  st_dimensions) >
+00012380: 2030 2061 6e64 2069 7369 6e73 7461 6e63   0 and isinstanc
+00012390: 6528 6272 6f61 6463 6173 745f 6469 6d65  e(broadcast_dime
+000123a0: 6e73 696f 6e73 5b30 5d2c 204a 5650 4475  nsions[0], JVPDu
+000123b0: 616c 293a 0a20 2020 2020 2020 2062 726f  al):.        bro
+000123c0: 6164 6361 7374 5f64 696d 656e 7369 6f6e  adcast_dimension
+000123d0: 732c 205f 203d 2073 6166 655f 7a69 7028  s, _ = safe_zip(
+000123e0: 2a62 726f 6164 6361 7374 5f64 696d 656e  *broadcast_dimen
+000123f0: 7369 6f6e 7329 0a20 2020 2072 6574 7572  sions).    retur
+00012400: 6e20 4a56 5044 7561 6c28 0a20 2020 2020  n JVPDual(.     
+00012410: 2020 2070 7269 6d73 2e62 726f 6164 6361     prims.broadca
+00012420: 7374 5f69 6e5f 6469 6d28 782c 2073 6861  st_in_dim(x, sha
+00012430: 7065 2c20 6272 6f61 6463 6173 745f 6469  pe, broadcast_di
+00012440: 6d65 6e73 696f 6e73 292c 2070 7269 6d73  mensions), prims
+00012450: 2e62 726f 6164 6361 7374 5f69 6e5f 6469  .broadcast_in_di
+00012460: 6d28 7864 2c20 7368 6170 652c 2062 726f  m(xd, shape, bro
+00012470: 6164 6361 7374 5f64 696d 656e 7369 6f6e  adcast_dimension
+00012480: 7329 0a20 2020 2029 0a0a 0a64 6566 2075  s).    )...def u
+00012490: 6e70 6163 6b5f 7365 7175 656e 6365 5f6a  npack_sequence_j
+000124a0: 7670 2873 6571 7565 6e63 653a 204a 5650  vp(sequence: JVP
+000124b0: 4475 616c 2c20 6c65 6e67 7468 3a20 4a56  Dual, length: JV
+000124c0: 5044 7561 6c29 202d 3e20 4a56 5044 7561  PDual) -> JVPDua
+000124d0: 6c3a 0a20 2020 2078 203d 2074 7265 655f  l:.    x = tree_
+000124e0: 6d61 7028 6c61 6d62 6461 2078 3a20 782e  map(lambda x: x.
+000124f0: 7072 696d 616c 2c20 7365 7175 656e 6365  primal, sequence
+00012500: 290a 2020 2020 7864 203d 2074 7265 655f  ).    xd = tree_
+00012510: 6d61 7028 6c61 6d62 6461 2078 3a20 782e  map(lambda x: x.
+00012520: 7461 6e67 656e 742c 2073 6571 7565 6e63  tangent, sequenc
+00012530: 6529 0a20 2020 206c 656e 6774 682c 205f  e).    length, _
+00012540: 203d 206c 656e 6774 680a 2020 2020 7072   = length.    pr
+00012550: 696d 616c 7320 3d20 7072 696d 732e 756e  imals = prims.un
+00012560: 7061 636b 5f73 6571 7565 6e63 6528 782c  pack_sequence(x,
+00012570: 206c 656e 6774 6829 0a20 2020 2074 616e   length).    tan
+00012580: 6765 6e74 7320 3d20 7072 696d 732e 756e  gents = prims.un
+00012590: 7061 636b 5f73 6571 7565 6e63 6528 7864  pack_sequence(xd
+000125a0: 2c20 6c65 6e67 7468 290a 2020 2020 7265  , length).    re
+000125b0: 7475 726e 2073 6166 655f 6d61 7028 7061  turn safe_map(pa
+000125c0: 6972 5f74 6f5f 6a76 705f 6475 616c 2c20  ir_to_jvp_dual, 
+000125d0: 7361 6665 5f7a 6970 2870 7269 6d61 6c73  safe_zip(primals
+000125e0: 2c20 7461 6e67 656e 7473 2929 0a0a 0a64  , tangents))...d
+000125f0: 6566 2075 6e70 6163 6b5f 7472 6976 6961  ef unpack_trivia
+00012600: 6c5f 6a76 7028 783a 204a 5650 4475 616c  l_jvp(x: JVPDual
+00012610: 2920 2d3e 204a 5650 4475 616c 3a0a 2020  ) -> JVPDual:.  
+00012620: 2020 7265 7475 726e 2078 0a0a 0a6a 7670    return x...jvp
+00012630: 5f69 6d70 6c73 3a20 6469 6374 5b70 7269  _impls: dict[pri
+00012640: 6d73 2e53 796d 626f 6c2c 2043 616c 6c61  ms.Symbol, Calla
+00012650: 626c 655d 203d 2064 6963 7428 290a 0a6a  ble] = dict()..j
+00012660: 7670 5f69 6d70 6c73 5b70 7269 6d73 2e50  vp_impls[prims.P
+00012670: 7269 6d49 4473 2e53 494e 5d20 3d20 7369  rimIDs.SIN] = si
+00012680: 6e5f 6a76 700a 6a76 705f 696d 706c 735b  n_jvp.jvp_impls[
+00012690: 7072 696d 732e 5072 696d 4944 732e 4d55  prims.PrimIDs.MU
+000126a0: 4c5d 203d 206d 756c 5f6a 7670 0a6a 7670  L] = mul_jvp.jvp
+000126b0: 5f69 6d70 6c73 5b70 7269 6d73 2e50 7269  _impls[prims.Pri
+000126c0: 6d49 4473 2e41 4444 5d20 3d20 6164 645f  mIDs.ADD] = add_
+000126d0: 6a76 700a 6a76 705f 696d 706c 735b 7072  jvp.jvp_impls[pr
+000126e0: 696d 732e 5072 696d 4944 732e 4252 4f41  ims.PrimIDs.BROA
+000126f0: 4443 4153 545f 494e 5f44 494d 5d20 3d20  DCAST_IN_DIM] = 
+00012700: 6272 6f61 6463 6173 745f 696e 5f64 696d  broadcast_in_dim
+00012710: 5f6a 7670 0a23 206a 7670 5f69 6d70 6c73  _jvp.# jvp_impls
+00012720: 5b70 7269 6d73 2e50 7269 6d49 4473 2e55  [prims.PrimIDs.U
+00012730: 4e50 4143 4b5f 5345 5155 454e 4345 5d20  NPACK_SEQUENCE] 
+00012740: 3d20 756e 7061 636b 5f73 6571 7565 6e63  = unpack_sequenc
+00012750: 655f 6a76 700a 2320 6a76 705f 696d 706c  e_jvp.# jvp_impl
+00012760: 735b 7072 696d 732e 5072 696d 4944 732e  s[prims.PrimIDs.
+00012770: 554e 5041 434b 5f54 5249 5649 414c 5d20  UNPACK_TRIVIAL] 
+00012780: 3d20 756e 7061 636b 5f74 7269 7669 616c  = unpack_trivial
+00012790: 5f6a 7670 0a0a 0a64 6566 206a 7670 5f73  _jvp...def jvp_s
+000127a0: 796d 626f 6c5f 6d61 7070 6572 2873 796d  ymbol_mapper(sym
+000127b0: 626f 6c3a 2070 7269 6d73 2e53 796d 626f  bol: prims.Symbo
+000127c0: 6c29 3a0a 2020 2020 2222 224d 6170 7320  l):.    """Maps 
+000127d0: 6120 7379 6d62 6f6c 2074 6f20 6120 4a56  a symbol to a JV
+000127e0: 5020 6675 6e63 7469 6f6e 2074 6861 7420  P function that 
+000127f0: 6576 616c 7561 7465 7320 6974 2e0a 0a20  evaluates it... 
+00012800: 2020 2041 7267 733a 0a20 2020 2020 2020     Args:.       
+00012810: 2073 796d 626f 6c20 2870 7269 6d73 2e53   symbol (prims.S
+00012820: 796d 626f 6c29 3a20 5379 6d62 6f6c 2074  ymbol): Symbol t
+00012830: 6f20 6576 616c 7561 7465 2e0a 0a20 2020  o evaluate...   
+00012840: 2052 6169 7365 733a 0a20 2020 2020 2020   Raises:.       
+00012850: 204e 6f74 496d 706c 656d 656e 7465 6445   NotImplementedE
+00012860: 7272 6f72 3a20 4966 2074 6865 204a 5650  rror: If the JVP
+00012870: 2066 6f72 2074 6865 2073 796d 626f 6c20   for the symbol 
+00012880: 6973 206e 6f74 2069 6d70 6c65 6d65 6e74  is not implement
+00012890: 6564 2e0a 0a20 2020 2052 6574 7572 6e73  ed...    Returns
+000128a0: 3a0a 2020 2020 2020 2020 4361 6c6c 6162  :.        Callab
+000128b0: 6c65 3a20 4a56 5020 6675 6e63 7469 6f6e  le: JVP function
+000128c0: 2074 6861 7420 6576 616c 7561 7465 7320   that evaluates 
+000128d0: 7468 6520 7379 6d62 6f6c 2e0a 2020 2020  the symbol..    
+000128e0: 2222 220a 0a20 2020 2064 6566 2077 7261  """..    def wra
+000128f0: 705f 6172 6728 7829 3a0a 2020 2020 2020  p_arg(x):.      
+00012900: 2020 6966 2069 7369 6e73 7461 6e63 6528    if isinstance(
+00012910: 782c 204a 5650 4475 616c 293a 0a20 2020  x, JVPDual):.   
+00012920: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00012930: 780a 2020 2020 2020 2020 656c 6966 2069  x.        elif i
+00012940: 7369 6e73 7461 6e63 6528 782c 204e 756d  sinstance(x, Num
+00012950: 6265 7229 3a0a 2020 2020 2020 2020 2020  ber):.          
+00012960: 2020 7265 7475 726e 204a 5650 4475 616c    return JVPDual
+00012970: 2878 2c20 7479 7065 2878 2928 3029 290a  (x, type(x)(0)).
+00012980: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00012990: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+000129a0: 5661 6c75 6545 7272 6f72 2866 224a 5650  ValueError(f"JVP
+000129b0: 2077 7261 705f 6172 6720 676f 7420 616e   wrap_arg got an
+000129c0: 2075 6e73 7570 706f 7274 6564 2074 7970   unsupported typ
+000129d0: 6520 7b74 7970 6528 7829 7d22 290a 0a20  e {type(x)}").. 
+000129e0: 2020 2023 2049 6620 7379 6d62 6f6c 2e61     # If symbol.a
+000129f0: 7267 7320 646f 6573 6e27 7420 6861 7665  rgs doesn't have
+00012a00: 2073 7562 636c 6173 7365 7320 6f66 2056   subclasses of V
+00012a10: 6172 6961 626c 652c 2074 6865 6e20 7765  ariable, then we
+00012a20: 206e 6565 6420 746f 2072 6574 7572 6e20   need to return 
+00012a30: 6120 7a65 726f 2074 616e 6765 6e74 0a20  a zero tangent. 
+00012a40: 2020 2023 2054 4f44 4f3a 2074 6865 7265     # TODO: there
+00012a50: 206d 6179 2062 6520 6120 6265 7474 6572   may be a better
+00012a60: 2077 6179 2074 6f20 6465 7465 6374 2063   way to detect c
+00012a70: 6f6e 7374 616e 7473 2069 6e20 7468 6520  onstants in the 
+00012a80: 7472 6163 650a 2020 2020 6966 2073 796d  trace.    if sym
+00012a90: 626f 6c2e 6172 655f 616c 6c5f 6172 6773  bol.are_all_args
+00012aa0: 5f63 6f6e 7374 616e 743a 0a0a 2020 2020  _constant:..    
+00012ab0: 2020 2020 6465 6620 7a65 726f 735f 6c69      def zeros_li
+00012ac0: 6b65 2878 293a 0a20 2020 2020 2020 2020  ke(x):.         
+00012ad0: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
+00012ae0: 2878 2c20 5465 6e73 6f72 5072 6f78 7929  (x, TensorProxy)
+00012af0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00012b00: 2020 7265 7475 726e 2066 756c 6c5f 6c69    return full_li
+00012b10: 6b65 2878 2c20 6669 6c6c 5f76 616c 7565  ke(x, fill_value
+00012b20: 3d30 290a 2020 2020 2020 2020 2020 2020  =0).            
+00012b30: 656c 6966 2069 7369 6e73 7461 6e63 6528  elif isinstance(
+00012b40: 782c 204e 756d 6265 7250 726f 7879 293a  x, NumberProxy):
+00012b50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00012b60: 2072 6574 7572 6e20 7479 7065 2878 2e76   return type(x.v
+00012b70: 616c 7565 2928 3029 0a20 2020 2020 2020  alue)(0).       
+00012b80: 2020 2020 2065 6c69 6620 6973 696e 7374       elif isinst
+00012b90: 616e 6365 2878 2c20 4e75 6d62 6572 293a  ance(x, Number):
+00012ba0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00012bb0: 2072 6574 7572 6e20 7479 7065 2878 2928   return type(x)(
+00012bc0: 3029 0a20 2020 2020 2020 2020 2020 2065  0).            e
+00012bd0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00012be0: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
+00012bf0: 4572 726f 7228 6622 7a65 726f 735f 6c69  Error(f"zeros_li
+00012c00: 6b65 2069 6e73 6964 6520 4a56 5020 676f  ke inside JVP go
+00012c10: 7420 616e 2075 6e73 7570 706f 7274 6564  t an unsupported
+00012c20: 2074 7970 6520 7b74 7970 6528 7829 7d22   type {type(x)}"
+00012c30: 290a 0a20 2020 2020 2020 2064 6566 206a  )..        def j
+00012c40: 7670 5f69 6d70 6c5f 636f 6e73 7428 7379  vp_impl_const(sy
+00012c50: 6d62 6f6c 2c20 2a61 7267 732c 202a 2a6b  mbol, *args, **k
+00012c60: 7761 7267 7329 3a0a 2020 2020 2020 2020  wargs):.        
+00012c70: 2020 2020 7072 696d 616c 7320 3d20 7379      primals = sy
+00012c80: 6d62 6f6c 5f74 6f5f 6576 616c 2873 796d  mbol_to_eval(sym
+00012c90: 626f 6c29 282a 6172 6773 2c20 2a2a 6b77  bol)(*args, **kw
+00012ca0: 6172 6773 290a 2020 2020 2020 2020 2020  args).          
+00012cb0: 2020 6966 2069 7369 6e73 7461 6e63 6528    if isinstance(
+00012cc0: 7072 696d 616c 732c 2053 6571 7565 6e63  primals, Sequenc
+00012cd0: 6529 3a0a 2020 2020 2020 2020 2020 2020  e):.            
+00012ce0: 2020 2020 7461 6e67 656e 7473 203d 2074      tangents = t
+00012cf0: 7570 6c65 287a 6572 6f73 5f6c 696b 6528  uple(zeros_like(
+00012d00: 7029 2066 6f72 2070 2069 6e20 7072 696d  p) for p in prim
+00012d10: 616c 7329 0a20 2020 2020 2020 2020 2020  als).           
+00012d20: 2020 2020 2072 6574 7572 6e20 7361 6665       return safe
+00012d30: 5f6d 6170 2870 6169 725f 746f 5f6a 7670  _map(pair_to_jvp
+00012d40: 5f64 7561 6c2c 2073 6166 655f 7a69 7028  _dual, safe_zip(
+00012d50: 7072 696d 616c 732c 2074 616e 6765 6e74  primals, tangent
+00012d60: 7329 290a 2020 2020 2020 2020 2020 2020  s)).            
+00012d70: 7265 7475 726e 204a 5650 4475 616c 2870  return JVPDual(p
+00012d80: 7269 6d61 6c73 2c20 7a65 726f 735f 6c69  rimals, zeros_li
+00012d90: 6b65 2870 7269 6d61 6c73 2929 0a0a 2020  ke(primals))..  
+00012da0: 2020 2020 2020 7265 7475 726e 2070 6172        return par
+00012db0: 7469 616c 286a 7670 5f69 6d70 6c5f 636f  tial(jvp_impl_co
+00012dc0: 6e73 742c 2073 796d 626f 6c29 0a0a 2020  nst, symbol)..  
+00012dd0: 2020 2320 4e6f 726d 616c 2063 6173 652c    # Normal case,
+00012de0: 2077 6520 6861 7665 2061 2070 726f 7879   we have a proxy
+00012df0: 2074 616e 6765 6e74 0a20 2020 206a 7670   tangent.    jvp
+00012e00: 5f69 6d70 6c20 3d20 6a76 705f 696d 706c  _impl = jvp_impl
+00012e10: 732e 6765 7428 7379 6d62 6f6c 2e73 796d  s.get(symbol.sym
+00012e20: 2e69 6429 0a20 2020 2069 6620 6a76 705f  .id).    if jvp_
+00012e30: 696d 706c 2069 7320 4e6f 6e65 3a0a 2020  impl is None:.  
+00012e40: 2020 2020 2020 7261 6973 6520 4e6f 7449        raise NotI
+00012e50: 6d70 6c65 6d65 6e74 6564 4572 726f 7228  mplementedError(
+00012e60: 6622 4a56 5020 666f 7220 7b73 796d 626f  f"JVP for {symbo
+00012e70: 6c2e 7379 6d2e 6964 7d20 6973 206e 6f74  l.sym.id} is not
+00012e80: 2069 6d70 6c65 6d65 6e74 6564 2229 0a0a   implemented")..
+00012e90: 2020 2020 6465 6620 5f6a 7670 5f69 6d70      def _jvp_imp
+00012ea0: 6c28 2a61 7267 732c 202a 2a6b 7761 7267  l(*args, **kwarg
+00012eb0: 7329 3a0a 2020 2020 2020 2020 6172 6773  s):.        args
+00012ec0: 203d 2074 7265 655f 6d61 7028 7772 6170   = tree_map(wrap
+00012ed0: 5f61 7267 2c20 6172 6773 290a 2020 2020  _arg, args).    
+00012ee0: 2020 2020 2320 4578 7065 6374 696e 6720      # Expecting 
+00012ef0: 4a56 5044 7561 6c73 2077 7261 7070 696e  JVPDuals wrappin
+00012f00: 6720 7061 6972 7320 6f66 2070 7269 6d61  g pairs of prima
+00012f10: 6c73 2061 6e64 2074 616e 6765 6e74 730a  ls and tangents.
+00012f20: 2020 2020 2020 2020 6173 7365 7274 2061          assert a
+00012f30: 6c6c 2869 7369 6e73 7461 6e63 6528 6172  ll(isinstance(ar
+00012f40: 672c 204a 5650 4475 616c 2920 666f 7220  g, JVPDual) for 
+00012f50: 6172 6720 696e 2074 7265 655f 666c 6174  arg in tree_flat
+00012f60: 7465 6e28 6172 6773 295b 305d 290a 2020  ten(args)[0]).  
+00012f70: 2020 2020 2020 7265 7475 726e 206a 7670        return jvp
+00012f80: 5f69 6d70 6c28 2a61 7267 732c 202a 2a6b  _impl(*args, **k
+00012f90: 7761 7267 7329 0a0a 2020 2020 7265 7475  wargs)..    retu
+00012fa0: 726e 205f 6a76 705f 696d 706c 0a0a 0a64  rn _jvp_impl...d
+00012fb0: 6566 205f 6a76 705f 6361 6c6c 5f6d 6574  ef _jvp_call_met
+00012fc0: 6166 756e 6328 6465 7461 6368 6564 3a20  afunc(detached: 
+00012fd0: 626f 6f6c 2c20 7072 696d 616c 732c 2074  bool, primals, t
+00012fe0: 616e 6765 6e74 732c 202a 2c20 6675 6e63  angents, *, func
+00012ff0: 7469 6f6e 5f74 7261 6365 3a20 5472 6163  tion_trace: Trac
+00013000: 652c 202a 2a6b 7761 7267 7329 3a0a 2020  e, **kwargs):.  
+00013010: 2020 2222 224d 6574 6166 756e 6374 696f    """Metafunctio
+00013020: 6e20 666f 7220 7468 6520 4a56 5020 7472  n for the JVP tr
+00013030: 616e 7366 6f72 6d2e 0a0a 2020 2020 4172  ansform...    Ar
+00013040: 6773 3a0a 2020 2020 2020 2020 6465 7461  gs:.        deta
+00013050: 6368 6564 2028 626f 6f6c 293a 2057 6865  ched (bool): Whe
+00013060: 7468 6572 2074 6f20 6465 7461 6368 2074  ther to detach t
+00013070: 6865 2074 7261 6365 2e0a 2020 2020 2020  he trace..      
+00013080: 2020 7072 696d 616c 7320 2854 7570 6c65    primals (Tuple
+00013090: 5b50 726f 7879 5d29 3a20 5072 696d 616c  [Proxy]): Primal
+000130a0: 2076 616c 7565 732e 0a20 2020 2020 2020   values..       
+000130b0: 2074 616e 6765 6e74 7320 2854 7570 6c65   tangents (Tuple
+000130c0: 5b50 726f 7879 5d29 3a20 5461 6e67 656e  [Proxy]): Tangen
+000130d0: 7420 7661 6c75 6573 2e0a 2020 2020 2020  t values..      
+000130e0: 2020 6675 6e63 7469 6f6e 5f74 7261 6365    function_trace
+000130f0: 2028 5472 6163 6529 3a20 5472 6163 6520   (Trace): Trace 
+00013100: 6f66 2074 6865 2066 756e 6374 696f 6e20  of the function 
+00013110: 746f 2062 6520 7472 616e 7366 6f72 6d65  to be transforme
+00013120: 642e 0a20 2020 2020 2020 206b 7761 7267  d..        kwarg
+00013130: 733a 204b 6579 776f 7264 2061 7267 756d  s: Keyword argum
+00013140: 656e 7473 2e0a 0a20 2020 2052 6169 7365  ents...    Raise
+00013150: 733a 0a20 2020 2020 2020 2041 7373 6572  s:.        Asser
+00013160: 7469 6f6e 4572 726f 723a 2049 6620 7468  tionError: If th
+00013170: 6520 4a56 5020 666f 7220 6b65 7977 6f72  e JVP for keywor
+00013180: 6420 6172 6775 6d65 6e74 7320 6973 206e  d arguments is n
+00013190: 6f74 2069 6d70 6c65 6d65 6e74 6564 2e0a  ot implemented..
+000131a0: 0a20 2020 2052 6574 7572 6e73 3a0a 2020  .    Returns:.  
+000131b0: 2020 2020 2020 5265 7375 6c74 206f 6620        Result of 
+000131c0: 7468 6520 4a56 5020 7472 616e 7366 6f72  the JVP transfor
+000131d0: 6d2e 0a20 2020 2022 2222 0a20 2020 2061  m..    """.    a
+000131e0: 7373 6572 7420 6c65 6e28 6b77 6172 6773  ssert len(kwargs
+000131f0: 2920 3d3d 2030 2c20 224a 5650 2066 6f72  ) == 0, "JVP for
+00013200: 206b 7761 7267 7320 6973 206e 6f74 2069   kwargs is not i
+00013210: 6d70 6c65 6d65 6e74 6564 220a 0a20 2020  mplemented"..   
+00013220: 2063 7478 203d 2064 6574 6163 6865 645f   ctx = detached_
+00013230: 7472 6163 6528 2920 6966 2064 6574 6163  trace() if detac
+00013240: 6865 6420 656c 7365 206e 756c 6c63 6f6e  hed else nullcon
+00013250: 7465 7874 2829 0a20 2020 2077 6974 6820  text().    with 
+00013260: 6374 783a 0a20 2020 2020 2020 2023 2057  ctx:.        # W
+00013270: 7261 7070 696e 6720 7468 6520 7072 696d  rapping the prim
+00013280: 616c 7320 616e 6420 7461 6e67 656e 7473  als and tangents
+00013290: 2069 6e20 4a56 5044 7561 6c73 2069 7320   in JVPDuals is 
+000132a0: 6e6f 7420 7374 7269 6374 6c79 206e 6563  not strictly nec
+000132b0: 6573 7361 7279 2c20 6275 7420 6974 206d  essary, but it m
+000132c0: 616b 6573 0a20 2020 2020 2020 2023 2074  akes.        # t
+000132d0: 6865 2063 6f64 6520 6d6f 7265 2072 6561  he code more rea
+000132e0: 6461 626c 650a 2020 2020 2020 2020 2320  dable.        # 
+000132f0: 5765 2070 726f 7061 6761 7465 2074 6865  We propagate the
+00013300: 204a 5650 4475 616c 7320 7468 726f 7567   JVPDuals throug
+00013310: 6820 7468 6520 7472 6163 652c 2061 6e64  h the trace, and
+00013320: 2074 6865 6e20 756e 7772 6170 2074 6865   then unwrap the
+00013330: 6d20 6174 2074 6865 2065 6e64 0a20 2020  m at the end.   
+00013340: 2020 2020 2070 7269 6d61 6c73 5f74 616e       primals_tan
+00013350: 6765 6e74 735f 6475 616c 7320 3d20 7361  gents_duals = sa
+00013360: 6665 5f6d 6170 2870 6169 725f 746f 5f6a  fe_map(pair_to_j
+00013370: 7670 5f64 7561 6c2c 2073 6166 655f 7a69  vp_dual, safe_zi
+00013380: 7028 7072 696d 616c 732c 2074 616e 6765  p(primals, tange
+00013390: 6e74 7329 290a 2020 2020 2020 2020 7265  nts)).        re
+000133a0: 7375 6c74 203d 2065 7661 6c5f 7472 6163  sult = eval_trac
+000133b0: 6528 6675 6e63 7469 6f6e 5f74 7261 6365  e(function_trace
+000133c0: 2c20 2a70 7269 6d61 6c73 5f74 616e 6765  , *primals_tange
+000133d0: 6e74 735f 6475 616c 732c 2073 796d 626f  nts_duals, symbo
+000133e0: 6c5f 6d61 7070 6572 3d6a 7670 5f73 796d  l_mapper=jvp_sym
+000133f0: 626f 6c5f 6d61 7070 6572 290a 2020 2020  bol_mapper).    
+00013400: 2020 2020 2320 556e 7772 6170 7069 6e67      # Unwrapping
+00013410: 2074 6865 204a 5650 4475 616c 730a 2020   the JVPDuals.  
+00013420: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
+00013430: 6e63 6528 7265 7375 6c74 2c20 5365 7175  nce(result, Sequ
+00013440: 656e 6365 293a 0a20 2020 2020 2020 2020  ence):.         
+00013450: 2020 2061 7373 6572 7420 616c 6c28 6973     assert all(is
+00013460: 696e 7374 616e 6365 2878 2c20 4a56 5044  instance(x, JVPD
+00013470: 7561 6c29 2066 6f72 2078 2069 6e20 7265  ual) for x in re
+00013480: 7375 6c74 290a 2020 2020 2020 2020 2020  sult).          
+00013490: 2020 7072 696d 616c 732c 2074 616e 6765    primals, tange
+000134a0: 6e74 7320 3d20 756e 7a69 7032 2872 6573  nts = unzip2(res
+000134b0: 756c 7429 0a20 2020 2020 2020 2020 2020  ult).           
+000134c0: 2072 6574 7572 6e20 7072 696d 616c 732c   return primals,
+000134d0: 2074 616e 6765 6e74 730a 2020 2020 2020   tangents.      
+000134e0: 2020 6173 7365 7274 2069 7369 6e73 7461    assert isinsta
+000134f0: 6e63 6528 7265 7375 6c74 2c20 4a56 5044  nce(result, JVPD
+00013500: 7561 6c29 0a20 2020 2020 2020 2072 6574  ual).        ret
+00013510: 7572 6e20 7265 7375 6c74 2e70 7269 6d61  urn result.prima
+00013520: 6c2c 2072 6573 756c 742e 7461 6e67 656e  l, result.tangen
+00013530: 740a 0a0a 6a76 705f 6361 6c6c 203d 2053  t...jvp_call = S
+00013540: 796d 626f 6c28 6964 3d54 7261 6e73 666f  ymbol(id=Transfo
+00013550: 726d 732e 4a76 704f 702c 206e 616d 653d  rms.JvpOp, name=
+00013560: 226a 7670 5f63 616c 6c22 2c20 6d65 7461  "jvp_call", meta
+00013570: 3d70 6172 7469 616c 285f 6a76 705f 6361  =partial(_jvp_ca
+00013580: 6c6c 5f6d 6574 6166 756e 632c 2046 616c  ll_metafunc, Fal
+00013590: 7365 2929 0a0a 0a64 6566 205f 6964 656e  se))...def _iden
+000135a0: 7469 7479 5f63 616c 6c5f 6a76 7028 2a61  tity_call_jvp(*a
+000135b0: 7267 733a 204a 5650 4475 616c 2c20 7472  rgs: JVPDual, tr
+000135c0: 6163 653a 2054 7261 6365 2c20 2a2a 6b77  ace: Trace, **kw
+000135d0: 6172 6773 293a 0a20 2020 2070 7269 6d61  args):.    prima
+000135e0: 6c73 2c20 7461 6e67 656e 7473 203d 2075  ls, tangents = u
+000135f0: 6e7a 6970 3228 6172 6773 290a 2020 2020  nzip2(args).    
+00013600: 6f75 745f 7072 696d 616c 732c 206f 7574  out_primals, out
+00013610: 5f74 616e 6765 6e74 7320 3d20 5f6a 7670  _tangents = _jvp
+00013620: 5f63 616c 6c5f 6d65 7461 6675 6e63 2846  _call_metafunc(F
+00013630: 616c 7365 2c20 7072 696d 616c 732c 2074  alse, primals, t
+00013640: 616e 6765 6e74 732c 2074 7261 6365 2c20  angents, trace, 
+00013650: 2a2a 6b77 6172 6773 290a 2020 2020 6966  **kwargs).    if
+00013660: 2069 7369 6e73 7461 6e63 6528 6f75 745f   isinstance(out_
+00013670: 7072 696d 616c 732c 2053 6571 7565 6e63  primals, Sequenc
+00013680: 6529 3a0a 2020 2020 2020 2020 7265 7475  e):.        retu
+00013690: 726e 2073 6166 655f 6d61 7028 7061 6972  rn safe_map(pair
+000136a0: 5f74 6f5f 6a76 705f 6475 616c 2c20 7361  _to_jvp_dual, sa
+000136b0: 6665 5f7a 6970 286f 7574 5f70 7269 6d61  fe_zip(out_prima
+000136c0: 6c73 2c20 6f75 745f 7461 6e67 656e 7473  ls, out_tangents
+000136d0: 2929 0a20 2020 2072 6574 7572 6e20 4a56  )).    return JV
+000136e0: 5044 7561 6c28 6f75 745f 7072 696d 616c  PDual(out_primal
+000136f0: 732c 206f 7574 5f74 616e 6765 6e74 7329  s, out_tangents)
+00013700: 0a0a 0a6a 7670 5f69 6d70 6c73 5b54 7261  ...jvp_impls[Tra
+00013710: 6e73 666f 726d 732e 4964 656e 7469 7479  nsforms.Identity
+00013720: 4f70 5d20 3d20 5f69 6465 6e74 6974 795f  Op] = _identity_
+00013730: 6361 6c6c 5f6a 7670 0a0a 0a64 6566 205f  call_jvp...def _
+00013740: 766d 6170 5f63 616c 6c5f 6a76 7028 6172  vmap_call_jvp(ar
+00013750: 6773 3a20 4a56 5044 7561 6c2c 2069 6e5f  gs: JVPDual, in_
+00013760: 6469 6d73 2c20 6f75 745f 6469 6d73 2c20  dims, out_dims, 
+00013770: 6178 6973 5f73 697a 652c 2074 7261 6365  axis_size, trace
+00013780: 3a20 5472 6163 652c 202a 2a6b 7761 7267  : Trace, **kwarg
+00013790: 7329 3a0a 2020 2020 7072 696d 616c 732c  s):.    primals,
+000137a0: 2074 616e 6765 6e74 7320 3d20 7361 6665   tangents = safe
+000137b0: 5f7a 6970 282a 6172 6773 290a 2020 2020  _zip(*args).    
+000137c0: 696e 5f64 696d 732c 205f 203d 2073 6166  in_dims, _ = saf
+000137d0: 655f 7a69 7028 2a69 6e5f 6469 6d73 290a  e_zip(*in_dims).
+000137e0: 2020 2020 6f75 745f 6469 6d73 2c20 5f20      out_dims, _ 
+000137f0: 3d20 7361 6665 5f7a 6970 282a 6f75 745f  = safe_zip(*out_
+00013800: 6469 6d73 290a 2020 2020 766d 6170 7065  dims).    vmappe
+00013810: 645f 7472 6163 6520 3d20 636f 6e73 7472  d_trace = constr
+00013820: 7563 745f 7472 6163 6528 2928 0a20 2020  uct_trace()(.   
+00013830: 2020 2020 2076 6d61 7028 7061 7274 6961       vmap(partia
+00013840: 6c28 6576 616c 5f74 7261 6365 2c20 7472  l(eval_trace, tr
+00013850: 6163 6529 2c20 696e 5f64 696d 733d 696e  ace), in_dims=in
+00013860: 5f64 696d 732c 206f 7574 5f64 696d 733d  _dims, out_dims=
+00013870: 6f75 745f 6469 6d73 2c20 6178 6973 5f73  out_dims, axis_s
+00013880: 697a 653d 6178 6973 5f73 697a 6529 2c20  ize=axis_size), 
+00013890: 2a70 7269 6d61 6c73 0a20 2020 2029 0a20  *primals.    ). 
+000138a0: 2020 2076 6d61 7070 6564 5f66 756e 6320     vmapped_func 
+000138b0: 3d20 7061 7274 6961 6c28 6576 616c 5f74  = partial(eval_t
+000138c0: 7261 6365 2c20 766d 6170 7065 645f 7472  race, vmapped_tr
+000138d0: 6163 6529 0a20 2020 206f 7574 5f70 7269  ace).    out_pri
+000138e0: 6d61 6c73 2c20 6f75 745f 7461 6e67 656e  mals, out_tangen
+000138f0: 7473 203d 206a 7670 2876 6d61 7070 6564  ts = jvp(vmapped
+00013900: 5f66 756e 6329 2870 7269 6d61 6c73 2c20  _func)(primals, 
+00013910: 7461 6e67 656e 7473 2c20 2a2a 6b77 6172  tangents, **kwar
+00013920: 6773 290a 2020 2020 6966 2069 7369 6e73  gs).    if isins
+00013930: 7461 6e63 6528 6f75 745f 7072 696d 616c  tance(out_primal
+00013940: 732c 2053 6571 7565 6e63 6529 3a0a 2020  s, Sequence):.  
+00013950: 2020 2020 2020 7265 7475 726e 2073 6166        return saf
+00013960: 655f 6d61 7028 7061 6972 5f74 6f5f 6a76  e_map(pair_to_jv
+00013970: 705f 6475 616c 2c20 7361 6665 5f7a 6970  p_dual, safe_zip
+00013980: 286f 7574 5f70 7269 6d61 6c73 2c20 6f75  (out_primals, ou
+00013990: 745f 7461 6e67 656e 7473 2929 0a20 2020  t_tangents)).   
+000139a0: 2072 6574 7572 6e20 4a56 5044 7561 6c28   return JVPDual(
+000139b0: 6f75 745f 7072 696d 616c 732c 206f 7574  out_primals, out
+000139c0: 5f74 616e 6765 6e74 7329 0a0a 0a6a 7670  _tangents)...jvp
+000139d0: 5f69 6d70 6c73 5b54 7261 6e73 666f 726d  _impls[Transform
+000139e0: 732e 566d 6170 4f70 5d20 3d20 5f76 6d61  s.VmapOp] = _vma
+000139f0: 705f 6361 6c6c 5f6a 7670 0a0a 0a64 6566  p_call_jvp...def
+00013a00: 206a 7670 2866 756e 6329 3a0a 2020 2020   jvp(func):.    
+00013a10: 2222 224a 6163 6f62 6961 6e2d 7665 6374  """Jacobian-vect
+00013a20: 6f72 2070 726f 6475 6374 2074 7261 6e73  or product trans
+00013a30: 666f 726d 2066 6f72 2061 2054 6875 6e64  form for a Thund
+00013a40: 6572 2066 756e 6374 696f 6e2e 0a0a 2020  er function...  
+00013a50: 2020 4172 6773 3a0a 2020 2020 2020 2020    Args:.        
+00013a60: 6675 6e63 2028 4361 6c6c 6162 6c65 293a  func (Callable):
+00013a70: 2041 2054 6875 6e64 6572 2066 756e 6374   A Thunder funct
+00013a80: 696f 6e20 746f 2062 6520 7472 616e 7366  ion to be transf
+00013a90: 6f72 6d65 642e 0a0a 2020 2020 5265 7475  ormed...    Retu
+00013aa0: 726e 733a 0a20 2020 2020 2020 2043 616c  rns:.        Cal
+00013ab0: 6c61 626c 653a 2041 2066 756e 6374 696f  lable: A functio
+00013ac0: 6e20 7468 6174 2063 6f6d 7075 7465 7320  n that computes 
+00013ad0: 7468 6520 4a61 636f 6269 616e 2d76 6563  the Jacobian-vec
+00013ae0: 746f 7220 7072 6f64 7563 740a 2020 2020  tor product.    
+00013af0: 2020 2020 2020 2020 7461 6b69 6e67 2070          taking p
+00013b00: 7269 6d61 6c73 2061 6e64 2074 616e 6765  rimals and tange
+00013b10: 6e74 7320 6173 2061 7267 756d 656e 7473  nts as arguments
+00013b20: 2e0a 2020 2020 2222 220a 0a20 2020 2064  ..    """..    d
+00013b30: 6566 2077 7261 7070 6572 2870 7269 6d61  ef wrapper(prima
+00013b40: 6c73 2c20 7461 6e67 656e 7473 293a 0a20  ls, tangents):. 
+00013b50: 2020 2020 2020 2074 7261 6365 203d 2063         trace = c
+00013b60: 6f6e 7374 7275 6374 5f74 7261 6365 2829  onstruct_trace()
+00013b70: 2866 756e 632c 202a 7072 696d 616c 7329  (func, *primals)
+00013b80: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00013b90: 6a76 705f 6361 6c6c 2870 7269 6d61 6c73  jvp_call(primals
+00013ba0: 2c20 7461 6e67 656e 7473 2c20 6675 6e63  , tangents, func
+00013bb0: 7469 6f6e 5f74 7261 6365 3d74 7261 6365  tion_trace=trace
+00013bc0: 290a 0a20 2020 2072 6574 7572 6e20 7772  )..    return wr
+00013bd0: 6170 7065 720a 0a0a 2320 544f 444f 2054  apper...# TODO T
+00013be0: 6869 7320 6675 6e63 7469 6f6e 2063 6f6d  his function com
+00013bf0: 6d65 6e74 6564 206f 7574 2062 6563 6175  mented out becau
+00013c00: 7365 2069 7420 6361 6c6c 7320 6d61 6b65  se it calls make
+00013c10: 5f74 7261 6365 642c 2077 6869 6368 2064  _traced, which d
+00013c20: 6f65 7320 6e6f 7420 6578 6973 740a 2320  oes not exist.# 
+00013c30: 6465 6620 6a76 705f 6561 6765 7228 6675  def jvp_eager(fu
+00013c40: 6e63 2c20 7072 696d 616c 732c 2074 616e  nc, primals, tan
+00013c50: 6765 6e74 732c 2065 7865 6375 746f 723d  gents, executor=
+00013c60: 2274 6f72 6368 2229 3a0a 2320 2020 2020  "torch"):.#     
+00013c70: 2222 2243 6f6d 7075 7465 7320 7468 6520  """Computes the 
+00013c80: 4a61 636f 6269 616e 2d76 6563 746f 7220  Jacobian-vector 
+00013c90: 7072 6f64 7563 7420 6f66 2061 2054 6875  product of a Thu
+00013ca0: 6e64 6572 2066 756e 6374 696f 6e2e 0a0a  nder function...
+00013cb0: 2320 2020 2020 4172 6773 3a0a 2320 2020  #     Args:.#   
+00013cc0: 2020 2020 2020 6675 6e63 2028 4361 6c6c        func (Call
+00013cd0: 6162 6c65 293a 2041 2054 6875 6e64 6572  able): A Thunder
+00013ce0: 2066 756e 6374 696f 6e20 746f 2062 6520   function to be 
+00013cf0: 7472 616e 7366 6f72 6d65 642e 0a23 2020  transformed..#  
+00013d00: 2020 2020 2020 2070 7269 6d61 6c73 2028         primals (
+00013d10: 5f74 7970 655f 293a 2050 7269 6d61 6c73  _type_): Primals
+00013d20: 206f 6620 7468 6520 6675 6e63 7469 6f6e   of the function
+00013d30: 2e0a 2320 2020 2020 2020 2020 7461 6e67  ..#         tang
+00013d40: 656e 7473 2028 5f74 7970 655f 293a 2054  ents (_type_): T
+00013d50: 616e 6765 6e74 7320 6f66 2074 6865 2066  angents of the f
+00013d60: 756e 6374 696f 6e2e 0a23 2020 2020 2020  unction..#      
+00013d70: 2020 2065 7865 6375 746f 7220 2873 7472     executor (str
+00013d80: 2c20 6f70 7469 6f6e 616c 293a 2045 7865  , optional): Exe
+00013d90: 6375 746f 7220 746f 2075 7365 2e20 4465  cutor to use. De
+00013da0: 6661 756c 7473 2074 6f20 2274 6f72 6368  faults to "torch
+00013db0: 222e 0a0a 2320 2020 2020 5265 7475 726e  "...#     Return
+00013dc0: 733a 0a23 2020 2020 2020 2020 2054 6865  s:.#         The
+00013dd0: 2072 6573 756c 7420 6f66 2074 6865 204a   result of the J
+00013de0: 6163 6f62 6961 6e2d 7665 6374 6f72 2070  acobian-vector p
+00013df0: 726f 6475 6374 2e0a 2320 2020 2020 2222  roduct..#     ""
+00013e00: 220a 2320 2020 2020 7472 6163 6520 3d20  ".#     trace = 
+00013e10: 6d61 6b65 5f74 7261 6365 2866 756e 632c  make_trace(func,
+00013e20: 2065 7865 6375 746f 723d 6578 6563 7574   executor=execut
+00013e30: 6f72 2c20 2a70 7269 6d61 6c73 290a 0a23  or, *primals)..#
+00013e40: 2020 2020 2064 6566 206a 7670 5f66 756e       def jvp_fun
+00013e50: 6328 2a70 7269 6d61 6c73 5f61 6e64 5f74  c(*primals_and_t
+00013e60: 616e 6765 6e74 7329 3a0a 2320 2020 2020  angents):.#     
+00013e70: 2020 2020 5f70 7269 6d61 6c73 2c20 5f74      _primals, _t
+00013e80: 616e 6765 6e74 7320 3d20 7072 696d 616c  angents = primal
+00013e90: 735f 616e 645f 7461 6e67 656e 7473 5b3a  s_and_tangents[:
+00013ea0: 206c 656e 2870 7269 6d61 6c73 295d 2c20   len(primals)], 
+00013eb0: 7072 696d 616c 735f 616e 645f 7461 6e67  primals_and_tang
+00013ec0: 656e 7473 5b6c 656e 2870 7269 6d61 6c73  ents[len(primals
+00013ed0: 2920 3a5d 0a23 2020 2020 2020 2020 2072  ) :].#         r
+00013ee0: 6574 7572 6e20 5f6a 7670 5f63 616c 6c5f  eturn _jvp_call_
+00013ef0: 6d65 7461 6675 6e63 285f 7072 696d 616c  metafunc(_primal
+00013f00: 732c 205f 7461 6e67 656e 7473 2c20 7472  s, _tangents, tr
+00013f10: 6163 652c 2064 6574 6163 6865 643d 4661  ace, detached=Fa
+00013f20: 6c73 6529 0a0a 2320 2020 2020 6a76 705f  lse)..#     jvp_
+00013f30: 7472 6163 6520 3d20 6d61 6b65 5f74 7261  trace = make_tra
+00013f40: 6365 286a 7670 5f66 756e 632c 2065 7865  ce(jvp_func, exe
+00013f50: 6375 746f 723d 6578 6563 7574 6f72 2928  cutor=executor)(
+00013f60: 2a70 7269 6d61 6c73 2c20 2a74 616e 6765  *primals, *tange
+00013f70: 6e74 7329 0a23 2020 2020 206a 7670 5f74  nts).#     jvp_t
+00013f80: 7261 6365 6420 3d20 6d61 6b65 5f74 7261  raced = make_tra
+00013f90: 6365 6428 7061 7274 6961 6c28 6576 616c  ced(partial(eval
+00013fa0: 5f74 7261 6365 2c20 6a76 705f 7472 6163  _trace, jvp_trac
+00013fb0: 6529 2c20 6578 6563 7574 6f72 3d65 7865  e), executor=exe
+00013fc0: 6375 746f 7229 0a23 2020 2020 2072 6574  cutor).#     ret
+00013fd0: 7572 6e20 6a76 705f 7472 6163 6564 282a  urn jvp_traced(*
+00013fe0: 7072 696d 616c 732c 202a 7461 6e67 656e  primals, *tangen
+00013ff0: 7473 290a 0a0a 2320 564a 5020 7472 616e  ts)...# VJP tran
+00014000: 7366 6f72 6d0a 2320 3d3d 3d3d 3d3d 3d3d  sform.# ========
+00014010: 3d3d 3d3d 3d0a 4064 6174 6163 6c61 7373  =====.@dataclass
+00014020: 2866 726f 7a65 6e3d 5472 7565 290a 636c  (frozen=True).cl
+00014030: 6173 7320 564a 5044 7561 6c3a 0a20 2020  ass VJPDual:.   
+00014040: 2022 2222 4120 7061 6972 206f 6620 7072   """A pair of pr
+00014050: 696d 616c 2061 6e64 2073 6176 6564 2069  imal and saved i
+00014060: 6e66 6f72 6d61 7469 6f6e 2066 6f72 2062  nformation for b
+00014070: 6163 6b77 6172 6420 2872 6573 6964 7561  ackward (residua
+00014080: 6c73 292e 0a0a 2020 2020 4172 6773 3a0a  ls)...    Args:.
+00014090: 2020 2020 2020 2020 7072 696d 616c 2028          primal (
+000140a0: 556e 696f 6e5b 5072 6f78 792c 204e 756d  Union[Proxy, Num
+000140b0: 6265 725d 293a 2050 7269 6d61 6c20 7661  ber]): Primal va
+000140c0: 6c75 652c 2069 2e65 2e2c 2074 6865 2076  lue, i.e., the v
+000140d0: 616c 7565 2062 6569 6e67 2064 6966 6665  alue being diffe
+000140e0: 7265 6e74 6961 7465 642e 0a20 2020 2020  rentiated..     
+000140f0: 2020 2072 6573 6964 7561 6c73 2028 5475     residuals (Tu
+00014100: 706c 655b 5072 6f78 792c 202e 2e2e 5d29  ple[Proxy, ...])
+00014110: 3a20 5265 7369 6475 616c 732c 2069 2e65  : Residuals, i.e
+00014120: 2e2c 2074 6865 2076 616c 7565 7320 7468  ., the values th
+00014130: 6174 2061 7265 0a20 2020 2020 2020 2020  at are.         
+00014140: 2020 2073 6176 6564 2066 6f72 2074 6865     saved for the
+00014150: 2062 6163 6b77 6172 642e 0a0a 2020 2020   backward...    
+00014160: 5969 656c 6473 3a0a 2020 2020 2020 2020  Yields:.        
+00014170: 5475 706c 655b 5661 7269 6162 6c65 2c20  Tuple[Variable, 
+00014180: 5475 706c 655b 5661 7269 6162 6c65 2c20  Tuple[Variable, 
+00014190: 2e2e 2e5d 2c20 4361 6c6c 6162 6c65 5d3a  ...], Callable]:
+000141a0: 2050 7269 6d61 6c20 616e 6420 7265 7369   Primal and resi
+000141b0: 6475 616c 730a 2020 2020 2222 220a 0a20  duals.    """.. 
+000141c0: 2020 2070 7269 6d61 6c3a 2050 726f 7879     primal: Proxy
+000141d0: 207c 204e 756d 6265 720a 2020 2020 7265   | Number.    re
+000141e0: 7369 6475 616c 733a 2074 7570 6c65 5b50  siduals: tuple[P
+000141f0: 726f 7879 2c20 2e2e 2e5d 0a0a 2020 2020  roxy, ...]..    
+00014200: 6465 6620 5f5f 6974 6572 5f5f 2873 656c  def __iter__(sel
+00014210: 6629 3a0a 2020 2020 2020 2020 7969 656c  f):.        yiel
+00014220: 6420 7365 6c66 2e70 7269 6d61 6c0a 2020  d self.primal.  
+00014230: 2020 2020 2020 7969 656c 6420 7365 6c66        yield self
+00014240: 2e72 6573 6964 7561 6c73 0a0a 0a63 6c61  .residuals...cla
+00014250: 7373 204e 6f50 756c 6c62 6163 6b3a 0a20  ss NoPullback:. 
+00014260: 2020 2022 2222 4120 6475 6d6d 7920 7075     """A dummy pu
+00014270: 6c6c 6261 636b 2066 756e 6374 696f 6e20  llback function 
+00014280: 7468 6174 2072 6574 7572 6e73 204e 6f6e  that returns Non
+00014290: 6520 6f72 2072 6169 7365 7320 616e 2065  e or raises an e
+000142a0: 7272 6f72 2e22 2222 0a0a 2020 2020 6465  rror."""..    de
+000142b0: 6620 5f5f 696e 6974 5f5f 2873 656c 662c  f __init__(self,
+000142c0: 206e 756d 5f61 7267 733d 3029 3a0a 2020   num_args=0):.  
+000142d0: 2020 2020 2020 7365 6c66 2e6e 756d 5f61        self.num_a
+000142e0: 7267 7320 3d20 6e75 6d5f 6172 6773 0a0a  rgs = num_args..
+000142f0: 2020 2020 6465 6620 5f5f 6361 6c6c 5f5f      def __call__
+00014300: 2873 656c 662c 202a 6172 6773 2c20 2a2a  (self, *args, **
+00014310: 6b77 6172 6773 293a 0a20 2020 2020 2020  kwargs):.       
+00014320: 2069 6620 7365 6c66 2e6e 756d 5f61 7267   if self.num_arg
+00014330: 7320 3e20 303a 0a20 2020 2020 2020 2020  s > 0:.         
+00014340: 2020 2072 6574 7572 6e20 284e 6f6e 652c     return (None,
+00014350: 2920 2a20 7365 6c66 2e6e 756d 5f61 7267  ) * self.num_arg
+00014360: 730a 2020 2020 2020 2020 7261 6973 6520  s.        raise 
+00014370: 5275 6e74 696d 6545 7272 6f72 2822 5075  RuntimeError("Pu
+00014380: 6c6c 6261 636b 2063 616c 6c65 6420 6f6e  llback called on
+00014390: 2061 206e 6f6e 2d64 6966 6665 7265 6e74   a non-different
+000143a0: 6961 626c 6520 7379 6d62 6f6c 206f 7220  iable symbol or 
+000143b0: 6120 636f 6e73 7461 6e74 2e22 290a 0a0a  a constant.")...
+000143c0: 636c 6173 7320 5a65 726f 4261 636b 7761  class ZeroBackwa
+000143d0: 7264 3a0a 2020 2020 2222 2241 2068 656c  rd:.    """A hel
+000143e0: 7065 7220 6261 636b 7761 7264 2066 756e  per backward fun
+000143f0: 6374 696f 6e20 7468 6174 2072 6574 7572  ction that retur
+00014400: 6e73 207a 6572 6f73 2e22 2222 0a0a 2020  ns zeros."""..  
+00014410: 2020 6465 6620 5f5f 696e 6974 5f5f 2873    def __init__(s
+00014420: 656c 662c 206e 756d 5f61 7267 7329 3a0a  elf, num_args):.
+00014430: 2020 2020 2020 2020 7365 6c66 2e6e 756d          self.num
+00014440: 5f61 7267 7320 3d20 6e75 6d5f 6172 6773  _args = num_args
+00014450: 0a0a 2020 2020 6465 6620 5f5f 6361 6c6c  ..    def __call
+00014460: 5f5f 2873 656c 662c 202a 6172 6773 2c20  __(self, *args, 
+00014470: 2a2a 6b77 6172 6773 293a 0a20 2020 2020  **kwargs):.     
+00014480: 2020 2023 2041 7373 756d 696e 6720 7468     # Assuming th
+00014490: 6174 2074 6865 2066 6972 7374 2061 7267  at the first arg
+000144a0: 756d 656e 7473 2061 7265 2074 6865 2066  uments are the f
+000144b0: 6f72 7761 7264 2061 7267 756d 656e 7473  orward arguments
+000144c0: 0a20 2020 2020 2020 2066 6f72 7761 7264  .        forward
+000144d0: 5f61 7267 7320 3d20 6172 6773 5b3a 2073  _args = args[: s
+000144e0: 656c 662e 6e75 6d5f 6172 6773 5d0a 0a20  elf.num_args].. 
+000144f0: 2020 2020 2020 2064 6566 207a 6572 6f73         def zeros
+00014500: 5f6c 696b 6528 7829 3a0a 2020 2020 2020  _like(x):.      
+00014510: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
+00014520: 6e63 6528 782c 2054 656e 736f 7250 726f  nce(x, TensorPro
+00014530: 7879 293a 0a20 2020 2020 2020 2020 2020  xy):.           
+00014540: 2020 2020 2072 6574 7572 6e20 6675 6c6c       return full
+00014550: 5f6c 696b 6528 782c 2066 696c 6c5f 7661  _like(x, fill_va
+00014560: 6c75 653d 3029 0a20 2020 2020 2020 2020  lue=0).         
+00014570: 2020 2065 6c69 6620 6973 696e 7374 616e     elif isinstan
+00014580: 6365 2878 2c20 4e75 6d62 6572 5072 6f78  ce(x, NumberProx
+00014590: 7929 3a0a 2020 2020 2020 2020 2020 2020  y):.            
+000145a0: 2020 2020 7265 7475 726e 2074 7970 6528      return type(
+000145b0: 782e 7661 6c75 6529 2830 290a 2020 2020  x.value)(0).    
+000145c0: 2020 2020 2020 2020 656c 6966 2069 7369          elif isi
+000145d0: 6e73 7461 6e63 6528 782c 204e 756d 6265  nstance(x, Numbe
+000145e0: 7229 3a0a 2020 2020 2020 2020 2020 2020  r):.            
+000145f0: 2020 2020 7265 7475 726e 2074 7970 6528      return type(
+00014600: 7829 2830 290a 2020 2020 2020 2020 2020  x)(0).          
+00014610: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00014620: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
+00014630: 6c75 6545 7272 6f72 2866 227a 6572 6f73  lueError(f"zeros
+00014640: 5f6c 696b 6520 696e 7369 6465 205a 6572  _like inside Zer
+00014650: 6f42 6163 6b77 6172 6420 676f 7420 616e  oBackward got an
+00014660: 2075 6e73 7570 706f 7274 6564 2074 7970   unsupported typ
+00014670: 6520 7b74 7970 6528 7829 7d22 290a 0a20  e {type(x)}").. 
+00014680: 2020 2020 2020 2072 6574 7572 6e20 7475         return tu
+00014690: 706c 6528 7a65 726f 735f 6c69 6b65 2861  ple(zeros_like(a
+000146a0: 7267 2920 666f 7220 6172 6720 696e 2066  rg) for arg in f
+000146b0: 6f72 7761 7264 5f61 7267 7329 0a0a 0a23  orward_args)...#
+000146c0: 204d 6170 7069 6e67 2066 726f 6d20 7379   Mapping from sy
+000146d0: 6d62 6f6c 7320 746f 2061 7567 6d65 6e74  mbols to augment
+000146e0: 6564 2070 7269 6d61 6c20 2866 6f72 7761  ed primal (forwa
+000146f0: 7264 2920 6675 6e63 7469 6f6e 7320 7573  rd) functions us
+00014700: 6564 2069 6e20 564a 500a 2320 5468 6520  ed in VJP.# The 
+00014710: 6175 676d 656e 7465 645f 7072 696d 616c  augmented_primal
+00014720: 2066 756e 6374 696f 6e20 7461 6b65 7320   function takes 
+00014730: 7468 6520 7072 696d 616c 2076 616c 7565  the primal value
+00014740: 7320 616e 6420 7265 7475 726e 7320 7468  s and returns th
+00014750: 6520 7072 696d 616c 0a23 2072 6573 756c  e primal.# resul
+00014760: 7420 616e 6420 7468 6520 7265 7369 6475  t and the residu
+00014770: 616c 7320 2873 6176 6564 2076 616c 7565  als (saved value
+00014780: 7320 666f 7220 7468 6520 6261 636b 7761  s for the backwa
+00014790: 7264 292e 0a61 7567 6d65 6e74 6564 5f66  rd)..augmented_f
+000147a0: 6f72 7761 7264 5f69 6d70 6c73 203d 207b  orward_impls = {
+000147b0: 0a20 2020 2070 7269 6d73 2e50 7269 6d49  .    prims.PrimI
+000147c0: 4473 2e41 434f 533a 206c 616d 6264 6120  Ds.ACOS: lambda 
+000147d0: 783a 2028 7072 696d 732e 6163 6f73 2878  x: (prims.acos(x
+000147e0: 292c 2028 782c 2929 2c0a 2020 2020 7072  ), (x,)),.    pr
+000147f0: 696d 732e 5072 696d 4944 732e 4143 4f53  ims.PrimIDs.ACOS
+00014800: 483a 206c 616d 6264 6120 783a 2028 7072  H: lambda x: (pr
+00014810: 696d 732e 6163 6f73 6828 7829 2c20 2878  ims.acosh(x), (x
+00014820: 2c29 292c 0a20 2020 2070 7269 6d73 2e50  ,)),.    prims.P
+00014830: 7269 6d49 4473 2e41 5349 4e3a 206c 616d  rimIDs.ASIN: lam
+00014840: 6264 6120 783a 2028 7072 696d 732e 6173  bda x: (prims.as
+00014850: 696e 2878 292c 2028 782c 2929 2c0a 2020  in(x), (x,)),.  
+00014860: 2020 7072 696d 732e 5072 696d 4944 732e    prims.PrimIDs.
+00014870: 4153 494e 483a 206c 616d 6264 6120 783a  ASINH: lambda x:
+00014880: 2028 7072 696d 732e 6173 696e 6828 7829   (prims.asinh(x)
+00014890: 2c20 2878 2c29 292c 0a20 2020 2070 7269  , (x,)),.    pri
+000148a0: 6d73 2e50 7269 6d49 4473 2e41 5441 4e3a  ms.PrimIDs.ATAN:
+000148b0: 206c 616d 6264 6120 783a 2028 7072 696d   lambda x: (prim
+000148c0: 732e 6174 616e 2878 292c 2028 782c 2929  s.atan(x), (x,))
+000148d0: 2c0a 2020 2020 7072 696d 732e 5072 696d  ,.    prims.Prim
+000148e0: 4944 732e 4154 414e 483a 206c 616d 6264  IDs.ATANH: lambd
+000148f0: 6120 783a 2028 7072 696d 732e 6174 616e  a x: (prims.atan
+00014900: 6828 7829 2c20 2878 2c29 292c 0a20 2020  h(x), (x,)),.   
+00014910: 2070 7269 6d73 2e50 7269 6d49 4473 2e41   prims.PrimIDs.A
+00014920: 5441 4e32 3a20 6c61 6d62 6461 2078 2c20  TAN2: lambda x, 
+00014930: 793a 2028 7072 696d 732e 6174 616e 3228  y: (prims.atan2(
+00014940: 782c 2079 292c 2028 782c 2079 2929 2c0a  x, y), (x, y)),.
+00014950: 2020 2020 7072 696d 732e 5072 696d 4944      prims.PrimID
+00014960: 732e 434f 5348 3a20 6c61 6d62 6461 2078  s.COSH: lambda x
+00014970: 3a20 2870 7269 6d73 2e63 6f73 6828 7829  : (prims.cosh(x)
+00014980: 2c20 2878 2c29 292c 0a20 2020 2070 7269  , (x,)),.    pri
+00014990: 6d73 2e50 7269 6d49 4473 2e44 4947 414d  ms.PrimIDs.DIGAM
+000149a0: 4d41 3a20 6c61 6d62 6461 2078 3a20 2870  MA: lambda x: (p
+000149b0: 7269 6d73 2e64 6967 616d 6d61 2878 292c  rims.digamma(x),
+000149c0: 2028 782c 2929 2c0a 2020 2020 7072 696d   (x,)),.    prim
+000149d0: 732e 5072 696d 4944 732e 4552 4643 3a20  s.PrimIDs.ERFC: 
+000149e0: 6c61 6d62 6461 2078 3a20 2870 7269 6d73  lambda x: (prims
+000149f0: 2e65 7266 6328 7829 2c20 2878 2c29 292c  .erfc(x), (x,)),
+00014a00: 0a20 2020 2070 7269 6d73 2e50 7269 6d49  .    prims.PrimI
+00014a10: 4473 2e45 5246 494e 563a 206c 616d 6264  Ds.ERFINV: lambd
+00014a20: 6120 783a 2028 7072 696d 732e 6572 6669  a x: (prims.erfi
+00014a30: 6e76 2878 292c 2028 7072 696d 732e 6572  nv(x), (prims.er
+00014a40: 6669 6e76 2878 292c 2929 2c0a 2020 2020  finv(x),)),.    
+00014a50: 7072 696d 732e 5072 696d 4944 732e 4552  prims.PrimIDs.ER
+00014a60: 4643 494e 563a 206c 616d 6264 6120 783a  FCINV: lambda x:
+00014a70: 2028 7072 696d 732e 6572 6663 696e 7628   (prims.erfcinv(
+00014a80: 7829 2c20 2870 7269 6d73 2e65 7266 6369  x), (prims.erfci
+00014a90: 6e76 2878 292c 2929 2c0a 2020 2020 7072  nv(x),)),.    pr
+00014aa0: 696d 732e 5072 696d 4944 732e 4558 5032  ims.PrimIDs.EXP2
 00014ab0: 3a20 6c61 6d62 6461 2078 3a20 2870 7269  : lambda x: (pri
-00014ac0: 6d73 2e6c 6f67 3228 7829 2c20 2878 2c29  ms.log2(x), (x,)
-00014ad0: 292c 0a20 2020 2070 7269 6d73 2e50 7269  ),.    prims.Pri
-00014ae0: 6d49 4473 2e5a 4554 413a 206c 616d 6264  mIDs.ZETA: lambd
-00014af0: 6120 782c 2079 3a20 2870 7269 6d73 2e7a  a x, y: (prims.z
-00014b00: 6574 6128 782c 2079 292c 2028 782c 2079  eta(x, y), (x, y
-00014b10: 2929 2c0a 2020 2020 7072 696d 732e 5072  )),.    prims.Pr
-00014b20: 696d 4944 732e 464d 4f44 3a20 6c61 6d62  imIDs.FMOD: lamb
-00014b30: 6461 2078 2c20 793a 2028 7072 696d 732e  da x, y: (prims.
-00014b40: 666d 6f64 2878 2c20 7929 2c20 2878 2c20  fmod(x, y), (x, 
-00014b50: 7929 292c 0a20 2020 2070 7269 6d73 2e50  y)),.    prims.P
-00014b60: 7269 6d49 4473 2e43 4f50 595f 3a20 6c61  rimIDs.COPY_: la
-00014b70: 6d62 6461 2078 2c20 793a 2028 7072 696d  mbda x, y: (prim
-00014b80: 732e 636f 7079 5f28 782c 2079 292c 2074  s.copy_(x, y), t
-00014b90: 7570 6c65 2829 292c 0a7d 0a0a 0a23 204d  uple()),.}...# M
-00014ba0: 6170 7069 6e67 2066 726f 6d20 7379 6d62  apping from symb
-00014bb0: 6f6c 7320 746f 2062 6163 6b77 6172 6420  ols to backward 
-00014bc0: 6675 6e63 7469 6f6e 7320 7573 6564 2069  functions used i
-00014bd0: 6e20 564a 500a 2320 5468 6520 6261 636b  n VJP.# The back
-00014be0: 7761 7264 2066 756e 6374 696f 6e20 7461  ward function ta
-00014bf0: 6b65 7320 7468 6520 7265 7369 6475 616c  kes the residual
-00014c00: 7320 616e 6420 636f 7461 6e67 656e 7473  s and cotangents
-00014c10: 2061 6e64 2072 6574 7572 6e73 2074 6865   and returns the
-00014c20: 0a23 2076 6563 746f 722d 4a61 636f 6269  .# vector-Jacobi
-00014c30: 616e 2070 726f 6475 6374 7320 666f 7220  an products for 
-00014c40: 6561 6368 2061 7267 756d 656e 742e 0a62  each argument..b
-00014c50: 6163 6b77 6172 645f 696d 706c 7320 3d20  ackward_impls = 
-00014c60: 7b0a 2020 2020 7072 696d 732e 5072 696d  {.    prims.Prim
-00014c70: 4944 732e 4143 4f53 3a20 6c61 6d62 6461  IDs.ACOS: lambda
-00014c80: 2078 2c20 673a 202d 6720 2f20 7072 696d   x, g: -g / prim
-00014c90: 732e 7371 7274 2831 2e30 202d 2078 202a  s.sqrt(1.0 - x *
-00014ca0: 2078 292c 0a20 2020 2070 7269 6d73 2e50   x),.    prims.P
-00014cb0: 7269 6d49 4473 2e41 434f 5348 3a20 6c61  rimIDs.ACOSH: la
-00014cc0: 6d62 6461 2078 2c20 673a 2067 202a 2070  mbda x, g: g * p
-00014cd0: 7269 6d73 2e72 7371 7274 2878 202a 2078  rims.rsqrt(x * x
-00014ce0: 202d 2031 2e30 292c 0a20 2020 2070 7269   - 1.0),.    pri
-00014cf0: 6d73 2e50 7269 6d49 4473 2e41 5349 4e3a  ms.PrimIDs.ASIN:
-00014d00: 206c 616d 6264 6120 782c 2067 3a20 6720   lambda x, g: g 
-00014d10: 2f20 7072 696d 732e 7371 7274 2831 2e30  / prims.sqrt(1.0
-00014d20: 202d 2078 202a 2078 292c 0a20 2020 2070   - x * x),.    p
-00014d30: 7269 6d73 2e50 7269 6d49 4473 2e41 5349  rims.PrimIDs.ASI
-00014d40: 4e48 3a20 6c61 6d62 6461 2078 2c20 673a  NH: lambda x, g:
-00014d50: 2067 202a 2070 7269 6d73 2e72 7371 7274   g * prims.rsqrt
-00014d60: 2831 2e30 202b 2078 202a 2078 292c 0a20  (1.0 + x * x),. 
-00014d70: 2020 2070 7269 6d73 2e50 7269 6d49 4473     prims.PrimIDs
-00014d80: 2e41 5441 4e3a 206c 616d 6264 6120 782c  .ATAN: lambda x,
-00014d90: 2067 3a20 6720 2f20 2831 2e30 202b 2078   g: g / (1.0 + x
-00014da0: 202a 2078 292c 0a20 2020 2070 7269 6d73   * x),.    prims
-00014db0: 2e50 7269 6d49 4473 2e41 5441 4e48 3a20  .PrimIDs.ATANH: 
-00014dc0: 6c61 6d62 6461 2078 2c20 673a 2067 202f  lambda x, g: g /
-00014dd0: 2028 312e 3020 2d20 7820 2a20 7829 2c0a   (1.0 - x * x),.
-00014de0: 2020 2020 7072 696d 732e 5072 696d 4944      prims.PrimID
-00014df0: 732e 434f 5348 3a20 6c61 6d62 6461 2078  s.COSH: lambda x
-00014e00: 2c20 673a 2070 7269 6d73 2e6d 756c 2867  , g: prims.mul(g
-00014e10: 2c20 7072 696d 732e 7369 6e68 2878 2929  , prims.sinh(x))
-00014e20: 2c0a 2020 2020 7072 696d 732e 5072 696d  ,.    prims.Prim
-00014e30: 4944 732e 4552 4643 3a20 6c61 6d62 6461  IDs.ERFC: lambda
-00014e40: 2078 2c20 673a 202d 6720 2a20 322e 3020   x, g: -g * 2.0 
-00014e50: 2f20 6d61 7468 2e73 7172 7428 6d61 7468  / math.sqrt(math
-00014e60: 2e70 6929 202a 2070 7269 6d73 2e65 7870  .pi) * prims.exp
-00014e70: 282d 7820 2a20 7829 2c0a 2020 2020 7072  (-x * x),.    pr
-00014e80: 696d 732e 5072 696d 4944 732e 4552 4649  ims.PrimIDs.ERFI
-00014e90: 4e56 3a20 6c61 6d62 6461 2072 6573 756c  NV: lambda resul
-00014ea0: 742c 2067 3a20 6720 2a20 302e 3520 2a20  t, g: g * 0.5 * 
-00014eb0: 6d61 7468 2e73 7172 7428 6d61 7468 2e70  math.sqrt(math.p
-00014ec0: 6929 202a 2070 7269 6d73 2e65 7870 2872  i) * prims.exp(r
-00014ed0: 6573 756c 742a 2a32 292c 0a20 2020 2070  esult**2),.    p
-00014ee0: 7269 6d73 2e50 7269 6d49 4473 2e45 5246  rims.PrimIDs.ERF
-00014ef0: 4349 4e56 3a20 6c61 6d62 6461 2072 6573  CINV: lambda res
-00014f00: 756c 742c 2067 3a20 2d67 202a 2030 2e35  ult, g: -g * 0.5
-00014f10: 202a 206d 6174 682e 7371 7274 286d 6174   * math.sqrt(mat
-00014f20: 682e 7069 2920 2a20 7072 696d 732e 6578  h.pi) * prims.ex
-00014f30: 7028 7265 7375 6c74 2a2a 3229 2c0a 2020  p(result**2),.  
-00014f40: 2020 7072 696d 732e 5072 696d 4944 732e    prims.PrimIDs.
-00014f50: 4558 5032 3a20 6c61 6d62 6461 2072 6573  EXP2: lambda res
-00014f60: 756c 742c 2067 3a20 6720 2a20 7265 7375  ult, g: g * resu
-00014f70: 6c74 202a 206d 6174 682e 6c6f 6728 322e  lt * math.log(2.
-00014f80: 3029 2c0a 2020 2020 7072 696d 732e 5072  0),.    prims.Pr
-00014f90: 696d 4944 732e 4558 504d 313a 206c 616d  imIDs.EXPM1: lam
-00014fa0: 6264 6120 7265 7375 6c74 2c20 673a 2067  bda result, g: g
-00014fb0: 202a 2028 7265 7375 6c74 202b 2031 2e30   * (result + 1.0
-00014fc0: 292c 0a20 2020 2070 7269 6d73 2e50 7269  ),.    prims.Pri
-00014fd0: 6d49 4473 2e4c 4741 4d4d 413a 206c 616d  mIDs.LGAMMA: lam
-00014fe0: 6264 6120 782c 2067 3a20 6720 2a20 7072  bda x, g: g * pr
-00014ff0: 696d 732e 6469 6761 6d6d 6128 7829 2c0a  ims.digamma(x),.
-00015000: 2020 2020 7072 696d 732e 5072 696d 4944      prims.PrimID
-00015010: 732e 4e44 5452 493a 206c 616d 6264 6120  s.NDTRI: lambda 
-00015020: 7265 7375 6c74 2c20 673a 2067 202a 2070  result, g: g * p
-00015030: 7269 6d73 2e65 7870 2830 2e35 202a 2072  rims.exp(0.5 * r
-00015040: 6573 756c 742a 2a32 2920 2a20 6d61 7468  esult**2) * math
-00015050: 2e73 7172 7428 322e 3020 2a20 6d61 7468  .sqrt(2.0 * math
-00015060: 2e70 6929 2c0a 2020 2020 7072 696d 732e  .pi),.    prims.
-00015070: 5072 696d 4944 732e 5349 4e48 3a20 6c61  PrimIDs.SINH: la
-00015080: 6d62 6461 2078 2c20 673a 2070 7269 6d73  mbda x, g: prims
-00015090: 2e6d 756c 2867 2c20 7072 696d 732e 636f  .mul(g, prims.co
-000150a0: 7368 2878 2929 2c0a 2020 2020 7072 696d  sh(x)),.    prim
-000150b0: 732e 5072 696d 4944 732e 5351 5254 3a20  s.PrimIDs.SQRT: 
-000150c0: 6c61 6d62 6461 2072 6573 756c 742c 2067  lambda result, g
-000150d0: 3a20 6720 2f20 2832 2e30 202a 2072 6573  : g / (2.0 * res
-000150e0: 756c 7429 2c0a 2020 2020 7072 696d 732e  ult),.    prims.
-000150f0: 5072 696d 4944 732e 4c4f 4731 303a 206c  PrimIDs.LOG10: l
-00015100: 616d 6264 6120 782c 2067 3a20 6720 2f20  ambda x, g: g / 
-00015110: 2878 202a 2032 2e33 3032 3538 3530 3932  (x * 2.302585092
-00015120: 3939 3430 3436 292c 0a20 2020 2070 7269  994046),.    pri
-00015130: 6d73 2e50 7269 6d49 4473 2e4c 4f47 3150  ms.PrimIDs.LOG1P
-00015140: 3a20 6c61 6d62 6461 2078 2c20 673a 2067  : lambda x, g: g
-00015150: 202f 2028 7820 2b20 3129 2c0a 2020 2020   / (x + 1),.    
-00015160: 7072 696d 732e 5072 696d 4944 732e 4c4f  prims.PrimIDs.LO
-00015170: 4732 3a20 6c61 6d62 6461 2078 2c20 673a  G2: lambda x, g:
-00015180: 2067 202f 2028 7820 2a20 302e 3639 3331   g / (x * 0.6931
-00015190: 3437 3138 3035 3539 3934 3533 292c 0a20  471805599453),. 
-000151a0: 2020 2070 7269 6d73 2e50 7269 6d49 4473     prims.PrimIDs
-000151b0: 2e46 4d4f 443a 206c 616d 6264 6120 782c  .FMOD: lambda x,
-000151c0: 2079 2c20 673a 2028 672c 202d 6720 2a20   y, g: (g, -g * 
-000151d0: 7072 696d 732e 7472 756e 6328 7820 2f20  prims.trunc(x / 
-000151e0: 7929 292c 0a20 2020 2023 2054 6865 2063  y)),.    # The c
-000151f0: 6f70 7920 7368 6f75 6c64 206e 6f74 2062  opy should not b
-00015200: 6520 6469 6666 6572 656e 7469 6162 6c65  e differentiable
-00015210: 2e20 5765 2072 6574 7572 6e20 4e6f 6e65  . We return None
-00015220: 2074 6f20 656e 6162 6c65 2074 6865 2067   to enable the g
-00015230: 656e 6572 6174 696f 6e20 6f66 2074 6865  eneration of the
-00015240: 2062 6163 6b77 6172 6420 6772 6170 6820   backward graph 
-00015250: 7468 726f 7567 6820 7468 656d 2e0a 2020  through them..  
-00015260: 2020 7072 696d 732e 5072 696d 4944 732e    prims.PrimIDs.
-00015270: 434f 5059 5f3a 206c 616d 6264 6120 673a  COPY_: lambda g:
-00015280: 2028 4e6f 6e65 2c20 4e6f 6e65 292c 0a7d   (None, None),.}
-00015290: 0a0a 0a64 6566 2072 6567 6973 7465 725f  ...def register_
-000152a0: 6175 676d 656e 7465 645f 666f 7277 6172  augmented_forwar
-000152b0: 6428 6f70 293a 0a20 2020 2022 2222 4465  d(op):.    """De
-000152c0: 636f 7261 746f 7220 746f 2072 6567 6973  corator to regis
-000152d0: 7465 7220 616e 2061 7567 6d65 6e74 6564  ter an augmented
-000152e0: 2066 6f72 7761 7264 2069 6d70 6c65 6d65   forward impleme
-000152f0: 6e74 6174 696f 6e20 666f 7220 6120 7379  ntation for a sy
-00015300: 6d62 6f6c 2e0a 0a20 2020 2041 7267 733a  mbol...    Args:
-00015310: 0a20 2020 2020 2020 206f 7020 284f 7073  .        op (Ops
-00015320: 293a 2053 796d 626f 6c20 666f 7220 7768  ): Symbol for wh
-00015330: 6963 6820 746f 2072 6567 6973 7465 7220  ich to register 
-00015340: 7468 6520 6175 676d 656e 7465 6420 666f  the augmented fo
-00015350: 7277 6172 6420 696d 706c 656d 656e 7461  rward implementa
-00015360: 7469 6f6e 2e0a 0a20 2020 2052 6574 7572  tion...    Retur
-00015370: 6e73 3a0a 2020 2020 2020 2020 4361 6c6c  ns:.        Call
-00015380: 6162 6c65 3a20 4465 636f 7261 746f 7220  able: Decorator 
-00015390: 6675 6e63 7469 6f6e 2e0a 2020 2020 2222  function..    ""
-000153a0: 220a 0a20 2020 2064 6566 2064 6563 6f72  "..    def decor
-000153b0: 6174 6f72 2866 756e 6329 3a0a 2020 2020  ator(func):.    
-000153c0: 2020 2020 6175 676d 656e 7465 645f 666f      augmented_fo
-000153d0: 7277 6172 645f 696d 706c 735b 6f70 5d20  rward_impls[op] 
-000153e0: 3d20 6675 6e63 0a20 2020 2020 2020 2072  = func.        r
-000153f0: 6574 7572 6e20 6675 6e63 0a0a 2020 2020  eturn func..    
-00015400: 7265 7475 726e 2064 6563 6f72 6174 6f72  return decorator
-00015410: 0a0a 0a64 6566 2072 6567 6973 7465 725f  ...def register_
-00015420: 6261 636b 7761 7264 286f 7029 3a0a 2020  backward(op):.  
-00015430: 2020 2222 2244 6563 6f72 6174 6f72 2074    """Decorator t
-00015440: 6f20 7265 6769 7374 6572 2061 2062 6163  o register a bac
-00015450: 6b77 6172 6420 696d 706c 656d 656e 7461  kward implementa
-00015460: 7469 6f6e 2066 6f72 2061 2073 796d 626f  tion for a symbo
-00015470: 6c2e 0a0a 2020 2020 4172 6773 3a0a 2020  l...    Args:.  
-00015480: 2020 2020 2020 6f70 2028 4f70 7329 3a20        op (Ops): 
-00015490: 5379 6d62 6f6c 2066 6f72 2077 6869 6368  Symbol for which
-000154a0: 2074 6f20 7265 6769 7374 6572 2074 6865   to register the
-000154b0: 2062 6163 6b77 6172 6420 696d 706c 656d   backward implem
-000154c0: 656e 7461 7469 6f6e 2e0a 0a20 2020 2052  entation...    R
-000154d0: 6574 7572 6e73 3a0a 2020 2020 2020 2020  eturns:.        
-000154e0: 4361 6c6c 6162 6c65 3a20 4465 636f 7261  Callable: Decora
-000154f0: 746f 7220 6675 6e63 7469 6f6e 2e0a 2020  tor function..  
-00015500: 2020 2222 220a 0a20 2020 2064 6566 2064    """..    def d
-00015510: 6563 6f72 6174 6f72 2866 756e 6329 3a0a  ecorator(func):.
-00015520: 2020 2020 2020 2020 6261 636b 7761 7264          backward
-00015530: 5f69 6d70 6c73 5b6f 705d 203d 2066 756e  _impls[op] = fun
-00015540: 630a 2020 2020 2020 2020 7265 7475 726e  c.        return
-00015550: 2066 756e 630a 0a20 2020 2072 6574 7572   func..    retur
-00015560: 6e20 6465 636f 7261 746f 720a 0a0a 6465  n decorator...de
-00015570: 6620 7265 7374 6f72 655f 7265 6475 6365  f restore_reduce
-00015580: 645f 6469 6d73 2878 2c20 7265 6475 6365  d_dims(x, reduce
-00015590: 645f 6469 6d73 2c20 6f72 6967 696e 616c  d_dims, original
-000155a0: 5f73 6861 7065 293a 0a20 2020 2022 2222  _shape):.    """
-000155b0: 5265 7374 6f72 6573 2074 6865 2072 6564  Restores the red
-000155c0: 7563 6564 2064 696d 656e 7369 6f6e 7320  uced dimensions 
-000155d0: 6f66 2061 2074 656e 736f 722e 0a0a 2020  of a tensor...  
-000155e0: 2020 4172 6773 3a0a 2020 2020 2020 2020    Args:.        
-000155f0: 7820 2856 6172 6961 626c 6529 3a20 5465  x (Variable): Te
-00015600: 6e73 6f72 2074 6f20 6265 2072 6573 6861  nsor to be resha
-00015610: 7065 642e 0a20 2020 2020 2020 2072 6564  ped..        red
-00015620: 7563 6564 5f64 696d 7320 2854 7570 6c65  uced_dims (Tuple
-00015630: 5b69 6e74 2c20 2e2e 2e5d 293a 2054 7570  [int, ...]): Tup
-00015640: 6c65 206f 6620 7265 6475 6365 6420 6469  le of reduced di
-00015650: 6d65 6e73 696f 6e73 2e0a 2020 2020 2020  mensions..      
-00015660: 2020 6f72 6967 696e 616c 5f73 6861 7065    original_shape
-00015670: 2028 5475 706c 655b 696e 742c 202e 2e2e   (Tuple[int, ...
-00015680: 5d29 3a20 4f72 6967 696e 616c 2073 6861  ]): Original sha
-00015690: 7065 206f 6620 7468 6520 7465 6e73 6f72  pe of the tensor
-000156a0: 2e0a 0a20 2020 2052 6574 7572 6e73 3a0a  ...    Returns:.
-000156b0: 2020 2020 2020 2020 5661 7269 6162 6c65          Variable
-000156c0: 3a20 5465 6e73 6f72 2077 6974 6820 7468  : Tensor with th
-000156d0: 6520 7265 6475 6365 6420 6469 6d65 6e73  e reduced dimens
-000156e0: 696f 6e73 2072 6573 746f 7265 642e 0a20  ions restored.. 
-000156f0: 2020 2022 2222 0a20 2020 2069 6620 6f72     """.    if or
-00015700: 6967 696e 616c 5f73 6861 7065 203d 3d20  iginal_shape == 
-00015710: 2829 3a20 2023 2073 6361 6c61 720a 2020  ():  # scalar.  
-00015720: 2020 2020 2020 7265 7475 726e 2078 0a0a        return x..
-00015730: 2020 2020 756e 7371 7565 657a 6564 203d      unsqueezed =
-00015740: 2063 6c61 6e67 2e75 6e73 7175 6565 7a65   clang.unsqueeze
-00015750: 2878 2c20 7265 6475 6365 645f 6469 6d73  (x, reduced_dims
-00015760: 290a 2020 2020 7265 7475 726e 2063 6c61  ).    return cla
-00015770: 6e67 2e65 7870 616e 6428 756e 7371 7565  ng.expand(unsque
-00015780: 657a 6564 2c20 6f72 6967 696e 616c 5f73  ezed, original_s
-00015790: 6861 7065 290a 0a0a 4072 6567 6973 7465  hape)...@registe
-000157a0: 725f 6261 636b 7761 7264 2870 7269 6d73  r_backward(prims
-000157b0: 2e50 7269 6d49 4473 2e5a 4554 4129 0a64  .PrimIDs.ZETA).d
-000157c0: 6566 207a 6574 615f 6261 636b 7761 7264  ef zeta_backward
-000157d0: 2878 2c20 792c 2067 293a 0a20 2020 2023  (x, y, g):.    #
-000157e0: 2054 6865 2064 6572 6976 6174 6976 6520   The derivative 
-000157f0: 7772 7420 7468 6520 6669 7273 7420 6172  wrt the first ar
-00015800: 6775 6d65 6e74 2069 7320 6e6f 7420 6578  gument is not ex
-00015810: 7072 6573 7369 626c 6520 696e 2074 6572  pressible in ter
-00015820: 6d73 206f 6620 7a65 7461 206f 720a 2020  ms of zeta or.  
-00015830: 2020 2320 6f74 6865 7220 7370 6563 6961    # other specia
-00015840: 6c20 6675 6e63 7469 6f6e 730a 2020 2020  l functions.    
-00015850: 2320 5468 6572 6566 6f72 652c 2077 6520  # Therefore, we 
-00015860: 636f 6d70 7574 6520 6f6e 6c79 2074 6865  compute only the
-00015870: 2064 6572 6976 6174 6976 6520 7772 7420   derivative wrt 
-00015880: 7468 6520 7365 636f 6e64 2061 7267 756d  the second argum
-00015890: 656e 740a 2020 2020 6779 203d 2067 202a  ent.    gy = g *
-000158a0: 202d 7820 2a20 7072 696d 732e 7a65 7461   -x * prims.zeta
-000158b0: 2878 202b 2031 2e30 2c20 7929 0a0a 2020  (x + 1.0, y)..  
-000158c0: 2020 2320 5265 7475 726e 2061 206d 6170    # Return a map
-000158d0: 7070 696e 6720 6672 6f6d 2074 6865 2066  pping from the f
-000158e0: 6f72 7761 7264 2061 7267 756d 656e 7473  orward arguments
-000158f0: 2074 6f20 7468 6520 6772 6164 6965 6e74   to the gradient
-00015900: 730a 2020 2020 7265 7475 726e 207b 2279  s.    return {"y
-00015910: 223a 2067 797d 0a0a 0a40 7265 6769 7374  ": gy}...@regist
-00015920: 6572 5f62 6163 6b77 6172 6428 7072 696d  er_backward(prim
-00015930: 732e 5072 696d 4944 732e 4449 4741 4d4d  s.PrimIDs.DIGAMM
-00015940: 4129 0a64 6566 2064 6967 616d 6d61 5f62  A).def digamma_b
-00015950: 6163 6b77 6172 6428 613a 2050 726f 7879  ackward(a: Proxy
-00015960: 2c20 6729 3a0a 2020 2020 6672 6f6d 2074  , g):.    from t
-00015970: 6875 6e64 6572 2e74 6f72 6368 2069 6d70  hunder.torch imp
-00015980: 6f72 7420 706f 6c79 6761 6d6d 610a 0a20  ort polygamma.. 
-00015990: 2020 2072 6574 7572 6e20 6720 2a20 706f     return g * po
-000159a0: 6c79 6761 6d6d 6128 312c 2061 290a 0a0a  lygamma(1, a)...
-000159b0: 4072 6567 6973 7465 725f 6175 676d 656e  @register_augmen
-000159c0: 7465 645f 666f 7277 6172 6428 2274 6f72  ted_forward("tor
-000159d0: 6368 2e70 6f6c 7967 616d 6d61 2229 0a64  ch.polygamma").d
-000159e0: 6566 2070 6f6c 7967 616d 6d61 5f61 7567  ef polygamma_aug
-000159f0: 5f66 7764 286e 3a20 696e 742c 2061 3a20  _fwd(n: int, a: 
-00015a00: 5072 6f78 7929 3a0a 2020 2020 6672 6f6d  Proxy):.    from
-00015a10: 2074 6875 6e64 6572 2e74 6f72 6368 2069   thunder.torch i
-00015a20: 6d70 6f72 7420 706f 6c79 6761 6d6d 610a  mport polygamma.
-00015a30: 0a20 2020 2070 7269 6d61 6c20 3d20 706f  .    primal = po
-00015a40: 6c79 6761 6d6d 6128 6e2c 2061 290a 2020  lygamma(n, a).  
-00015a50: 2020 7265 7369 6475 616c 7320 3d20 286e    residuals = (n
-00015a60: 2c20 6129 0a20 2020 2072 6574 7572 6e20  , a).    return 
-00015a70: 564a 5044 7561 6c28 7072 696d 616c 2c20  VJPDual(primal, 
-00015a80: 7265 7369 6475 616c 7329 0a0a 0a40 7265  residuals)...@re
-00015a90: 6769 7374 6572 5f62 6163 6b77 6172 6428  gister_backward(
-00015aa0: 2274 6f72 6368 2e70 6f6c 7967 616d 6d61  "torch.polygamma
-00015ab0: 2229 0a64 6566 2070 6f6c 7967 616d 6d61  ").def polygamma
-00015ac0: 5f62 6163 6b77 6172 6428 6e3a 2069 6e74  _backward(n: int
-00015ad0: 2c20 613a 2050 726f 7879 2c20 6729 3a0a  , a: Proxy, g):.
-00015ae0: 2020 2020 6672 6f6d 2074 6875 6e64 6572      from thunder
-00015af0: 2e74 6f72 6368 2069 6d70 6f72 7420 706f  .torch import po
-00015b00: 6c79 6761 6d6d 610a 0a20 2020 2072 6574  lygamma..    ret
-00015b10: 7572 6e20 4e6f 6e65 2c20 6720 2a20 706f  urn None, g * po
-00015b20: 6c79 6761 6d6d 6128 6e20 2b20 312c 2061  lygamma(n + 1, a
-00015b30: 290a 0a0a 4072 6567 6973 7465 725f 6261  )...@register_ba
-00015b40: 636b 7761 7264 2870 7269 6d73 2e50 7269  ckward(prims.Pri
-00015b50: 6d49 4473 2e41 5441 4e32 290a 6465 6620  mIDs.ATAN2).def 
-00015b60: 6174 616e 325f 6261 636b 7761 7264 2878  atan2_backward(x
-00015b70: 2c20 792c 2067 293a 0a20 2020 2061 6c70  , y, g):.    alp
-00015b80: 6861 203d 2031 2e30 202f 2028 7820 2a20  ha = 1.0 / (x * 
-00015b90: 7820 2b20 7920 2a20 7929 0a20 2020 2067  x + y * y).    g
-00015ba0: 7261 645f 7820 3d20 6720 2a20 7920 2a20  rad_x = g * y * 
-00015bb0: 616c 7068 610a 2020 2020 6772 6164 5f79  alpha.    grad_y
-00015bc0: 203d 2067 202a 202d 7820 2a20 616c 7068   = g * -x * alph
-00015bd0: 610a 2020 2020 7265 7475 726e 2067 7261  a.    return gra
-00015be0: 645f 782c 2067 7261 645f 790a 0a0a 4072  d_x, grad_y...@r
-00015bf0: 6567 6973 7465 725f 6175 676d 656e 7465  egister_augmente
-00015c00: 645f 666f 7277 6172 6428 7072 696d 732e  d_forward(prims.
-00015c10: 5072 696d 4944 732e 5641 5229 0a64 6566  PrimIDs.VAR).def
-00015c20: 2076 6172 5f61 7567 5f66 7764 2861 2c20   var_aug_fwd(a, 
-00015c30: 6469 6d2c 202a 2c20 636f 7272 6563 7469  dim, *, correcti
-00015c40: 6f6e 293a 0a20 2020 2076 203d 2070 7269  on):.    v = pri
-00015c50: 6d73 2e76 6172 2861 2c20 6469 6d2c 2063  ms.var(a, dim, c
-00015c60: 6f72 7265 6374 696f 6e3d 636f 7272 6563  orrection=correc
-00015c70: 7469 6f6e 290a 2020 2020 7265 7475 726e  tion).    return
-00015c80: 2056 4a50 4475 616c 2828 762c 292c 2028   VJPDual((v,), (
-00015c90: 612c 2064 696d 2c20 636f 7272 6563 7469  a, dim, correcti
-00015ca0: 6f6e 2c20 7629 290a 0a0a 2320 544f 444f  on, v))...# TODO
-00015cb0: 3a20 6669 7820 6469 7669 7369 6f6e 2062  : fix division b
-00015cc0: 7920 7a65 726f 2077 6865 6e20 6e5f 656c  y zero when n_el
-00015cd0: 656d 5f72 6564 7563 6564 203d 3d20 3020  em_reduced == 0 
-00015ce0: 6f72 2077 6865 6e20 762e 6e75 6d65 6c20  or when v.numel 
-00015cf0: 3d3d 2030 0a23 2062 7920 7265 7475 726e  == 0.# by return
-00015d00: 696e 6720 7a65 726f 735f 6c69 6b65 2861  ing zeros_like(a
-00015d10: 2920 6f72 2073 696d 696c 6172 2e0a 2320  ) or similar..# 
-00015d20: 544f 444f 3a20 6669 7820 6772 6164 2077  TODO: fix grad w
-00015d30: 6865 6e20 636f 7272 6563 7469 6f6e 203e  hen correction >
-00015d40: 206e 5f65 6c65 6d5f 7265 6475 6365 642e   n_elem_reduced.
-00015d50: 0a40 7265 6769 7374 6572 5f62 6163 6b77  .@register_backw
-00015d60: 6172 6428 7072 696d 732e 5072 696d 4944  ard(prims.PrimID
-00015d70: 732e 5641 5229 0a64 6566 2076 6172 5f62  s.VAR).def var_b
-00015d80: 6163 6b77 6172 6428 612c 2064 696d 2c20  ackward(a, dim, 
-00015d90: 636f 7272 6563 7469 6f6e 2c20 762c 2067  correction, v, g
-00015da0: 293a 0a20 2020 206e 5f65 6c65 6d5f 7265  ):.    n_elem_re
-00015db0: 6475 6365 6420 3d20 612e 6e75 6d65 6c28  duced = a.numel(
-00015dc0: 2920 2f2f 2076 2e6e 756d 656c 2829 2069  ) // v.numel() i
-00015dd0: 6620 612e 6e75 6d65 6c28 2920 213d 2030  f a.numel() != 0
-00015de0: 2065 6c73 6520 310a 2020 2020 6e6f 726d   else 1.    norm
-00015df0: 616c 697a 6174 696f 6e5f 7363 616c 6172  alization_scalar
-00015e00: 203d 206e 5f65 6c65 6d5f 7265 6475 6365   = n_elem_reduce
-00015e10: 6420 2d20 636f 7272 6563 7469 6f6e 0a20  d - correction. 
-00015e20: 2020 2067 203d 2072 6573 746f 7265 5f72     g = restore_r
-00015e30: 6564 7563 6564 5f64 696d 7328 672c 2064  educed_dims(g, d
-00015e40: 696d 2c20 612e 7368 6170 6529 0a20 2020  im, a.shape).   
-00015e50: 2069 6620 612e 6474 7970 6520 213d 2076   if a.dtype != v
-00015e60: 2e64 7479 7065 3a0a 2020 2020 2020 2020  .dtype:.        
-00015e70: 6120 3d20 7072 696d 732e 636f 6e76 6572  a = prims.conver
-00015e80: 745f 656c 656d 656e 745f 7479 7065 2861  t_element_type(a
-00015e90: 2c20 762e 6474 7970 6529 0a20 2020 206d  , v.dtype).    m
-00015ea0: 6561 6e20 3d20 7072 696d 732e 7375 6d28  ean = prims.sum(
-00015eb0: 612c 2064 696d 2920 2f20 6e5f 656c 656d  a, dim) / n_elem
-00015ec0: 5f72 6564 7563 6564 0a20 2020 206d 6561  _reduced.    mea
-00015ed0: 6e20 3d20 7265 7374 6f72 655f 7265 6475  n = restore_redu
-00015ee0: 6365 645f 6469 6d73 286d 6561 6e2c 2064  ced_dims(mean, d
-00015ef0: 696d 2c20 612e 7368 6170 6529 0a20 2020  im, a.shape).   
-00015f00: 2072 6574 7572 6e20 2832 202a 2067 202a   return (2 * g *
-00015f10: 2028 6120 2d20 6d65 616e 2929 202f 206e   (a - mean)) / n
-00015f20: 6f72 6d61 6c69 7a61 7469 6f6e 5f73 6361  ormalization_sca
-00015f30: 6c61 720a 0a0a 6465 6620 6e5f 656c 656d  lar...def n_elem
-00015f40: 5f72 6564 7563 6564 2861 5f6e 6469 6d2c  _reduced(a_ndim,
-00015f50: 2061 5f73 6861 7065 2c20 6469 6d73 293a   a_shape, dims):
-00015f60: 0a20 2020 2064 696d 7320 3d20 7574 696c  .    dims = util
-00015f70: 732e 6361 6e6f 6e69 6361 6c69 7a65 5f64  s.canonicalize_d
-00015f80: 696d 7328 615f 6e64 696d 2c20 6469 6d73  ims(a_ndim, dims
-00015f90: 290a 2020 2020 7265 6475 6374 696f 6e5f  ).    reduction_
-00015fa0: 7369 7a65 203d 2031 0a20 2020 2066 6f72  size = 1.    for
-00015fb0: 2069 6478 2c20 7369 7a65 2069 6e20 656e   idx, size in en
-00015fc0: 756d 6572 6174 6528 615f 7368 6170 6529  umerate(a_shape)
-00015fd0: 3a0a 2020 2020 2020 2020 6966 2069 6478  :.        if idx
-00015fe0: 2069 6e20 6469 6d73 3a0a 2020 2020 2020   in dims:.      
-00015ff0: 2020 2020 2020 7265 6475 6374 696f 6e5f        reduction_
-00016000: 7369 7a65 202a 3d20 7369 7a65 0a20 2020  size *= size.   
-00016010: 2072 6574 7572 6e20 7265 6475 6374 696f   return reductio
-00016020: 6e5f 7369 7a65 0a0a 0a64 6566 206d 6561  n_size...def mea
-00016030: 6e5f 6261 636b 7761 7264 2861 5f6e 6469  n_backward(a_ndi
-00016040: 6d2c 2061 5f73 6861 7065 2c20 6469 6d73  m, a_shape, dims
-00016050: 2c20 6772 6164 293a 0a20 2020 206d 6561  , grad):.    mea
-00016060: 6e5f 6c6f 6361 6c5f 6772 6164 203d 2031  n_local_grad = 1
-00016070: 2e30 202f 206e 5f65 6c65 6d5f 7265 6475  .0 / n_elem_redu
-00016080: 6365 6428 615f 6e64 696d 2c20 615f 7368  ced(a_ndim, a_sh
-00016090: 6170 652c 2064 696d 7329 0a20 2020 2072  ape, dims).    r
-000160a0: 6574 7572 6e20 7265 7374 6f72 655f 7265  eturn restore_re
-000160b0: 6475 6365 645f 6469 6d73 2867 7261 642c  duced_dims(grad,
-000160c0: 2064 696d 732c 2061 5f73 6861 7065 2920   dims, a_shape) 
-000160d0: 2a20 6d65 616e 5f6c 6f63 616c 5f67 7261  * mean_local_gra
-000160e0: 640a 0a0a 4072 6567 6973 7465 725f 6175  d...@register_au
-000160f0: 676d 656e 7465 645f 666f 7277 6172 6428  gmented_forward(
-00016100: 7072 696d 732e 5072 696d 4944 732e 5041  prims.PrimIDs.PA
-00016110: 4429 0a64 6566 2070 6164 5f61 7567 5f66  D).def pad_aug_f
-00016120: 7764 2861 2c20 7061 6464 696e 675f 7661  wd(a, padding_va
-00016130: 6c75 652c 2070 6164 6469 6e67 5f63 6f6e  lue, padding_con
-00016140: 6669 6729 3a0a 2020 2020 7265 7475 726e  fig):.    return
-00016150: 2056 4a50 4475 616c 2828 7072 696d 732e   VJPDual((prims.
-00016160: 7061 6428 612c 2070 6164 6469 6e67 5f76  pad(a, padding_v
-00016170: 616c 7565 2c20 7061 6464 696e 675f 636f  alue, padding_co
-00016180: 6e66 6967 292c 292c 2028 612c 2070 6164  nfig),), (a, pad
-00016190: 6469 6e67 5f63 6f6e 6669 6729 290a 0a0a  ding_config))...
-000161a0: 4072 6567 6973 7465 725f 6261 636b 7761  @register_backwa
-000161b0: 7264 2870 7269 6d73 2e50 7269 6d49 4473  rd(prims.PrimIDs
-000161c0: 2e50 4144 290a 6465 6620 7061 645f 6261  .PAD).def pad_ba
-000161d0: 636b 7761 7264 2861 2c20 7061 6464 696e  ckward(a, paddin
-000161e0: 675f 636f 6e66 6967 2c20 6729 3a0a 2020  g_config, g):.  
-000161f0: 2020 2320 5368 6f72 7420 6369 7263 7569    # Short circui
-00016200: 7420 6f6e 2065 6d70 7479 2069 6e70 7574  t on empty input
-00016210: 2e0a 2020 2020 6966 2061 6e79 2864 696d  ..    if any(dim
-00016220: 203d 3d20 3020 666f 7220 6469 6d20 696e   == 0 for dim in
-00016230: 2061 2e73 6861 7065 293a 0a20 2020 2020   a.shape):.     
-00016240: 2020 2072 6574 7572 6e20 6675 6c6c 5f6c     return full_l
-00016250: 696b 6528 612c 2066 696c 6c5f 7661 6c75  ike(a, fill_valu
-00016260: 653d 3029 0a0a 2020 2020 2320 556e 2d70  e=0)..    # Un-p
-00016270: 6164 2062 7920 7061 6464 696e 6720 7769  ad by padding wi
-00016280: 7468 207a 6572 6f20 7661 6c75 6573 0a20  th zero values. 
-00016290: 2020 207a 6572 6f5f 7061 6464 696e 675f     zero_padding_
-000162a0: 636f 6e66 6967 203d 205b 282d 6c6f 2c20  config = [(-lo, 
-000162b0: 2d68 692c 2030 2920 666f 7220 6c6f 2c20  -hi, 0) for lo, 
-000162c0: 6869 2c20 5f20 696e 2070 6164 6469 6e67  hi, _ in padding
-000162d0: 5f63 6f6e 6669 675d 0a0a 2020 2020 6720  _config]..    g 
-000162e0: 3d20 7072 696d 732e 7061 6428 672c 2030  = prims.pad(g, 0
-000162f0: 2e30 2c20 7a65 726f 5f70 6164 6469 6e67  .0, zero_padding
-00016300: 5f63 6f6e 6669 6729 0a0a 2020 2020 2320  _config)..    # 
-00016310: 556e 2d73 6c69 6365 2062 7920 736c 6963  Un-slice by slic
-00016320: 696e 6720 7769 7468 2061 2073 7472 6964  ing with a strid
-00016330: 6520 6f66 2076 616c 7565 2028 6469 6c61  e of value (dila
-00016340: 7469 6f6e 202b 2031 290a 2020 2020 666f  tion + 1).    fo
-00016350: 7220 6469 6d2c 2028 5f2c 205f 2c20 6429  r dim, (_, _, d)
-00016360: 2069 6e20 656e 756d 6572 6174 6528 7061   in enumerate(pa
-00016370: 6464 696e 675f 636f 6e66 6967 293a 0a20  dding_config):. 
-00016380: 2020 2020 2020 2067 203d 2073 6c69 6365         g = slice
-00016390: 5f69 6e5f 6469 6d28 672c 2030 2c20 672e  _in_dim(g, 0, g.
-000163a0: 7368 6170 655b 6469 6d5d 2c20 7374 7269  shape[dim], stri
-000163b0: 6465 3d64 202b 2031 2c20 6469 6d3d 6469  de=d + 1, dim=di
-000163c0: 6d29 0a0a 2020 2020 7265 7475 726e 2067  m)..    return g
-000163d0: 0a0a 0a40 7265 6769 7374 6572 5f61 7567  ...@register_aug
-000163e0: 6d65 6e74 6564 5f66 6f72 7761 7264 2870  mented_forward(p
-000163f0: 7269 6d73 2e50 7269 6d49 4473 2e50 524f  rims.PrimIDs.PRO
-00016400: 4429 0a64 6566 2070 726f 645f 6175 675f  D).def prod_aug_
-00016410: 6677 6428 782c 2064 696d 7329 3a0a 2020  fwd(x, dims):.  
-00016420: 2020 2222 2241 7567 6d65 6e74 6564 2070    """Augmented p
-00016430: 726f 6420 6f70 6572 6174 696f 6e2e 0a0a  rod operation...
-00016440: 2020 2020 4172 6773 3a0a 2020 2020 2020      Args:.      
-00016450: 2020 7820 2856 6172 6961 626c 6529 3a20    x (Variable): 
-00016460: 5465 6e73 6f72 2074 6f20 6265 206d 756c  Tensor to be mul
-00016470: 7469 706c 6965 642e 0a20 2020 2020 2020  tiplied..       
-00016480: 2064 696d 7320 2854 7570 6c65 5b69 6e74   dims (Tuple[int
-00016490: 2c20 2e2e 2e5d 293a 2044 696d 656e 7369  , ...]): Dimensi
-000164a0: 6f6e 7320 746f 2062 6520 6d75 6c74 6970  ons to be multip
-000164b0: 6c69 6564 2e0a 0a20 2020 2052 6574 7572  lied...    Retur
-000164c0: 6e73 3a0a 2020 2020 2020 2020 564a 5044  ns:.        VJPD
-000164d0: 7561 6c3a 2050 7269 6d61 6c20 616e 6420  ual: Primal and 
-000164e0: 7265 7369 6475 616c 732e 0a20 2020 2022  residuals..    "
-000164f0: 2222 0a20 2020 2070 7269 6d61 6c20 3d20  "".    primal = 
-00016500: 7072 696d 732e 7072 6f64 2878 2c20 6469  prims.prod(x, di
-00016510: 6d73 290a 0a20 2020 2072 6573 6964 7561  ms)..    residua
-00016520: 6c73 203d 2028 0a20 2020 2020 2020 2070  ls = (.        p
-00016530: 7269 6d61 6c2c 0a20 2020 2020 2020 2078  rimal,.        x
-00016540: 2c0a 2020 2020 2020 2020 782e 7368 6170  ,.        x.shap
-00016550: 652c 0a20 2020 2020 2020 2064 696d 732c  e,.        dims,
-00016560: 0a20 2020 2029 0a20 2020 2072 6574 7572  .    ).    retur
-00016570: 6e20 564a 5044 7561 6c28 7072 696d 616c  n VJPDual(primal
-00016580: 2c20 7265 7369 6475 616c 7329 0a0a 0a40  , residuals)...@
-00016590: 7265 6769 7374 6572 5f62 6163 6b77 6172  register_backwar
-000165a0: 6428 7072 696d 732e 5072 696d 4944 732e  d(prims.PrimIDs.
-000165b0: 5052 4f44 290a 6465 6620 7072 6f64 5f70  PROD).def prod_p
-000165c0: 756c 6c62 6163 6b28 7072 696d 616c 2c20  ullback(primal, 
-000165d0: 782c 2078 5f73 6861 7065 2c20 7265 6475  x, x_shape, redu
-000165e0: 6365 645f 6469 6d73 2c20 6729 3a0a 2020  ced_dims, g):.  
-000165f0: 2020 7265 7475 726e 2070 7269 6d73 2e64    return prims.d
-00016600: 6976 2872 6573 746f 7265 5f72 6564 7563  iv(restore_reduc
-00016610: 6564 5f64 696d 7328 7072 696d 616c 202a  ed_dims(primal *
-00016620: 2067 2c20 7265 6475 6365 645f 6469 6d73   g, reduced_dims
-00016630: 2c20 785f 7368 6170 6529 2c20 7829 0a0a  , x_shape), x)..
-00016640: 0a64 6566 206b 6565 7064 696d 5f72 6564  .def keepdim_red
-00016650: 7563 7469 6f6e 2872 6564 7563 7469 6f6e  uction(reduction
-00016660: 5f66 6e2c 2078 2c20 6469 6d73 293a 0a20  _fn, x, dims):. 
-00016670: 2020 2022 2222 4170 706c 6965 7320 7265     """Applies re
-00016680: 6475 6374 696f 6e20 616e 6420 6669 7865  duction and fixe
-00016690: 7320 6f75 7470 7574 2074 6f20 636f 6e66  s output to conf
-000166a0: 6f72 6d20 746f 206b 6565 7064 696d 3d54  orm to keepdim=T
-000166b0: 7275 6522 2222 0a20 2020 206f 7574 203d  rue""".    out =
-000166c0: 2072 6564 7563 7469 6f6e 5f66 6e28 782c   reduction_fn(x,
-000166d0: 2064 696d 7329 0a20 2020 2061 7267 6d61   dims).    argma
-000166e0: 785f 7375 6d5f 6f75 745f 7368 6170 6520  x_sum_out_shape 
-000166f0: 3d20 5b78 2e73 6861 7065 5b69 5d20 6966  = [x.shape[i] if
-00016700: 2069 206e 6f74 2069 6e20 6469 6d73 2065   i not in dims e
-00016710: 6c73 6520 3120 666f 7220 6920 696e 2072  lse 1 for i in r
-00016720: 616e 6765 2878 2e6e 6469 6d29 5d0a 2020  ange(x.ndim)].  
-00016730: 2020 6272 6f61 6463 6173 745f 6469 6d73    broadcast_dims
-00016740: 203d 205b 6920 666f 7220 6920 696e 2072   = [i for i in r
-00016750: 616e 6765 2878 2e6e 6469 6d29 2069 6620  ange(x.ndim) if 
-00016760: 6920 6e6f 7420 696e 2064 696d 735d 0a20  i not in dims]. 
-00016770: 2020 2072 6574 7572 6e20 7072 696d 732e     return prims.
-00016780: 6272 6f61 6463 6173 745f 696e 5f64 696d  broadcast_in_dim
-00016790: 286f 7574 2c20 6172 676d 6178 5f73 756d  (out, argmax_sum
-000167a0: 5f6f 7574 5f73 6861 7065 2c20 6272 6f61  _out_shape, broa
-000167b0: 6463 6173 745f 6469 6d73 290a 0a0a 2320  dcast_dims)...# 
-000167c0: 496e 7370 6972 6564 2066 726f 6d20 6874  Inspired from ht
-000167d0: 7470 733a 2f2f 6769 7468 7562 2e63 6f6d  tps://github.com
-000167e0: 2f48 4950 532f 6175 746f 6772 6164 2f62  /HIPS/autograd/b
-000167f0: 6c6f 622f 6d61 7374 6572 2f61 7574 6f67  lob/master/autog
-00016800: 7261 642f 6e75 6d70 792f 6e75 6d70 795f  rad/numpy/numpy_
-00016810: 766a 7073 2e70 7923 4c33 3533 0a64 6566  vjps.py#L353.def
-00016820: 2067 7261 645f 6368 6f6f 7365 725f 6261   grad_chooser_ba
-00016830: 636b 7761 7264 2870 7269 6d61 6c2c 2078  ckward(primal, x
-00016840: 2c20 785f 7368 6170 652c 2072 6564 7563  , x_shape, reduc
-00016850: 6564 5f64 696d 732c 2067 293a 0a20 2020  ed_dims, g):.   
-00016860: 2022 2222 4275 696c 6473 2067 7261 6469   """Builds gradi
-00016870: 656e 7420 6f66 2066 756e 6374 696f 6e73  ent of functions
-00016880: 2074 6861 7420 6368 6f6f 7365 2061 2073   that choose a s
-00016890: 696e 676c 6520 6974 656d 2c20 7375 6368  ingle item, such
-000168a0: 2061 7320 6d69 6e20 6f72 206d 6178 2e22   as min or max."
-000168b0: 2222 0a20 2020 2067 5f72 6570 6561 7465  "".    g_repeate
-000168c0: 6420 3d20 7265 7374 6f72 655f 7265 6475  d = restore_redu
-000168d0: 6365 645f 6469 6d73 2867 2c20 7265 6475  ced_dims(g, redu
-000168e0: 6365 645f 6469 6d73 2c20 785f 7368 6170  ced_dims, x_shap
-000168f0: 6529 0a20 2020 2070 7269 6d61 6c5f 7265  e).    primal_re
-00016900: 7065 6174 6564 203d 2072 6573 746f 7265  peated = restore
-00016910: 5f72 6564 7563 6564 5f64 696d 7328 7072  _reduced_dims(pr
-00016920: 696d 616c 2c20 7265 6475 6365 645f 6469  imal, reduced_di
-00016930: 6d73 2c20 785f 7368 6170 6529 0a20 2020  ms, x_shape).   
-00016940: 2061 7267 6d61 785f 6c6f 6361 7469 6f6e   argmax_location
-00016950: 7320 3d20 7820 3d3d 2070 7269 6d61 6c5f  s = x == primal_
-00016960: 7265 7065 6174 6564 0a20 2020 2061 7267  repeated.    arg
-00016970: 6d61 785f 7375 6d20 3d20 6b65 6570 6469  max_sum = keepdi
-00016980: 6d5f 7265 6475 6374 696f 6e28 7072 696d  m_reduction(prim
-00016990: 732e 7375 6d2c 2061 7267 6d61 785f 6c6f  s.sum, argmax_lo
-000169a0: 6361 7469 6f6e 732c 2072 6564 7563 6564  cations, reduced
-000169b0: 5f64 696d 7329 0a20 2020 206f 7574 203d  _dims).    out =
-000169c0: 2067 5f72 6570 6561 7465 6420 2a20 6172   g_repeated * ar
-000169d0: 676d 6178 5f6c 6f63 6174 696f 6e73 202f  gmax_locations /
-000169e0: 2061 7267 6d61 785f 7375 6d0a 2020 2020   argmax_sum.    
-000169f0: 7265 7475 726e 206f 7574 0a0a 0a72 6567  return out...reg
-00016a00: 6973 7465 725f 6261 636b 7761 7264 2870  ister_backward(p
-00016a10: 7269 6d73 2e50 7269 6d49 4473 2e41 4d49  rims.PrimIDs.AMI
-00016a20: 4e29 2867 7261 645f 6368 6f6f 7365 725f  N)(grad_chooser_
-00016a30: 6261 636b 7761 7264 290a 0a0a 4072 6567  backward)...@reg
-00016a40: 6973 7465 725f 6175 676d 656e 7465 645f  ister_augmented_
-00016a50: 666f 7277 6172 6428 7072 696d 732e 5072  forward(prims.Pr
-00016a60: 696d 4944 732e 414d 494e 290a 6465 6620  imIDs.AMIN).def 
-00016a70: 616d 696e 5f61 7567 5f66 7764 2878 2c20  amin_aug_fwd(x, 
-00016a80: 6469 6d73 293a 0a20 2020 2022 2222 4175  dims):.    """Au
-00016a90: 676d 656e 7465 6420 616d 696e 206f 7065  gmented amin ope
-00016aa0: 7261 7469 6f6e 2e0a 2020 2020 4172 6773  ration..    Args
-00016ab0: 3a0a 2020 2020 2020 2020 7820 2856 6172  :.        x (Var
-00016ac0: 6961 626c 6529 3a20 5465 6e73 6f72 2074  iable): Tensor t
-00016ad0: 6f20 636f 6d70 7574 6520 616d 696e 206f  o compute amin o
-00016ae0: 6e2e 0a20 2020 2020 2020 2064 696d 7320  n..        dims 
-00016af0: 2854 7570 6c65 5b69 6e74 2c20 2e2e 2e5d  (Tuple[int, ...]
-00016b00: 293a 2044 696d 656e 7369 6f6e 7320 746f  ): Dimensions to
-00016b10: 2063 6f6d 7075 7465 2061 6d69 6e20 6f76   compute amin ov
-00016b20: 6572 2e0a 2020 2020 5265 7475 726e 733a  er..    Returns:
-00016b30: 0a20 2020 2020 2020 2056 4a50 4475 616c  .        VJPDual
-00016b40: 3a20 5072 696d 616c 2061 6e64 2072 6573  : Primal and res
-00016b50: 6964 7561 6c73 2e0a 2020 2020 2222 220a  iduals..    """.
-00016b60: 2020 2020 7072 696d 616c 203d 2070 7269      primal = pri
-00016b70: 6d73 2e61 6d69 6e28 782c 2064 696d 7329  ms.amin(x, dims)
-00016b80: 0a0a 2020 2020 7265 7369 6475 616c 7320  ..    residuals 
-00016b90: 3d20 280a 2020 2020 2020 2020 7072 696d  = (.        prim
-00016ba0: 616c 2c0a 2020 2020 2020 2020 782c 0a20  al,.        x,. 
-00016bb0: 2020 2020 2020 2078 2e73 6861 7065 2c0a         x.shape,.
-00016bc0: 2020 2020 2020 2020 6469 6d73 2c0a 2020          dims,.  
-00016bd0: 2020 290a 0a20 2020 2072 6574 7572 6e20    )..    return 
-00016be0: 564a 5044 7561 6c28 7072 696d 616c 2c20  VJPDual(primal, 
-00016bf0: 7265 7369 6475 616c 7329 0a0a 0a40 7265  residuals)...@re
-00016c00: 6769 7374 6572 5f61 7567 6d65 6e74 6564  gister_augmented
-00016c10: 5f66 6f72 7761 7264 2870 7269 6d73 2e50  _forward(prims.P
-00016c20: 7269 6d49 4473 2e50 4f57 290a 6465 6620  rimIDs.POW).def 
-00016c30: 706f 775f 6175 675f 6665 6428 782c 2079  pow_aug_fed(x, y
-00016c40: 293a 0a20 2020 2022 2222 4175 676d 656e  ):.    """Augmen
-00016c50: 7465 6420 7468 6520 706f 7720 6f70 6572  ted the pow oper
-00016c60: 6174 696f 6e2e 0a0a 2020 2020 4172 6773  ation...    Args
-00016c70: 3a0a 2020 2020 2020 2020 7820 2856 6172  :.        x (Var
-00016c80: 6961 626c 6529 3a20 5465 6e73 6f72 2077  iable): Tensor w
-00016c90: 6974 6820 7468 6520 6261 7365 2074 6f20  ith the base to 
-00016ca0: 6265 2065 7870 6f6e 656e 7469 6174 6564  be exponentiated
-00016cb0: 2e0a 2020 2020 2020 2020 7920 2856 6172  ..        y (Var
-00016cc0: 6961 626c 6529 3a20 5465 6e73 6f72 2077  iable): Tensor w
-00016cd0: 6974 6820 706f 7765 7220 746f 2072 6169  ith power to rai
-00016ce0: 7365 2074 6f2e 0a0a 2020 2020 5265 7475  se to...    Retu
-00016cf0: 726e 733a 0a20 2020 2020 2020 2056 4a50  rns:.        VJP
-00016d00: 4475 616c 3a20 5072 696d 616c 2061 6e64  Dual: Primal and
-00016d10: 2072 6573 6964 7561 6c73 2e0a 2020 2020   residuals..    
-00016d20: 2222 220a 2020 2020 7072 696d 616c 203d  """.    primal =
-00016d30: 2070 7269 6d73 2e70 6f77 2878 2c20 7929   prims.pow(x, y)
-00016d40: 0a20 2020 2072 6573 6964 7561 6c73 203d  .    residuals =
-00016d50: 2028 7072 696d 616c 2c20 782c 2079 290a   (primal, x, y).
-00016d60: 2020 2020 7265 7475 726e 2056 4a50 4475      return VJPDu
-00016d70: 616c 2870 7269 6d61 6c2c 2072 6573 6964  al(primal, resid
-00016d80: 7561 6c73 290a 0a0a 4072 6567 6973 7465  uals)...@registe
-00016d90: 725f 6261 636b 7761 7264 2870 7269 6d73  r_backward(prims
-00016da0: 2e50 7269 6d49 4473 2e50 4f57 290a 6465  .PrimIDs.POW).de
-00016db0: 6620 706f 775f 6261 636b 7761 7264 2872  f pow_backward(r
-00016dc0: 6573 756c 742c 2078 2c20 792c 2067 293a  esult, x, y, g):
-00016dd0: 0a20 2020 2069 6d70 6f72 7420 7468 756e  .    import thun
-00016de0: 6465 722e 636c 616e 6720 6173 2074 6c61  der.clang as tla
-00016df0: 6e67 0a0a 2020 2020 6772 6573 756c 7420  ng..    gresult 
-00016e00: 3d20 6720 2a20 7265 7375 6c74 2020 2320  = g * result  # 
-00016e10: 7265 7573 6520 636f 6d6d 6f6e 2066 6163  reuse common fac
-00016e20: 746f 720a 2020 2020 6478 203d 2067 202a  tor.    dx = g *
-00016e30: 2079 202a 2078 202a 2a20 2879 202d 2031   y * x ** (y - 1
-00016e40: 290a 2020 2020 6479 203d 2067 7265 7375  ).    dy = gresu
-00016e50: 6c74 202a 2074 6c61 6e67 2e6c 6f67 2878  lt * tlang.log(x
-00016e60: 290a 2020 2020 7265 7475 726e 2064 782c  ).    return dx,
-00016e70: 2064 790a 0a0a 4072 6567 6973 7465 725f   dy...@register_
-00016e80: 6175 676d 656e 7465 645f 666f 7277 6172  augmented_forwar
-00016e90: 6428 7072 696d 732e 5072 696d 4944 732e  d(prims.PrimIDs.
-00016ea0: 5441 4e29 0a64 6566 2074 616e 5f61 7567  TAN).def tan_aug
-00016eb0: 5f66 7764 2878 293a 0a20 2020 2022 2222  _fwd(x):.    """
-00016ec0: 4175 676d 656e 7465 6420 7461 6e20 6f70  Augmented tan op
-00016ed0: 6572 6174 696f 6e2e 0a0a 2020 2020 4172  eration...    Ar
-00016ee0: 6773 3a0a 2020 2020 2020 2020 7820 2856  gs:.        x (V
-00016ef0: 6172 6961 626c 6529 3a20 5465 6e73 6f72  ariable): Tensor
-00016f00: 2074 6f20 6265 2070 6173 7365 6420 746f   to be passed to
-00016f10: 2074 616e 2e0a 2020 2020 2222 220a 0a20   tan..    """.. 
-00016f20: 2020 2070 7269 6d61 6c20 3d20 7072 696d     primal = prim
-00016f30: 732e 7461 6e28 7829 0a20 2020 2072 6573  s.tan(x).    res
-00016f40: 6964 7561 6c73 203d 2028 7072 696d 616c  iduals = (primal
-00016f50: 2c29 0a20 2020 2072 6574 7572 6e20 564a  ,).    return VJ
-00016f60: 5044 7561 6c28 7072 696d 616c 2c20 7265  PDual(primal, re
-00016f70: 7369 6475 616c 7329 0a0a 0a40 7265 6769  siduals)...@regi
-00016f80: 7374 6572 5f62 6163 6b77 6172 6428 7072  ster_backward(pr
-00016f90: 696d 732e 5072 696d 4944 732e 5441 4e29  ims.PrimIDs.TAN)
-00016fa0: 0a64 6566 2074 616e 5f62 6163 6b77 6172  .def tan_backwar
-00016fb0: 6428 7265 7375 6c74 2c20 6729 3a0a 2020  d(result, g):.  
-00016fc0: 2020 7265 7475 726e 2067 202a 2028 3120    return g * (1 
-00016fd0: 2b20 7265 7375 6c74 202a 2072 6573 756c  + result * resul
-00016fe0: 7429 0a0a 0a23 204e 4f54 453a 204a 6178  t)...# NOTE: Jax
-00016ff0: 2075 7365 7320 6e70 2e61 7267 736f 7274   uses np.argsort
-00017000: 2069 6e20 6974 7320 7472 616e 7370 6f73   in its transpos
-00017010: 6520 766a 7020 636f 6d70 7574 6174 696f  e vjp computatio
-00017020: 6e0a 6465 6620 5f61 7267 736f 7274 2873  n.def _argsort(s
-00017030: 6571 293a 0a20 2020 2072 6574 7572 6e20  eq):.    return 
-00017040: 736f 7274 6564 2872 616e 6765 286c 656e  sorted(range(len
-00017050: 2873 6571 2929 2c20 6b65 793d 7365 712e  (seq)), key=seq.
-00017060: 5f5f 6765 7469 7465 6d5f 5f29 0a0a 0a40  __getitem__)...@
-00017070: 7265 6769 7374 6572 5f61 7567 6d65 6e74  register_augment
-00017080: 6564 5f66 6f72 7761 7264 2870 7269 6d73  ed_forward(prims
-00017090: 2e50 7269 6d49 4473 2e44 4556 4943 455f  .PrimIDs.DEVICE_
-000170a0: 5055 5429 0a64 6566 2064 6576 6963 655f  PUT).def device_
-000170b0: 7075 745f 6175 675f 6677 6428 613a 2054  put_aug_fwd(a: T
-000170c0: 656e 736f 7250 726f 7879 2c20 6465 7669  ensorProxy, devi
-000170d0: 6365 3a20 4465 7669 6365 2920 2d3e 2054  ce: Device) -> T
-000170e0: 656e 736f 7250 726f 7879 3a0a 2020 2020  ensorProxy:.    
-000170f0: 7072 696d 616c 203d 2070 7269 6d73 2e64  primal = prims.d
-00017100: 6576 6963 655f 7075 7428 612c 2064 6576  evice_put(a, dev
-00017110: 6963 6529 0a20 2020 2072 6573 6964 7561  ice).    residua
-00017120: 6c73 203d 2028 612e 6465 7669 6365 2c29  ls = (a.device,)
-00017130: 0a20 2020 2072 6574 7572 6e20 564a 5044  .    return VJPD
-00017140: 7561 6c28 7072 696d 616c 2c20 7265 7369  ual(primal, resi
-00017150: 6475 616c 7329 0a0a 0a40 7265 6769 7374  duals)...@regist
-00017160: 6572 5f62 6163 6b77 6172 6428 7072 696d  er_backward(prim
-00017170: 732e 5072 696d 4944 732e 4445 5649 4345  s.PrimIDs.DEVICE
-00017180: 5f50 5554 290a 6465 6620 6465 7669 6365  _PUT).def device
-00017190: 5f70 7574 5f62 6163 6b77 6172 6428 6f72  _put_backward(or
-000171a0: 6967 5f64 6576 6963 652c 2067 293a 0a20  ig_device, g):. 
-000171b0: 2020 2072 6574 7572 6e20 7072 696d 732e     return prims.
-000171c0: 6465 7669 6365 5f70 7574 2867 2c20 6f72  device_put(g, or
-000171d0: 6967 5f64 6576 6963 6529 2c20 4e6f 6e65  ig_device), None
-000171e0: 0a0a 0a40 7265 6769 7374 6572 5f61 7567  ...@register_aug
-000171f0: 6d65 6e74 6564 5f66 6f72 7761 7264 2870  mented_forward(p
-00017200: 7269 6d73 2e50 7269 6d49 4473 2e43 4f4e  rims.PrimIDs.CON
-00017210: 564f 4c55 5449 4f4e 290a 6465 6620 636f  VOLUTION).def co
-00017220: 6e76 6f6c 7574 696f 6e5f 6175 675f 6677  nvolution_aug_fw
-00017230: 6428 0a20 2020 2061 3a20 5072 6f78 792c  d(.    a: Proxy,
-00017240: 0a20 2020 2077 6569 6768 742c 0a20 2020  .    weight,.   
-00017250: 2062 6961 732c 0a20 2020 2073 7472 6964   bias,.    strid
-00017260: 652c 0a20 2020 2070 6164 6469 6e67 2c0a  e,.    padding,.
-00017270: 2020 2020 6469 6c61 7469 6f6e 2c0a 2020      dilation,.  
-00017280: 2020 7472 616e 7370 6f73 6564 2c0a 2020    transposed,.  
-00017290: 2020 6f75 7470 7574 5f70 6164 6469 6e67    output_padding
-000172a0: 2c0a 2020 2020 6772 6f75 7073 2c0a 293a  ,.    groups,.):
-000172b0: 0a20 2020 2070 7269 6d61 6c20 3d20 636f  .    primal = co
-000172c0: 6e76 6f6c 7574 696f 6e28 612c 2077 6569  nvolution(a, wei
-000172d0: 6768 742c 2062 6961 732c 2073 7472 6964  ght, bias, strid
-000172e0: 652c 2070 6164 6469 6e67 2c20 6469 6c61  e, padding, dila
-000172f0: 7469 6f6e 2c20 7472 616e 7370 6f73 6564  tion, transposed
-00017300: 2c20 6f75 7470 7574 5f70 6164 6469 6e67  , output_padding
-00017310: 2c20 6772 6f75 7073 290a 2020 2020 7265  , groups).    re
-00017320: 7369 6475 616c 7320 3d20 2870 7269 6d61  siduals = (prima
-00017330: 6c2c 2061 2c20 7765 6967 6874 2c20 6269  l, a, weight, bi
-00017340: 6173 2c20 7374 7269 6465 2c20 7061 6464  as, stride, padd
-00017350: 696e 672c 2064 696c 6174 696f 6e2c 2074  ing, dilation, t
-00017360: 7261 6e73 706f 7365 642c 206f 7574 7075  ransposed, outpu
-00017370: 745f 7061 6464 696e 672c 2067 726f 7570  t_padding, group
-00017380: 7329 0a20 2020 2072 6574 7572 6e20 564a  s).    return VJ
-00017390: 5044 7561 6c28 7072 696d 616c 2c20 7265  PDual(primal, re
-000173a0: 7369 6475 616c 7329 0a0a 0a40 7265 6769  siduals)...@regi
-000173b0: 7374 6572 5f62 6163 6b77 6172 6428 7072  ster_backward(pr
-000173c0: 696d 732e 5072 696d 4944 732e 434f 4e56  ims.PrimIDs.CONV
-000173d0: 4f4c 5554 494f 4e29 0a64 6566 2063 6f6e  OLUTION).def con
-000173e0: 766f 6c75 7469 6f6e 5f62 6163 6b77 6172  volution_backwar
-000173f0: 6428 0a20 2020 206f 7574 7075 743a 2050  d(.    output: P
-00017400: 726f 7879 2c0a 2020 2020 696e 7075 743a  roxy,.    input:
-00017410: 2050 726f 7879 2c0a 2020 2020 7765 6967   Proxy,.    weig
-00017420: 6874 2c0a 2020 2020 6269 6173 2c0a 2020  ht,.    bias,.  
-00017430: 2020 7374 7269 6465 2c0a 2020 2020 7061    stride,.    pa
-00017440: 6464 696e 672c 0a20 2020 2064 696c 6174  dding,.    dilat
-00017450: 696f 6e2c 0a20 2020 2074 7261 6e73 706f  ion,.    transpo
-00017460: 7365 642c 0a20 2020 206f 7574 7075 745f  sed,.    output_
-00017470: 7061 6464 696e 672c 0a20 2020 2067 726f  padding,.    gro
-00017480: 7570 732c 0a20 2020 2067 7261 642c 0a29  ups,.    grad,.)
-00017490: 3a0a 2020 2020 2320 5472 616e 7370 6f73  :.    # Transpos
-000174a0: 6564 2063 6f6e 766f 6c75 7469 6f6e 2069  ed convolution i
-000174b0: 7320 6e6f 7420 7375 7070 6f72 7465 6421  s not supported!
-000174c0: 0a20 2020 2061 7373 6572 7420 7472 616e  .    assert tran
-000174d0: 7370 6f73 6564 203d 3d20 300a 0a20 2020  sposed == 0..   
-000174e0: 2069 6e70 7574 5f67 7261 6420 3d20 4e6f   input_grad = No
-000174f0: 6e65 0a20 2020 2077 6569 6768 745f 6772  ne.    weight_gr
-00017500: 6164 203d 204e 6f6e 650a 2020 2020 6269  ad = None.    bi
-00017510: 6173 5f67 7261 6420 3d20 4e6f 6e65 0a0a  as_grad = None..
-00017520: 2020 2020 2320 5368 6f72 7420 6369 7263      # Short circ
-00017530: 7569 7420 6f6e 207a 6572 6f2d 6469 6d20  uit on zero-dim 
-00017540: 6772 6164 0a20 2020 2069 6620 616e 7928  grad.    if any(
-00017550: 7320 3d3d 2030 2066 6f72 2073 2069 6e20  s == 0 for s in 
-00017560: 6772 6164 2e73 6861 7065 293a 0a20 2020  grad.shape):.   
-00017570: 2020 2020 2069 6e70 7574 5f67 7261 6420       input_grad 
-00017580: 3d20 6675 6c6c 5f6c 696b 6528 696e 7075  = full_like(inpu
-00017590: 742c 2066 696c 6c5f 7661 6c75 653d 3029  t, fill_value=0)
-000175a0: 0a20 2020 2020 2020 2077 6569 6768 745f  .        weight_
-000175b0: 6772 6164 203d 2066 756c 6c5f 6c69 6b65  grad = full_like
-000175c0: 2877 6569 6768 742c 2066 696c 6c5f 7661  (weight, fill_va
-000175d0: 6c75 653d 3029 0a20 2020 2020 2020 2069  lue=0).        i
-000175e0: 6620 6269 6173 2069 7320 6e6f 7420 4e6f  f bias is not No
-000175f0: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
-00017600: 6269 6173 5f67 7261 6420 3d20 6675 6c6c  bias_grad = full
-00017610: 5f6c 696b 6528 6269 6173 2c20 6669 6c6c  _like(bias, fill
-00017620: 5f76 616c 7565 3d30 290a 2020 2020 2020  _value=0).      
-00017630: 2020 7265 7475 726e 2028 696e 7075 745f    return (input_
-00017640: 6772 6164 2c20 7765 6967 6874 5f67 7261  grad, weight_gra
-00017650: 642c 2062 6961 735f 6772 6164 2920 2b20  d, bias_grad) + 
-00017660: 2828 4e6f 6e65 2c29 202a 2036 290a 0a20  ((None,) * 6).. 
-00017670: 2020 2062 6174 6368 2c20 696e 5f63 6861     batch, in_cha
-00017680: 6e6e 656c 732c 202a 7370 6174 6961 6c5f  nnels, *spatial_
-00017690: 6469 6d73 203d 2069 6e70 7574 2e73 6861  dims = input.sha
-000176a0: 7065 0a20 2020 206f 7574 5f63 6861 6e6e  pe.    out_chann
-000176b0: 656c 732c 2067 696e 5f63 6861 6e6e 656c  els, gin_channel
-000176c0: 732c 202a 6b65 726e 656c 5f64 696d 7320  s, *kernel_dims 
-000176d0: 3d20 7765 6967 6874 2e73 6861 7065 0a20  = weight.shape. 
-000176e0: 2020 2064 696d 203d 206c 656e 2873 7061     dim = len(spa
-000176f0: 7469 616c 5f64 696d 7329 0a0a 2020 2020  tial_dims)..    
-00017700: 6465 6620 6d61 7962 655f 6578 7061 6e64  def maybe_expand
-00017710: 5f73 6571 2873 2c20 6469 6d29 3a0a 2020  _seq(s, dim):.  
-00017720: 2020 2020 2020 6966 206c 656e 2873 2920        if len(s) 
-00017730: 3d3d 2031 3a0a 2020 2020 2020 2020 2020  == 1:.          
-00017740: 2020 7265 7475 726e 2028 735b 305d 2c29    return (s[0],)
-00017750: 202a 2064 696d 0a20 2020 2020 2020 2065   * dim.        e
-00017760: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00017770: 2072 6574 7572 6e20 730a 0a20 2020 2073   return s..    s
-00017780: 7472 6964 6520 3d20 6d61 7962 655f 6578  tride = maybe_ex
-00017790: 7061 6e64 5f73 6571 2873 7472 6964 652c  pand_seq(stride,
-000177a0: 2064 696d 290a 2020 2020 7061 6464 696e   dim).    paddin
-000177b0: 6720 3d20 6d61 7962 655f 6578 7061 6e64  g = maybe_expand
-000177c0: 5f73 6571 2870 6164 6469 6e67 2c20 6469  _seq(padding, di
-000177d0: 6d29 0a20 2020 2064 696c 6174 696f 6e20  m).    dilation 
-000177e0: 3d20 6d61 7962 655f 6578 7061 6e64 5f73  = maybe_expand_s
-000177f0: 6571 2864 696c 6174 696f 6e2c 2064 696d  eq(dilation, dim
-00017800: 290a 0a20 2020 2064 6566 2063 6f6e 765f  )..    def conv_
-00017810: 7472 616e 7370 6f73 6528 7429 3a0a 2020  transpose(t):.  
-00017820: 2020 2020 2020 7265 7475 726e 2070 7269        return pri
-00017830: 6d73 2e74 7261 6e73 706f 7365 2874 2c20  ms.transpose(t, 
-00017840: 2831 2c20 3029 202b 2074 7570 6c65 2872  (1, 0) + tuple(r
-00017850: 616e 6765 2832 2c20 742e 6e64 696d 2929  ange(2, t.ndim))
-00017860: 290a 0a20 2020 2023 2069 6e70 7574 5f67  )..    # input_g
-00017870: 7261 6420 3d20 7b0a 2020 2020 6465 6620  rad = {.    def 
-00017880: 7472 616e 7370 6f73 655f 616e 645f 666c  transpose_and_fl
-00017890: 6970 5f77 6569 6768 7428 7765 6967 6874  ip_weight(weight
-000178a0: 293a 0a20 2020 2020 2020 2023 2054 6865  ):.        # The
-000178b0: 206c 696e 6573 2062 656c 6f77 2061 7265   lines below are
-000178c0: 2074 7261 6e73 706f 7369 6e67 2074 6865   transposing the
-000178d0: 2063 6861 6e6e 656c 7320 6469 6d73 2e0a   channels dims..
-000178e0: 2020 2020 2020 2020 2320 5765 2061 6c73          # We als
-000178f0: 6f20 6e65 6564 2074 6f20 6578 7472 6163  o need to extrac
-00017900: 7420 7468 6520 6772 6f75 7020 696e 666f  t the group info
-00017910: 726d 6174 696f 6e20 616e 6420 6d65 7267  rmation and merg
-00017920: 6520 6974 0a20 2020 2020 2020 2023 2077  e it.        # w
-00017930: 6974 6820 7468 6520 6469 6d65 6e73 696f  ith the dimensio
-00017940: 6e20 636f 7272 6573 706f 6e64 696e 6720  n corresponding 
-00017950: 746f 2074 6865 2022 6f75 745f 6368 616e  to the "out_chan
-00017960: 6e65 6c73 2220 6469 6d2e 0a20 2020 2020  nels" dim..     
-00017970: 2020 2023 2028 6f75 745f 6368 616e 6e65     # (out_channe
-00017980: 6c73 2c20 6769 6e5f 6368 616e 6e65 6c73  ls, gin_channels
-00017990: 2920 2d3e 2028 6769 6e5f 6368 616e 6e65  ) -> (gin_channe
-000179a0: 6c73 2c20 6f75 745f 6368 616e 6e65 6c73  ls, out_channels
-000179b0: 290a 2020 2020 2020 2020 7765 6967 6874  ).        weight
-000179c0: 203d 2063 6f6e 765f 7472 616e 7370 6f73   = conv_transpos
-000179d0: 6528 7765 6967 6874 290a 2020 2020 2020  e(weight).      
-000179e0: 2020 2320 5370 6c69 7420 286f 7574 5f63    # Split (out_c
-000179f0: 6861 6e6e 656c 732c 2920 2d3e 2028 6772  hannels,) -> (gr
-00017a00: 6f75 7073 2c20 6f75 745f 6368 616e 6e65  oups, out_channe
-00017a10: 6c73 202f 2f20 6772 6f75 7073 290a 2020  ls // groups).  
-00017a20: 2020 2020 2020 7765 6967 6874 203d 2077        weight = w
-00017a30: 6569 6768 742e 7265 7368 6170 6528 5b67  eight.reshape([g
-00017a40: 696e 5f63 6861 6e6e 656c 732c 2067 726f  in_channels, gro
-00017a50: 7570 732c 206f 7574 5f63 6861 6e6e 656c  ups, out_channel
-00017a60: 7320 2f2f 2067 726f 7570 735d 202b 206b  s // groups] + k
-00017a70: 6572 6e65 6c5f 6469 6d73 290a 2020 2020  ernel_dims).    
-00017a80: 2020 2020 2320 4d6f 7669 6e67 2067 726f      # Moving gro
-00017a90: 7570 7320 746f 2074 6865 206c 6566 742d  ups to the left-
-00017aa0: 6d6f 7374 2070 6f73 6974 696f 6e2e 0a20  most position.. 
-00017ab0: 2020 2020 2020 2023 2028 6769 6e5f 6368         # (gin_ch
-00017ac0: 616e 6e65 6c73 2c20 6772 6f75 7073 2c20  annels, groups, 
-00017ad0: 6f75 745f 6368 616e 6e65 6c73 202f 2f20  out_channels // 
-00017ae0: 6772 6f75 7073 2920 2d3e 2028 6772 6f75  groups) -> (grou
-00017af0: 7073 2c20 6769 6e5f 6368 616e 6e65 6c73  ps, gin_channels
-00017b00: 2c20 6f75 745f 6368 616e 6e65 6c73 202f  , out_channels /
-00017b10: 2f20 6772 6f75 7073 290a 2020 2020 2020  / groups).      
-00017b20: 2020 7765 6967 6874 203d 2063 6f6e 765f    weight = conv_
-00017b30: 7472 616e 7370 6f73 6528 7765 6967 6874  transpose(weight
-00017b40: 290a 2020 2020 2020 2020 2320 5371 7561  ).        # Squa
-00017b50: 7368 2028 6772 6f75 7073 2c20 6769 6e5f  sh (groups, gin_
-00017b60: 6368 616e 6e65 6c73 2920 2d3e 2028 696e  channels) -> (in
-00017b70: 5f63 6861 6e6e 656c 7329 0a20 2020 2020  _channels).     
-00017b80: 2020 2077 6569 6768 7420 3d20 7765 6967     weight = weig
-00017b90: 6874 2e72 6573 6861 7065 285b 696e 5f63  ht.reshape([in_c
-00017ba0: 6861 6e6e 656c 732c 206f 7574 5f63 6861  hannels, out_cha
-00017bb0: 6e6e 656c 7320 2f2f 2067 726f 7570 735d  nnels // groups]
-00017bc0: 202b 206b 6572 6e65 6c5f 6469 6d73 290a   + kernel_dims).
-00017bd0: 0a20 2020 2020 2020 2023 2046 6c69 7020  .        # Flip 
-00017be0: 7370 6174 6961 6c20 6469 6d65 6e73 696f  spatial dimensio
-00017bf0: 6e73 0a20 2020 2020 2020 2077 6569 6768  ns.        weigh
-00017c00: 7420 3d20 7072 696d 732e 666c 6970 2877  t = prims.flip(w
-00017c10: 6569 6768 742c 2074 7570 6c65 2872 616e  eight, tuple(ran
-00017c20: 6765 2832 2c20 7765 6967 6874 2e6e 6469  ge(2, weight.ndi
-00017c30: 6d29 2929 0a20 2020 2020 2020 2072 6574  m))).        ret
-00017c40: 7572 6e20 7765 6967 6874 0a0a 2020 2020  urn weight..    
-00017c50: 2320 5765 206e 6565 6420 746f 2070 6164  # We need to pad
-00017c60: 2074 6865 2067 7261 6469 656e 7420 746f   the gradient to
-00017c70: 2062 6520 6162 6c65 2074 6f20 6669 7420   be able to fit 
-00017c80: 6b65 726e 656c 2077 696e 646f 7773 2e0a  kernel windows..
-00017c90: 2020 2020 696e 6974 6961 6c5f 6772 6164      initial_grad
-00017ca0: 5f70 6164 6469 6e67 203d 205b 6420 2a20  _padding = [d * 
-00017cb0: 286b 202d 2031 2920 666f 7220 642c 206b  (k - 1) for d, k
-00017cc0: 2069 6e20 7a69 7028 6469 6c61 7469 6f6e   in zip(dilation
-00017cd0: 2c20 6b65 726e 656c 5f64 696d 7329 5d0a  , kernel_dims)].
-00017ce0: 0a20 2020 2069 6e70 7574 5f67 7261 6420  .    input_grad 
-00017cf0: 3d20 636f 6e76 6f6c 7574 696f 6e28 0a20  = convolution(. 
-00017d00: 2020 2020 2020 2070 7269 6d73 2e70 6164         prims.pad
-00017d10: 280a 2020 2020 2020 2020 2020 2020 6772  (.            gr
-00017d20: 6164 2c0a 2020 2020 2020 2020 2020 2020  ad,.            
-00017d30: 302e 302c 0a20 2020 2020 2020 2020 2020  0.0,.           
-00017d40: 2023 2054 6865 2070 6978 6573 2061 7265   # The pixes are
-00017d50: 2073 7472 6964 6520 6177 6179 2066 726f   stride away fro
-00017d60: 6d20 6561 6368 206f 7468 6572 2069 6e20  m each other in 
-00017d70: 7468 6520 6f72 6967 696e 616c 2069 6e70  the original inp
-00017d80: 7574 2e0a 2020 2020 2020 2020 2020 2020  ut..            
-00017d90: 2320 4865 6e63 6520 7765 206e 6565 6420  # Hence we need 
-00017da0: 746f 2064 696c 6174 6520 7468 6520 6772  to dilate the gr
-00017db0: 6164 6965 6e74 2062 7920 6469 6c61 7469  adient by dilati
-00017dc0: 6f6e 3d73 7472 6964 6520 2d20 310a 2020  on=stride - 1.  
-00017dd0: 2020 2020 2020 2020 2020 2320 736f 2074            # so t
-00017de0: 6861 7420 7468 6572 6520 6172 6520 7374  hat there are st
-00017df0: 7269 6465 202d 2031 207a 6572 6f73 2062  ride - 1 zeros b
-00017e00: 6574 7765 656e 2074 6865 2070 6978 656c  etween the pixel
-00017e10: 732e 0a20 2020 2020 2020 2020 2020 205b  s..            [
-00017e20: 2830 2c20 302c 2030 292c 2028 302c 2030  (0, 0, 0), (0, 0
-00017e30: 2c20 3029 5d20 2b20 5b28 302c 2030 2c20  , 0)] + [(0, 0, 
-00017e40: 7320 2d20 3129 2066 6f72 2073 2069 6e20  s - 1) for s in 
-00017e50: 7374 7269 6465 5d2c 0a20 2020 2020 2020  stride],.       
-00017e60: 2029 2c0a 2020 2020 2020 2020 7472 616e   ),.        tran
-00017e70: 7370 6f73 655f 616e 645f 666c 6970 5f77  spose_and_flip_w
-00017e80: 6569 6768 7428 7765 6967 6874 292c 0a20  eight(weight),. 
-00017e90: 2020 2020 2020 204e 6f6e 652c 0a20 2020         None,.   
-00017ea0: 2020 2020 2023 2053 6574 7469 6e67 2073       # Setting s
-00017eb0: 7472 6964 6520 746f 2031 2061 7320 7468  tride to 1 as th
-00017ec0: 6520 6469 7374 616e 6365 2062 6574 7765  e distance betwe
-00017ed0: 656e 2070 6978 656c 7320 6973 2074 616b  en pixels is tak
-00017ee0: 656e 0a20 2020 2020 2020 2023 2063 6172  en.        # car
-00017ef0: 6520 6279 2074 6865 2070 6164 2072 6967  e by the pad rig
-00017f00: 6874 2061 626f 7665 2e0a 2020 2020 2020  ht above..      
-00017f10: 2020 2831 2c29 2c0a 2020 2020 2020 2020    (1,),.        
-00017f20: 696e 6974 6961 6c5f 6772 6164 5f70 6164  initial_grad_pad
-00017f30: 6469 6e67 2c0a 2020 2020 2020 2020 6469  ding,.        di
-00017f40: 6c61 7469 6f6e 2c0a 2020 2020 2020 2020  lation,.        
-00017f50: 7472 616e 7370 6f73 6564 2c0a 2020 2020  transposed,.    
-00017f60: 2020 2020 6f75 7470 7574 5f70 6164 6469      output_paddi
-00017f70: 6e67 2c0a 2020 2020 2020 2020 6772 6f75  ng,.        grou
-00017f80: 7073 2c0a 2020 2020 290a 0a20 2020 2064  ps,.    )..    d
-00017f90: 6566 2070 6164 5f74 6f5f 696e 7075 7428  ef pad_to_input(
-00017fa0: 6772 6164 293a 0a20 2020 2020 2020 2023  grad):.        #
-00017fb0: 2057 6520 6e65 6564 2074 6f20 756e 7061   We need to unpa
-00017fc0: 6420 7468 6520 7061 6464 696e 6720 646f  d the padding do
-00017fd0: 6e65 2074 6f20 7468 6520 696e 7075 7420  ne to the input 
-00017fe0: 7072 696f 7220 746f 2074 6865 2063 6f6e  prior to the con
-00017ff0: 766f 6c75 7469 6f6e 2e0a 2020 2020 2020  volution..      
-00018000: 2020 2320 4e6f 7465 2074 6861 7420 6c6f    # Note that lo
-00018010: 7720 616e 6420 6869 6768 2070 6164 6469  w and high paddi
-00018020: 6e67 2061 7265 206e 6f74 206e 6563 6573  ng are not neces
-00018030: 7361 7269 6c79 2065 7175 616c 2c20 736f  sarily equal, so
-00018040: 2077 6520 6361 6e6e 6f74 0a20 2020 2020   we cannot.     
-00018050: 2020 2023 2061 6273 6f72 6220 6974 2069     # absorb it i
-00018060: 6e74 6f20 7468 6520 636f 6e76 6f6c 7574  nto the convolut
-00018070: 696f 6e20 6a75 7374 2079 6574 2c20 756e  ion just yet, un
-00018080: 6c65 7373 2074 6865 2041 5049 2069 7320  less the API is 
-00018090: 6d6f 6469 6669 6564 2e0a 2020 2020 2020  modified..      
-000180a0: 2020 7061 645f 636f 6e66 6967 203d 205b    pad_config = [
-000180b0: 2830 2c20 302c 2030 292c 2028 302c 2030  (0, 0, 0), (0, 0
-000180c0: 2c20 3029 5d0a 2020 2020 2020 2020 666f  , 0)].        fo
-000180d0: 7220 6f2c 2069 2c20 672c 2070 2069 6e20  r o, i, g, p in 
-000180e0: 7a69 7028 6772 6164 2e73 6861 7065 5b32  zip(grad.shape[2
-000180f0: 3a5d 2c20 7370 6174 6961 6c5f 6469 6d73  :], spatial_dims
-00018100: 2c20 696e 7075 745f 6772 6164 2e73 6861  , input_grad.sha
-00018110: 7065 5b32 3a5d 2c20 7061 6464 696e 6729  pe[2:], padding)
-00018120: 3a0a 2020 2020 2020 2020 2020 2020 6c6f  :.            lo
-00018130: 203d 202d 700a 2020 2020 2020 2020 2020   = -p.          
-00018140: 2020 2320 4e6f 7465 2074 6861 7420 2869    # Note that (i
-00018150: 202b 2032 202a 2070 2920 6973 2074 6865   + 2 * p) is the
-00018160: 2073 697a 6520 6f66 2074 6865 2070 6164   size of the pad
-00018170: 6465 6420 696e 7075 742c 0a20 2020 2020  ded input,.     
-00018180: 2020 2020 2020 2023 2073 6f20 7468 6520         # so the 
-00018190: 7175 616e 7469 7479 2028 6920 2b20 3220  quantity (i + 2 
-000181a0: 2a20 7029 202d 2067 2074 656c 6c73 2075  * p) - g tells u
-000181b0: 7320 6279 2068 6f77 206d 7563 680a 2020  s by how much.  
-000181c0: 2020 2020 2020 2020 2020 2320 7765 206e            # we n
-000181d0: 6565 6420 746f 2070 6164 2074 6865 2067  eed to pad the g
-000181e0: 7261 6469 656e 7420 736f 2074 6861 7420  radient so that 
-000181f0: 7468 6520 656c 656d 656e 7473 206f 7574  the elements out
-00018200: 7369 6465 0a20 2020 2020 2020 2020 2020  side.           
-00018210: 2023 206f 6620 7468 6520 636f 6e76 6f6c   # of the convol
-00018220: 7574 696f 6e20 7265 6365 6976 6520 7a65  ution receive ze
-00018230: 726f 2067 7261 6469 656e 742e 0a20 2020  ro gradient..   
-00018240: 2020 2020 2020 2020 2023 2070 2069 7320           # p is 
-00018250: 6164 6469 7469 6f6e 616c 6c79 2073 7562  additionally sub
-00018260: 7472 6163 7465 6420 746f 206e 6567 6174  tracted to negat
-00018270: 6520 7468 6520 696e 7075 7427 7320 7061  e the input's pa
-00018280: 640a 2020 2020 2020 2020 2020 2020 2320  d.            # 
-00018290: 696e 2066 6f72 7761 7264 2e0a 2020 2020  in forward..    
-000182a0: 2020 2020 2020 2020 6869 203d 2028 6920          hi = (i 
-000182b0: 2b20 3220 2a20 7029 202d 2067 202d 2070  + 2 * p) - g - p
-000182c0: 0a20 2020 2020 2020 2020 2020 2070 6164  .            pad
-000182d0: 5f63 6f6e 6669 672e 6170 7065 6e64 2828  _config.append((
-000182e0: 6c6f 2c20 6869 2c20 3029 290a 2020 2020  lo, hi, 0)).    
-000182f0: 2020 2020 7265 7475 726e 2070 7269 6d73      return prims
-00018300: 2e70 6164 2867 7261 642c 2030 2e30 2c20  .pad(grad, 0.0, 
-00018310: 7061 645f 636f 6e66 6967 290a 0a20 2020  pad_config)..   
-00018320: 2069 6e70 7574 5f67 7261 6420 3d20 7061   input_grad = pa
-00018330: 645f 746f 5f69 6e70 7574 2869 6e70 7574  d_to_input(input
-00018340: 5f67 7261 6429 0a20 2020 2023 207d 0a0a  _grad).    # }..
-00018350: 2020 2020 2320 6269 6173 5f67 7261 6420      # bias_grad 
-00018360: 3d20 7b0a 2020 2020 6966 2062 6961 7320  = {.    if bias 
-00018370: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
-00018380: 2020 2020 2069 6d70 6f72 7420 7468 756e       import thun
-00018390: 6465 722e 746f 7263 6820 6173 206c 746f  der.torch as lto
-000183a0: 7263 680a 0a20 2020 2020 2020 2062 6961  rch..        bia
-000183b0: 735f 6772 6164 203d 206c 746f 7263 682e  s_grad = ltorch.
-000183c0: 7375 6d28 6772 6164 2c20 5b64 2066 6f72  sum(grad, [d for
-000183d0: 2064 2069 6e20 7261 6e67 6528 6772 6164   d in range(grad
-000183e0: 2e6e 6469 6d29 2069 6620 6420 213d 2031  .ndim) if d != 1
-000183f0: 5d29 0a20 2020 2023 207d 0a0a 2020 2020  ]).    # }..    
-00018400: 2320 7765 6967 6874 2067 7261 6420 3d20  # weight grad = 
-00018410: 7b0a 2020 2020 6465 6620 7061 645f 7472  {.    def pad_tr
-00018420: 616e 7370 6f73 655f 616e 645f 7075 7368  anspose_and_push
-00018430: 5f67 726f 7570 735f 696e 746f 5f62 6174  _groups_into_bat
-00018440: 6368 6573 2874 293a 0a20 2020 2020 2020  ches(t):.       
-00018450: 2023 2046 6972 7374 2070 6164 2c2e 2e2e   # First pad,...
-00018460: 0a20 2020 2020 2020 2023 2050 6164 2061  .        # Pad a
-00018470: 7320 6e65 6365 7373 6172 7920 736f 2074  s necessary so t
-00018480: 6861 7420 696e 2063 6f6e 766f 6c75 7469  hat in convoluti
-00018490: 6f6e 7320 7765 206e 6576 6572 2061 6476  ons we never adv
-000184a0: 616e 6365 0a20 2020 2020 2020 2023 2070  ance.        # p
-000184b0: 6173 7420 7265 6c65 7661 6e74 2069 6e70  ast relevant inp
-000184c0: 7574 732e 0a20 2020 2020 2020 2070 6164  uts..        pad
-000184d0: 5f63 6f6e 6669 6720 3d20 5b28 302c 2030  _config = [(0, 0
-000184e0: 2c20 3029 2c20 2830 2c20 302c 2030 295d  , 0), (0, 0, 0)]
-000184f0: 0a20 2020 2020 2020 2066 6f72 206f 2c20  .        for o, 
-00018500: 692c 206b 2c20 702c 2073 2c20 6420 696e  i, k, p, s, d in
-00018510: 207a 6970 2867 7261 642e 7368 6170 655b   zip(grad.shape[
-00018520: 323a 5d2c 2073 7061 7469 616c 5f64 696d  2:], spatial_dim
-00018530: 732c 206b 6572 6e65 6c5f 6469 6d73 2c20  s, kernel_dims, 
-00018540: 7061 6464 696e 672c 2073 7472 6964 652c  padding, stride,
-00018550: 2064 696c 6174 696f 6e29 3a0a 2020 2020   dilation):.    
-00018560: 2020 2020 2020 2020 2320 5061 6464 696e          # Paddin
-00018570: 6720 6672 6f6d 2062 656c 6f77 2069 7320  g from below is 
-00018580: 7468 6520 7361 6d65 2e0a 2020 2020 2020  the same..      
-00018590: 2020 2020 2020 6c6f 203d 2070 0a20 2020        lo = p.   
-000185a0: 2020 2020 2020 2020 2023 2054 6865 7265           # There
-000185b0: 2069 7320 616c 7761 7973 2074 6865 206d   is always the m
-000185c0: 6178 2069 6e64 6578 2069 6478 2069 6e20  ax index idx in 
-000185d0: 7468 6520 696e 7075 740a 2020 2020 2020  the input.      
-000185e0: 2020 2020 2020 2320 7468 6520 7661 6c75        # the valu
-000185f0: 6520 6f66 2077 6869 6368 2c20 696e 7075  e of which, inpu
-00018600: 745b 6964 785d 2c20 7468 6520 6b65 726e  t[idx], the kern
-00018610: 656c 2074 6f75 6368 6573 2e0a 2020 2020  el touches..    
-00018620: 2020 2020 2020 2020 2320 5468 6520 6b65          # The ke
-00018630: 726e 656c 2072 6561 6368 2c20 6f72 206b  rnel reach, or k
-00018640: 5f72 6561 6368 2c20 6973 2065 7861 6374  _reach, is exact
-00018650: 6c79 2069 6478 202b 2031 2e0a 2020 2020  ly idx + 1..    
-00018660: 2020 2020 2020 2020 2320 5765 2075 7365          # We use
-00018670: 2069 7420 746f 2064 6563 6964 6520 6279   it to decide by
-00018680: 2068 6f77 206d 7563 6820 7765 206e 6565   how much we nee
-00018690: 6420 746f 2070 6164 2066 726f 6d20 6162  d to pad from ab
-000186a0: 6f76 650a 2020 2020 2020 2020 2020 2020  ove.            
-000186b0: 2320 6173 2074 6f20 6e6f 7420 6d6f 7665  # as to not move
-000186c0: 2070 6173 7420 7265 6c65 7661 6e74 2076   past relevant v
-000186d0: 616c 7565 732e 0a20 2020 2020 2020 2020  alues..         
-000186e0: 2020 206b 5f72 6561 6368 203d 2028 6f20     k_reach = (o 
-000186f0: 2d20 3129 202a 2073 202b 2064 202a 2028  - 1) * s + d * (
-00018700: 6b20 2d20 3129 202b 2031 0a20 2020 2020  k - 1) + 1.     
-00018710: 2020 2020 2020 2023 2054 6865 2070 6164         # The pad
-00018720: 2066 726f 6d20 6162 6f76 6520 6571 7561   from above equa
-00018730: 6c73 206b 5f72 6561 6368 206d 696e 7573  ls k_reach minus
-00018740: 2074 6865 206c 656e 6774 680a 2020 2020   the length.    
-00018750: 2020 2020 2020 2020 2320 6f66 2074 6865          # of the
-00018760: 2069 6e70 7574 2070 6164 6465 6420 6672   input padded fr
-00018770: 6f6d 2062 656c 6f77 2e0a 2020 2020 2020  om below..      
-00018780: 2020 2020 2020 6869 203d 206b 5f72 6561        hi = k_rea
-00018790: 6368 202d 2028 6920 2b20 7029 0a20 2020  ch - (i + p).   
-000187a0: 2020 2020 2020 2020 2070 6164 5f63 6f6e           pad_con
-000187b0: 6669 672e 6170 7065 6e64 2828 6c6f 2c20  fig.append((lo, 
-000187c0: 6869 2c20 3029 290a 2020 2020 2020 2020  hi, 0)).        
-000187d0: 7420 3d20 7072 696d 732e 7061 6428 742c  t = prims.pad(t,
-000187e0: 2030 2e30 2c20 7061 645f 636f 6e66 6967   0.0, pad_config
-000187f0: 290a 0a20 2020 2020 2020 205f 2c20 5f2c  )..        _, _,
-00018800: 202a 745f 7370 6174 6961 6c5f 6469 6d73   *t_spatial_dims
-00018810: 203d 2074 2e73 6861 7065 0a0a 2020 2020   = t.shape..    
-00018820: 2020 2020 2320 2e2e 2e20 7468 656e 2064      # ... then d
-00018830: 6f20 7468 6520 7265 7374 2e0a 2020 2020  o the rest..    
-00018840: 2020 2020 2320 742e 7368 6170 6520 3d3d      # t.shape ==
-00018850: 2028 6261 7463 682c 2069 6e5f 6368 616e   (batch, in_chan
-00018860: 6e65 6c73 2c20 2e2e 2e29 0a20 2020 2020  nels, ...).     
-00018870: 2020 2023 2054 6865 2072 6573 756c 7420     # The result 
-00018880: 6f66 2074 6869 7320 6675 6e63 7469 6f6e  of this function
-00018890: 2068 6173 2073 6861 7065 0a20 2020 2020   has shape.     
-000188a0: 2020 2023 2028 696e 5f63 6861 6e6e 656c     # (in_channel
-000188b0: 732c 2062 6174 6368 202a 2067 726f 7570  s, batch * group
-000188c0: 7329 0a20 2020 2020 2020 2023 2028 6261  s).        # (ba
-000188d0: 7463 682c 2069 6e5f 6368 616e 6e65 6c73  tch, in_channels
-000188e0: 2920 2d3e 2028 696e 5f63 6861 6e6e 656c  ) -> (in_channel
-000188f0: 732c 2062 6174 6368 290a 2020 2020 2020  s, batch).      
-00018900: 2020 7420 3d20 636f 6e76 5f74 7261 6e73    t = conv_trans
-00018910: 706f 7365 2874 290a 2020 2020 2020 2020  pose(t).        
-00018920: 2320 5370 6c69 7420 2869 6e5f 6368 616e  # Split (in_chan
-00018930: 6e65 6c73 2c29 202d 3e20 2867 726f 7570  nels,) -> (group
-00018940: 732c 2067 696e 5f63 6861 6e6e 656c 7329  s, gin_channels)
-00018950: 0a20 2020 2020 2020 2074 203d 2074 2e72  .        t = t.r
-00018960: 6573 6861 7065 285b 6772 6f75 7073 2c20  eshape([groups, 
-00018970: 6769 6e5f 6368 616e 6e65 6c73 2c20 6261  gin_channels, ba
-00018980: 7463 685d 202b 2074 5f73 7061 7469 616c  tch] + t_spatial
-00018990: 5f64 696d 7329 0a20 2020 2020 2020 2023  _dims).        #
-000189a0: 2054 7261 6e73 706f 7365 2028 6772 6f75   Transpose (grou
-000189b0: 7073 2c20 6769 6e5f 6368 616e 6e65 6c73  ps, gin_channels
-000189c0: 2c20 6261 7463 6829 202d 3e20 2867 696e  , batch) -> (gin
-000189d0: 5f63 6861 6e6e 656c 732c 2067 726f 7570  _channels, group
-000189e0: 732c 2062 6174 6368 290a 2020 2020 2020  s, batch).      
-000189f0: 2020 7420 3d20 636f 6e76 5f74 7261 6e73    t = conv_trans
-00018a00: 706f 7365 2874 290a 2020 2020 2020 2020  pose(t).        
-00018a10: 2320 466c 6174 7465 6e20 2867 726f 7570  # Flatten (group
-00018a20: 732c 2062 6174 6368 2920 2d3e 2028 6772  s, batch) -> (gr
-00018a30: 6f75 7073 202a 2062 6174 6368 2c29 0a20  oups * batch,). 
-00018a40: 2020 2020 2020 2074 203d 2074 2e72 6573         t = t.res
-00018a50: 6861 7065 285b 6769 6e5f 6368 616e 6e65  hape([gin_channe
-00018a60: 6c73 2c20 6772 6f75 7073 202a 2062 6174  ls, groups * bat
-00018a70: 6368 5d20 2b20 745f 7370 6174 6961 6c5f  ch] + t_spatial_
-00018a80: 6469 6d73 290a 2020 2020 2020 2020 7265  dims).        re
-00018a90: 7475 726e 2074 0a0a 2020 2020 2320 696e  turn t..    # in
-00018aa0: 7075 7420 7769 6c6c 2068 6176 6520 7368  put will have sh
-00018ab0: 6170 6520 2867 696e 5f63 6861 6e6e 656c  ape (gin_channel
-00018ac0: 732c 2067 726f 7570 7320 2a20 6261 7463  s, groups * batc
-00018ad0: 6829 0a20 2020 2069 6e70 7574 203d 2070  h).    input = p
-00018ae0: 6164 5f74 7261 6e73 706f 7365 5f61 6e64  ad_transpose_and
-00018af0: 5f70 7573 685f 6772 6f75 7073 5f69 6e74  _push_groups_int
-00018b00: 6f5f 6261 7463 6865 7328 696e 7075 7429  o_batches(input)
-00018b10: 0a20 2020 2023 2067 7261 6420 7769 6c6c  .    # grad will
-00018b20: 2068 6176 6520 7368 6170 6520 286f 7574   have shape (out
-00018b30: 5f63 6861 6e6e 656c 732c 2062 6174 6368  _channels, batch
-00018b40: 290a 2020 2020 2320 4e6f 7465 2074 6861  ).    # Note tha
-00018b50: 7420 7468 6573 6520 7368 6170 6573 2061  t these shapes a
-00018b60: 7265 2063 6f6d 7061 7469 626c 6520 666f  re compatible fo
-00018b70: 7220 6120 6772 6f75 7020 636f 6e76 6f6c  r a group convol
-00018b80: 7574 696f 6e2e 0a20 2020 2067 7261 6420  ution..    grad 
-00018b90: 3d20 636f 6e76 5f74 7261 6e73 706f 7365  = conv_transpose
-00018ba0: 2867 7261 6429 0a0a 2020 2020 2320 5768  (grad)..    # Wh
-00018bb0: 7920 646f 2077 6520 666c 6970 2073 7472  y do we flip str
-00018bc0: 6964 6520 616e 6420 6469 6c61 7469 6f6e  ide and dilation
-00018bd0: 3f0a 2020 2020 2320 6b65 726e 656c 5b69  ?.    # kernel[i
-00018be0: 5d20 616e 6420 6b65 726e 656c 5b69 202b  ] and kernel[i +
-00018bf0: 2031 5d20 6172 6520 6469 6c61 7469 6f6e   1] are dilation
-00018c00: 2061 7061 7274 2066 726f 6d20 6561 6368   apart from each
-00018c10: 206f 7468 6572 2c0a 2020 2020 2320 736f   other,.    # so
-00018c20: 2064 696c 6174 696f 6e20 6265 636f 6d65   dilation become
-00018c30: 7320 7468 6520 6e65 7720 7374 7269 6465  s the new stride
-00018c40: 2e0a 2020 2020 2320 416c 6c20 7468 6520  ..    # All the 
-00018c50: 656c 656d 656e 7473 2074 6861 7420 6b65  elements that ke
-00018c60: 726e 656c 5b69 5d20 746f 7563 6865 7320  rnel[i] touches 
-00018c70: 6172 6520 7374 7269 6465 2061 7761 7920  are stride away 
-00018c80: 6672 6f6d 2065 6163 6820 6f74 6865 722c  from each other,
-00018c90: 0a20 2020 2023 2068 656e 6365 2073 7472  .    # hence str
-00018ca0: 6964 6520 6265 636f 6d65 7320 7468 6520  ide becomes the 
-00018cb0: 6e65 7720 6469 6c61 7469 6f6e 2e0a 2020  new dilation..  
-00018cc0: 2020 7765 6967 6874 5f67 7261 6420 3d20    weight_grad = 
-00018cd0: 636f 6e76 6f6c 7574 696f 6e28 0a20 2020  convolution(.   
-00018ce0: 2020 2020 2069 6e70 7574 2c0a 2020 2020       input,.    
-00018cf0: 2020 2020 6772 6164 2c0a 2020 2020 2020      grad,.      
-00018d00: 2020 4e6f 6e65 2c0a 2020 2020 2020 2020    None,.        
-00018d10: 6469 6c61 7469 6f6e 2c20 2023 2073 6574  dilation,  # set
-00018d20: 2073 7472 6964 653d 6469 6c61 7469 6f6e   stride=dilation
-00018d30: 0a20 2020 2020 2020 2028 302c 292c 0a20  .        (0,),. 
-00018d40: 2020 2020 2020 2073 7472 6964 652c 2020         stride,  
-00018d50: 2320 7365 7420 6469 6c61 7469 6f6e 3d73  # set dilation=s
-00018d60: 7472 6964 650a 2020 2020 2020 2020 7472  tride.        tr
-00018d70: 616e 7370 6f73 6564 2c0a 2020 2020 2020  ansposed,.      
-00018d80: 2020 6f75 7470 7574 5f70 6164 6469 6e67    output_padding
-00018d90: 2c0a 2020 2020 2020 2020 6772 6f75 7073  ,.        groups
-00018da0: 2c0a 2020 2020 290a 0a20 2020 2023 2054  ,.    )..    # T
-00018db0: 6865 2072 6573 756c 7420 6f66 2074 6865  he result of the
-00018dc0: 2063 6f6e 766f 6c75 7469 6f6e 2068 6173   convolution has
-00018dd0: 2073 6861 7065 2028 6769 6e5f 6368 616e   shape (gin_chan
-00018de0: 6e65 6c73 2c20 6f75 745f 6368 616e 6e65  nels, out_channe
-00018df0: 6c73 292c 0a20 2020 2023 2073 6f20 7472  ls),.    # so tr
-00018e00: 616e 7370 6f73 6974 696f 6e20 6973 2072  ansposition is r
-00018e10: 6571 7569 7265 642e 0a20 2020 2077 6569  equired..    wei
-00018e20: 6768 745f 6772 6164 203d 2063 6f6e 765f  ght_grad = conv_
-00018e30: 7472 616e 7370 6f73 6528 7765 6967 6874  transpose(weight
-00018e40: 5f67 7261 6429 0a20 2020 2023 207d 0a0a  _grad).    # }..
-00018e50: 2020 2020 7265 7475 726e 2028 696e 7075      return (inpu
-00018e60: 745f 6772 6164 2c20 7765 6967 6874 5f67  t_grad, weight_g
-00018e70: 7261 642c 2062 6961 735f 6772 6164 290a  rad, bias_grad).
-00018e80: 0a0a 4072 6567 6973 7465 725f 6175 676d  ..@register_augm
-00018e90: 656e 7465 645f 666f 7277 6172 6428 2274  ented_forward("t
-00018ea0: 6f72 6368 2e6c 6f67 5f73 6f66 746d 6178  orch.log_softmax
-00018eb0: 2229 0a64 6566 206c 6f67 5f73 6f66 746d  ").def log_softm
-00018ec0: 6178 5f61 7567 5f66 7764 2869 6e70 7574  ax_aug_fwd(input
-00018ed0: 3a20 5465 6e73 6f72 5072 6f78 792c 2064  : TensorProxy, d
-00018ee0: 696d 3a20 696e 742c 202a 2c20 6474 7970  im: int, *, dtyp
-00018ef0: 653d 4e6f 6e65 2920 2d3e 2056 4a50 4475  e=None) -> VJPDu
-00018f00: 616c 3a0a 2020 2020 6672 6f6d 2074 6875  al:.    from thu
-00018f10: 6e64 6572 2e74 6f72 6368 2069 6d70 6f72  nder.torch impor
-00018f20: 7420 6c6f 675f 736f 6674 6d61 780a 0a20  t log_softmax.. 
-00018f30: 2020 2070 7269 6d61 6c20 3d20 6c6f 675f     primal = log_
-00018f40: 736f 6674 6d61 7828 696e 7075 742c 2064  softmax(input, d
-00018f50: 696d 3d64 696d 2c20 6474 7970 653d 6474  im=dim, dtype=dt
-00018f60: 7970 6529 0a20 2020 2072 6573 6964 7561  ype).    residua
-00018f70: 6c73 203d 2028 7072 696d 616c 2c20 6469  ls = (primal, di
-00018f80: 6d2c 2069 6e70 7574 2e64 7479 7065 290a  m, input.dtype).
-00018f90: 2020 2020 7265 7475 726e 2056 4a50 4475      return VJPDu
-00018fa0: 616c 2870 7269 6d61 6c2c 2072 6573 6964  al(primal, resid
-00018fb0: 7561 6c73 290a 0a0a 4072 6567 6973 7465  uals)...@registe
-00018fc0: 725f 6261 636b 7761 7264 2822 746f 7263  r_backward("torc
-00018fd0: 682e 6c6f 675f 736f 6674 6d61 7822 290a  h.log_softmax").
-00018fe0: 6465 6620 6c6f 675f 736f 6674 6d61 785f  def log_softmax_
-00018ff0: 6261 636b 7761 7264 2870 7269 6d61 6c2c  backward(primal,
-00019000: 2064 696d 2c20 6474 7970 652c 2067 293a   dim, dtype, g):
-00019010: 0a20 2020 2066 726f 6d20 7468 756e 6465  .    from thunde
-00019020: 722e 746f 7263 6820 696d 706f 7274 206c  r.torch import l
-00019030: 6f67 5f73 6f66 746d 6178 5f62 6163 6b77  og_softmax_backw
-00019040: 6172 640a 0a20 2020 2072 6574 7572 6e20  ard..    return 
-00019050: 6c6f 675f 736f 6674 6d61 785f 6261 636b  log_softmax_back
-00019060: 7761 7264 2867 2c20 7072 696d 616c 2c20  ward(g, primal, 
-00019070: 6469 6d2c 2064 7479 7065 290a 0a0a 4072  dim, dtype)...@r
-00019080: 6567 6973 7465 725f 6175 676d 656e 7465  egister_augmente
-00019090: 645f 666f 7277 6172 6428 2274 6f72 6368  d_forward("torch
-000190a0: 2e6e 6e2e 6675 6e63 7469 6f6e 616c 2e6e  .nn.functional.n
-000190b0: 6c6c 5f6c 6f73 7322 290a 6465 6620 6e6c  ll_loss").def nl
-000190c0: 6c5f 6c6f 7373 5f61 7567 5f66 7764 280a  l_loss_aug_fwd(.
-000190d0: 2020 2020 696e 7075 743a 2050 726f 7879      input: Proxy
-000190e0: 2c0a 2020 2020 7461 7267 6574 3a20 5072  ,.    target: Pr
-000190f0: 6f78 792c 0a20 2020 2077 6569 6768 743a  oxy,.    weight:
-00019100: 204e 6f6e 6520 7c20 5072 6f78 792c 0a20   None | Proxy,. 
-00019110: 2020 2069 676e 6f72 655f 696e 6465 783a     ignore_index:
-00019120: 2069 6e74 2c0a 2020 2020 7265 6475 6374   int,.    reduct
-00019130: 696f 6e3a 2073 7472 2c0a 2920 2d3e 2056  ion: str,.) -> V
-00019140: 4a50 4475 616c 3a0a 2020 2020 6672 6f6d  JPDual:.    from
-00019150: 2074 6875 6e64 6572 2e74 6f72 6368 2069   thunder.torch i
-00019160: 6d70 6f72 7420 5f6e 6c6c 5f6c 6f73 735f  mport _nll_loss_
-00019170: 6865 6c70 6572 0a0a 2020 2020 7072 696d  helper..    prim
-00019180: 616c 2c20 746f 7461 6c5f 7765 6967 6874  al, total_weight
-00019190: 203d 205f 6e6c 6c5f 6c6f 7373 5f68 656c   = _nll_loss_hel
-000191a0: 7065 7228 0a20 2020 2020 2020 2069 6e70  per(.        inp
-000191b0: 7574 2c0a 2020 2020 2020 2020 7461 7267  ut,.        targ
-000191c0: 6574 2c0a 2020 2020 2020 2020 7765 6967  et,.        weig
-000191d0: 6874 2c0a 2020 2020 2020 2020 6967 6e6f  ht,.        igno
-000191e0: 7265 5f69 6e64 6578 2c0a 2020 2020 2020  re_index,.      
-000191f0: 2020 7265 6475 6374 696f 6e2c 0a20 2020    reduction,.   
-00019200: 2029 0a20 2020 2072 6573 6964 7561 6c73   ).    residuals
-00019210: 203d 2028 696e 7075 742c 2074 6172 6765   = (input, targe
-00019220: 742c 2077 6569 6768 742c 2072 6564 7563  t, weight, reduc
-00019230: 7469 6f6e 2c20 6967 6e6f 7265 5f69 6e64  tion, ignore_ind
-00019240: 6578 2c20 746f 7461 6c5f 7765 6967 6874  ex, total_weight
-00019250: 290a 2020 2020 7265 7475 726e 2056 4a50  ).    return VJP
-00019260: 4475 616c 2870 7269 6d61 6c2c 2072 6573  Dual(primal, res
-00019270: 6964 7561 6c73 290a 0a0a 4072 6567 6973  iduals)...@regis
-00019280: 7465 725f 6261 636b 7761 7264 2822 746f  ter_backward("to
-00019290: 7263 682e 6e6e 2e66 756e 6374 696f 6e61  rch.nn.functiona
-000192a0: 6c2e 6e6c 6c5f 6c6f 7373 2229 0a64 6566  l.nll_loss").def
-000192b0: 206e 6c6c 5f6c 6f73 735f 6261 636b 7761   nll_loss_backwa
-000192c0: 7264 2869 6e70 7574 2c20 7461 7267 6574  rd(input, target
-000192d0: 2c20 7765 6967 6874 2c20 7265 6475 6374  , weight, reduct
-000192e0: 696f 6e2c 2069 676e 6f72 655f 696e 6465  ion, ignore_inde
-000192f0: 782c 2074 6f74 616c 5f77 6569 6768 742c  x, total_weight,
-00019300: 2067 293a 0a20 2020 2066 726f 6d20 7468   g):.    from th
-00019310: 756e 6465 722e 746f 7263 6820 696d 706f  under.torch impo
-00019320: 7274 206e 6c6c 5f6c 6f73 735f 6261 636b  rt nll_loss_back
-00019330: 7761 7264 0a0a 2020 2020 6769 6e70 7574  ward..    ginput
-00019340: 203d 206e 6c6c 5f6c 6f73 735f 6261 636b   = nll_loss_back
-00019350: 7761 7264 2867 2c20 696e 7075 742c 2074  ward(g, input, t
-00019360: 6172 6765 742c 2077 6569 6768 742c 2072  arget, weight, r
-00019370: 6564 7563 7469 6f6e 2c20 6967 6e6f 7265  eduction, ignore
-00019380: 5f69 6e64 6578 2c20 746f 7461 6c5f 7765  _index, total_we
-00019390: 6967 6874 290a 2020 2020 7265 7475 726e  ight).    return
-000193a0: 2067 696e 7075 742c 202a 2828 4e6f 6e65   ginput, *((None
-000193b0: 2c29 202a 2034 290a 0a0a 4072 6567 6973  ,) * 4)...@regis
-000193c0: 7465 725f 6175 676d 656e 7465 645f 666f  ter_augmented_fo
-000193d0: 7277 6172 6428 2274 6f72 6368 2e73 706c  rward("torch.spl
-000193e0: 6974 2229 0a64 6566 2073 706c 6974 5f61  it").def split_a
-000193f0: 7567 5f66 7764 2861 3a20 5465 6e73 6f72  ug_fwd(a: Tensor
-00019400: 5072 6f78 792c 2073 706c 6974 5f73 697a  Proxy, split_siz
-00019410: 655f 6f72 5f73 6563 7469 6f6e 733a 2069  e_or_sections: i
-00019420: 6e74 207c 2053 6571 7565 6e63 655b 696e  nt | Sequence[in
-00019430: 745d 2c20 6469 6d3a 2069 6e74 203d 2030  t], dim: int = 0
-00019440: 2920 2d3e 2056 4a50 4475 616c 3a0a 2020  ) -> VJPDual:.  
-00019450: 2020 6672 6f6d 2074 6875 6e64 6572 2e74    from thunder.t
-00019460: 6f72 6368 2069 6d70 6f72 7420 7370 6c69  orch import spli
-00019470: 740a 0a20 2020 2070 7269 6d61 6c20 3d20  t..    primal = 
-00019480: 7370 6c69 7428 612c 2073 706c 6974 5f73  split(a, split_s
-00019490: 697a 655f 6f72 5f73 6563 7469 6f6e 732c  ize_or_sections,
-000194a0: 2064 696d 290a 2020 2020 7265 7369 6475   dim).    residu
-000194b0: 616c 7320 3d20 2864 696d 2c29 0a20 2020  als = (dim,).   
-000194c0: 2072 6574 7572 6e20 564a 5044 7561 6c28   return VJPDual(
-000194d0: 7072 696d 616c 2c20 7265 7369 6475 616c  primal, residual
-000194e0: 7329 0a0a 0a40 7265 6769 7374 6572 5f62  s)...@register_b
-000194f0: 6163 6b77 6172 6428 2274 6f72 6368 2e73  ackward("torch.s
-00019500: 706c 6974 2229 0a64 6566 2073 706c 6974  plit").def split
-00019510: 5f62 6163 6b77 6172 6428 6469 6d2c 202a  _backward(dim, *
-00019520: 6772 6164 7329 3a0a 2020 2020 6672 6f6d  grads):.    from
-00019530: 2074 6875 6e64 6572 2e74 6f72 6368 2069   thunder.torch i
-00019540: 6d70 6f72 7420 6361 740a 0a20 2020 2072  mport cat..    r
-00019550: 6574 7572 6e20 6361 7428 6772 6164 732c  eturn cat(grads,
-00019560: 2064 696d 290a 0a0a 4072 6567 6973 7465   dim)...@registe
-00019570: 725f 6175 676d 656e 7465 645f 666f 7277  r_augmented_forw
-00019580: 6172 6428 2274 6f72 6368 2e6e 6e2e 6675  ard("torch.nn.fu
-00019590: 6e63 7469 6f6e 616c 2e65 6d62 6564 6469  nctional.embeddi
-000195a0: 6e67 2229 0a64 6566 2065 6d62 6564 6469  ng").def embeddi
-000195b0: 6e67 5f61 7567 5f66 7764 280a 2020 2020  ng_aug_fwd(.    
-000195c0: 613a 2050 726f 7879 2c0a 2020 2020 7765  a: Proxy,.    we
-000195d0: 6967 6874 3a20 5072 6f78 792c 0a20 2020  ight: Proxy,.   
-000195e0: 2070 6164 6469 6e67 5f69 6478 3a20 696e   padding_idx: in
-000195f0: 7420 7c20 4e6f 6e65 2c0a 2020 2020 6d61  t | None,.    ma
-00019600: 785f 6e6f 726d 3a20 666c 6f61 7420 7c20  x_norm: float | 
-00019610: 4e6f 6e65 2c0a 2020 2020 6e6f 726d 5f74  None,.    norm_t
-00019620: 7970 653a 2066 6c6f 6174 2c0a 2020 2020  ype: float,.    
-00019630: 7363 616c 655f 6772 6164 5f62 795f 6672  scale_grad_by_fr
-00019640: 6571 3a20 626f 6f6c 2c0a 2020 2020 7370  eq: bool,.    sp
-00019650: 6172 7365 3a20 626f 6f6c 2c0a 2920 2d3e  arse: bool,.) ->
-00019660: 2056 4a50 4475 616c 3a0a 2020 2020 6672   VJPDual:.    fr
-00019670: 6f6d 2074 6875 6e64 6572 2e74 6f72 6368  om thunder.torch
-00019680: 2069 6d70 6f72 7420 656d 6265 6464 696e   import embeddin
-00019690: 670a 0a20 2020 2070 7269 6d61 6c20 3d20  g..    primal = 
-000196a0: 656d 6265 6464 696e 6728 0a20 2020 2020  embedding(.     
-000196b0: 2020 2061 2c0a 2020 2020 2020 2020 7765     a,.        we
-000196c0: 6967 6874 2c0a 2020 2020 2020 2020 7061  ight,.        pa
-000196d0: 6464 696e 675f 6964 783d 7061 6464 696e  dding_idx=paddin
-000196e0: 675f 6964 782c 0a20 2020 2020 2020 206d  g_idx,.        m
-000196f0: 6178 5f6e 6f72 6d3d 6d61 785f 6e6f 726d  ax_norm=max_norm
-00019700: 2c0a 2020 2020 2020 2020 6e6f 726d 5f74  ,.        norm_t
-00019710: 7970 653d 6e6f 726d 5f74 7970 652c 0a20  ype=norm_type,. 
-00019720: 2020 2020 2020 2073 6361 6c65 5f67 7261         scale_gra
-00019730: 645f 6279 5f66 7265 713d 7363 616c 655f  d_by_freq=scale_
-00019740: 6772 6164 5f62 795f 6672 6571 2c0a 2020  grad_by_freq,.  
-00019750: 2020 2020 2020 7370 6172 7365 3d73 7061        sparse=spa
-00019760: 7273 652c 0a20 2020 2029 0a20 2020 2072  rse,.    ).    r
-00019770: 6573 6964 7561 6c73 203d 2028 612c 2077  esiduals = (a, w
-00019780: 6569 6768 742e 7368 6170 655b 305d 2c20  eight.shape[0], 
-00019790: 7061 6464 696e 675f 6964 782c 2073 6361  padding_idx, sca
-000197a0: 6c65 5f67 7261 645f 6279 5f66 7265 712c  le_grad_by_freq,
-000197b0: 2073 7061 7273 6529 0a20 2020 2072 6574   sparse).    ret
-000197c0: 7572 6e20 564a 5044 7561 6c28 7072 696d  urn VJPDual(prim
-000197d0: 616c 2c20 7265 7369 6475 616c 7329 0a0a  al, residuals)..
-000197e0: 0a40 7265 6769 7374 6572 5f62 6163 6b77  .@register_backw
-000197f0: 6172 6428 2274 6f72 6368 2e6e 6e2e 6675  ard("torch.nn.fu
-00019800: 6e63 7469 6f6e 616c 2e65 6d62 6564 6469  nctional.embeddi
-00019810: 6e67 2229 0a64 6566 2065 6d62 6564 6469  ng").def embeddi
-00019820: 6e67 5f62 6163 6b77 6172 6428 612c 206e  ng_backward(a, n
-00019830: 756d 5f77 6569 6768 7473 2c20 7061 6464  um_weights, padd
-00019840: 696e 675f 6964 782c 2073 6361 6c65 5f67  ing_idx, scale_g
-00019850: 7261 645f 6279 5f66 7265 712c 2073 7061  rad_by_freq, spa
-00019860: 7273 652c 2067 293a 0a20 2020 2066 726f  rse, g):.    fro
-00019870: 6d20 7468 756e 6465 722e 746f 7263 6820  m thunder.torch 
-00019880: 696d 706f 7274 2065 6d62 6564 6469 6e67  import embedding
-00019890: 5f62 6163 6b77 6172 640a 0a20 2020 2070  _backward..    p
-000198a0: 6164 6469 6e67 5f69 6478 203d 202d 3120  adding_idx = -1 
-000198b0: 6966 2070 6164 6469 6e67 5f69 6478 2069  if padding_idx i
-000198c0: 7320 4e6f 6e65 2065 6c73 6520 7061 6464  s None else padd
-000198d0: 696e 675f 6964 780a 2020 2020 6777 6569  ing_idx.    gwei
-000198e0: 6768 7420 3d20 656d 6265 6464 696e 675f  ght = embedding_
-000198f0: 6261 636b 7761 7264 2867 2c20 612c 206e  backward(g, a, n
-00019900: 756d 5f77 6569 6768 7473 2c20 7061 6464  um_weights, padd
-00019910: 696e 675f 6964 782c 2073 6361 6c65 5f67  ing_idx, scale_g
-00019920: 7261 645f 6279 5f66 7265 712c 2073 7061  rad_by_freq, spa
-00019930: 7273 6529 0a20 2020 2072 6574 7572 6e20  rse).    return 
-00019940: 6777 6569 6768 740a 0a0a 4072 6567 6973  gweight...@regis
-00019950: 7465 725f 6175 676d 656e 7465 645f 666f  ter_augmented_fo
-00019960: 7277 6172 6428 2274 6f72 6368 2e63 756d  rward("torch.cum
-00019970: 7375 6d22 290a 6465 6620 6375 6d73 756d  sum").def cumsum
-00019980: 5f61 7567 5f66 7764 2861 3a20 5072 6f78  _aug_fwd(a: Prox
-00019990: 792c 2064 696d 3a20 696e 742c 202a 2c20  y, dim: int, *, 
-000199a0: 6474 7970 653a 204e 6f6e 6520 7c20 6474  dtype: None | dt
-000199b0: 7970 6573 2e64 7479 7065 203d 204e 6f6e  ypes.dtype = Non
-000199c0: 6529 202d 3e20 564a 5044 7561 6c3a 0a20  e) -> VJPDual:. 
-000199d0: 2020 2066 726f 6d20 7468 756e 6465 722e     from thunder.
-000199e0: 746f 7263 6820 696d 706f 7274 2063 756d  torch import cum
-000199f0: 7375 6d0a 0a20 2020 2070 7269 6d61 6c20  sum..    primal 
-00019a00: 3d20 6375 6d73 756d 2861 2c20 6469 6d2c  = cumsum(a, dim,
-00019a10: 2064 7479 7065 3d64 7479 7065 290a 2020   dtype=dtype).  
-00019a20: 2020 7265 7369 6475 616c 7320 3d20 280a    residuals = (.
-00019a30: 2020 2020 2020 2020 612e 6474 7970 652c          a.dtype,
-00019a40: 0a20 2020 2020 2020 2064 696d 2c0a 2020  .        dim,.  
-00019a50: 2020 290a 2020 2020 7265 7475 726e 2056    ).    return V
-00019a60: 4a50 4475 616c 2870 7269 6d61 6c2c 2072  JPDual(primal, r
-00019a70: 6573 6964 7561 6c73 290a 0a0a 4072 6567  esiduals)...@reg
-00019a80: 6973 7465 725f 6261 636b 7761 7264 2822  ister_backward("
-00019a90: 746f 7263 682e 6375 6d73 756d 2229 0a64  torch.cumsum").d
-00019aa0: 6566 2063 756d 7375 6d5f 6261 636b 7761  ef cumsum_backwa
-00019ab0: 7264 2861 5f64 7479 7065 2c20 6469 6d2c  rd(a_dtype, dim,
-00019ac0: 2067 293a 0a20 2020 2067 203d 2067 2e74   g):.    g = g.t
-00019ad0: 6f28 615f 6474 7970 6529 0a20 2020 2069  o(a_dtype).    i
-00019ae0: 6620 672e 6e75 6d65 6c28 2920 3c3d 2031  f g.numel() <= 1
-00019af0: 206f 7220 672e 7368 6170 655b 6469 6d5d   or g.shape[dim]
-00019b00: 203d 3d20 313a 0a20 2020 2020 2020 2072   == 1:.        r
-00019b10: 6574 7572 6e20 670a 2020 2020 7265 7475  eturn g.    retu
-00019b20: 726e 2067 2e66 6c69 7028 6469 6d29 2e63  rn g.flip(dim).c
-00019b30: 756d 7375 6d28 6469 6d29 2e66 6c69 7028  umsum(dim).flip(
-00019b40: 6469 6d29 0a0a 0a40 7265 6769 7374 6572  dim)...@register
-00019b50: 5f61 7567 6d65 6e74 6564 5f66 6f72 7761  _augmented_forwa
-00019b60: 7264 2822 746f 7263 682e 736f 6674 6d61  rd("torch.softma
-00019b70: 7822 290a 6465 6620 736f 6674 6d61 785f  x").def softmax_
-00019b80: 6175 675f 6677 6428 613a 2050 726f 7879  aug_fwd(a: Proxy
-00019b90: 2c20 6469 6d3a 2069 6e74 2c20 6474 7970  , dim: int, dtyp
-00019ba0: 653a 2064 7479 7065 732e 6474 7970 6520  e: dtypes.dtype 
-00019bb0: 7c20 4e6f 6e65 203d 204e 6f6e 6529 202d  | None = None) -
-00019bc0: 3e20 564a 5044 7561 6c3a 0a20 2020 2066  > VJPDual:.    f
-00019bd0: 726f 6d20 7468 756e 6465 722e 746f 7263  rom thunder.torc
-00019be0: 6820 696d 706f 7274 2073 6f66 746d 6178  h import softmax
-00019bf0: 0a0a 2020 2020 7072 696d 616c 203d 2073  ..    primal = s
-00019c00: 6f66 746d 6178 2861 2c20 6469 6d2c 2064  oftmax(a, dim, d
-00019c10: 7479 7065 3d64 7479 7065 290a 2020 2020  type=dtype).    
-00019c20: 7265 7369 6475 616c 7320 3d20 2870 7269  residuals = (pri
-00019c30: 6d61 6c2c 2064 696d 290a 2020 2020 7265  mal, dim).    re
-00019c40: 7475 726e 2056 4a50 4475 616c 2870 7269  turn VJPDual(pri
-00019c50: 6d61 6c2c 2072 6573 6964 7561 6c73 290a  mal, residuals).
-00019c60: 0a0a 4072 6567 6973 7465 725f 6261 636b  ..@register_back
-00019c70: 7761 7264 2822 746f 7263 682e 736f 6674  ward("torch.soft
-00019c80: 6d61 7822 290a 6465 6620 736f 6674 6d61  max").def softma
-00019c90: 785f 6261 636b 7761 7264 2870 7269 6d61  x_backward(prima
-00019ca0: 6c2c 2064 696d 2c20 6729 3a0a 2020 2020  l, dim, g):.    
-00019cb0: 7265 7475 726e 2070 7269 6d61 6c20 2a20  return primal * 
-00019cc0: 2867 202d 2028 7072 696d 616c 202a 2067  (g - (primal * g
-00019cd0: 292e 7375 6d28 6469 6d2c 206b 6565 7064  ).sum(dim, keepd
-00019ce0: 696d 3d54 7275 6529 290a 0a0a 6465 6620  im=True))...def 
-00019cf0: 6974 6572 5f62 6f75 6e64 5f73 796d 626f  iter_bound_symbo
-00019d00: 6c73 2862 6f75 6e64 5f73 796d 626f 6c73  ls(bound_symbols
-00019d10: 293a 0a20 2020 2022 2222 4974 6572 6174  ):.    """Iterat
-00019d20: 6520 6f76 6572 2062 6f75 6e64 2073 796d  e over bound sym
-00019d30: 626f 6c73 2c20 736b 6970 7069 6e67 2073  bols, skipping s
-00019d40: 796d 626f 6c73 2074 6861 7420 6172 6520  ymbols that are 
-00019d50: 6e6f 7420 7375 7070 6f72 7465 6420 6279  not supported by
-00019d60: 0a20 2020 2074 6865 2074 7261 6e73 666f  .    the transfo
-00019d70: 726d 7320 696e 6672 6173 7472 7563 7475  rms infrastructu
-00019d80: 7265 2e0a 0a20 2020 2041 7267 733a 0a20  re...    Args:. 
-00019d90: 2020 2020 2020 2062 6f75 6e64 5f73 796d         bound_sym
-00019da0: 626f 6c73 2028 4c69 7374 5b42 6f75 6e64  bols (List[Bound
-00019db0: 5379 6d62 6f6c 5d29 3a20 4c69 7374 206f  Symbol]): List o
-00019dc0: 6620 626f 756e 6420 7379 6d62 6f6c 730a  f bound symbols.
-00019dd0: 0a20 2020 2059 6965 6c64 733a 0a20 2020  .    Yields:.   
-00019de0: 2020 2020 2042 6f75 6e64 5379 6d62 6f6c       BoundSymbol
-00019df0: 3a20 426f 756e 6420 7379 6d62 6f6c 7320  : Bound symbols 
-00019e00: 7468 6174 2061 7265 2073 7570 706f 7274  that are support
-00019e10: 6564 2062 7920 7468 6520 7472 616e 7366  ed by the transf
-00019e20: 6f72 6d73 0a20 2020 2020 2020 2069 6e66  orms.        inf
-00019e30: 7261 7374 7275 6374 7572 650a 2020 2020  rastructure.    
-00019e40: 2222 220a 2020 2020 666f 7220 7379 6d62  """.    for symb
-00019e50: 6f6c 2069 6e20 626f 756e 645f 7379 6d62  ol in bound_symb
-00019e60: 6f6c 733a 0a20 2020 2020 2020 2069 6620  ols:.        if 
-00019e70: 7379 6d62 6f6c 2e73 796d 2e69 6420 696e  symbol.sym.id in
-00019e80: 2074 7261 6e73 666f 726d 5f73 6b69 705f   transform_skip_
-00019e90: 6c69 7374 3a0a 2020 2020 2020 2020 2020  list:.          
-00019ea0: 2020 636f 6e74 696e 7565 0a20 2020 2020    continue.     
-00019eb0: 2020 2065 6c69 6620 7379 6d62 6f6c 2e6f     elif symbol.o
-00019ec0: 7574 7075 7420 6973 204e 6f6e 653a 0a20  utput is None:. 
-00019ed0: 2020 2020 2020 2020 2020 2063 6f6e 7469             conti
-00019ee0: 6e75 650a 2020 2020 2020 2020 656c 7365  nue.        else
-00019ef0: 3a0a 2020 2020 2020 2020 2020 2020 7969  :.            yi
-00019f00: 656c 6420 7379 6d62 6f6c 0a0a 0a64 6566  eld symbol...def
-00019f10: 2064 6563 6f6e 7374 7275 6374 5f66 6f72   deconstruct_for
-00019f20: 7761 7264 5f65 6e76 5f66 6f72 5f62 6163  ward_env_for_bac
-00019f30: 6b77 6172 6428 7472 6163 652c 2065 6e76  kward(trace, env
-00019f40: 293a 0a20 2020 2023 204e 6f74 6520 5b53  ):.    # Note [S
-00019f50: 6176 696e 6720 7468 6520 666f 7277 6172  aving the forwar
-00019f60: 6420 656e 7669 726f 6e6d 656e 7420 696e  d environment in
-00019f70: 2074 6865 2062 6163 6b77 6172 6420 7275   the backward ru
-00019f80: 6c65 5d0a 2020 2020 2320 5765 2063 616e  le].    # We can
-00019f90: 6e6f 7420 7361 7665 2074 6865 2074 7261  not save the tra
-00019fa0: 6365 206f 626a 6563 7420 696e 2074 6865  ce object in the
-00019fb0: 2072 6573 6964 7561 6c73 2062 6563 6175   residuals becau
-00019fc0: 7365 2065 7865 6375 746f 7273 206d 6179  se executors may
-00019fd0: 206e 6f74 0a20 2020 2023 2062 6520 6162   not.    # be ab
-00019fe0: 6c65 2074 6f20 7265 7475 726e 2069 7420  le to return it 
-00019ff0: 666f 7220 7468 6520 7370 6c69 7474 6564  for the splitted
-0001a000: 2066 6f72 7761 7264 2f62 6163 6b77 6172   forward/backwar
-0001a010: 6420 7061 7373 6573 2e20 496e 7374 6561  d passes. Instea
-0001a020: 642c 2077 650a 2020 2020 2320 7361 7665  d, we.    # save
-0001a030: 2061 7267 7320 616e 6420 6b77 6172 6773   args and kwargs
-0001a040: 206f 6620 7468 6520 6f72 6967 696e 616c   of the original
-0001a050: 2066 756e 6374 696f 6e20 6361 6c6c 2061   function call a
-0001a060: 6e64 2072 6563 6f6e 7374 7275 6374 2074  nd reconstruct t
-0001a070: 6865 0a20 2020 2023 2074 7261 6365 206f  he.    # trace o
-0001a080: 626a 6563 7420 616e 6420 6974 7320 656e  bject and its en
-0001a090: 7669 726f 6e6d 656e 7420 6469 6374 2069  vironment dict i
-0001a0a0: 6e20 7468 6520 6261 636b 7761 7264 2072  n the backward r
-0001a0b0: 756c 652e 2048 6572 6520 7765 2072 656c  ule. Here we rel
-0001a0c0: 790a 2020 2020 2320 6f6e 2074 6865 2066  y.    # on the f
-0001a0d0: 6163 7420 7468 6174 2074 6865 206f 7264  act that the ord
-0001a0e0: 6572 206f 6620 7468 6520 7379 6d62 6f6c  er of the symbol
-0001a0f0: 7320 696e 2074 6865 2074 7261 6365 2069  s in the trace i
-0001a100: 7320 6465 7465 726d 696e 6973 7469 630a  s deterministic.
-0001a110: 2020 2020 2320 616e 6420 616c 7761 7973      # and always
-0001a120: 2074 6865 2073 616d 6520 666f 7220 7468   the same for th
-0001a130: 6520 7361 6d65 2066 756e 6374 696f 6e20  e same function 
-0001a140: 6361 6c6c 2061 6e64 2074 6865 2073 616d  call and the sam
-0001a150: 6520 7365 7420 6f66 0a20 2020 2023 2061  e set of.    # a
-0001a160: 7267 756d 656e 7473 2e20 5365 6520 7465  rguments. See te
-0001a170: 7374 5f67 7261 642e 7079 3a74 6573 745f  st_grad.py:test_
-0001a180: 746f 7263 685f 6175 746f 6772 6164 5f66  torch_autograd_f
-0001a190: 756e 6374 696f 6e20 666f 7220 616e 2065  unction for an e
-0001a1a0: 7861 6d70 6c65 0a20 2020 2023 2077 6865  xample.    # whe
-0001a1b0: 7265 2074 6869 7320 6973 2074 6573 7465  re this is teste
-0001a1c0: 642e 0a20 2020 2062 6f75 6e64 5f73 796d  d..    bound_sym
-0001a1d0: 626f 6c73 203d 2069 7465 725f 626f 756e  bols = iter_boun
-0001a1e0: 645f 7379 6d62 6f6c 7328 7472 6163 652e  d_symbols(trace.
-0001a1f0: 626f 756e 645f 7379 6d62 6f6c 7329 0a20  bound_symbols). 
-0001a200: 2020 2073 6176 6564 5f66 6f72 5f62 6163     saved_for_bac
-0001a210: 6b77 6172 6420 3d20 7475 706c 6528 656e  kward = tuple(en
-0001a220: 765b 7365 7175 656e 6369 6679 2873 796d  v[sequencify(sym
-0001a230: 626f 6c2e 6f75 7470 7574 295b 305d 2e6e  bol.output)[0].n
-0001a240: 616d 655d 2e72 6573 6964 7561 6c73 2066  ame].residuals f
-0001a250: 6f72 2073 796d 626f 6c20 696e 2062 6f75  or symbol in bou
-0001a260: 6e64 5f73 796d 626f 6c73 290a 2020 2020  nd_symbols).    
-0001a270: 7265 7475 726e 2073 6176 6564 5f66 6f72  return saved_for
-0001a280: 5f62 6163 6b77 6172 640a 0a0a 6465 6620  _backward...def 
-0001a290: 7265 636f 6e73 7472 7563 745f 666f 7277  reconstruct_forw
-0001a2a0: 6172 645f 656e 765f 666f 725f 6261 636b  ard_env_for_back
-0001a2b0: 7761 7264 2874 7261 6365 2c20 7361 7665  ward(trace, save
-0001a2c0: 645f 666f 725f 6261 636b 7761 7264 293a  d_for_backward):
-0001a2d0: 0a20 2020 2062 6f75 6e64 5f73 796d 626f  .    bound_symbo
-0001a2e0: 6c73 203d 2069 7465 725f 626f 756e 645f  ls = iter_bound_
-0001a2f0: 7379 6d62 6f6c 7328 7472 6163 652e 626f  symbols(trace.bo
-0001a300: 756e 645f 7379 6d62 6f6c 7329 0a0a 2020  und_symbols)..  
-0001a310: 2020 7265 636f 6e73 7472 7563 7465 645f    reconstructed_
-0001a320: 656e 7620 3d20 7b7d 0a0a 2020 2020 666f  env = {}..    fo
-0001a330: 7220 6964 782c 2073 796d 2069 6e20 656e  r idx, sym in en
-0001a340: 756d 6572 6174 6528 626f 756e 645f 7379  umerate(bound_sy
-0001a350: 6d62 6f6c 7329 3a0a 2020 2020 2020 2020  mbols):.        
-0001a360: 6b20 3d20 7365 7175 656e 6369 6679 2873  k = sequencify(s
-0001a370: 796d 2e6f 7574 7075 7429 5b30 5d2e 6e61  ym.output)[0].na
-0001a380: 6d65 0a20 2020 2020 2020 2076 203d 2056  me.        v = V
-0001a390: 4a50 4475 616c 284e 6f6e 652c 2073 6176  JPDual(None, sav
-0001a3a0: 6564 5f66 6f72 5f62 6163 6b77 6172 645b  ed_for_backward[
-0001a3b0: 6964 785d 290a 2020 2020 2020 2020 7265  idx]).        re
-0001a3c0: 636f 6e73 7472 7563 7465 645f 656e 765b  constructed_env[
-0001a3d0: 6b5d 203d 2076 0a0a 2020 2020 7265 7475  k] = v..    retu
-0001a3e0: 726e 2072 6563 6f6e 7374 7275 6374 6564  rn reconstructed
-0001a3f0: 5f65 6e76 0a0a 0a64 6566 2064 6563 6f6d  _env...def decom
-0001a400: 706f 7365 645f 666e 5f61 7567 5f66 7764  posed_fn_aug_fwd
-0001a410: 5f72 756c 6528 2a61 7267 732c 2064 6563  _rule(*args, dec
-0001a420: 6f6d 706f 7365 645f 666e 2c20 2a2a 6b77  omposed_fn, **kw
-0001a430: 6172 6773 293a 0a20 2020 2022 2222 4175  args):.    """Au
-0001a440: 676d 656e 7465 6420 666f 7277 6172 6420  gmented forward 
-0001a450: 7275 6c65 2066 6f72 2063 6f6d 706f 7369  rule for composi
-0001a460: 7465 2066 756e 6374 696f 6e73 2069 6d70  te functions imp
-0001a470: 6c65 6d65 6e74 6564 2069 6e20 7465 726d  lemented in term
-0001a480: 7320 6f66 206f 7468 6572 2066 756e 6374  s of other funct
-0001a490: 696f 6e73 2074 6861 7420 6172 650a 2020  ions that are.  
-0001a4a0: 2020 7375 7070 6f73 6564 2074 6f20 6265    supposed to be
-0001a4b0: 2073 7570 706f 7274 6564 2062 7920 7468   supported by th
-0001a4c0: 6520 564a 5020 696e 6672 6173 7472 7563  e VJP infrastruc
-0001a4d0: 7475 7265 2e0a 0a20 2020 2041 7267 733a  ture...    Args:
-0001a4e0: 0a20 2020 2020 2020 2064 6563 6f6d 706f  .        decompo
-0001a4f0: 7365 645f 666e 2028 4361 6c6c 6162 6c65  sed_fn (Callable
-0001a500: 293a 2064 6563 6f6d 706f 7365 6420 7665  ): decomposed ve
-0001a510: 7273 696f 6e20 6f66 2074 6865 2066 756e  rsion of the fun
-0001a520: 6374 696f 6e0a 0a20 2020 2052 6574 7572  ction..    Retur
-0001a530: 6e73 3a0a 2020 2020 2020 2020 4361 6c6c  ns:.        Call
-0001a540: 6162 6c65 3a20 4175 676d 656e 7465 6420  able: Augmented 
-0001a550: 666f 7277 6172 6420 7275 6c65 2066 6f72  forward rule for
-0001a560: 2074 6865 2063 6f6d 706f 7369 7465 2066   the composite f
-0001a570: 756e 6374 696f 6e0a 2020 2020 2222 220a  unction.    """.
-0001a580: 2020 2020 7472 6163 6520 3d20 636f 6e73      trace = cons
-0001a590: 7472 7563 745f 7472 6163 6528 2928 6465  truct_trace()(de
-0001a5a0: 636f 6d70 6f73 6564 5f66 6e2c 202a 6172  composed_fn, *ar
-0001a5b0: 6773 2c20 2a2a 6b77 6172 6773 290a 2020  gs, **kwargs).  
-0001a5c0: 2020 7472 6163 6520 3d20 756e 7772 6170    trace = unwrap
-0001a5d0: 5f6f 6e65 5f6c 6576 656c 5f6f 665f 7375  _one_level_of_su
-0001a5e0: 6273 796d 626f 6c73 2874 7261 6365 290a  bsymbols(trace).
-0001a5f0: 2020 2020 2320 5468 6572 6520 6d61 7920      # There may 
-0001a600: 6265 2061 2064 6561 6420 6e6f 6465 206c  be a dead node l
-0001a610: 696b 6520 225f 203d 2070 7269 6d73 2e63  ike "_ = prims.c
-0001a620: 6f6e 7665 7274 5f65 6c65 6d65 6e74 5f74  onvert_element_t
-0001a630: 7970 6528 302c 2066 6c6f 6174 2922 0a20  ype(0, float)". 
-0001a640: 2020 2023 2069 6e20 7468 6520 7472 6163     # in the trac
-0001a650: 652e 2057 6520 6e65 6564 2074 6f20 7265  e. We need to re
-0001a660: 6d6f 7665 2069 7420 6265 666f 7265 2077  move it before w
-0001a670: 6520 6361 6e20 7573 6520 7468 6520 7472  e can use the tr
-0001a680: 6163 6520 666f 720a 2020 2020 2320 6175  ace for.    # au
-0001a690: 676d 656e 7465 645f 666f 7277 6172 645f  gmented_forward_
-0001a6a0: 7061 7373 2e0a 2020 2020 7472 6163 6520  pass..    trace 
-0001a6b0: 3d20 6463 6528 7472 6163 6529 0a20 2020  = dce(trace).   
-0001a6c0: 2072 6573 756c 742c 2065 6e76 203d 2061   result, env = a
-0001a6d0: 7567 6d65 6e74 6564 5f66 6f72 7761 7264  ugmented_forward
-0001a6e0: 5f70 6173 7328 2a61 7267 732c 2074 7261  _pass(*args, tra
-0001a6f0: 6365 3d74 7261 6365 2c20 2a2a 6b77 6172  ce=trace, **kwar
-0001a700: 6773 290a 2020 2020 7361 7665 645f 666f  gs).    saved_fo
-0001a710: 725f 6261 636b 7761 7264 203d 2064 6563  r_backward = dec
-0001a720: 6f6e 7374 7275 6374 5f66 6f72 7761 7264  onstruct_forward
-0001a730: 5f65 6e76 5f66 6f72 5f62 6163 6b77 6172  _env_for_backwar
-0001a740: 6428 7472 6163 652c 2065 6e76 290a 2020  d(trace, env).  
-0001a750: 2020 2320 5374 6174 6963 2063 6163 6869    # Static cachi
-0001a760: 6e67 2064 6f65 7320 6e6f 7420 7769 7468  ng does not with
-0001a770: 2077 6974 6820 6b77 6172 6773 2064 6963   with kwargs dic
-0001a780: 7473 2c20 736f 2077 6527 7265 2063 6f6e  ts, so we're con
-0001a790: 7665 7274 696e 6720 7468 656d 0a20 2020  verting them.   
-0001a7a0: 2023 2074 6f20 4e6f 6e65 2066 6f72 206e   # to None for n
-0001a7b0: 6f77 2077 6865 6e20 706f 7373 6962 6c65  ow when possible
-0001a7c0: 2e0a 2020 2020 6b77 6172 6773 203d 204e  ..    kwargs = N
-0001a7d0: 6f6e 6520 6966 206e 6f74 206b 7761 7267  one if not kwarg
-0001a7e0: 7320 656c 7365 206b 7761 7267 730a 2020  s else kwargs.  
-0001a7f0: 2020 7265 7369 6475 616c 7320 3d20 2861    residuals = (a
-0001a800: 7267 732c 206b 7761 7267 732c 2073 6176  rgs, kwargs, sav
-0001a810: 6564 5f66 6f72 5f62 6163 6b77 6172 6429  ed_for_backward)
-0001a820: 0a20 2020 2072 6574 7572 6e20 564a 5044  .    return VJPD
-0001a830: 7561 6c28 7265 7375 6c74 2c20 7265 7369  ual(result, resi
-0001a840: 6475 616c 7329 0a0a 0a64 6566 2064 6563  duals)...def dec
-0001a850: 6f6d 706f 7365 645f 666e 5f62 6163 6b77  omposed_fn_backw
-0001a860: 6172 645f 7275 6c65 2864 6563 6f6d 706f  ard_rule(decompo
-0001a870: 7365 645f 666e 2c20 6172 6773 2c20 6b77  sed_fn, args, kw
-0001a880: 6172 6773 2c20 7361 7665 645f 666f 725f  args, saved_for_
-0001a890: 6261 636b 7761 7264 2c20 2a67 7261 6473  backward, *grads
-0001a8a0: 293a 0a20 2020 206b 7761 7267 7320 3d20  ):.    kwargs = 
-0001a8b0: 7b7d 2069 6620 6b77 6172 6773 2069 7320  {} if kwargs is 
-0001a8c0: 4e6f 6e65 2065 6c73 6520 6b77 6172 6773  None else kwargs
-0001a8d0: 0a20 2020 2074 7261 6365 203d 2063 6f6e  .    trace = con
-0001a8e0: 7374 7275 6374 5f74 7261 6365 2829 2864  struct_trace()(d
-0001a8f0: 6563 6f6d 706f 7365 645f 666e 2c20 2a61  ecomposed_fn, *a
-0001a900: 7267 732c 202a 2a6b 7761 7267 7329 0a20  rgs, **kwargs). 
-0001a910: 2020 2074 7261 6365 203d 2075 6e77 7261     trace = unwra
-0001a920: 705f 6f6e 655f 6c65 7665 6c5f 6f66 5f73  p_one_level_of_s
-0001a930: 7562 7379 6d62 6f6c 7328 7472 6163 6529  ubsymbols(trace)
-0001a940: 0a20 2020 2074 7261 6365 203d 2064 6365  .    trace = dce
-0001a950: 2874 7261 6365 290a 2020 2020 2320 626f  (trace).    # bo
-0001a960: 756e 645f 7379 6d62 6f6c 7320 3d20 6974  und_symbols = it
-0001a970: 6572 5f62 6f75 6e64 5f73 796d 626f 6c73  er_bound_symbols
-0001a980: 2874 7261 6365 2e62 6f75 6e64 5f73 796d  (trace.bound_sym
-0001a990: 626f 6c73 290a 2020 2020 2320 7265 636f  bols).    # reco
-0001a9a0: 6e73 7472 7563 7465 645f 656e 7620 3d20  nstructed_env = 
-0001a9b0: 7b0a 2020 2020 2320 2020 2020 7365 7175  {.    #     sequ
-0001a9c0: 656e 6369 6679 2873 796d 626f 6c2e 6f75  encify(symbol.ou
-0001a9d0: 7470 7574 295b 305d 2e6e 616d 653a 2056  tput)[0].name: V
-0001a9e0: 4a50 4475 616c 284e 6f6e 652c 2073 6176  JPDual(None, sav
-0001a9f0: 6564 5f66 6f72 5f62 6163 6b77 6172 645b  ed_for_backward[
-0001aa00: 695d 290a 2020 2020 2320 2020 2020 666f  i]).    #     fo
-0001aa10: 7220 692c 2073 796d 626f 6c20 696e 2065  r i, symbol in e
-0001aa20: 6e75 6d65 7261 7465 2862 6f75 6e64 5f73  numerate(bound_s
-0001aa30: 796d 626f 6c73 290a 2020 2020 2320 7d0a  ymbols).    # }.
-0001aa40: 2020 2020 7265 636f 6e73 7472 7563 7465      reconstructe
-0001aa50: 645f 656e 7620 3d20 7265 636f 6e73 7472  d_env = reconstr
-0001aa60: 7563 745f 666f 7277 6172 645f 656e 765f  uct_forward_env_
-0001aa70: 666f 725f 6261 636b 7761 7264 2874 7261  for_backward(tra
-0001aa80: 6365 2c20 7361 7665 645f 666f 725f 6261  ce, saved_for_ba
-0001aa90: 636b 7761 7264 290a 2020 2020 7265 7375  ckward).    resu
-0001aaa0: 6c74 203d 2062 6163 6b77 6172 645f 7061  lt = backward_pa
-0001aab0: 7373 2872 6563 6f6e 7374 7275 6374 6564  ss(reconstructed
-0001aac0: 5f65 6e76 2c20 7472 6163 652c 2067 7261  _env, trace, gra
-0001aad0: 6473 290a 2020 2020 6966 206c 656e 2861  ds).    if len(a
-0001aae0: 7267 7329 203d 3d20 313a 0a20 2020 2020  rgs) == 1:.     
-0001aaf0: 2020 2072 6574 7572 6e20 7265 7375 6c74     return result
-0001ab00: 5b30 5d0a 2020 2020 2320 4261 636b 7761  [0].    # Backwa
-0001ab10: 7264 2070 6173 7320 6d69 6768 7420 7265  rd pass might re
-0001ab20: 7475 726e 2061 2064 6963 7420 7769 7468  turn a dict with
-0001ab30: 2067 7261 6473 2062 7574 2063 7572 7265   grads but curre
-0001ab40: 6e74 2069 6e74 6572 6661 6365 206f 660a  nt interface of.
-0001ab50: 2020 2020 2320 6261 636b 7761 7264 2072      # backward r
-0001ab60: 756c 6520 646f 6573 206e 6f74 2073 7570  ule does not sup
-0001ab70: 706f 7274 2069 742e 2053 6f20 7765 206a  port it. So we j
-0001ab80: 7573 7420 6472 6f70 2069 7420 666f 7220  ust drop it for 
-0001ab90: 6e6f 772e 0a20 2020 2065 6c69 6620 6973  now..    elif is
-0001aba0: 696e 7374 616e 6365 2872 6573 756c 745b  instance(result[
-0001abb0: 2d31 5d2c 2064 6963 7429 3a0a 2020 2020  -1], dict):.    
-0001abc0: 2020 2020 7265 7475 726e 2072 6573 756c      return resul
-0001abd0: 745b 3a2d 315d 0a20 2020 2072 6574 7572  t[:-1].    retur
-0001abe0: 6e20 7265 7375 6c74 0a0a 0a40 7265 6769  n result...@regi
-0001abf0: 7374 6572 5f61 7567 6d65 6e74 6564 5f66  ster_augmented_f
-0001ac00: 6f72 7761 7264 2822 746f 7263 682e 5465  orward("torch.Te
-0001ac10: 6e73 6f72 2e63 6f6e 7469 6775 6f75 7322  nsor.contiguous"
-0001ac20: 290a 4072 6567 6973 7465 725f 6175 676d  ).@register_augm
-0001ac30: 656e 7465 645f 666f 7277 6172 6428 2274  ented_forward("t
-0001ac40: 6f72 6368 2e63 6f6e 7469 6775 6f75 7322  orch.contiguous"
-0001ac50: 290a 6465 6620 636f 6e74 6967 756f 7573  ).def contiguous
-0001ac60: 5f61 7567 5f66 7764 2878 3a20 5465 6e73  _aug_fwd(x: Tens
-0001ac70: 6f72 5072 6f78 792c 202f 2c20 2a2c 206d  orProxy, /, *, m
-0001ac80: 656d 6f72 795f 666f 726d 6174 3a20 746f  emory_format: to
-0001ac90: 7263 682e 6d65 6d6f 7279 5f66 6f72 6d61  rch.memory_forma
-0001aca0: 7420 3d20 746f 7263 682e 636f 6e74 6967  t = torch.contig
-0001acb0: 756f 7573 5f66 6f72 6d61 7429 202d 3e20  uous_format) -> 
-0001acc0: 564a 5044 7561 6c3a 0a20 2020 2066 726f  VJPDual:.    fro
-0001acd0: 6d20 7468 756e 6465 722e 746f 7263 6820  m thunder.torch 
-0001ace0: 696d 706f 7274 2063 6f6e 7469 6775 6f75  import contiguou
-0001acf0: 730a 0a20 2020 2072 6574 7572 6e20 564a  s..    return VJ
-0001ad00: 5044 7561 6c28 636f 6e74 6967 756f 7573  PDual(contiguous
-0001ad10: 2878 2c20 6d65 6d6f 7279 5f66 6f72 6d61  (x, memory_forma
-0001ad20: 743d 6d65 6d6f 7279 5f66 6f72 6d61 7429  t=memory_format)
-0001ad30: 2c20 7475 706c 6528 2929 0a0a 0a40 7265  , tuple())...@re
-0001ad40: 6769 7374 6572 5f62 6163 6b77 6172 6428  gister_backward(
-0001ad50: 2274 6f72 6368 2e54 656e 736f 722e 636f  "torch.Tensor.co
-0001ad60: 6e74 6967 756f 7573 2229 0a40 7265 6769  ntiguous").@regi
-0001ad70: 7374 6572 5f62 6163 6b77 6172 6428 2274  ster_backward("t
-0001ad80: 6f72 6368 2e63 6f6e 7469 6775 6f75 7322  orch.contiguous"
-0001ad90: 290a 6465 6620 636f 6e74 6967 756f 7573  ).def contiguous
-0001ada0: 5f62 6163 6b77 6172 6428 2a72 6573 6964  _backward(*resid
-0001adb0: 7561 6c73 5f61 6e64 5f67 7261 6429 202d  uals_and_grad) -
-0001adc0: 3e20 5465 6e73 6f72 5072 6f78 793a 0a20  > TensorProxy:. 
-0001add0: 2020 2023 2052 6573 6964 7561 6c73 2069     # Residuals i
-0001ade0: 7320 6e6f 7420 656d 7074 7920 6265 6361  s not empty beca
-0001adf0: 7573 6520 636f 6e74 6967 756f 7573 2073  use contiguous s
-0001ae00: 796d 626f 6c20 6861 7320 7468 6520 7361  ymbol has the sa
-0001ae10: 6d65 206f 7574 7075 7420 6173 2069 7473  me output as its
-0001ae20: 2069 6e70 7574 0a20 2020 2067 203d 2072   input.    g = r
-0001ae30: 6573 6964 7561 6c73 5f61 6e64 5f67 7261  esiduals_and_gra
-0001ae40: 645b 2d31 5d0a 2020 2020 7265 7475 726e  d[-1].    return
-0001ae50: 2067 0a0a 0a64 6566 2072 6563 6970 726f   g...def recipro
-0001ae60: 6361 6c5f 6175 675f 6677 6428 613a 2054  cal_aug_fwd(a: T
-0001ae70: 656e 736f 7250 726f 7879 2920 2d3e 2056  ensorProxy) -> V
-0001ae80: 4a50 4475 616c 3a0a 2020 2020 7072 696d  JPDual:.    prim
-0001ae90: 616c 203d 2072 6563 6970 726f 6361 6c28  al = reciprocal(
-0001aea0: 6129 0a20 2020 2072 6574 7572 6e20 564a  a).    return VJ
-0001aeb0: 5044 7561 6c28 7072 696d 616c 2c20 2870  PDual(primal, (p
-0001aec0: 7269 6d61 6c2c 2929 0a0a 0a64 6566 2072  rimal,))...def r
-0001aed0: 6563 6970 726f 6361 6c5f 6261 636b 7761  eciprocal_backwa
-0001aee0: 7264 2870 7269 6d61 6c2c 2067 293a 0a20  rd(primal, g):. 
-0001aef0: 2020 2072 6574 7572 6e20 2d67 202a 2070     return -g * p
-0001af00: 7269 6d61 6c20 2a20 7072 696d 616c 0a0a  rimal * primal..
-0001af10: 0a40 7061 7274 6961 6c28 7265 6769 7374  .@partial(regist
-0001af20: 6572 5f67 7261 642c 2070 7269 6d73 2e50  er_grad, prims.P
-0001af30: 7269 6d49 4473 2e52 4543 4950 524f 4341  rimIDs.RECIPROCA
-0001af40: 4c29 0a64 6566 2072 6563 6970 726f 6361  L).def reciproca
-0001af50: 6c5f 6a6f 696e 745f 666f 7277 6172 645f  l_joint_forward_
-0001af60: 6261 636b 7761 7264 5f72 756c 6528 613a  backward_rule(a:
-0001af70: 2054 656e 736f 7250 726f 7879 2920 2d3e   TensorProxy) ->
-0001af80: 2054 656e 736f 7250 726f 7879 3a0a 2020   TensorProxy:.  
-0001af90: 2020 7265 7375 6c74 2c20 7361 7665 6420    result, saved 
-0001afa0: 3d20 7265 6369 7072 6f63 616c 5f61 7567  = reciprocal_aug
-0001afb0: 5f66 7764 2861 290a 2020 2020 6720 3d20  _fwd(a).    g = 
-0001afc0: 6765 745f 6772 6164 2872 6573 756c 7429  get_grad(result)
-0001afd0: 0a20 2020 2067 6120 3d20 7265 6369 7072  .    ga = recipr
-0001afe0: 6f63 616c 5f62 6163 6b77 6172 6428 2a73  ocal_backward(*s
-0001aff0: 6176 6564 2c20 6729 0a20 2020 2070 7574  aved, g).    put
-0001b000: 5f67 7261 6428 612c 2067 6129 0a20 2020  _grad(a, ga).   
-0001b010: 2072 6574 7572 6e20 7265 7375 6c74 0a0a   return result..
-0001b020: 0a40 7265 6769 7374 6572 5f61 7567 6d65  .@register_augme
-0001b030: 6e74 6564 5f66 6f72 7761 7264 2822 746f  nted_forward("to
-0001b040: 7263 682e 696e 6465 785f 7075 7422 290a  rch.index_put").
-0001b050: 6465 6620 696e 6465 785f 7075 745f 6175  def index_put_au
-0001b060: 675f 6677 6428 0a20 2020 2061 3a20 5465  g_fwd(.    a: Te
-0001b070: 6e73 6f72 5072 6f78 792c 202f 2c20 696e  nsorProxy, /, in
-0001b080: 6469 6365 733a 2053 6571 7565 6e63 655b  dices: Sequence[
-0001b090: 5465 6e73 6f72 5072 6f78 795d 2c20 7661  TensorProxy], va
-0001b0a0: 6c75 6573 3a20 5465 6e73 6f72 5072 6f78  lues: TensorProx
-0001b0b0: 792c 2061 6363 756d 756c 6174 653a 2062  y, accumulate: b
-0001b0c0: 6f6f 6c20 3d20 4661 6c73 650a 2920 2d3e  ool = False.) ->
-0001b0d0: 2056 4a50 4475 616c 3a0a 2020 2020 7072   VJPDual:.    pr
-0001b0e0: 696d 616c 203d 2063 6c61 6e67 2e69 6e64  imal = clang.ind
-0001b0f0: 6578 5f70 7574 2861 2c20 696e 6469 6365  ex_put(a, indice
-0001b100: 732c 2076 616c 7565 732c 2061 6363 756d  s, values, accum
-0001b110: 756c 6174 6529 0a20 2020 2072 6573 6964  ulate).    resid
-0001b120: 7561 6c73 203d 2028 0a20 2020 2020 2020  uals = (.       
-0001b130: 2069 6e64 6963 6573 2c0a 2020 2020 2020   indices,.      
-0001b140: 2020 7661 6c75 6573 2c0a 2020 2020 2020    values,.      
-0001b150: 2020 6163 6375 6d75 6c61 7465 2c0a 2020    accumulate,.  
-0001b160: 2020 290a 2020 2020 7265 7475 726e 2056    ).    return V
-0001b170: 4a50 4475 616c 2870 7269 6d61 6c2c 2072  JPDual(primal, r
-0001b180: 6573 6964 7561 6c73 290a 0a0a 6465 6620  esiduals)...def 
-0001b190: 7375 6d5f 746f 2861 3a20 5465 6e73 6f72  sum_to(a: Tensor
-0001b1a0: 5072 6f78 792c 2073 6861 7065 3a20 5365  Proxy, shape: Se
-0001b1b0: 7175 656e 6365 5b69 6e74 5d29 202d 3e20  quence[int]) -> 
-0001b1c0: 5465 6e73 6f72 5072 6f78 793a 0a20 2020  TensorProxy:.   
-0001b1d0: 2069 6620 6e6f 7420 7368 6170 653a 0a20   if not shape:. 
-0001b1e0: 2020 2020 2020 2072 6574 7572 6e20 612e         return a.
-0001b1f0: 7375 6d28 290a 2020 2020 6c65 6164 696e  sum().    leadin
-0001b200: 675f 6469 6d73 203d 2061 2e6e 6469 6d20  g_dims = a.ndim 
-0001b210: 2d20 6c65 6e28 7368 6170 6529 0a20 2020  - len(shape).   
-0001b220: 2072 6564 7563 655f 6469 6d73 203d 2074   reduce_dims = t
-0001b230: 7570 6c65 2872 616e 6765 286c 6561 6469  uple(range(leadi
-0001b240: 6e67 5f64 696d 7329 2920 2b20 7475 706c  ng_dims)) + tupl
-0001b250: 6528 0a20 2020 2020 2020 2069 2066 6f72  e(.        i for
-0001b260: 2069 2069 6e20 7261 6e67 6528 6c65 6164   i in range(lead
-0001b270: 696e 675f 6469 6d73 2c20 612e 6e64 696d  ing_dims, a.ndim
-0001b280: 2920 6966 2073 6861 7065 5b69 202d 206c  ) if shape[i - l
-0001b290: 6561 6469 6e67 5f64 696d 735d 203d 3d20  eading_dims] == 
-0001b2a0: 3120 616e 6420 612e 7368 6170 655b 695d  1 and a.shape[i]
-0001b2b0: 2021 3d20 310a 2020 2020 290a 2020 2020   != 1.    ).    
-0001b2c0: 6120 3d20 6c74 6f72 6368 2e73 756d 2861  a = ltorch.sum(a
-0001b2d0: 2c20 6469 6d3d 7265 6475 6365 5f64 696d  , dim=reduce_dim
-0001b2e0: 732c 206b 6565 7064 696d 3d54 7275 6529  s, keepdim=True)
-0001b2f0: 0a20 2020 2069 6620 6c65 6164 696e 675f  .    if leading_
-0001b300: 6469 6d73 203e 2030 3a0a 2020 2020 2020  dims > 0:.      
-0001b310: 2020 7265 7475 726e 206c 746f 7263 682e    return ltorch.
-0001b320: 7669 6577 2861 2c20 7368 6170 6529 0a20  view(a, shape). 
-0001b330: 2020 2072 6574 7572 6e20 610a 0a0a 4072     return a...@r
-0001b340: 6567 6973 7465 725f 6261 636b 7761 7264  egister_backward
-0001b350: 2822 746f 7263 682e 696e 6465 785f 7075  ("torch.index_pu
-0001b360: 7422 290a 6465 6620 696e 6465 785f 7075  t").def index_pu
-0001b370: 745f 6261 636b 7761 7264 2869 6e64 6963  t_backward(indic
-0001b380: 6573 3a20 5365 7175 656e 6365 5b54 656e  es: Sequence[Ten
-0001b390: 736f 7250 726f 7879 5d2c 2076 616c 7565  sorProxy], value
-0001b3a0: 733a 2054 656e 736f 7250 726f 7879 2c20  s: TensorProxy, 
-0001b3b0: 6163 6375 6d75 6c61 7465 3a20 626f 6f6c  accumulate: bool
-0001b3c0: 2c20 673a 2054 656e 736f 7250 726f 7879  , g: TensorProxy
-0001b3d0: 293a 0a20 2020 2067 5f76 616c 7565 7320  ):.    g_values 
-0001b3e0: 3d20 675b 696e 6469 6365 735d 0a20 2020  = g[indices].   
-0001b3f0: 2023 2074 6f72 6368 2068 6173 2065 7874   # torch has ext
-0001b400: 7261 206c 6f67 6963 2074 6f20 6861 6e64  ra logic to hand
-0001b410: 6c65 2074 6865 2065 7870 616e 6465 6420  le the expanded 
-0001b420: 7661 6c75 6573 0a20 2020 2069 6620 6e6f  values.    if no
-0001b430: 7420 7574 696c 732e 7361 6d65 5f73 6861  t utils.same_sha
-0001b440: 7065 2867 5f76 616c 7565 732e 7368 6170  pe(g_values.shap
-0001b450: 652c 2076 616c 7565 732e 7368 6170 6529  e, values.shape)
-0001b460: 3a0a 2020 2020 2020 2020 6966 2063 6c61  :.        if cla
-0001b470: 6e67 2e63 6f6d 7075 7465 5f62 726f 6164  ng.compute_broad
-0001b480: 6361 7374 5f73 6861 7065 2867 5f76 616c  cast_shape(g_val
-0001b490: 7565 732e 7368 6170 652c 2076 616c 7565  ues.shape, value
-0001b4a0: 732e 7368 6170 6529 3a0a 2020 2020 2020  s.shape):.      
-0001b4b0: 2020 2020 2020 675f 7661 6c75 6573 203d        g_values =
-0001b4c0: 2073 756d 5f74 6f28 675f 7661 6c75 6573   sum_to(g_values
-0001b4d0: 2c20 7661 6c75 6573 2e73 6861 7065 290a  , values.shape).
-0001b4e0: 2020 2020 6966 2061 6363 756d 756c 6174      if accumulat
-0001b4f0: 653a 0a20 2020 2020 2020 2072 6574 7572  e:.        retur
-0001b500: 6e20 672c 2067 5f76 616c 7565 730a 2020  n g, g_values.  
-0001b510: 2020 7265 7475 726e 2063 6c61 6e67 2e69    return clang.i
-0001b520: 6e64 6578 5f70 7574 2867 2c20 696e 6469  ndex_put(g, indi
-0001b530: 6365 732c 206c 746f 7263 682e 7a65 726f  ces, ltorch.zero
-0001b540: 735f 6c69 6b65 2876 616c 7565 7329 2c20  s_like(values), 
-0001b550: 4661 6c73 6529 2c20 675f 7661 6c75 6573  False), g_values
-0001b560: 0a0a 0a64 6566 2075 6e69 666f 726d 5f61  ...def uniform_a
-0001b570: 7567 5f66 7764 2873 6861 7065 2c20 6d69  ug_fwd(shape, mi
-0001b580: 6e76 616c 2c20 6d61 7876 616c 2c20 2a2c  nval, maxval, *,
-0001b590: 2064 6576 6963 652c 2064 7479 7065 293a   device, dtype):
-0001b5a0: 0a20 2020 2070 7269 6d61 6c20 3d20 7072  .    primal = pr
-0001b5b0: 696d 732e 756e 6966 6f72 6d28 7368 6170  ims.uniform(shap
-0001b5c0: 652c 206d 696e 7661 6c2c 206d 6178 7661  e, minval, maxva
-0001b5d0: 6c2c 2064 6576 6963 653d 6465 7669 6365  l, device=device
-0001b5e0: 2c20 6474 7970 653d 6474 7970 6529 0a20  , dtype=dtype). 
-0001b5f0: 2020 2072 6574 7572 6e20 564a 5044 7561     return VJPDua
-0001b600: 6c28 7072 696d 616c 2c20 2870 7269 6d61  l(primal, (prima
-0001b610: 6c2c 206d 696e 7661 6c2c 206d 6178 7661  l, minval, maxva
-0001b620: 6c29 290a 0a0a 6465 6620 756e 6966 6f72  l))...def unifor
-0001b630: 6d5f 6261 636b 7761 7264 2870 7269 6d61  m_backward(prima
-0001b640: 6c2c 206d 696e 7661 6c2c 206d 6178 7661  l, minval, maxva
-0001b650: 6c2c 2067 293a 0a20 2020 2023 2075 6e69  l, g):.    # uni
-0001b660: 666f 726d 2069 7320 696d 706c 656d 656e  form is implemen
-0001b670: 7465 6420 6173 2028 6d61 7876 616c 202d  ted as (maxval -
-0001b680: 206d 696e 7661 6c29 202a 2075 6e69 666f   minval) * unifo
-0001b690: 726d 2873 6861 7065 2c20 302c 2031 2920  rm(shape, 0, 1) 
-0001b6a0: 2b20 6d69 6e76 616c 0a20 2020 2075 6e73  + minval.    uns
-0001b6b0: 6361 6c65 645f 7072 696d 616c 203d 2028  caled_primal = (
-0001b6c0: 7072 696d 616c 202d 206d 696e 7661 6c29  primal - minval)
-0001b6d0: 202f 2028 6d61 7876 616c 202d 206d 696e   / (maxval - min
-0001b6e0: 7661 6c29 0a20 2020 2072 6564 7563 655f  val).    reduce_
-0001b6f0: 616c 6c5f 6469 6d73 203d 2074 7570 6c65  all_dims = tuple
-0001b700: 2872 616e 6765 2867 2e6e 6469 6d29 290a  (range(g.ndim)).
-0001b710: 2020 2020 7375 6d20 3d20 7061 7274 6961      sum = partia
-0001b720: 6c28 7072 696d 732e 7375 6d2c 2064 696d  l(prims.sum, dim
-0001b730: 733d 7265 6475 6365 5f61 6c6c 5f64 696d  s=reduce_all_dim
-0001b740: 7329 0a20 2020 2072 6574 7572 6e20 4e6f  s).    return No
-0001b750: 6e65 2c20 7375 6d28 6720 2a20 2831 202d  ne, sum(g * (1 -
-0001b760: 2075 6e73 6361 6c65 645f 7072 696d 616c   unscaled_primal
-0001b770: 2929 2c20 7375 6d28 6720 2a20 756e 7363  )), sum(g * unsc
-0001b780: 616c 6564 5f70 7269 6d61 6c29 0a0a 0a6e  aled_primal)...n
-0001b790: 6f6e 6469 6666 6572 656e 7469 6162 6c65  ondifferentiable
-0001b7a0: 5f76 6a70 5f73 796d 626f 6c73 203d 2028  _vjp_symbols = (
-0001b7b0: 7072 696d 732e 5072 696d 4944 732e 4249  prims.PrimIDs.BI
-0001b7c0: 5457 4953 455f 414e 442c 2070 7269 6d73  TWISE_AND, prims
-0001b7d0: 2e50 7269 6d49 4473 2e53 4947 4e42 4954  .PrimIDs.SIGNBIT
-0001b7e0: 2c20 7072 696d 732e 5072 696d 4944 732e  , prims.PrimIDs.
-0001b7f0: 4655 4c4c 290a 0a0a 6465 6620 6973 5f63  FULL)...def is_c
-0001b800: 6f6e 7374 616e 745f 666f 725f 766a 7028  onstant_for_vjp(
-0001b810: 7379 6d62 6f6c 3a20 7072 696d 732e 5379  symbol: prims.Sy
-0001b820: 6d62 6f6c 2920 2d3e 2062 6f6f 6c3a 0a20  mbol) -> bool:. 
-0001b830: 2020 2022 2222 4368 6563 6b20 6966 2061     """Check if a
-0001b840: 2073 796d 626f 6c20 6973 2063 6f6e 7374   symbol is const
-0001b850: 616e 7420 666f 7220 7468 6520 564a 5020  ant for the VJP 
-0001b860: 7472 616e 7366 6f72 6d2e 0a0a 2020 2020  transform...    
-0001b870: 4172 6773 3a0a 2020 2020 2020 2020 7379  Args:.        sy
-0001b880: 6d62 6f6c 2028 7072 696d 732e 5379 6d62  mbol (prims.Symb
-0001b890: 6f6c 293a 2053 796d 626f 6c20 746f 2063  ol): Symbol to c
-0001b8a0: 6865 636b 2e0a 0a20 2020 2052 6574 7572  heck...    Retur
-0001b8b0: 6e73 3a0a 2020 2020 2020 2020 626f 6f6c  ns:.        bool
-0001b8c0: 3a20 5472 7565 2069 6620 7468 6520 7379  : True if the sy
-0001b8d0: 6d62 6f6c 2069 7320 636f 6e73 7461 6e74  mbol is constant
-0001b8e0: 2c20 4661 6c73 6520 6f74 6865 7277 6973  , False otherwis
-0001b8f0: 652e 0a20 2020 2022 2222 0a20 2020 2061  e..    """.    a
-0001b900: 7265 5f61 6c6c 5f61 7267 735f 6e6f 6e5f  re_all_args_non_
-0001b910: 6469 6666 6572 656e 7469 6162 6c65 203d  differentiable =
-0001b920: 206e 6f74 2061 6e79 2869 7369 6e73 7461   not any(isinsta
-0001b930: 6e63 6528 6172 672c 2028 466c 6f61 7450  nce(arg, (FloatP
-0001b940: 726f 7879 2c20 5465 6e73 6f72 5072 6f78  roxy, TensorProx
-0001b950: 7929 2920 666f 7220 6172 6720 696e 2073  y)) for arg in s
-0001b960: 796d 626f 6c2e 666c 6174 5f61 7267 7329  ymbol.flat_args)
-0001b970: 0a20 2020 2072 6574 7572 6e20 280a 2020  .    return (.  
-0001b980: 2020 2020 2020 6172 655f 616c 6c5f 6172        are_all_ar
-0001b990: 6773 5f6e 6f6e 5f64 6966 6665 7265 6e74  gs_non_different
-0001b9a0: 6961 626c 650a 2020 2020 2020 2020 6f72  iable.        or
-0001b9b0: 2073 796d 626f 6c2e 6172 655f 616c 6c5f   symbol.are_all_
-0001b9c0: 6172 6773 5f63 6f6e 7374 616e 740a 2020  args_constant.  
-0001b9d0: 2020 2020 2020 6f72 2073 796d 626f 6c2e        or symbol.
-0001b9e0: 7379 6d2e 6964 2069 6e20 6e6f 6e64 6966  sym.id in nondif
-0001b9f0: 6665 7265 6e74 6961 626c 655f 766a 705f  ferentiable_vjp_
-0001ba00: 7379 6d62 6f6c 730a 2020 2020 290a 0a0a  symbols.    )...
-0001ba10: 6465 6620 766a 705f 7379 6d62 6f6c 5f6d  def vjp_symbol_m
-0001ba20: 6170 7065 7228 7379 6d62 6f6c 3a20 7072  apper(symbol: pr
-0001ba30: 696d 732e 5379 6d62 6f6c 2c20 2a61 7267  ims.Symbol, *arg
-0001ba40: 732c 202a 2a6b 7761 7267 7329 3a0a 2020  s, **kwargs):.  
-0001ba50: 2020 2222 2253 796d 626f 6c20 6d61 7070    """Symbol mapp
-0001ba60: 6572 2066 6f72 2074 6865 2056 4a50 2074  er for the VJP t
-0001ba70: 7261 6e73 666f 726d 2e0a 0a20 2020 2041  ransform...    A
-0001ba80: 7267 733a 0a20 2020 2020 2020 2073 796d  rgs:.        sym
-0001ba90: 626f 6c20 2870 7269 6d73 2e53 796d 626f  bol (prims.Symbo
-0001baa0: 6c29 3a20 5379 6d62 6f6c 2074 6f20 6265  l): Symbol to be
-0001bab0: 206d 6170 7065 642e 0a20 2020 2020 2020   mapped..       
-0001bac0: 2061 7267 7320 2854 7570 6c65 5b56 6172   args (Tuple[Var
-0001bad0: 6961 626c 655d 293a 2041 7267 756d 656e  iable]): Argumen
-0001bae0: 7473 2074 6f20 7468 6520 7379 6d62 6f6c  ts to the symbol
-0001baf0: 2e0a 2020 2020 2020 2020 6b77 6172 6773  ..        kwargs
-0001bb00: 2028 4469 6374 5b73 7472 2c20 5661 7269   (Dict[str, Vari
-0001bb10: 6162 6c65 5d29 3a20 4b65 7977 6f72 6420  able]): Keyword 
-0001bb20: 6172 6775 6d65 6e74 7320 746f 2074 6865  arguments to the
-0001bb30: 2073 796d 626f 6c2e 0a0a 2020 2020 5265   symbol...    Re
-0001bb40: 7475 726e 733a 0a20 2020 2020 2020 2043  turns:.        C
-0001bb50: 616c 6c61 626c 653a 2041 2066 756e 6374  allable: A funct
-0001bb60: 696f 6e20 7468 6174 2063 6f6d 7075 7465  ion that compute
-0001bb70: 7320 7468 6520 564a 5020 6f66 2074 6865  s the VJP of the
-0001bb80: 2073 796d 626f 6c2e 0a20 2020 2022 2222   symbol..    """
-0001bb90: 0a20 2020 2023 2043 6f6e 7374 616e 7420  .    # Constant 
-0001bba0: 6361 7365 0a20 2020 2069 6620 6973 5f63  case.    if is_c
-0001bbb0: 6f6e 7374 616e 745f 666f 725f 766a 7028  onstant_for_vjp(
-0001bbc0: 7379 6d62 6f6c 293a 0a0a 2020 2020 2020  symbol):..      
-0001bbd0: 2020 6465 6620 766a 705f 696d 706c 5f63    def vjp_impl_c
-0001bbe0: 6f6e 7374 2873 796d 626f 6c2c 202a 6172  onst(symbol, *ar
-0001bbf0: 6773 2c20 2a2a 6b77 6172 6773 293a 0a20  gs, **kwargs):. 
-0001bc00: 2020 2020 2020 2020 2020 2061 7267 732c             args,
-0001bc10: 206b 7761 7267 7320 3d20 7472 6565 5f6d   kwargs = tree_m
-0001bc20: 6170 286c 616d 6264 6120 783a 2078 2e70  ap(lambda x: x.p
-0001bc30: 7269 6d61 6c20 6966 2069 7369 6e73 7461  rimal if isinsta
-0001bc40: 6e63 6528 782c 2056 4a50 4475 616c 2920  nce(x, VJPDual) 
-0001bc50: 656c 7365 2078 2c20 2861 7267 732c 206b  else x, (args, k
-0001bc60: 7761 7267 7329 290a 2020 2020 2020 2020  wargs)).        
-0001bc70: 2020 2020 7072 696d 616c 7320 3d20 7379      primals = sy
-0001bc80: 6d62 6f6c 5f74 6f5f 6576 616c 2873 796d  mbol_to_eval(sym
-0001bc90: 626f 6c29 282a 6172 6773 2c20 2a2a 6b77  bol)(*args, **kw
-0001bca0: 6172 6773 290a 2020 2020 2020 2020 2020  args).          
-0001bcb0: 2020 6966 2069 7369 6e73 7461 6e63 6528    if isinstance(
-0001bcc0: 7072 696d 616c 732c 2053 6571 7565 6e63  primals, Sequenc
-0001bcd0: 6529 3a0a 2020 2020 2020 2020 2020 2020  e):.            
-0001bce0: 2020 2020 7265 7475 726e 2074 7265 655f      return tree_
-0001bcf0: 6d61 7028 6c61 6d62 6461 2078 3a20 564a  map(lambda x: VJ
-0001bd00: 5044 7561 6c28 782c 2074 7570 6c65 2829  PDual(x, tuple()
-0001bd10: 292c 2070 7269 6d61 6c73 290a 2020 2020  ), primals).    
-0001bd20: 2020 2020 2020 2020 7265 7475 726e 2056          return V
-0001bd30: 4a50 4475 616c 2870 7269 6d61 6c73 2c20  JPDual(primals, 
-0001bd40: 7475 706c 6528 2929 0a0a 2020 2020 2020  tuple())..      
-0001bd50: 2020 7265 7475 726e 2070 6172 7469 616c    return partial
-0001bd60: 2876 6a70 5f69 6d70 6c5f 636f 6e73 742c  (vjp_impl_const,
-0001bd70: 2073 796d 626f 6c29 0a0a 2020 2020 2320   symbol)..    # 
-0001bd80: 4e6f 726d 616c 2063 6173 652c 2077 6520  Normal case, we 
-0001bd90: 6861 7665 2061 2070 726f 7879 2074 616e  have a proxy tan
-0001bda0: 6765 6e74 0a20 2020 2076 6a70 5f69 6d70  gent.    vjp_imp
-0001bdb0: 6c20 3d20 6175 676d 656e 7465 645f 666f  l = augmented_fo
-0001bdc0: 7277 6172 645f 696d 706c 732e 6765 7428  rward_impls.get(
-0001bdd0: 7379 6d62 6f6c 2e73 796d 2e69 6429 0a0a  symbol.sym.id)..
-0001bde0: 2020 2020 6966 205f 6765 745f 6772 6164      if _get_grad
-0001bdf0: 666e 5f61 6e64 5f65 7865 6375 746f 7228  fn_and_executor(
-0001be00: 7379 6d62 6f6c 295b 305d 2069 7320 6e6f  symbol)[0] is no
-0001be10: 7420 4e6f 6e65 3a0a 2020 2020 2020 2020  t None:.        
-0001be20: 766a 705f 696d 706c 2c20 6261 636b 7761  vjp_impl, backwa
-0001be30: 7264 5f66 6e20 3d20 6d61 6b65 5f61 7567  rd_fn = make_aug
-0001be40: 5f66 6f72 7761 7264 5f61 6e64 5f62 6163  _forward_and_bac
-0001be50: 6b77 6172 6428 7379 6d62 6f6c 290a 0a20  kward(symbol).. 
-0001be60: 2020 2069 6620 766a 705f 696d 706c 2069     if vjp_impl i
-0001be70: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
-0001be80: 2320 5765 2063 6f75 6c64 206e 6f74 2066  # We could not f
-0001be90: 696e 6420 6120 564a 5020 666f 7220 7468  ind a VJP for th
-0001bea0: 6973 2073 796d 626f 6c2c 2073 6f20 7765  is symbol, so we
-0001beb0: 2074 7279 2074 6f20 6465 636f 6d70 6f73   try to decompos
-0001bec0: 6520 6974 0a20 2020 2020 2020 2069 6620  e it.        if 
-0001bed0: 6c65 6e28 7379 6d62 6f6c 2e73 7562 7379  len(symbol.subsy
-0001bee0: 6d62 6f6c 7329 203e 2030 2061 6e64 206e  mbols) > 0 and n
-0001bef0: 6f74 2069 7369 6e73 7461 6e63 6528 7379  ot isinstance(sy
-0001bf00: 6d62 6f6c 2e73 796d 2e69 642c 2070 7269  mbol.sym.id, pri
-0001bf10: 6d73 2e50 7269 6d49 4473 293a 0a20 2020  ms.PrimIDs):.   
-0001bf20: 2020 2020 2020 2020 2076 6a70 5f69 6d70           vjp_imp
-0001bf30: 6c20 3d20 7061 7274 6961 6c28 6465 636f  l = partial(deco
-0001bf40: 6d70 6f73 6564 5f66 6e5f 6175 675f 6677  mposed_fn_aug_fw
-0001bf50: 645f 7275 6c65 2c20 6465 636f 6d70 6f73  d_rule, decompos
-0001bf60: 6564 5f66 6e3d 7379 6d62 6f6c 2e73 796d  ed_fn=symbol.sym
-0001bf70: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
-0001bf80: 2020 2020 2020 2020 2020 2020 2320 5765              # We
-0001bf90: 2063 6f75 6c64 206e 6f74 2066 696e 6420   could not find 
-0001bfa0: 6120 564a 5020 666f 7220 7468 6973 2073  a VJP for this s
-0001bfb0: 796d 626f 6c20 616e 6420 7765 2063 6f75  ymbol and we cou
-0001bfc0: 6c64 206e 6f74 2064 6563 6f6d 706f 7365  ld not decompose
-0001bfd0: 2069 740a 2020 2020 2020 2020 2020 2020   it.            
-0001bfe0: 2320 4974 2063 6f75 6c64 2062 6520 6120  # It could be a 
-0001bff0: 746f 7263 682e 6472 6f70 6f75 7420 7769  torch.dropout wi
-0001c000: 7468 2030 2e30 2070 726f 6261 6269 6c69  th 0.0 probabili
-0001c010: 7479 2c20 736f 2077 6520 736b 6970 2069  ty, so we skip i
-0001c020: 740a 2020 2020 2020 2020 2020 2020 6966  t.            if
-0001c030: 2073 796d 626f 6c2e 7379 6d2e 6964 203d   symbol.sym.id =
-0001c040: 3d20 2274 6f72 6368 2e6e 6e2e 6675 6e63  = "torch.nn.func
-0001c050: 7469 6f6e 616c 2e64 726f 706f 7574 223a  tional.dropout":
-0001c060: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001c070: 2072 6574 7572 6e20 4e6f 6e65 0a20 2020   return None.   
-0001c080: 2020 2020 2020 2020 2070 7269 6e74 2866           print(f
-0001c090: 2256 4a50 2066 6f72 207b 7379 6d62 6f6c  "VJP for {symbol
-0001c0a0: 7d20 6973 206e 6f74 2069 6d70 6c65 6d65  } is not impleme
-0001c0b0: 6e74 6564 2229 0a20 2020 2020 2020 2020  nted").         
-0001c0c0: 2020 2072 6169 7365 204e 6f74 496d 706c     raise NotImpl
-0001c0d0: 656d 656e 7465 6445 7272 6f72 2866 2256  ementedError(f"V
-0001c0e0: 4a50 2066 6f72 207b 7379 6d62 6f6c 2e73  JP for {symbol.s
-0001c0f0: 796d 2e69 647d 2069 7320 6e6f 7420 696d  ym.id} is not im
-0001c100: 706c 656d 656e 7465 6422 290a 0a20 2020  plemented")..   
-0001c110: 2064 6566 205f 766a 705f 696d 706c 282a   def _vjp_impl(*
-0001c120: 6172 6773 2c20 2a2a 6b77 6172 6773 293a  args, **kwargs):
-0001c130: 0a20 2020 2020 2020 2070 7269 6d61 6c73  .        primals
-0001c140: 2c20 6b77 6172 6773 203d 2074 7265 655f  , kwargs = tree_
-0001c150: 6d61 7028 6c61 6d62 6461 2078 3a20 782e  map(lambda x: x.
-0001c160: 7072 696d 616c 2069 6620 6973 696e 7374  primal if isinst
-0001c170: 616e 6365 2878 2c20 564a 5044 7561 6c29  ance(x, VJPDual)
-0001c180: 2065 6c73 6520 782c 2028 6172 6773 2c20   else x, (args, 
-0001c190: 6b77 6172 6773 2929 0a20 2020 2020 2020  kwargs)).       
-0001c1a0: 206f 7574 5f70 7269 6d61 6c2c 206f 7574   out_primal, out
-0001c1b0: 5f72 6573 6964 7561 6c73 203d 2076 6a70  _residuals = vjp
-0001c1c0: 5f69 6d70 6c28 2a70 7269 6d61 6c73 2c20  _impl(*primals, 
-0001c1d0: 2a2a 6b77 6172 6773 290a 0a20 2020 2020  **kwargs)..     
-0001c1e0: 2020 2023 2057 6520 6172 6520 7361 7669     # We are savi
-0001c1f0: 6e67 2074 6865 2072 6573 6964 7561 6c73  ng the residuals
-0001c200: 2061 6e64 2070 756c 6c62 6163 6b20 6f6e   and pullback on
-0001c210: 6c79 2069 6e20 7468 6520 6669 7273 7420  ly in the first 
-0001c220: 6f75 7470 7574 0a20 2020 2020 2020 2023  output.        #
-0001c230: 2062 6163 6b77 6172 645f 7061 7373 2074   backward_pass t
-0001c240: 6865 6e20 7265 7472 6965 7665 7320 7468  hen retrieves th
-0001c250: 6520 7265 7369 6475 616c 7320 616e 6420  e residuals and 
-0001c260: 7075 6c6c 6261 636b 2066 726f 6d20 7468  pullback from th
-0001c270: 6520 6669 7273 7420 6f75 7470 7574 0a20  e first output. 
-0001c280: 2020 2020 2020 2069 6620 6973 696e 7374         if isinst
-0001c290: 616e 6365 286f 7574 5f70 7269 6d61 6c2c  ance(out_primal,
-0001c2a0: 2053 6571 7565 6e63 6529 3a0a 2020 2020   Sequence):.    
-0001c2b0: 2020 2020 2020 2020 7265 7475 726e 2028          return (
-0001c2c0: 564a 5044 7561 6c28 6f75 745f 7072 696d  VJPDual(out_prim
-0001c2d0: 616c 5b30 5d2c 206f 7574 5f72 6573 6964  al[0], out_resid
-0001c2e0: 7561 6c73 292c 202a 2856 4a50 4475 616c  uals), *(VJPDual
-0001c2f0: 286f 2c20 7475 706c 6528 2929 2066 6f72  (o, tuple()) for
-0001c300: 206f 2069 6e20 6f75 745f 7072 696d 616c   o in out_primal
-0001c310: 5b31 3a5d 2929 0a0a 2020 2020 2020 2020  [1:]))..        
-0001c320: 7265 7475 726e 2028 564a 5044 7561 6c28  return (VJPDual(
-0001c330: 6f75 745f 7072 696d 616c 2c20 6f75 745f  out_primal, out_
-0001c340: 7265 7369 6475 616c 7329 2c29 0a0a 2020  residuals),)..  
-0001c350: 2020 7265 7475 726e 205f 766a 705f 696d    return _vjp_im
-0001c360: 706c 0a0a 0a64 6566 2063 6865 636b 5f62  pl...def check_b
-0001c370: 7379 6d5f 666f 725f 766a 7028 6273 796d  sym_for_vjp(bsym
-0001c380: 293a 0a20 2020 2022 2222 0a20 2020 2043  ):.    """.    C
-0001c390: 6865 636b 2069 6620 6120 626f 756e 6420  heck if a bound 
-0001c3a0: 7379 6d62 6f6c 2069 7320 7375 7070 6f72  symbol is suppor
-0001c3b0: 7465 6420 6279 2076 6a70 2e0a 0a20 2020  ted by vjp...   
-0001c3c0: 2041 7267 733a 0a20 2020 2020 2020 2062   Args:.        b
-0001c3d0: 7379 6d20 2842 6f75 6e64 5379 6d62 6f6c  sym (BoundSymbol
-0001c3e0: 293a 2054 6865 2062 6f75 6e64 2073 796d  ): The bound sym
-0001c3f0: 626f 6c20 746f 2063 6865 636b 2e0a 0a20  bol to check... 
-0001c400: 2020 2052 6574 7572 6e73 3a0a 2020 2020     Returns:.    
-0001c410: 2020 2020 626f 6f6c 3a20 5472 7565 2069      bool: True i
-0001c420: 6620 7468 6520 626f 756e 6420 7379 6d62  f the bound symb
-0001c430: 6f6c 2069 7320 7375 7070 6f72 7465 6420  ol is supported 
-0001c440: 6279 2076 6a70 2c20 4661 6c73 6520 6f74  by vjp, False ot
-0001c450: 6865 7277 6973 652e 0a20 2020 2022 2222  herwise..    """
-0001c460: 0a0a 2020 2020 6966 2062 7379 6d2e 7379  ..    if bsym.sy
-0001c470: 6d2e 6964 2069 6e20 7472 616e 7366 6f72  m.id in transfor
-0001c480: 6d5f 736b 6970 5f6c 6973 743a 0a20 2020  m_skip_list:.   
-0001c490: 2020 2020 2072 6574 7572 6e20 5472 7565       return True
-0001c4a0: 0a0a 2020 2020 6966 2062 7379 6d2e 7379  ..    if bsym.sy
-0001c4b0: 6d2e 6964 2069 6e20 6261 636b 7761 7264  m.id in backward
-0001c4c0: 5f69 6d70 6c73 2061 6e64 2062 7379 6d2e  _impls and bsym.
-0001c4d0: 7379 6d2e 6964 2069 6e20 6175 676d 656e  sym.id in augmen
-0001c4e0: 7465 645f 666f 7277 6172 645f 696d 706c  ted_forward_impl
-0001c4f0: 733a 0a20 2020 2020 2020 2072 6574 7572  s:.        retur
-0001c500: 6e20 5472 7565 0a0a 2020 2020 6966 2062  n True..    if b
-0001c510: 7379 6d2e 7379 6d2e 6964 2069 6e20 5f67  sym.sym.id in _g
-0001c520: 7261 645f 666e 5f6d 6170 3a0a 2020 2020  rad_fn_map:.    
-0001c530: 2020 2020 7265 7475 726e 2054 7275 650a      return True.
-0001c540: 0a20 2020 2023 2057 6520 636f 756c 6420  .    # We could 
-0001c550: 6e6f 7420 6669 6e64 2061 2056 4a50 2066  not find a VJP f
-0001c560: 6f72 2074 6869 7320 7379 6d62 6f6c 2c20  or this symbol, 
-0001c570: 736f 2077 6520 7472 7920 746f 2064 6563  so we try to dec
-0001c580: 6f6d 706f 7365 2069 740a 2020 2020 2320  ompose it.    # 
-0001c590: 696e 746f 2073 7562 2d73 796d 626f 6c73  into sub-symbols
-0001c5a0: 2061 6e64 2063 6865 636b 2069 6620 7468   and check if th
-0001c5b0: 6579 2061 7265 2073 7570 706f 7274 6564  ey are supported
-0001c5c0: 0a20 2020 2069 6620 6c65 6e28 6273 796d  .    if len(bsym
-0001c5d0: 2e73 7562 7379 6d62 6f6c 7329 203e 2030  .subsymbols) > 0
-0001c5e0: 2061 6e64 206e 6f74 2062 7379 6d2e 7379   and not bsym.sy
-0001c5f0: 6d2e 6973 5f70 7269 6d3a 0a20 2020 2020  m.is_prim:.     
-0001c600: 2020 2073 7562 7472 6163 6520 3d20 636f     subtrace = co
-0001c610: 6e73 7472 7563 745f 7472 6163 6528 2928  nstruct_trace()(
-0001c620: 6273 796d 2e73 796d 2c20 2a62 7379 6d2e  bsym.sym, *bsym.
-0001c630: 6172 6773 2c20 2a2a 6273 796d 2e6b 7761  args, **bsym.kwa
-0001c640: 7267 7329 0a20 2020 2020 2020 2073 7562  rgs).        sub
-0001c650: 7472 6163 6520 3d20 756e 7772 6170 5f6f  trace = unwrap_o
-0001c660: 6e65 5f6c 6576 656c 5f6f 665f 7375 6273  ne_level_of_subs
-0001c670: 796d 626f 6c73 2873 7562 7472 6163 6529  ymbols(subtrace)
-0001c680: 0a20 2020 2020 2020 2061 6c6c 5f73 7570  .        all_sup
-0001c690: 706f 7274 6564 203d 2061 6c6c 2863 6865  ported = all(che
-0001c6a0: 636b 5f62 7379 6d5f 666f 725f 766a 7028  ck_bsym_for_vjp(
-0001c6b0: 7375 6262 7379 6d29 2066 6f72 2073 7562  subbsym) for sub
-0001c6c0: 6273 796d 2069 6e20 7375 6274 7261 6365  bsym in subtrace
-0001c6d0: 2e62 6f75 6e64 5f73 796d 626f 6c73 290a  .bound_symbols).
-0001c6e0: 2020 2020 2020 2020 7265 7475 726e 2061          return a
-0001c6f0: 6c6c 5f73 7570 706f 7274 6564 0a0a 2020  ll_supported..  
-0001c700: 2020 7265 7475 726e 2046 616c 7365 0a0a    return False..
-0001c710: 0a64 6566 2061 7567 6d65 6e74 6564 5f66  .def augmented_f
-0001c720: 6f72 7761 7264 5f70 6173 7328 2a61 7267  orward_pass(*arg
-0001c730: 732c 2074 7261 6365 3a20 5472 6163 652c  s, trace: Trace,
-0001c740: 202a 2a6b 7761 7267 7329 3a0a 2020 2020   **kwargs):.    
-0001c750: 2222 2241 7567 6d65 6e74 6564 2066 6f72  """Augmented for
-0001c760: 7761 7264 2070 6173 7320 666f 7220 7468  ward pass for th
-0001c770: 6520 564a 5020 7472 616e 7366 6f72 6d2e  e VJP transform.
-0001c780: 0a0a 2020 2020 5468 6520 6175 676d 656e  ..    The augmen
-0001c790: 7465 6420 666f 7277 6172 6420 7061 7373  ted forward pass
-0001c7a0: 2069 7320 6120 666f 7277 6172 6420 7061   is a forward pa
-0001c7b0: 7373 2074 6861 7420 7265 7475 726e 7320  ss that returns 
-0001c7c0: 7468 6520 7265 7369 6475 616c 730a 2020  the residuals.  
-0001c7d0: 2020 6f66 2074 6865 2066 6f72 7761 7264    of the forward
-0001c7e0: 2070 6173 732e 0a20 2020 2054 6865 7365   pass..    These
-0001c7f0: 2072 6573 6964 7561 6c73 2061 7265 2075   residuals are u
-0001c800: 7365 6420 696e 2074 6865 2062 6163 6b77  sed in the backw
-0001c810: 6172 6420 7061 7373 2074 6f20 636f 6d70  ard pass to comp
-0001c820: 7574 6520 7468 6520 564a 5020 616e 6420  ute the VJP and 
-0001c830: 7468 6579 0a20 2020 2061 7265 2072 6563  they.    are rec
-0001c840: 6f72 6465 6420 696e 2074 6865 2065 6e76  orded in the env
-0001c850: 6972 6f6e 6d65 6e74 2064 6963 7469 6f6e  ironment diction
-0001c860: 6172 7920 666f 7220 6561 6368 2076 6172  ary for each var
-0001c870: 6961 626c 652e 0a0a 2020 2020 4172 6773  iable...    Args
-0001c880: 3a0a 2020 2020 2020 2020 6172 6773 2028  :.        args (
-0001c890: 5475 706c 655b 5661 7269 6162 6c65 5d29  Tuple[Variable])
-0001c8a0: 3a20 4172 6775 6d65 6e74 7320 746f 2074  : Arguments to t
-0001c8b0: 6865 2066 756e 6374 696f 6e2e 0a20 2020  he function..   
-0001c8c0: 2020 2020 2074 7261 6365 2028 5472 6163       trace (Trac
-0001c8d0: 6529 3a20 5472 6163 6520 6f66 2074 6865  e): Trace of the
-0001c8e0: 2066 756e 6374 696f 6e2e 0a20 2020 2020   function..     
-0001c8f0: 2020 206b 7761 7267 7320 2844 6963 745b     kwargs (Dict[
-0001c900: 7374 722c 2056 6172 6961 626c 655d 293a  str, Variable]):
-0001c910: 204b 6579 776f 7264 2061 7267 756d 656e   Keyword argumen
-0001c920: 7473 2074 6f20 7468 6520 6675 6e63 7469  ts to the functi
-0001c930: 6f6e 2e0a 0a20 2020 2052 6574 7572 6e73  on...    Returns
-0001c940: 3a0a 2020 2020 2020 2020 5475 706c 655b  :.        Tuple[
-0001c950: 416e 792c 2044 6963 745b 7374 722c 2041  Any, Dict[str, A
-0001c960: 6e79 5d5d 3a20 5475 706c 6520 6f66 2074  ny]]: Tuple of t
-0001c970: 6865 2070 7269 6d61 6c20 6f75 7470 7574  he primal output
-0001c980: 7320 616e 6420 7468 6520 656e 7669 726f  s and the enviro
-0001c990: 6e6d 656e 742e 0a20 2020 2022 2222 0a20  nment..    """. 
-0001c9a0: 2020 2061 7267 732c 206b 7761 7267 7320     args, kwargs 
-0001c9b0: 3d20 7472 6565 5f6d 6170 286c 616d 6264  = tree_map(lambd
-0001c9c0: 6120 783a 2056 4a50 4475 616c 2878 2c20  a x: VJPDual(x, 
-0001c9d0: 7475 706c 6528 2929 2c20 2861 7267 732c  tuple()), (args,
-0001c9e0: 206b 7761 7267 7329 290a 2020 2020 7265   kwargs)).    re
-0001c9f0: 7375 6c74 2c20 656e 7620 3d20 6576 616c  sult, env = eval
-0001ca00: 5f74 7261 6365 280a 2020 2020 2020 2020  _trace(.        
-0001ca10: 7472 6163 652c 0a20 2020 2020 2020 202a  trace,.        *
-0001ca20: 6172 6773 2c0a 2020 2020 2020 2020 2a2a  args,.        **
-0001ca30: 6b77 6172 6773 2c0a 2020 2020 2020 2020  kwargs,.        
-0001ca40: 7769 7468 5f65 6e76 3d54 7275 652c 0a20  with_env=True,. 
-0001ca50: 2020 2020 2020 2073 796d 626f 6c5f 6d61         symbol_ma
-0001ca60: 7070 6572 3d76 6a70 5f73 796d 626f 6c5f  pper=vjp_symbol_
-0001ca70: 6d61 7070 6572 2c0a 2020 2020 290a 2020  mapper,.    ).  
-0001ca80: 2020 7265 7375 6c74 203d 2074 7265 655f    result = tree_
-0001ca90: 6d61 7028 6c61 6d62 6461 2078 3a20 782e  map(lambda x: x.
-0001caa0: 7072 696d 616c 2069 6620 6973 696e 7374  primal if isinst
-0001cab0: 616e 6365 2878 2c20 564a 5044 7561 6c29  ance(x, VJPDual)
-0001cac0: 2065 6c73 6520 782c 2072 6573 756c 7429   else x, result)
-0001cad0: 0a20 2020 2072 6574 7572 6e20 7265 7375  .    return resu
-0001cae0: 6c74 2c20 656e 760a 0a0a 2320 544f 444f  lt, env...# TODO
-0001caf0: 3a20 496e 7374 6561 6420 6f66 2075 7369  : Instead of usi
-0001cb00: 6e67 2074 6865 2065 6e76 6972 6f6e 6d65  ng the environme
-0001cb10: 6e74 2064 6963 7469 6f6e 6172 792c 2077  nt dictionary, w
-0001cb20: 6520 636f 756c 6420 7573 6520 7468 6520  e could use the 
-0001cb30: 7472 6163 650a 2320 7379 6d62 6f6c 7320  trace.# symbols 
-0001cb40: 6f72 6465 7220 2874 6861 7420 7368 6f75  order (that shou
-0001cb50: 6c64 2062 6520 6465 7465 726d 696e 6973  ld be determinis
-0001cb60: 7469 6329 2074 6f20 7265 7472 6965 7665  tic) to retrieve
-0001cb70: 2074 6865 2072 6573 6964 7561 6c73 206e   the residuals n
-0001cb80: 6565 6465 640a 2320 666f 7220 7468 6520  eeded.# for the 
-0001cb90: 6261 636b 7761 7264 2070 6173 732e 0a64  backward pass..d
-0001cba0: 6566 2062 6163 6b77 6172 645f 7061 7373  ef backward_pass
-0001cbb0: 2866 6f72 7761 7264 5f65 6e76 2c20 7472  (forward_env, tr
-0001cbc0: 6163 652c 2069 6e69 745f 636f 7461 6e67  ace, init_cotang
-0001cbd0: 656e 7473 293a 0a20 2020 2022 2222 4261  ents):.    """Ba
-0001cbe0: 636b 7761 7264 2070 6173 7320 666f 7220  ckward pass for 
-0001cbf0: 7468 6520 564a 5020 7472 616e 7366 6f72  the VJP transfor
-0001cc00: 6d2e 0a0a 2020 2020 5468 6520 6261 636b  m...    The back
-0001cc10: 7761 7264 2070 6173 7320 6973 2061 2072  ward pass is a r
-0001cc20: 6576 6572 7365 206d 6f64 6520 6175 746f  everse mode auto
-0001cc30: 6d61 7469 6320 6469 6666 6572 656e 7469  matic differenti
-0001cc40: 6174 696f 6e20 7061 7373 2074 6861 740a  ation pass that.
-0001cc50: 2020 2020 636f 6d70 7574 6573 2074 6865      computes the
-0001cc60: 2076 6563 746f 722d 4a61 636f 6269 616e   vector-Jacobian
-0001cc70: 2070 726f 6475 6374 2028 564a 5029 206f   product (VJP) o
-0001cc80: 6620 7468 6520 6675 6e63 7469 6f6e 2e0a  f the function..
-0001cc90: 0a20 2020 2041 7267 733a 0a20 2020 2020  .    Args:.     
-0001cca0: 2020 2066 6f72 7761 7264 5f65 6e76 2028     forward_env (
-0001ccb0: 4469 6374 5b73 7472 2c20 416e 795d 293a  Dict[str, Any]):
-0001ccc0: 2045 6e76 6972 6f6e 6d65 6e74 206f 6620   Environment of 
-0001ccd0: 7468 6520 666f 7277 6172 6420 7061 7373  the forward pass
-0001cce0: 2e0a 2020 2020 2020 2020 7472 6163 6520  ..        trace 
-0001ccf0: 2854 7261 6365 293a 2054 7261 6365 206f  (Trace): Trace o
-0001cd00: 6620 7468 6520 6675 6e63 7469 6f6e 2e0a  f the function..
-0001cd10: 2020 2020 2020 2020 696e 6974 5f63 6f74          init_cot
-0001cd20: 616e 6765 6e74 7320 2854 7570 6c65 5b56  angents (Tuple[V
-0001cd30: 6172 6961 626c 655d 293a 2049 6e69 7469  ariable]): Initi
-0001cd40: 616c 2063 6f74 616e 6765 6e74 732e 0a0a  al cotangents...
-0001cd50: 2020 2020 5265 7475 726e 733a 0a20 2020      Returns:.   
-0001cd60: 2020 2020 2054 7570 6c65 5b50 726f 7879       Tuple[Proxy
-0001cd70: 2c20 2e2e 2e5d 3a20 5475 706c 6520 6f66  , ...]: Tuple of
-0001cd80: 2074 6865 2072 6573 756c 7473 206f 6620   the results of 
-0001cd90: 7468 6520 6261 636b 7761 7264 2070 6173  the backward pas
-0001cda0: 7320 666f 7220 6561 6368 2069 6e70 7574  s for each input
-0001cdb0: 2e0a 2020 2020 2222 220a 2020 2020 656e  ..    """.    en
-0001cdc0: 7620 3d20 7b7d 0a0a 2020 2020 6465 6620  v = {}..    def 
-0001cdd0: 6765 745f 6772 6164 2878 3a20 5661 7269  get_grad(x: Vari
-0001cde0: 6162 6c65 293a 0a20 2020 2020 2020 2069  able):.        i
-0001cdf0: 6620 6973 696e 7374 616e 6365 2878 2c20  f isinstance(x, 
-0001ce00: 5661 7269 6162 6c65 293a 0a20 2020 2020  Variable):.     
-0001ce10: 2020 2020 2020 2023 2052 6574 7572 6e20         # Return 
-0001ce20: 4e6f 6e65 2069 6620 7468 6520 7661 7269  None if the vari
-0001ce30: 6162 6c65 2077 6173 206e 6f74 2075 7365  able was not use
-0001ce40: 6420 696e 2074 6865 2063 6f6d 7075 7461  d in the computa
-0001ce50: 7469 6f6e 2061 6e64 0a20 2020 2020 2020  tion and.       
-0001ce60: 2020 2020 2023 2068 656e 6365 206e 6f74       # hence not
-0001ce70: 2069 6e20 7468 6520 656e 760a 2020 2020   in the env.    
-0001ce80: 2020 2020 2020 2020 7265 7475 726e 2065          return e
-0001ce90: 6e76 2e67 6574 2878 2e6e 616d 652c 204e  nv.get(x.name, N
-0001cea0: 6f6e 6529 0a20 2020 2020 2020 2065 6c73  one).        els
-0001ceb0: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
-0001cec0: 6574 7572 6e20 780a 0a20 2020 2064 6566  eturn x..    def
-0001ced0: 2070 7574 5f67 7261 6428 763a 2056 6172   put_grad(v: Var
-0001cee0: 6961 626c 652c 2076 616c 3a20 416e 7929  iable, val: Any)
-0001cef0: 202d 3e20 4e6f 6e65 3a0a 2020 2020 2020   -> None:.      
-0001cf00: 2020 6966 2069 7369 6e73 7461 6e63 6528    if isinstance(
-0001cf10: 762c 2056 6172 6961 626c 6529 3a0a 2020  v, Variable):.  
-0001cf20: 2020 2020 2020 2020 2020 6966 2076 2e6e            if v.n
-0001cf30: 616d 6520 696e 2065 6e76 3a0a 2020 2020  ame in env:.    
-0001cf40: 2020 2020 2020 2020 2020 2020 6966 2076              if v
-0001cf50: 616c 2069 7320 4e6f 6e65 3a0a 2020 2020  al is None:.    
-0001cf60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001cf70: 7265 7475 726e 0a20 2020 2020 2020 2020  return.         
-0001cf80: 2020 2020 2020 2023 2041 6363 756d 756c         # Accumul
-0001cf90: 6174 6520 636f 7461 6e67 656e 7473 0a20  ate cotangents. 
-0001cfa0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-0001cfb0: 6e76 5b76 2e6e 616d 655d 203d 2063 6c61  nv[v.name] = cla
-0001cfc0: 6e67 2e61 6464 2865 6e76 5b76 2e6e 616d  ng.add(env[v.nam
-0001cfd0: 655d 2c20 7661 6c29 2069 6620 656e 765b  e], val) if env[
-0001cfe0: 762e 6e61 6d65 5d20 6973 206e 6f74 204e  v.name] is not N
-0001cff0: 6f6e 6520 656c 7365 2076 616c 0a20 2020  one else val.   
-0001d000: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-0001d010: 7572 6e0a 2020 2020 2020 2020 2020 2020  urn.            
-0001d020: 656e 765b 762e 6e61 6d65 5d20 3d20 7661  env[v.name] = va
-0001d030: 6c0a 2020 2020 2020 2020 656c 6966 2069  l.        elif i
-0001d040: 7369 6e73 7461 6e63 6528 762c 2053 6571  sinstance(v, Seq
-0001d050: 7565 6e63 6529 2061 6e64 2061 6c6c 2869  uence) and all(i
-0001d060: 7369 6e73 7461 6e63 6528 782c 2069 6e74  sinstance(x, int
-0001d070: 2920 666f 7220 7820 696e 2076 293a 0a20  ) for x in v):. 
-0001d080: 2020 2020 2020 2020 2020 2023 2054 4f44             # TOD
-0001d090: 4f3a 2072 656d 6f76 6520 7768 656e 2077  O: remove when w
-0001d0a0: 6520 6d6f 7665 2064 696d 7320 746f 206b  e move dims to k
-0001d0b0: 7761 7267 730a 2020 2020 2020 2020 2020  wargs.          
-0001d0c0: 2020 7061 7373 0a20 2020 2020 2020 2065    pass.        e
-0001d0d0: 6c69 6620 6973 696e 7374 616e 6365 2876  lif isinstance(v
-0001d0e0: 2c20 7374 7229 3a0a 2020 2020 2020 2020  , str):.        
-0001d0f0: 2020 2020 656e 765b 765d 203d 2076 616c      env[v] = val
-0001d100: 0a20 2020 2020 2020 2065 6c69 6620 6973  .        elif is
-0001d110: 696e 7374 616e 6365 2876 2c20 5365 7175  instance(v, Sequ
-0001d120: 656e 6365 2920 616e 6420 7661 6c20 6973  ence) and val is
-0001d130: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
-0001d140: 2020 2023 2062 726f 6164 6361 7374 204e     # broadcast N
-0001d150: 6f6e 6520 746f 2074 6865 2072 6967 6874  one to the right
-0001d160: 2073 6861 7065 0a20 2020 2020 2020 2020   shape.         
-0001d170: 2020 2073 6166 655f 6d61 7028 7075 745f     safe_map(put_
-0001d180: 6772 6164 2c20 762c 205b 4e6f 6e65 5d20  grad, v, [None] 
-0001d190: 2a20 6c65 6e28 7629 290a 2020 2020 2020  * len(v)).      
-0001d1a0: 2020 656c 6966 2069 7369 6e73 7461 6e63    elif isinstanc
-0001d1b0: 6528 762c 2053 6571 7565 6e63 6529 2061  e(v, Sequence) a
-0001d1c0: 6e64 2069 7369 6e73 7461 6e63 6528 7661  nd isinstance(va
-0001d1d0: 6c2c 2053 6571 7565 6e63 6529 3a0a 2020  l, Sequence):.  
-0001d1e0: 2020 2020 2020 2020 2020 7361 6665 5f6d            safe_m
-0001d1f0: 6170 5f66 6c61 7428 7075 745f 6772 6164  ap_flat(put_grad
-0001d200: 2c20 762c 2076 616c 290a 2020 2020 2020  , v, val).      
-0001d210: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-0001d220: 2020 2020 2320 536b 6970 2077 7269 7469      # Skip writi
-0001d230: 6e67 2074 6f20 636f 6e73 7461 6e74 730a  ng to constants.
-0001d240: 2020 2020 2020 2020 2020 2020 7061 7373              pass
-0001d250: 0a0a 2020 2020 6966 2069 7369 6e73 7461  ..    if isinsta
-0001d260: 6e63 6528 696e 6974 5f63 6f74 616e 6765  nce(init_cotange
-0001d270: 6e74 732c 2053 6571 7565 6e63 6529 2061  nts, Sequence) a
-0001d280: 6e64 206c 656e 2869 6e69 745f 636f 7461  nd len(init_cota
-0001d290: 6e67 656e 7473 2920 3d3d 2031 2061 6e64  ngents) == 1 and
-0001d2a0: 206e 6f74 2069 7369 6e73 7461 6e63 6528   not isinstance(
-0001d2b0: 7472 6163 652e 6f75 7470 7574 2c20 5365  trace.output, Se
-0001d2c0: 7175 656e 6365 293a 0a20 2020 2020 2020  quence):.       
-0001d2d0: 2069 6e69 745f 636f 7461 6e67 656e 7473   init_cotangents
-0001d2e0: 203d 2069 6e69 745f 636f 7461 6e67 656e   = init_cotangen
-0001d2f0: 7473 5b30 5d0a 2020 2020 7361 6665 5f6d  ts[0].    safe_m
-0001d300: 6170 5f66 6c61 7428 7075 745f 6772 6164  ap_flat(put_grad
-0001d310: 2c20 7472 6163 652e 6f75 7470 7574 2c20  , trace.output, 
-0001d320: 696e 6974 5f63 6f74 616e 6765 6e74 7329  init_cotangents)
-0001d330: 0a0a 2020 2020 666f 7220 7379 6d62 6f6c  ..    for symbol
-0001d340: 2069 6e20 7265 7665 7273 6564 286c 6973   in reversed(lis
-0001d350: 7428 6974 6572 5f62 6f75 6e64 5f73 796d  t(iter_bound_sym
-0001d360: 626f 6c73 2874 7261 6365 2e62 6f75 6e64  bols(trace.bound
-0001d370: 5f73 796d 626f 6c73 2929 293a 0a20 2020  _symbols))):.   
-0001d380: 2020 2020 2073 796d 626f 6c5f 6f75 7470       symbol_outp
-0001d390: 7574 203d 2073 6571 7565 6e63 6966 7928  ut = sequencify(
-0001d3a0: 7379 6d62 6f6c 2e6f 7574 7075 7429 0a0a  symbol.output)..
-0001d3b0: 2020 2020 2020 2020 636f 7461 6e67 656e          cotangen
-0001d3c0: 7473 203d 2074 7265 655f 6d61 7028 6765  ts = tree_map(ge
-0001d3d0: 745f 6772 6164 2c20 7379 6d62 6f6c 5f6f  t_grad, symbol_o
-0001d3e0: 7574 7075 7429 0a20 2020 2020 2020 2023  utput).        #
-0001d3f0: 2048 6176 696e 6720 6120 7369 6e67 6c65   Having a single
-0001d400: 2063 6f74 616e 6765 6e74 2069 7320 6120   cotangent is a 
-0001d410: 636f 6d6d 6f6e 2063 6173 652c 2073 6f20  common case, so 
-0001d420: 7765 2066 6c61 7474 656e 2069 740a 2020  we flatten it.  
-0001d430: 2020 2020 2020 2320 4f74 6865 7277 6973        # Otherwis
-0001d440: 652c 2077 6520 7769 6c6c 206e 6565 6420  e, we will need 
-0001d450: 746f 2072 6577 7269 7465 2074 6865 2070  to rewrite the p
-0001d460: 756c 6c62 6163 6b20 6675 6e63 7469 6f6e  ullback function
-0001d470: 730a 2020 2020 2020 2020 636f 7461 6e67  s.        cotang
-0001d480: 656e 7473 203d 2074 7265 655f 666c 6174  ents = tree_flat
-0001d490: 7465 6e28 636f 7461 6e67 656e 7473 295b  ten(cotangents)[
-0001d4a0: 305d 0a20 2020 2020 2020 2072 6573 6964  0].        resid
-0001d4b0: 7561 6c73 203d 2066 6f72 7761 7264 5f65  uals = forward_e
-0001d4c0: 6e76 5b73 796d 626f 6c5f 6f75 7470 7574  nv[symbol_output
-0001d4d0: 5b30 5d2e 6e61 6d65 5d2e 7265 7369 6475  [0].name].residu
-0001d4e0: 616c 730a 2020 2020 2020 2020 6966 2069  als.        if i
-0001d4f0: 735f 636f 6e73 7461 6e74 5f66 6f72 5f76  s_constant_for_v
-0001d500: 6a70 2873 796d 626f 6c29 3a0a 2020 2020  jp(symbol):.    
-0001d510: 2020 2020 2020 2020 2320 5765 2063 616e          # We can
-0001d520: 2073 6b69 7020 7468 6520 7075 6c6c 6261   skip the pullba
-0001d530: 636b 2069 6620 616c 6c20 7468 6520 6172  ck if all the ar
-0001d540: 6775 6d65 6e74 7320 6172 6520 636f 6e73  guments are cons
-0001d550: 7461 6e74 0a20 2020 2020 2020 2020 2020  tant.           
-0001d560: 2063 6f6e 7469 6e75 650a 0a20 2020 2020   continue..     
-0001d570: 2020 2069 6620 616c 6c28 636f 7461 6e67     if all(cotang
-0001d580: 656e 7420 6973 204e 6f6e 6520 666f 7220  ent is None for 
-0001d590: 636f 7461 6e67 656e 7420 696e 2063 6f74  cotangent in cot
-0001d5a0: 616e 6765 6e74 7329 3a0a 2020 2020 2020  angents):.      
-0001d5b0: 2020 2020 2020 2320 5765 2063 616e 2073        # We can s
-0001d5c0: 6b69 7020 7468 6520 7075 6c6c 6261 636b  kip the pullback
-0001d5d0: 2069 6620 7468 6520 636f 7461 6e67 656e   if the cotangen
-0001d5e0: 7420 6973 204e 6f6e 650a 2020 2020 2020  t is None.      
-0001d5f0: 2020 2020 2020 7361 6665 5f6d 6170 2870        safe_map(p
-0001d600: 7574 5f67 7261 642c 2073 796d 626f 6c2e  ut_grad, symbol.
-0001d610: 6172 6773 2c20 284e 6f6e 652c 2920 2a20  args, (None,) * 
-0001d620: 6c65 6e28 7379 6d62 6f6c 2e61 7267 7329  len(symbol.args)
-0001d630: 290a 2020 2020 2020 2020 2020 2020 636f  ).            co
-0001d640: 6e74 696e 7565 0a0a 2020 2020 2020 2020  ntinue..        
-0001d650: 6966 2073 796d 626f 6c2e 7379 6d2e 6964  if symbol.sym.id
-0001d660: 203d 3d20 2274 6f72 6368 2e6e 6e2e 6675   == "torch.nn.fu
-0001d670: 6e63 7469 6f6e 616c 2e64 726f 706f 7574  nctional.dropout
-0001d680: 2220 616e 6420 6e6f 7420 7379 6d62 6f6c  " and not symbol
-0001d690: 2e73 7562 7379 6d62 6f6c 733a 0a20 2020  .subsymbols:.   
-0001d6a0: 2020 2020 2020 2020 2023 2057 6520 6361           # We ca
-0001d6b0: 6e20 736b 6970 2074 6865 2070 756c 6c62  n skip the pullb
-0001d6c0: 6163 6b20 6966 2074 6865 2064 726f 706f  ack if the dropo
-0001d6d0: 7574 2070 726f 6261 6269 6c69 7479 2069  ut probability i
-0001d6e0: 7320 302e 300a 2020 2020 2020 2020 2020  s 0.0.          
-0001d6f0: 2020 2320 4173 7375 6d69 6e67 2074 6861    # Assuming tha
-0001d700: 7420 7468 6520 6472 6f70 6f75 7420 7379  t the dropout sy
-0001d710: 6d62 6f6c 2068 6173 2074 6865 2073 616d  mbol has the sam
-0001d720: 6520 6f75 7470 7574 2061 6e64 2061 7267  e output and arg
-0001d730: 756d 656e 740a 2020 2020 2020 2020 2020  ument.          
-0001d740: 2020 6173 7365 7274 2073 796d 626f 6c2e    assert symbol.
-0001d750: 6f75 7470 7574 2e6e 616d 6520 3d3d 2073  output.name == s
-0001d760: 796d 626f 6c2e 6172 6773 5b30 5d2e 6e61  ymbol.args[0].na
-0001d770: 6d65 2c20 2244 726f 706f 7574 2073 796d  me, "Dropout sym
-0001d780: 626f 6c20 6861 7320 6120 6469 6666 6572  bol has a differ
-0001d790: 656e 7420 6f75 7470 7574 2061 6e64 2061  ent output and a
-0001d7a0: 7267 756d 656e 7422 0a20 2020 2020 2020  rgument".       
-0001d7b0: 2020 2020 2069 6620 7379 6d62 6f6c 2e61       if symbol.a
-0001d7c0: 7267 735b 315d 203d 3d20 302e 3020 6f72  rgs[1] == 0.0 or
-0001d7d0: 2073 796d 626f 6c2e 6172 6773 5b32 5d20   symbol.args[2] 
-0001d7e0: 6973 2046 616c 7365 3a0a 2020 2020 2020  is False:.      
-0001d7f0: 2020 2020 2020 2020 2020 636f 6e74 696e            contin
-0001d800: 7565 0a0a 2020 2020 2020 2020 6261 636b  ue..        back
-0001d810: 7761 7264 203d 2062 6163 6b77 6172 645f  ward = backward_
-0001d820: 696d 706c 732e 6765 7428 7379 6d62 6f6c  impls.get(symbol
-0001d830: 2e73 796d 2e69 6429 0a20 2020 2020 2020  .sym.id).       
-0001d840: 2061 7567 5f66 6f72 7761 7264 203d 2061   aug_forward = a
-0001d850: 7567 6d65 6e74 6564 5f66 6f72 7761 7264  ugmented_forward
-0001d860: 5f69 6d70 6c73 2e67 6574 2873 796d 626f  _impls.get(symbo
-0001d870: 6c2e 7379 6d2e 6964 290a 0a20 2020 2020  l.sym.id)..     
-0001d880: 2020 2069 6620 5f67 6574 5f67 7261 6466     if _get_gradf
-0001d890: 6e5f 616e 645f 6578 6563 7574 6f72 2873  n_and_executor(s
-0001d8a0: 796d 626f 6c29 5b30 5d20 6973 206e 6f74  ymbol)[0] is not
-0001d8b0: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
-0001d8c0: 2020 2061 7567 5f66 6f72 7761 7264 2c20     aug_forward, 
-0001d8d0: 6261 636b 7761 7264 203d 206d 616b 655f  backward = make_
-0001d8e0: 6175 675f 666f 7277 6172 645f 616e 645f  aug_forward_and_
-0001d8f0: 6261 636b 7761 7264 2873 796d 626f 6c29  backward(symbol)
-0001d900: 0a0a 2020 2020 2020 2020 6966 2062 6163  ..        if bac
-0001d910: 6b77 6172 6420 6973 204e 6f6e 653a 0a20  kward is None:. 
-0001d920: 2020 2020 2020 2020 2020 2069 6620 6c65             if le
-0001d930: 6e28 7379 6d62 6f6c 2e73 7562 7379 6d62  n(symbol.subsymb
-0001d940: 6f6c 7329 203e 2030 2061 6e64 206e 6f74  ols) > 0 and not
-0001d950: 2069 7369 6e73 7461 6e63 6528 7379 6d62   isinstance(symb
-0001d960: 6f6c 2e73 796d 2e69 642c 2070 7269 6d73  ol.sym.id, prims
-0001d970: 2e50 7269 6d49 4473 293a 0a20 2020 2020  .PrimIDs):.     
-0001d980: 2020 2020 2020 2020 2020 2023 2057 6520             # We 
-0001d990: 636f 756c 6420 6e6f 7420 6669 6e64 2061  could not find a
-0001d9a0: 2062 6163 6b77 6172 6420 666f 7220 7468   backward for th
-0001d9b0: 6973 2073 796d 626f 6c2c 2073 6f20 7765  is symbol, so we
-0001d9c0: 2074 7279 2074 6f20 6465 636f 6d70 6f73   try to decompos
-0001d9d0: 6520 6974 0a20 2020 2020 2020 2020 2020  e it.           
-0001d9e0: 2020 2020 2062 6163 6b77 6172 6420 3d20       backward = 
-0001d9f0: 7061 7274 6961 6c28 6465 636f 6d70 6f73  partial(decompos
-0001da00: 6564 5f66 6e5f 6261 636b 7761 7264 5f72  ed_fn_backward_r
-0001da10: 756c 652c 2073 796d 626f 6c2e 7379 6d29  ule, symbol.sym)
-0001da20: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
-0001da30: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-0001da40: 2020 2023 2057 6520 636f 756c 6420 6e6f     # We could no
-0001da50: 7420 6669 6e64 2061 2062 6163 6b77 6172  t find a backwar
-0001da60: 6420 666f 7220 7468 6973 2073 796d 626f  d for this symbo
-0001da70: 6c20 616e 6420 7765 2063 6f75 6c64 206e  l and we could n
-0001da80: 6f74 2064 6563 6f6d 706f 7365 2069 740a  ot decompose it.
-0001da90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001daa0: 7261 6973 6520 4e6f 7449 6d70 6c65 6d65  raise NotImpleme
-0001dab0: 6e74 6564 4572 726f 7228 6622 4261 636b  ntedError(f"Back
-0001dac0: 7761 7264 2066 6f72 207b 7379 6d62 6f6c  ward for {symbol
-0001dad0: 2e73 796d 2e69 647d 2069 7320 6e6f 7420  .sym.id} is not 
-0001dae0: 696d 706c 656d 656e 7465 6422 290a 0a20  implemented").. 
-0001daf0: 2020 2020 2020 2072 6573 756c 7420 3d20         result = 
-0001db00: 6261 636b 7761 7264 282a 7265 7369 6475  backward(*residu
-0001db10: 616c 732c 202a 636f 7461 6e67 656e 7473  als, *cotangents
-0001db20: 290a 2020 2020 2020 2020 6966 2069 7369  ).        if isi
-0001db30: 6e73 7461 6e63 6528 7265 7375 6c74 2c20  nstance(result, 
-0001db40: 6469 6374 293a 0a20 2020 2020 2020 2020  dict):.         
-0001db50: 2020 2023 2049 6620 7468 6520 6261 636b     # If the back
-0001db60: 7761 7264 2072 6574 7572 6e73 2061 2064  ward returns a d
-0001db70: 6963 742c 2077 6520 6173 7375 6d65 2074  ict, we assume t
-0001db80: 6861 7420 6974 2069 7320 6120 6469 6374  hat it is a dict
-0001db90: 206f 660a 2020 2020 2020 2020 2020 2020   of.            
-0001dba0: 2320 666f 7277 6172 6420 6172 6775 6d65  # forward argume
-0001dbb0: 6e74 7320 746f 2074 6865 2063 6f72 7265  nts to the corre
-0001dbc0: 7370 6f6e 6469 6e67 0a20 2020 2020 2020  sponding.       
-0001dbd0: 2020 2020 2023 2067 7261 6469 656e 7473       # gradients
-0001dbe0: 2f63 6f74 616e 6765 6e74 732f 6164 6a6f  /cotangents/adjo
-0001dbf0: 696e 7473 2f73 656e 7369 7469 7669 7469  ints/sensitiviti
-0001dc00: 6573 2e0a 2020 2020 2020 2020 2020 2020  es..            
-0001dc10: 7573 6564 5f6e 616d 6573 203d 2073 6574  used_names = set
-0001dc20: 2829 0a20 2020 2020 2020 2020 2020 2066  ().            f
-0001dc30: 6f72 2069 2c20 286b 2c20 7629 2069 6e20  or i, (k, v) in 
-0001dc40: 656e 756d 6572 6174 6528 696e 7370 6563  enumerate(inspec
-0001dc50: 742e 7369 676e 6174 7572 6528 6175 675f  t.signature(aug_
-0001dc60: 666f 7277 6172 6429 2e70 6172 616d 6574  forward).paramet
-0001dc70: 6572 732e 6974 656d 7328 2929 3a0a 2020  ers.items()):.  
-0001dc80: 2020 2020 2020 2020 2020 2020 2020 6966                if
-0001dc90: 2076 2e6b 696e 6420 696e 2028 696e 7370   v.kind in (insp
-0001dca0: 6563 742e 5061 7261 6d65 7465 722e 504f  ect.Parameter.PO
-0001dcb0: 5349 5449 4f4e 414c 5f4f 4e4c 592c 2069  SITIONAL_ONLY, i
-0001dcc0: 6e73 7065 6374 2e50 6172 616d 6574 6572  nspect.Parameter
-0001dcd0: 2e50 4f53 4954 494f 4e41 4c5f 4f52 5f4b  .POSITIONAL_OR_K
-0001dce0: 4559 574f 5244 293a 0a20 2020 2020 2020  EYWORD):.       
-0001dcf0: 2020 2020 2020 2020 2020 2020 2070 7574               put
-0001dd00: 5f67 7261 6428 7379 6d62 6f6c 2e61 7267  _grad(symbol.arg
-0001dd10: 735b 695d 2c20 7265 7375 6c74 2e67 6574  s[i], result.get
-0001dd20: 286b 2c20 4e6f 6e65 2929 0a20 2020 2020  (k, None)).     
-0001dd30: 2020 2020 2020 2020 2020 2020 2020 2075                 u
-0001dd40: 7365 645f 6e61 6d65 732e 6164 6428 6b29  sed_names.add(k)
-0001dd50: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-0001dd60: 466f 7220 6465 7665 6c6f 7065 7220 636f  For developer co
-0001dd70: 6e76 656e 6965 6e63 652c 2077 6520 616c  nvenience, we al
-0001dd80: 6c6f 7720 7573 696e 6720 7468 6520 6e61  low using the na
-0001dd90: 6d65 2066 726f 6d20 7468 650a 2020 2020  me from the.    
-0001dda0: 2020 2020 2020 2020 2320 666f 7277 6172          # forwar
-0001ddb0: 6420 6d65 7461 2069 6e20 6164 6469 7469  d meta in additi
-0001ddc0: 6f6e 2074 6f20 7468 6520 6e61 6d65 2066  on to the name f
-0001ddd0: 726f 6d20 7468 6520 6175 676d 656e 7465  rom the augmente
-0001dde0: 6420 666f 7277 6172 640a 2020 2020 2020  d forward.      
-0001ddf0: 2020 2020 2020 2320 7369 676e 6174 7572        # signatur
-0001de00: 652e 0a20 2020 2020 2020 2020 2020 2023  e..            #
-0001de10: 2049 6620 626f 7468 206e 616d 6573 2061   If both names a
-0001de20: 7265 2075 7365 642c 2074 6865 206f 6e65  re used, the one
-0001de30: 2066 726f 6d20 7468 6520 666f 7277 6172   from the forwar
-0001de40: 6420 6d65 7461 2074 616b 6573 0a20 2020  d meta takes.   
-0001de50: 2020 2020 2020 2020 2023 2070 7265 6365           # prece
-0001de60: 6465 6e63 652e 0a20 2020 2020 2020 2020  dence..         
-0001de70: 2020 2066 6f72 2069 2c20 286b 2c20 7629     for i, (k, v)
-0001de80: 2069 6e20 656e 756d 6572 6174 6528 696e   in enumerate(in
-0001de90: 7370 6563 742e 7369 676e 6174 7572 6528  spect.signature(
-0001dea0: 7379 6d62 6f6c 2e73 796d 2e6d 6574 6129  symbol.sym.meta)
-0001deb0: 2e70 6172 616d 6574 6572 732e 6974 656d  .parameters.item
-0001dec0: 7328 2929 3a0a 2020 2020 2020 2020 2020  s()):.          
-0001ded0: 2020 2020 2020 6966 2076 2e6b 696e 6420        if v.kind 
-0001dee0: 696e 2028 696e 7370 6563 742e 5061 7261  in (inspect.Para
-0001def0: 6d65 7465 722e 504f 5349 5449 4f4e 414c  meter.POSITIONAL
-0001df00: 5f4f 4e4c 592c 2069 6e73 7065 6374 2e50  _ONLY, inspect.P
-0001df10: 6172 616d 6574 6572 2e50 4f53 4954 494f  arameter.POSITIO
-0001df20: 4e41 4c5f 4f52 5f4b 4559 574f 5244 293a  NAL_OR_KEYWORD):
+00014ac0: 6d73 2e65 7870 3228 7829 2c20 2870 7269  ms.exp2(x), (pri
+00014ad0: 6d73 2e65 7870 3228 7829 2c29 292c 0a20  ms.exp2(x),)),. 
+00014ae0: 2020 2070 7269 6d73 2e50 7269 6d49 4473     prims.PrimIDs
+00014af0: 2e45 5850 4d31 3a20 6c61 6d62 6461 2078  .EXPM1: lambda x
+00014b00: 3a20 2870 7269 6d73 2e65 7870 6d31 2878  : (prims.expm1(x
+00014b10: 292c 2028 7072 696d 732e 6578 706d 3128  ), (prims.expm1(
+00014b20: 7829 2c29 292c 0a20 2020 2070 7269 6d73  x),)),.    prims
+00014b30: 2e50 7269 6d49 4473 2e4c 4741 4d4d 413a  .PrimIDs.LGAMMA:
+00014b40: 206c 616d 6264 6120 783a 2028 7072 696d   lambda x: (prim
+00014b50: 732e 6c67 616d 6d61 2878 292c 2028 782c  s.lgamma(x), (x,
+00014b60: 2929 2c0a 2020 2020 7072 696d 732e 5072  )),.    prims.Pr
+00014b70: 696d 4944 732e 4e44 5452 493a 206c 616d  imIDs.NDTRI: lam
+00014b80: 6264 6120 783a 2028 7072 696d 732e 6e64  bda x: (prims.nd
+00014b90: 7472 6928 7829 2c20 2870 7269 6d73 2e6e  tri(x), (prims.n
+00014ba0: 6474 7269 2878 292c 2929 2c0a 2020 2020  dtri(x),)),.    
+00014bb0: 7072 696d 732e 5072 696d 4944 732e 5349  prims.PrimIDs.SI
+00014bc0: 4e48 3a20 6c61 6d62 6461 2078 3a20 2870  NH: lambda x: (p
+00014bd0: 7269 6d73 2e73 696e 6828 7829 2c20 2878  rims.sinh(x), (x
+00014be0: 2c29 292c 0a20 2020 2070 7269 6d73 2e50  ,)),.    prims.P
+00014bf0: 7269 6d49 4473 2e53 5152 543a 206c 616d  rimIDs.SQRT: lam
+00014c00: 6264 6120 783a 2028 7072 696d 732e 7371  bda x: (prims.sq
+00014c10: 7274 2878 292c 2028 7072 696d 732e 7371  rt(x), (prims.sq
+00014c20: 7274 2878 292c 2929 2c0a 2020 2020 7072  rt(x),)),.    pr
+00014c30: 696d 732e 5072 696d 4944 732e 4c4f 4731  ims.PrimIDs.LOG1
+00014c40: 303a 206c 616d 6264 6120 783a 2028 7072  0: lambda x: (pr
+00014c50: 696d 732e 6c6f 6731 3028 7829 2c20 2878  ims.log10(x), (x
+00014c60: 2c29 292c 0a20 2020 2070 7269 6d73 2e50  ,)),.    prims.P
+00014c70: 7269 6d49 4473 2e4c 4f47 3150 3a20 6c61  rimIDs.LOG1P: la
+00014c80: 6d62 6461 2078 3a20 2870 7269 6d73 2e6c  mbda x: (prims.l
+00014c90: 6f67 3170 2878 292c 2028 782c 2929 2c0a  og1p(x), (x,)),.
+00014ca0: 2020 2020 7072 696d 732e 5072 696d 4944      prims.PrimID
+00014cb0: 732e 4c4f 4732 3a20 6c61 6d62 6461 2078  s.LOG2: lambda x
+00014cc0: 3a20 2870 7269 6d73 2e6c 6f67 3228 7829  : (prims.log2(x)
+00014cd0: 2c20 2878 2c29 292c 0a20 2020 2070 7269  , (x,)),.    pri
+00014ce0: 6d73 2e50 7269 6d49 4473 2e5a 4554 413a  ms.PrimIDs.ZETA:
+00014cf0: 206c 616d 6264 6120 782c 2079 3a20 2870   lambda x, y: (p
+00014d00: 7269 6d73 2e7a 6574 6128 782c 2079 292c  rims.zeta(x, y),
+00014d10: 2028 782c 2079 2929 2c0a 2020 2020 7072   (x, y)),.    pr
+00014d20: 696d 732e 5072 696d 4944 732e 464d 4f44  ims.PrimIDs.FMOD
+00014d30: 3a20 6c61 6d62 6461 2078 2c20 793a 2028  : lambda x, y: (
+00014d40: 7072 696d 732e 666d 6f64 2878 2c20 7929  prims.fmod(x, y)
+00014d50: 2c20 2878 2c20 7929 292c 0a20 2020 2070  , (x, y)),.    p
+00014d60: 7269 6d73 2e50 7269 6d49 4473 2e43 4f50  rims.PrimIDs.COP
+00014d70: 595f 3a20 6c61 6d62 6461 2078 2c20 793a  Y_: lambda x, y:
+00014d80: 2028 7072 696d 732e 636f 7079 5f28 782c   (prims.copy_(x,
+00014d90: 2079 292c 2074 7570 6c65 2829 292c 0a7d   y), tuple()),.}
+00014da0: 0a0a 0a23 204d 6170 7069 6e67 2066 726f  ...# Mapping fro
+00014db0: 6d20 7379 6d62 6f6c 7320 746f 2062 6163  m symbols to bac
+00014dc0: 6b77 6172 6420 6675 6e63 7469 6f6e 7320  kward functions 
+00014dd0: 7573 6564 2069 6e20 564a 500a 2320 5468  used in VJP.# Th
+00014de0: 6520 6261 636b 7761 7264 2066 756e 6374  e backward funct
+00014df0: 696f 6e20 7461 6b65 7320 7468 6520 7265  ion takes the re
+00014e00: 7369 6475 616c 7320 616e 6420 636f 7461  siduals and cota
+00014e10: 6e67 656e 7473 2061 6e64 2072 6574 7572  ngents and retur
+00014e20: 6e73 2074 6865 0a23 2076 6563 746f 722d  ns the.# vector-
+00014e30: 4a61 636f 6269 616e 2070 726f 6475 6374  Jacobian product
+00014e40: 7320 666f 7220 6561 6368 2061 7267 756d  s for each argum
+00014e50: 656e 742e 0a62 6163 6b77 6172 645f 696d  ent..backward_im
+00014e60: 706c 7320 3d20 7b0a 2020 2020 7072 696d  pls = {.    prim
+00014e70: 732e 5072 696d 4944 732e 4143 4f53 3a20  s.PrimIDs.ACOS: 
+00014e80: 6c61 6d62 6461 2078 2c20 673a 202d 6720  lambda x, g: -g 
+00014e90: 2f20 7072 696d 732e 7371 7274 2831 2e30  / prims.sqrt(1.0
+00014ea0: 202d 2078 202a 2078 292c 0a20 2020 2070   - x * x),.    p
+00014eb0: 7269 6d73 2e50 7269 6d49 4473 2e41 434f  rims.PrimIDs.ACO
+00014ec0: 5348 3a20 6c61 6d62 6461 2078 2c20 673a  SH: lambda x, g:
+00014ed0: 2067 202a 2070 7269 6d73 2e72 7371 7274   g * prims.rsqrt
+00014ee0: 2878 202a 2078 202d 2031 2e30 292c 0a20  (x * x - 1.0),. 
+00014ef0: 2020 2070 7269 6d73 2e50 7269 6d49 4473     prims.PrimIDs
+00014f00: 2e41 5349 4e3a 206c 616d 6264 6120 782c  .ASIN: lambda x,
+00014f10: 2067 3a20 6720 2f20 7072 696d 732e 7371   g: g / prims.sq
+00014f20: 7274 2831 2e30 202d 2078 202a 2078 292c  rt(1.0 - x * x),
+00014f30: 0a20 2020 2070 7269 6d73 2e50 7269 6d49  .    prims.PrimI
+00014f40: 4473 2e41 5349 4e48 3a20 6c61 6d62 6461  Ds.ASINH: lambda
+00014f50: 2078 2c20 673a 2067 202a 2070 7269 6d73   x, g: g * prims
+00014f60: 2e72 7371 7274 2831 2e30 202b 2078 202a  .rsqrt(1.0 + x *
+00014f70: 2078 292c 0a20 2020 2070 7269 6d73 2e50   x),.    prims.P
+00014f80: 7269 6d49 4473 2e41 5441 4e3a 206c 616d  rimIDs.ATAN: lam
+00014f90: 6264 6120 782c 2067 3a20 6720 2f20 2831  bda x, g: g / (1
+00014fa0: 2e30 202b 2078 202a 2078 292c 0a20 2020  .0 + x * x),.   
+00014fb0: 2070 7269 6d73 2e50 7269 6d49 4473 2e41   prims.PrimIDs.A
+00014fc0: 5441 4e48 3a20 6c61 6d62 6461 2078 2c20  TANH: lambda x, 
+00014fd0: 673a 2067 202f 2028 312e 3020 2d20 7820  g: g / (1.0 - x 
+00014fe0: 2a20 7829 2c0a 2020 2020 7072 696d 732e  * x),.    prims.
+00014ff0: 5072 696d 4944 732e 434f 5348 3a20 6c61  PrimIDs.COSH: la
+00015000: 6d62 6461 2078 2c20 673a 2070 7269 6d73  mbda x, g: prims
+00015010: 2e6d 756c 2867 2c20 7072 696d 732e 7369  .mul(g, prims.si
+00015020: 6e68 2878 2929 2c0a 2020 2020 7072 696d  nh(x)),.    prim
+00015030: 732e 5072 696d 4944 732e 4552 4643 3a20  s.PrimIDs.ERFC: 
+00015040: 6c61 6d62 6461 2078 2c20 673a 202d 6720  lambda x, g: -g 
+00015050: 2a20 322e 3020 2f20 6d61 7468 2e73 7172  * 2.0 / math.sqr
+00015060: 7428 6d61 7468 2e70 6929 202a 2070 7269  t(math.pi) * pri
+00015070: 6d73 2e65 7870 282d 7820 2a20 7829 2c0a  ms.exp(-x * x),.
+00015080: 2020 2020 7072 696d 732e 5072 696d 4944      prims.PrimID
+00015090: 732e 4552 4649 4e56 3a20 6c61 6d62 6461  s.ERFINV: lambda
+000150a0: 2072 6573 756c 742c 2067 3a20 6720 2a20   result, g: g * 
+000150b0: 302e 3520 2a20 6d61 7468 2e73 7172 7428  0.5 * math.sqrt(
+000150c0: 6d61 7468 2e70 6929 202a 2070 7269 6d73  math.pi) * prims
+000150d0: 2e65 7870 2872 6573 756c 742a 2a32 292c  .exp(result**2),
+000150e0: 0a20 2020 2070 7269 6d73 2e50 7269 6d49  .    prims.PrimI
+000150f0: 4473 2e45 5246 4349 4e56 3a20 6c61 6d62  Ds.ERFCINV: lamb
+00015100: 6461 2072 6573 756c 742c 2067 3a20 2d67  da result, g: -g
+00015110: 202a 2030 2e35 202a 206d 6174 682e 7371   * 0.5 * math.sq
+00015120: 7274 286d 6174 682e 7069 2920 2a20 7072  rt(math.pi) * pr
+00015130: 696d 732e 6578 7028 7265 7375 6c74 2a2a  ims.exp(result**
+00015140: 3229 2c0a 2020 2020 7072 696d 732e 5072  2),.    prims.Pr
+00015150: 696d 4944 732e 4558 5032 3a20 6c61 6d62  imIDs.EXP2: lamb
+00015160: 6461 2072 6573 756c 742c 2067 3a20 6720  da result, g: g 
+00015170: 2a20 7265 7375 6c74 202a 206d 6174 682e  * result * math.
+00015180: 6c6f 6728 322e 3029 2c0a 2020 2020 7072  log(2.0),.    pr
+00015190: 696d 732e 5072 696d 4944 732e 4558 504d  ims.PrimIDs.EXPM
+000151a0: 313a 206c 616d 6264 6120 7265 7375 6c74  1: lambda result
+000151b0: 2c20 673a 2067 202a 2028 7265 7375 6c74  , g: g * (result
+000151c0: 202b 2031 2e30 292c 0a20 2020 2070 7269   + 1.0),.    pri
+000151d0: 6d73 2e50 7269 6d49 4473 2e4c 4741 4d4d  ms.PrimIDs.LGAMM
+000151e0: 413a 206c 616d 6264 6120 782c 2067 3a20  A: lambda x, g: 
+000151f0: 6720 2a20 7072 696d 732e 6469 6761 6d6d  g * prims.digamm
+00015200: 6128 7829 2c0a 2020 2020 7072 696d 732e  a(x),.    prims.
+00015210: 5072 696d 4944 732e 4e44 5452 493a 206c  PrimIDs.NDTRI: l
+00015220: 616d 6264 6120 7265 7375 6c74 2c20 673a  ambda result, g:
+00015230: 2067 202a 2070 7269 6d73 2e65 7870 2830   g * prims.exp(0
+00015240: 2e35 202a 2072 6573 756c 742a 2a32 2920  .5 * result**2) 
+00015250: 2a20 6d61 7468 2e73 7172 7428 322e 3020  * math.sqrt(2.0 
+00015260: 2a20 6d61 7468 2e70 6929 2c0a 2020 2020  * math.pi),.    
+00015270: 7072 696d 732e 5072 696d 4944 732e 5349  prims.PrimIDs.SI
+00015280: 4e48 3a20 6c61 6d62 6461 2078 2c20 673a  NH: lambda x, g:
+00015290: 2070 7269 6d73 2e6d 756c 2867 2c20 7072   prims.mul(g, pr
+000152a0: 696d 732e 636f 7368 2878 2929 2c0a 2020  ims.cosh(x)),.  
+000152b0: 2020 7072 696d 732e 5072 696d 4944 732e    prims.PrimIDs.
+000152c0: 5351 5254 3a20 6c61 6d62 6461 2072 6573  SQRT: lambda res
+000152d0: 756c 742c 2067 3a20 6720 2f20 2832 2e30  ult, g: g / (2.0
+000152e0: 202a 2072 6573 756c 7429 2c0a 2020 2020   * result),.    
+000152f0: 7072 696d 732e 5072 696d 4944 732e 4c4f  prims.PrimIDs.LO
+00015300: 4731 303a 206c 616d 6264 6120 782c 2067  G10: lambda x, g
+00015310: 3a20 6720 2f20 2878 202a 2032 2e33 3032  : g / (x * 2.302
+00015320: 3538 3530 3932 3939 3430 3436 292c 0a20  585092994046),. 
+00015330: 2020 2070 7269 6d73 2e50 7269 6d49 4473     prims.PrimIDs
+00015340: 2e4c 4f47 3150 3a20 6c61 6d62 6461 2078  .LOG1P: lambda x
+00015350: 2c20 673a 2067 202f 2028 7820 2b20 3129  , g: g / (x + 1)
+00015360: 2c0a 2020 2020 7072 696d 732e 5072 696d  ,.    prims.Prim
+00015370: 4944 732e 4c4f 4732 3a20 6c61 6d62 6461  IDs.LOG2: lambda
+00015380: 2078 2c20 673a 2067 202f 2028 7820 2a20   x, g: g / (x * 
+00015390: 302e 3639 3331 3437 3138 3035 3539 3934  0.69314718055994
+000153a0: 3533 292c 0a20 2020 2070 7269 6d73 2e50  53),.    prims.P
+000153b0: 7269 6d49 4473 2e46 4d4f 443a 206c 616d  rimIDs.FMOD: lam
+000153c0: 6264 6120 782c 2079 2c20 673a 2028 672c  bda x, y, g: (g,
+000153d0: 202d 6720 2a20 7072 696d 732e 7472 756e   -g * prims.trun
+000153e0: 6328 7820 2f20 7929 292c 0a20 2020 2023  c(x / y)),.    #
+000153f0: 2054 6865 2063 6f70 7920 7368 6f75 6c64   The copy should
+00015400: 206e 6f74 2062 6520 6469 6666 6572 656e   not be differen
+00015410: 7469 6162 6c65 2e20 5765 2072 6574 7572  tiable. We retur
+00015420: 6e20 4e6f 6e65 2074 6f20 656e 6162 6c65  n None to enable
+00015430: 2074 6865 2067 656e 6572 6174 696f 6e20   the generation 
+00015440: 6f66 2074 6865 2062 6163 6b77 6172 6420  of the backward 
+00015450: 6772 6170 6820 7468 726f 7567 6820 7468  graph through th
+00015460: 656d 2e0a 2020 2020 7072 696d 732e 5072  em..    prims.Pr
+00015470: 696d 4944 732e 434f 5059 5f3a 206c 616d  imIDs.COPY_: lam
+00015480: 6264 6120 673a 2028 4e6f 6e65 2c20 4e6f  bda g: (None, No
+00015490: 6e65 292c 0a7d 0a0a 0a64 6566 2072 6567  ne),.}...def reg
+000154a0: 6973 7465 725f 6175 676d 656e 7465 645f  ister_augmented_
+000154b0: 666f 7277 6172 6428 6f70 293a 0a20 2020  forward(op):.   
+000154c0: 2022 2222 4465 636f 7261 746f 7220 746f   """Decorator to
+000154d0: 2072 6567 6973 7465 7220 616e 2061 7567   register an aug
+000154e0: 6d65 6e74 6564 2066 6f72 7761 7264 2069  mented forward i
+000154f0: 6d70 6c65 6d65 6e74 6174 696f 6e20 666f  mplementation fo
+00015500: 7220 6120 7379 6d62 6f6c 2e0a 0a20 2020  r a symbol...   
+00015510: 2041 7267 733a 0a20 2020 2020 2020 206f   Args:.        o
+00015520: 7020 284f 7073 293a 2053 796d 626f 6c20  p (Ops): Symbol 
+00015530: 666f 7220 7768 6963 6820 746f 2072 6567  for which to reg
+00015540: 6973 7465 7220 7468 6520 6175 676d 656e  ister the augmen
+00015550: 7465 6420 666f 7277 6172 6420 696d 706c  ted forward impl
+00015560: 656d 656e 7461 7469 6f6e 2e0a 0a20 2020  ementation...   
+00015570: 2052 6574 7572 6e73 3a0a 2020 2020 2020   Returns:.      
+00015580: 2020 4361 6c6c 6162 6c65 3a20 4465 636f    Callable: Deco
+00015590: 7261 746f 7220 6675 6e63 7469 6f6e 2e0a  rator function..
+000155a0: 2020 2020 2222 220a 0a20 2020 2064 6566      """..    def
+000155b0: 2064 6563 6f72 6174 6f72 2866 756e 6329   decorator(func)
+000155c0: 3a0a 2020 2020 2020 2020 6175 676d 656e  :.        augmen
+000155d0: 7465 645f 666f 7277 6172 645f 696d 706c  ted_forward_impl
+000155e0: 735b 6f70 5d20 3d20 6675 6e63 0a20 2020  s[op] = func.   
+000155f0: 2020 2020 2072 6574 7572 6e20 6675 6e63       return func
+00015600: 0a0a 2020 2020 7265 7475 726e 2064 6563  ..    return dec
+00015610: 6f72 6174 6f72 0a0a 0a64 6566 2072 6567  orator...def reg
+00015620: 6973 7465 725f 6261 636b 7761 7264 286f  ister_backward(o
+00015630: 7029 3a0a 2020 2020 2222 2244 6563 6f72  p):.    """Decor
+00015640: 6174 6f72 2074 6f20 7265 6769 7374 6572  ator to register
+00015650: 2061 2062 6163 6b77 6172 6420 696d 706c   a backward impl
+00015660: 656d 656e 7461 7469 6f6e 2066 6f72 2061  ementation for a
+00015670: 2073 796d 626f 6c2e 0a0a 2020 2020 4172   symbol...    Ar
+00015680: 6773 3a0a 2020 2020 2020 2020 6f70 2028  gs:.        op (
+00015690: 4f70 7329 3a20 5379 6d62 6f6c 2066 6f72  Ops): Symbol for
+000156a0: 2077 6869 6368 2074 6f20 7265 6769 7374   which to regist
+000156b0: 6572 2074 6865 2062 6163 6b77 6172 6420  er the backward 
+000156c0: 696d 706c 656d 656e 7461 7469 6f6e 2e0a  implementation..
+000156d0: 0a20 2020 2052 6574 7572 6e73 3a0a 2020  .    Returns:.  
+000156e0: 2020 2020 2020 4361 6c6c 6162 6c65 3a20        Callable: 
+000156f0: 4465 636f 7261 746f 7220 6675 6e63 7469  Decorator functi
+00015700: 6f6e 2e0a 2020 2020 2222 220a 0a20 2020  on..    """..   
+00015710: 2064 6566 2064 6563 6f72 6174 6f72 2866   def decorator(f
+00015720: 756e 6329 3a0a 2020 2020 2020 2020 6261  unc):.        ba
+00015730: 636b 7761 7264 5f69 6d70 6c73 5b6f 705d  ckward_impls[op]
+00015740: 203d 2066 756e 630a 2020 2020 2020 2020   = func.        
+00015750: 7265 7475 726e 2066 756e 630a 0a20 2020  return func..   
+00015760: 2072 6574 7572 6e20 6465 636f 7261 746f   return decorato
+00015770: 720a 0a0a 6465 6620 7265 7374 6f72 655f  r...def restore_
+00015780: 7265 6475 6365 645f 6469 6d73 2878 2c20  reduced_dims(x, 
+00015790: 7265 6475 6365 645f 6469 6d73 2c20 6f72  reduced_dims, or
+000157a0: 6967 696e 616c 5f73 6861 7065 293a 0a20  iginal_shape):. 
+000157b0: 2020 2022 2222 5265 7374 6f72 6573 2074     """Restores t
+000157c0: 6865 2072 6564 7563 6564 2064 696d 656e  he reduced dimen
+000157d0: 7369 6f6e 7320 6f66 2061 2074 656e 736f  sions of a tenso
+000157e0: 722e 0a0a 2020 2020 4172 6773 3a0a 2020  r...    Args:.  
+000157f0: 2020 2020 2020 7820 2856 6172 6961 626c        x (Variabl
+00015800: 6529 3a20 5465 6e73 6f72 2074 6f20 6265  e): Tensor to be
+00015810: 2072 6573 6861 7065 642e 0a20 2020 2020   reshaped..     
+00015820: 2020 2072 6564 7563 6564 5f64 696d 7320     reduced_dims 
+00015830: 2854 7570 6c65 5b69 6e74 2c20 2e2e 2e5d  (Tuple[int, ...]
+00015840: 293a 2054 7570 6c65 206f 6620 7265 6475  ): Tuple of redu
+00015850: 6365 6420 6469 6d65 6e73 696f 6e73 2e0a  ced dimensions..
+00015860: 2020 2020 2020 2020 6f72 6967 696e 616c          original
+00015870: 5f73 6861 7065 2028 5475 706c 655b 696e  _shape (Tuple[in
+00015880: 742c 202e 2e2e 5d29 3a20 4f72 6967 696e  t, ...]): Origin
+00015890: 616c 2073 6861 7065 206f 6620 7468 6520  al shape of the 
+000158a0: 7465 6e73 6f72 2e0a 0a20 2020 2052 6574  tensor...    Ret
+000158b0: 7572 6e73 3a0a 2020 2020 2020 2020 5661  urns:.        Va
+000158c0: 7269 6162 6c65 3a20 5465 6e73 6f72 2077  riable: Tensor w
+000158d0: 6974 6820 7468 6520 7265 6475 6365 6420  ith the reduced 
+000158e0: 6469 6d65 6e73 696f 6e73 2072 6573 746f  dimensions resto
+000158f0: 7265 642e 0a20 2020 2022 2222 0a20 2020  red..    """.   
+00015900: 2069 6620 6f72 6967 696e 616c 5f73 6861   if original_sha
+00015910: 7065 203d 3d20 2829 3a20 2023 2073 6361  pe == ():  # sca
+00015920: 6c61 720a 2020 2020 2020 2020 7265 7475  lar.        retu
+00015930: 726e 2078 0a0a 2020 2020 756e 7371 7565  rn x..    unsque
+00015940: 657a 6564 203d 2063 6c61 6e67 2e75 6e73  ezed = clang.uns
+00015950: 7175 6565 7a65 2878 2c20 7265 6475 6365  queeze(x, reduce
+00015960: 645f 6469 6d73 290a 2020 2020 7265 7475  d_dims).    retu
+00015970: 726e 2063 6c61 6e67 2e65 7870 616e 6428  rn clang.expand(
+00015980: 756e 7371 7565 657a 6564 2c20 6f72 6967  unsqueezed, orig
+00015990: 696e 616c 5f73 6861 7065 290a 0a0a 4072  inal_shape)...@r
+000159a0: 6567 6973 7465 725f 6261 636b 7761 7264  egister_backward
+000159b0: 2870 7269 6d73 2e50 7269 6d49 4473 2e5a  (prims.PrimIDs.Z
+000159c0: 4554 4129 0a64 6566 207a 6574 615f 6261  ETA).def zeta_ba
+000159d0: 636b 7761 7264 2878 2c20 792c 2067 293a  ckward(x, y, g):
+000159e0: 0a20 2020 2023 2054 6865 2064 6572 6976  .    # The deriv
+000159f0: 6174 6976 6520 7772 7420 7468 6520 6669  ative wrt the fi
+00015a00: 7273 7420 6172 6775 6d65 6e74 2069 7320  rst argument is 
+00015a10: 6e6f 7420 6578 7072 6573 7369 626c 6520  not expressible 
+00015a20: 696e 2074 6572 6d73 206f 6620 7a65 7461  in terms of zeta
+00015a30: 206f 720a 2020 2020 2320 6f74 6865 7220   or.    # other 
+00015a40: 7370 6563 6961 6c20 6675 6e63 7469 6f6e  special function
+00015a50: 730a 2020 2020 2320 5468 6572 6566 6f72  s.    # Therefor
+00015a60: 652c 2077 6520 636f 6d70 7574 6520 6f6e  e, we compute on
+00015a70: 6c79 2074 6865 2064 6572 6976 6174 6976  ly the derivativ
+00015a80: 6520 7772 7420 7468 6520 7365 636f 6e64  e wrt the second
+00015a90: 2061 7267 756d 656e 740a 2020 2020 6779   argument.    gy
+00015aa0: 203d 2067 202a 202d 7820 2a20 7072 696d   = g * -x * prim
+00015ab0: 732e 7a65 7461 2878 202b 2031 2e30 2c20  s.zeta(x + 1.0, 
+00015ac0: 7929 0a0a 2020 2020 2320 5265 7475 726e  y)..    # Return
+00015ad0: 2061 206d 6170 7070 696e 6720 6672 6f6d   a mappping from
+00015ae0: 2074 6865 2066 6f72 7761 7264 2061 7267   the forward arg
+00015af0: 756d 656e 7473 2074 6f20 7468 6520 6772  uments to the gr
+00015b00: 6164 6965 6e74 730a 2020 2020 7265 7475  adients.    retu
+00015b10: 726e 207b 2279 223a 2067 797d 0a0a 0a40  rn {"y": gy}...@
+00015b20: 7265 6769 7374 6572 5f62 6163 6b77 6172  register_backwar
+00015b30: 6428 7072 696d 732e 5072 696d 4944 732e  d(prims.PrimIDs.
+00015b40: 4449 4741 4d4d 4129 0a64 6566 2064 6967  DIGAMMA).def dig
+00015b50: 616d 6d61 5f62 6163 6b77 6172 6428 613a  amma_backward(a:
+00015b60: 2050 726f 7879 2c20 6729 3a0a 2020 2020   Proxy, g):.    
+00015b70: 6672 6f6d 2074 6875 6e64 6572 2e74 6f72  from thunder.tor
+00015b80: 6368 2069 6d70 6f72 7420 706f 6c79 6761  ch import polyga
+00015b90: 6d6d 610a 0a20 2020 2072 6574 7572 6e20  mma..    return 
+00015ba0: 6720 2a20 706f 6c79 6761 6d6d 6128 312c  g * polygamma(1,
+00015bb0: 2061 290a 0a0a 4072 6567 6973 7465 725f   a)...@register_
+00015bc0: 6175 676d 656e 7465 645f 666f 7277 6172  augmented_forwar
+00015bd0: 6428 2274 6f72 6368 2e70 6f6c 7967 616d  d("torch.polygam
+00015be0: 6d61 2229 0a64 6566 2070 6f6c 7967 616d  ma").def polygam
+00015bf0: 6d61 5f61 7567 5f66 7764 286e 3a20 696e  ma_aug_fwd(n: in
+00015c00: 742c 2061 3a20 5072 6f78 7929 3a0a 2020  t, a: Proxy):.  
+00015c10: 2020 6672 6f6d 2074 6875 6e64 6572 2e74    from thunder.t
+00015c20: 6f72 6368 2069 6d70 6f72 7420 706f 6c79  orch import poly
+00015c30: 6761 6d6d 610a 0a20 2020 2070 7269 6d61  gamma..    prima
+00015c40: 6c20 3d20 706f 6c79 6761 6d6d 6128 6e2c  l = polygamma(n,
+00015c50: 2061 290a 2020 2020 7265 7369 6475 616c   a).    residual
+00015c60: 7320 3d20 286e 2c20 6129 0a20 2020 2072  s = (n, a).    r
+00015c70: 6574 7572 6e20 564a 5044 7561 6c28 7072  eturn VJPDual(pr
+00015c80: 696d 616c 2c20 7265 7369 6475 616c 7329  imal, residuals)
+00015c90: 0a0a 0a40 7265 6769 7374 6572 5f62 6163  ...@register_bac
+00015ca0: 6b77 6172 6428 2274 6f72 6368 2e70 6f6c  kward("torch.pol
+00015cb0: 7967 616d 6d61 2229 0a64 6566 2070 6f6c  ygamma").def pol
+00015cc0: 7967 616d 6d61 5f62 6163 6b77 6172 6428  ygamma_backward(
+00015cd0: 6e3a 2069 6e74 2c20 613a 2050 726f 7879  n: int, a: Proxy
+00015ce0: 2c20 6729 3a0a 2020 2020 6672 6f6d 2074  , g):.    from t
+00015cf0: 6875 6e64 6572 2e74 6f72 6368 2069 6d70  hunder.torch imp
+00015d00: 6f72 7420 706f 6c79 6761 6d6d 610a 0a20  ort polygamma.. 
+00015d10: 2020 2072 6574 7572 6e20 4e6f 6e65 2c20     return None, 
+00015d20: 6720 2a20 706f 6c79 6761 6d6d 6128 6e20  g * polygamma(n 
+00015d30: 2b20 312c 2061 290a 0a0a 4072 6567 6973  + 1, a)...@regis
+00015d40: 7465 725f 6261 636b 7761 7264 2870 7269  ter_backward(pri
+00015d50: 6d73 2e50 7269 6d49 4473 2e41 5441 4e32  ms.PrimIDs.ATAN2
+00015d60: 290a 6465 6620 6174 616e 325f 6261 636b  ).def atan2_back
+00015d70: 7761 7264 2878 2c20 792c 2067 293a 0a20  ward(x, y, g):. 
+00015d80: 2020 2061 6c70 6861 203d 2031 2e30 202f     alpha = 1.0 /
+00015d90: 2028 7820 2a20 7820 2b20 7920 2a20 7929   (x * x + y * y)
+00015da0: 0a20 2020 2067 7261 645f 7820 3d20 6720  .    grad_x = g 
+00015db0: 2a20 7920 2a20 616c 7068 610a 2020 2020  * y * alpha.    
+00015dc0: 6772 6164 5f79 203d 2067 202a 202d 7820  grad_y = g * -x 
+00015dd0: 2a20 616c 7068 610a 2020 2020 7265 7475  * alpha.    retu
+00015de0: 726e 2067 7261 645f 782c 2067 7261 645f  rn grad_x, grad_
+00015df0: 790a 0a0a 4072 6567 6973 7465 725f 6175  y...@register_au
+00015e00: 676d 656e 7465 645f 666f 7277 6172 6428  gmented_forward(
+00015e10: 7072 696d 732e 5072 696d 4944 732e 5641  prims.PrimIDs.VA
+00015e20: 5229 0a64 6566 2076 6172 5f61 7567 5f66  R).def var_aug_f
+00015e30: 7764 2861 2c20 6469 6d2c 202a 2c20 636f  wd(a, dim, *, co
+00015e40: 7272 6563 7469 6f6e 293a 0a20 2020 2076  rrection):.    v
+00015e50: 203d 2070 7269 6d73 2e76 6172 2861 2c20   = prims.var(a, 
+00015e60: 6469 6d2c 2063 6f72 7265 6374 696f 6e3d  dim, correction=
+00015e70: 636f 7272 6563 7469 6f6e 290a 2020 2020  correction).    
+00015e80: 7265 7475 726e 2056 4a50 4475 616c 2828  return VJPDual((
+00015e90: 762c 292c 2028 612c 2064 696d 2c20 636f  v,), (a, dim, co
+00015ea0: 7272 6563 7469 6f6e 2c20 7629 290a 0a0a  rrection, v))...
+00015eb0: 2320 544f 444f 3a20 6669 7820 6469 7669  # TODO: fix divi
+00015ec0: 7369 6f6e 2062 7920 7a65 726f 2077 6865  sion by zero whe
+00015ed0: 6e20 6e5f 656c 656d 5f72 6564 7563 6564  n n_elem_reduced
+00015ee0: 203d 3d20 3020 6f72 2077 6865 6e20 762e   == 0 or when v.
+00015ef0: 6e75 6d65 6c20 3d3d 2030 0a23 2062 7920  numel == 0.# by 
+00015f00: 7265 7475 726e 696e 6720 7a65 726f 735f  returning zeros_
+00015f10: 6c69 6b65 2861 2920 6f72 2073 696d 696c  like(a) or simil
+00015f20: 6172 2e0a 2320 544f 444f 3a20 6669 7820  ar..# TODO: fix 
+00015f30: 6772 6164 2077 6865 6e20 636f 7272 6563  grad when correc
+00015f40: 7469 6f6e 203e 206e 5f65 6c65 6d5f 7265  tion > n_elem_re
+00015f50: 6475 6365 642e 0a40 7265 6769 7374 6572  duced..@register
+00015f60: 5f62 6163 6b77 6172 6428 7072 696d 732e  _backward(prims.
+00015f70: 5072 696d 4944 732e 5641 5229 0a64 6566  PrimIDs.VAR).def
+00015f80: 2076 6172 5f62 6163 6b77 6172 6428 612c   var_backward(a,
+00015f90: 2064 696d 2c20 636f 7272 6563 7469 6f6e   dim, correction
+00015fa0: 2c20 762c 2067 293a 0a20 2020 206e 5f65  , v, g):.    n_e
+00015fb0: 6c65 6d5f 7265 6475 6365 6420 3d20 612e  lem_reduced = a.
+00015fc0: 6e75 6d65 6c28 2920 2f2f 2076 2e6e 756d  numel() // v.num
+00015fd0: 656c 2829 2069 6620 612e 6e75 6d65 6c28  el() if a.numel(
+00015fe0: 2920 213d 2030 2065 6c73 6520 310a 2020  ) != 0 else 1.  
+00015ff0: 2020 6e6f 726d 616c 697a 6174 696f 6e5f    normalization_
+00016000: 7363 616c 6172 203d 206e 5f65 6c65 6d5f  scalar = n_elem_
+00016010: 7265 6475 6365 6420 2d20 636f 7272 6563  reduced - correc
+00016020: 7469 6f6e 0a20 2020 2067 203d 2072 6573  tion.    g = res
+00016030: 746f 7265 5f72 6564 7563 6564 5f64 696d  tore_reduced_dim
+00016040: 7328 672c 2064 696d 2c20 612e 7368 6170  s(g, dim, a.shap
+00016050: 6529 0a20 2020 2069 6620 612e 6474 7970  e).    if a.dtyp
+00016060: 6520 213d 2076 2e64 7479 7065 3a0a 2020  e != v.dtype:.  
+00016070: 2020 2020 2020 6120 3d20 7072 696d 732e        a = prims.
+00016080: 636f 6e76 6572 745f 656c 656d 656e 745f  convert_element_
+00016090: 7479 7065 2861 2c20 762e 6474 7970 6529  type(a, v.dtype)
+000160a0: 0a20 2020 206d 6561 6e20 3d20 7072 696d  .    mean = prim
+000160b0: 732e 7375 6d28 612c 2064 696d 2920 2f20  s.sum(a, dim) / 
+000160c0: 6e5f 656c 656d 5f72 6564 7563 6564 0a20  n_elem_reduced. 
+000160d0: 2020 206d 6561 6e20 3d20 7265 7374 6f72     mean = restor
+000160e0: 655f 7265 6475 6365 645f 6469 6d73 286d  e_reduced_dims(m
+000160f0: 6561 6e2c 2064 696d 2c20 612e 7368 6170  ean, dim, a.shap
+00016100: 6529 0a20 2020 2072 6574 7572 6e20 2832  e).    return (2
+00016110: 202a 2067 202a 2028 6120 2d20 6d65 616e   * g * (a - mean
+00016120: 2929 202f 206e 6f72 6d61 6c69 7a61 7469  )) / normalizati
+00016130: 6f6e 5f73 6361 6c61 720a 0a0a 6465 6620  on_scalar...def 
+00016140: 6e5f 656c 656d 5f72 6564 7563 6564 2861  n_elem_reduced(a
+00016150: 5f6e 6469 6d2c 2061 5f73 6861 7065 2c20  _ndim, a_shape, 
+00016160: 6469 6d73 293a 0a20 2020 2064 696d 7320  dims):.    dims 
+00016170: 3d20 7574 696c 732e 6361 6e6f 6e69 6361  = utils.canonica
+00016180: 6c69 7a65 5f64 696d 7328 615f 6e64 696d  lize_dims(a_ndim
+00016190: 2c20 6469 6d73 290a 2020 2020 7265 6475  , dims).    redu
+000161a0: 6374 696f 6e5f 7369 7a65 203d 2031 0a20  ction_size = 1. 
+000161b0: 2020 2066 6f72 2069 6478 2c20 7369 7a65     for idx, size
+000161c0: 2069 6e20 656e 756d 6572 6174 6528 615f   in enumerate(a_
+000161d0: 7368 6170 6529 3a0a 2020 2020 2020 2020  shape):.        
+000161e0: 6966 2069 6478 2069 6e20 6469 6d73 3a0a  if idx in dims:.
+000161f0: 2020 2020 2020 2020 2020 2020 7265 6475              redu
+00016200: 6374 696f 6e5f 7369 7a65 202a 3d20 7369  ction_size *= si
+00016210: 7a65 0a20 2020 2072 6574 7572 6e20 7265  ze.    return re
+00016220: 6475 6374 696f 6e5f 7369 7a65 0a0a 0a64  duction_size...d
+00016230: 6566 206d 6561 6e5f 6261 636b 7761 7264  ef mean_backward
+00016240: 2861 5f6e 6469 6d2c 2061 5f73 6861 7065  (a_ndim, a_shape
+00016250: 2c20 6469 6d73 2c20 6772 6164 293a 0a20  , dims, grad):. 
+00016260: 2020 206d 6561 6e5f 6c6f 6361 6c5f 6772     mean_local_gr
+00016270: 6164 203d 2031 2e30 202f 206e 5f65 6c65  ad = 1.0 / n_ele
+00016280: 6d5f 7265 6475 6365 6428 615f 6e64 696d  m_reduced(a_ndim
+00016290: 2c20 615f 7368 6170 652c 2064 696d 7329  , a_shape, dims)
+000162a0: 0a20 2020 2072 6574 7572 6e20 7265 7374  .    return rest
+000162b0: 6f72 655f 7265 6475 6365 645f 6469 6d73  ore_reduced_dims
+000162c0: 2867 7261 642c 2064 696d 732c 2061 5f73  (grad, dims, a_s
+000162d0: 6861 7065 2920 2a20 6d65 616e 5f6c 6f63  hape) * mean_loc
+000162e0: 616c 5f67 7261 640a 0a0a 4072 6567 6973  al_grad...@regis
+000162f0: 7465 725f 6175 676d 656e 7465 645f 666f  ter_augmented_fo
+00016300: 7277 6172 6428 7072 696d 732e 5072 696d  rward(prims.Prim
+00016310: 4944 732e 5041 4429 0a64 6566 2070 6164  IDs.PAD).def pad
+00016320: 5f61 7567 5f66 7764 2861 2c20 7061 6464  _aug_fwd(a, padd
+00016330: 696e 675f 7661 6c75 652c 2070 6164 6469  ing_value, paddi
+00016340: 6e67 5f63 6f6e 6669 6729 3a0a 2020 2020  ng_config):.    
+00016350: 7265 7475 726e 2056 4a50 4475 616c 2828  return VJPDual((
+00016360: 7072 696d 732e 7061 6428 612c 2070 6164  prims.pad(a, pad
+00016370: 6469 6e67 5f76 616c 7565 2c20 7061 6464  ding_value, padd
+00016380: 696e 675f 636f 6e66 6967 292c 292c 2028  ing_config),), (
+00016390: 612c 2070 6164 6469 6e67 5f63 6f6e 6669  a, padding_confi
+000163a0: 6729 290a 0a0a 4072 6567 6973 7465 725f  g))...@register_
+000163b0: 6261 636b 7761 7264 2870 7269 6d73 2e50  backward(prims.P
+000163c0: 7269 6d49 4473 2e50 4144 290a 6465 6620  rimIDs.PAD).def 
+000163d0: 7061 645f 6261 636b 7761 7264 2861 2c20  pad_backward(a, 
+000163e0: 7061 6464 696e 675f 636f 6e66 6967 2c20  padding_config, 
+000163f0: 6729 3a0a 2020 2020 2320 5368 6f72 7420  g):.    # Short 
+00016400: 6369 7263 7569 7420 6f6e 2065 6d70 7479  circuit on empty
+00016410: 2069 6e70 7574 2e0a 2020 2020 6966 2061   input..    if a
+00016420: 6e79 2864 696d 203d 3d20 3020 666f 7220  ny(dim == 0 for 
+00016430: 6469 6d20 696e 2061 2e73 6861 7065 293a  dim in a.shape):
+00016440: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00016450: 6675 6c6c 5f6c 696b 6528 612c 2066 696c  full_like(a, fil
+00016460: 6c5f 7661 6c75 653d 3029 0a0a 2020 2020  l_value=0)..    
+00016470: 2320 556e 2d70 6164 2062 7920 7061 6464  # Un-pad by padd
+00016480: 696e 6720 7769 7468 207a 6572 6f20 7661  ing with zero va
+00016490: 6c75 6573 0a20 2020 207a 6572 6f5f 7061  lues.    zero_pa
+000164a0: 6464 696e 675f 636f 6e66 6967 203d 205b  dding_config = [
+000164b0: 282d 6c6f 2c20 2d68 692c 2030 2920 666f  (-lo, -hi, 0) fo
+000164c0: 7220 6c6f 2c20 6869 2c20 5f20 696e 2070  r lo, hi, _ in p
+000164d0: 6164 6469 6e67 5f63 6f6e 6669 675d 0a0a  adding_config]..
+000164e0: 2020 2020 6720 3d20 7072 696d 732e 7061      g = prims.pa
+000164f0: 6428 672c 2030 2e30 2c20 7a65 726f 5f70  d(g, 0.0, zero_p
+00016500: 6164 6469 6e67 5f63 6f6e 6669 6729 0a0a  adding_config)..
+00016510: 2020 2020 2320 556e 2d73 6c69 6365 2062      # Un-slice b
+00016520: 7920 736c 6963 696e 6720 7769 7468 2061  y slicing with a
+00016530: 2073 7472 6964 6520 6f66 2076 616c 7565   stride of value
+00016540: 2028 6469 6c61 7469 6f6e 202b 2031 290a   (dilation + 1).
+00016550: 2020 2020 666f 7220 6469 6d2c 2028 5f2c      for dim, (_,
+00016560: 205f 2c20 6429 2069 6e20 656e 756d 6572   _, d) in enumer
+00016570: 6174 6528 7061 6464 696e 675f 636f 6e66  ate(padding_conf
+00016580: 6967 293a 0a20 2020 2020 2020 2067 203d  ig):.        g =
+00016590: 2073 6c69 6365 5f69 6e5f 6469 6d28 672c   slice_in_dim(g,
+000165a0: 2030 2c20 672e 7368 6170 655b 6469 6d5d   0, g.shape[dim]
+000165b0: 2c20 7374 7269 6465 3d64 202b 2031 2c20  , stride=d + 1, 
+000165c0: 6469 6d3d 6469 6d29 0a0a 2020 2020 7265  dim=dim)..    re
+000165d0: 7475 726e 2067 0a0a 0a40 7265 6769 7374  turn g...@regist
+000165e0: 6572 5f61 7567 6d65 6e74 6564 5f66 6f72  er_augmented_for
+000165f0: 7761 7264 2870 7269 6d73 2e50 7269 6d49  ward(prims.PrimI
+00016600: 4473 2e50 524f 4429 0a64 6566 2070 726f  Ds.PROD).def pro
+00016610: 645f 6175 675f 6677 6428 782c 2064 696d  d_aug_fwd(x, dim
+00016620: 7329 3a0a 2020 2020 2222 2241 7567 6d65  s):.    """Augme
+00016630: 6e74 6564 2070 726f 6420 6f70 6572 6174  nted prod operat
+00016640: 696f 6e2e 0a0a 2020 2020 4172 6773 3a0a  ion...    Args:.
+00016650: 2020 2020 2020 2020 7820 2856 6172 6961          x (Varia
+00016660: 626c 6529 3a20 5465 6e73 6f72 2074 6f20  ble): Tensor to 
+00016670: 6265 206d 756c 7469 706c 6965 642e 0a20  be multiplied.. 
+00016680: 2020 2020 2020 2064 696d 7320 2854 7570         dims (Tup
+00016690: 6c65 5b69 6e74 2c20 2e2e 2e5d 293a 2044  le[int, ...]): D
+000166a0: 696d 656e 7369 6f6e 7320 746f 2062 6520  imensions to be 
+000166b0: 6d75 6c74 6970 6c69 6564 2e0a 0a20 2020  multiplied...   
+000166c0: 2052 6574 7572 6e73 3a0a 2020 2020 2020   Returns:.      
+000166d0: 2020 564a 5044 7561 6c3a 2050 7269 6d61    VJPDual: Prima
+000166e0: 6c20 616e 6420 7265 7369 6475 616c 732e  l and residuals.
+000166f0: 0a20 2020 2022 2222 0a20 2020 2070 7269  .    """.    pri
+00016700: 6d61 6c20 3d20 7072 696d 732e 7072 6f64  mal = prims.prod
+00016710: 2878 2c20 6469 6d73 290a 0a20 2020 2072  (x, dims)..    r
+00016720: 6573 6964 7561 6c73 203d 2028 0a20 2020  esiduals = (.   
+00016730: 2020 2020 2070 7269 6d61 6c2c 0a20 2020       primal,.   
+00016740: 2020 2020 2078 2c0a 2020 2020 2020 2020       x,.        
+00016750: 782e 7368 6170 652c 0a20 2020 2020 2020  x.shape,.       
+00016760: 2064 696d 732c 0a20 2020 2029 0a20 2020   dims,.    ).   
+00016770: 2072 6574 7572 6e20 564a 5044 7561 6c28   return VJPDual(
+00016780: 7072 696d 616c 2c20 7265 7369 6475 616c  primal, residual
+00016790: 7329 0a0a 0a40 7265 6769 7374 6572 5f62  s)...@register_b
+000167a0: 6163 6b77 6172 6428 7072 696d 732e 5072  ackward(prims.Pr
+000167b0: 696d 4944 732e 5052 4f44 290a 6465 6620  imIDs.PROD).def 
+000167c0: 7072 6f64 5f70 756c 6c62 6163 6b28 7072  prod_pullback(pr
+000167d0: 696d 616c 2c20 782c 2078 5f73 6861 7065  imal, x, x_shape
+000167e0: 2c20 7265 6475 6365 645f 6469 6d73 2c20  , reduced_dims, 
+000167f0: 6729 3a0a 2020 2020 7265 7475 726e 2070  g):.    return p
+00016800: 7269 6d73 2e64 6976 2872 6573 746f 7265  rims.div(restore
+00016810: 5f72 6564 7563 6564 5f64 696d 7328 7072  _reduced_dims(pr
+00016820: 696d 616c 202a 2067 2c20 7265 6475 6365  imal * g, reduce
+00016830: 645f 6469 6d73 2c20 785f 7368 6170 6529  d_dims, x_shape)
+00016840: 2c20 7829 0a0a 0a64 6566 206b 6565 7064  , x)...def keepd
+00016850: 696d 5f72 6564 7563 7469 6f6e 2872 6564  im_reduction(red
+00016860: 7563 7469 6f6e 5f66 6e2c 2078 2c20 6469  uction_fn, x, di
+00016870: 6d73 293a 0a20 2020 2022 2222 4170 706c  ms):.    """Appl
+00016880: 6965 7320 7265 6475 6374 696f 6e20 616e  ies reduction an
+00016890: 6420 6669 7865 7320 6f75 7470 7574 2074  d fixes output t
+000168a0: 6f20 636f 6e66 6f72 6d20 746f 206b 6565  o conform to kee
+000168b0: 7064 696d 3d54 7275 6522 2222 0a20 2020  pdim=True""".   
+000168c0: 206f 7574 203d 2072 6564 7563 7469 6f6e   out = reduction
+000168d0: 5f66 6e28 782c 2064 696d 7329 0a20 2020  _fn(x, dims).   
+000168e0: 2061 7267 6d61 785f 7375 6d5f 6f75 745f   argmax_sum_out_
+000168f0: 7368 6170 6520 3d20 5b78 2e73 6861 7065  shape = [x.shape
+00016900: 5b69 5d20 6966 2069 206e 6f74 2069 6e20  [i] if i not in 
+00016910: 6469 6d73 2065 6c73 6520 3120 666f 7220  dims else 1 for 
+00016920: 6920 696e 2072 616e 6765 2878 2e6e 6469  i in range(x.ndi
+00016930: 6d29 5d0a 2020 2020 6272 6f61 6463 6173  m)].    broadcas
+00016940: 745f 6469 6d73 203d 205b 6920 666f 7220  t_dims = [i for 
+00016950: 6920 696e 2072 616e 6765 2878 2e6e 6469  i in range(x.ndi
+00016960: 6d29 2069 6620 6920 6e6f 7420 696e 2064  m) if i not in d
+00016970: 696d 735d 0a20 2020 2072 6574 7572 6e20  ims].    return 
+00016980: 7072 696d 732e 6272 6f61 6463 6173 745f  prims.broadcast_
+00016990: 696e 5f64 696d 286f 7574 2c20 6172 676d  in_dim(out, argm
+000169a0: 6178 5f73 756d 5f6f 7574 5f73 6861 7065  ax_sum_out_shape
+000169b0: 2c20 6272 6f61 6463 6173 745f 6469 6d73  , broadcast_dims
+000169c0: 290a 0a0a 2320 496e 7370 6972 6564 2066  )...# Inspired f
+000169d0: 726f 6d20 6874 7470 733a 2f2f 6769 7468  rom https://gith
+000169e0: 7562 2e63 6f6d 2f48 4950 532f 6175 746f  ub.com/HIPS/auto
+000169f0: 6772 6164 2f62 6c6f 622f 6d61 7374 6572  grad/blob/master
+00016a00: 2f61 7574 6f67 7261 642f 6e75 6d70 792f  /autograd/numpy/
+00016a10: 6e75 6d70 795f 766a 7073 2e70 7923 4c33  numpy_vjps.py#L3
+00016a20: 3533 0a64 6566 2067 7261 645f 6368 6f6f  53.def grad_choo
+00016a30: 7365 725f 6261 636b 7761 7264 2870 7269  ser_backward(pri
+00016a40: 6d61 6c2c 2078 2c20 785f 7368 6170 652c  mal, x, x_shape,
+00016a50: 2072 6564 7563 6564 5f64 696d 732c 2067   reduced_dims, g
+00016a60: 293a 0a20 2020 2022 2222 4275 696c 6473  ):.    """Builds
+00016a70: 2067 7261 6469 656e 7420 6f66 2066 756e   gradient of fun
+00016a80: 6374 696f 6e73 2074 6861 7420 6368 6f6f  ctions that choo
+00016a90: 7365 2061 2073 696e 676c 6520 6974 656d  se a single item
+00016aa0: 2c20 7375 6368 2061 7320 6d69 6e20 6f72  , such as min or
+00016ab0: 206d 6178 2e22 2222 0a20 2020 2067 5f72   max.""".    g_r
+00016ac0: 6570 6561 7465 6420 3d20 7265 7374 6f72  epeated = restor
+00016ad0: 655f 7265 6475 6365 645f 6469 6d73 2867  e_reduced_dims(g
+00016ae0: 2c20 7265 6475 6365 645f 6469 6d73 2c20  , reduced_dims, 
+00016af0: 785f 7368 6170 6529 0a20 2020 2070 7269  x_shape).    pri
+00016b00: 6d61 6c5f 7265 7065 6174 6564 203d 2072  mal_repeated = r
+00016b10: 6573 746f 7265 5f72 6564 7563 6564 5f64  estore_reduced_d
+00016b20: 696d 7328 7072 696d 616c 2c20 7265 6475  ims(primal, redu
+00016b30: 6365 645f 6469 6d73 2c20 785f 7368 6170  ced_dims, x_shap
+00016b40: 6529 0a20 2020 2061 7267 6d61 785f 6c6f  e).    argmax_lo
+00016b50: 6361 7469 6f6e 7320 3d20 7820 3d3d 2070  cations = x == p
+00016b60: 7269 6d61 6c5f 7265 7065 6174 6564 0a20  rimal_repeated. 
+00016b70: 2020 2061 7267 6d61 785f 7375 6d20 3d20     argmax_sum = 
+00016b80: 6b65 6570 6469 6d5f 7265 6475 6374 696f  keepdim_reductio
+00016b90: 6e28 7072 696d 732e 7375 6d2c 2061 7267  n(prims.sum, arg
+00016ba0: 6d61 785f 6c6f 6361 7469 6f6e 732c 2072  max_locations, r
+00016bb0: 6564 7563 6564 5f64 696d 7329 0a20 2020  educed_dims).   
+00016bc0: 206f 7574 203d 2067 5f72 6570 6561 7465   out = g_repeate
+00016bd0: 6420 2a20 6172 676d 6178 5f6c 6f63 6174  d * argmax_locat
+00016be0: 696f 6e73 202f 2061 7267 6d61 785f 7375  ions / argmax_su
+00016bf0: 6d0a 2020 2020 7265 7475 726e 206f 7574  m.    return out
+00016c00: 0a0a 0a72 6567 6973 7465 725f 6261 636b  ...register_back
+00016c10: 7761 7264 2870 7269 6d73 2e50 7269 6d49  ward(prims.PrimI
+00016c20: 4473 2e41 4d49 4e29 2867 7261 645f 6368  Ds.AMIN)(grad_ch
+00016c30: 6f6f 7365 725f 6261 636b 7761 7264 290a  ooser_backward).
+00016c40: 0a0a 4072 6567 6973 7465 725f 6175 676d  ..@register_augm
+00016c50: 656e 7465 645f 666f 7277 6172 6428 7072  ented_forward(pr
+00016c60: 696d 732e 5072 696d 4944 732e 414d 494e  ims.PrimIDs.AMIN
+00016c70: 290a 6465 6620 616d 696e 5f61 7567 5f66  ).def amin_aug_f
+00016c80: 7764 2878 2c20 6469 6d73 293a 0a20 2020  wd(x, dims):.   
+00016c90: 2022 2222 4175 676d 656e 7465 6420 616d   """Augmented am
+00016ca0: 696e 206f 7065 7261 7469 6f6e 2e0a 2020  in operation..  
+00016cb0: 2020 4172 6773 3a0a 2020 2020 2020 2020    Args:.        
+00016cc0: 7820 2856 6172 6961 626c 6529 3a20 5465  x (Variable): Te
+00016cd0: 6e73 6f72 2074 6f20 636f 6d70 7574 6520  nsor to compute 
+00016ce0: 616d 696e 206f 6e2e 0a20 2020 2020 2020  amin on..       
+00016cf0: 2064 696d 7320 2854 7570 6c65 5b69 6e74   dims (Tuple[int
+00016d00: 2c20 2e2e 2e5d 293a 2044 696d 656e 7369  , ...]): Dimensi
+00016d10: 6f6e 7320 746f 2063 6f6d 7075 7465 2061  ons to compute a
+00016d20: 6d69 6e20 6f76 6572 2e0a 2020 2020 5265  min over..    Re
+00016d30: 7475 726e 733a 0a20 2020 2020 2020 2056  turns:.        V
+00016d40: 4a50 4475 616c 3a20 5072 696d 616c 2061  JPDual: Primal a
+00016d50: 6e64 2072 6573 6964 7561 6c73 2e0a 2020  nd residuals..  
+00016d60: 2020 2222 220a 2020 2020 7072 696d 616c    """.    primal
+00016d70: 203d 2070 7269 6d73 2e61 6d69 6e28 782c   = prims.amin(x,
+00016d80: 2064 696d 7329 0a0a 2020 2020 7265 7369   dims)..    resi
+00016d90: 6475 616c 7320 3d20 280a 2020 2020 2020  duals = (.      
+00016da0: 2020 7072 696d 616c 2c0a 2020 2020 2020    primal,.      
+00016db0: 2020 782c 0a20 2020 2020 2020 2078 2e73    x,.        x.s
+00016dc0: 6861 7065 2c0a 2020 2020 2020 2020 6469  hape,.        di
+00016dd0: 6d73 2c0a 2020 2020 290a 0a20 2020 2072  ms,.    )..    r
+00016de0: 6574 7572 6e20 564a 5044 7561 6c28 7072  eturn VJPDual(pr
+00016df0: 696d 616c 2c20 7265 7369 6475 616c 7329  imal, residuals)
+00016e00: 0a0a 0a40 7265 6769 7374 6572 5f61 7567  ...@register_aug
+00016e10: 6d65 6e74 6564 5f66 6f72 7761 7264 2870  mented_forward(p
+00016e20: 7269 6d73 2e50 7269 6d49 4473 2e50 4f57  rims.PrimIDs.POW
+00016e30: 290a 6465 6620 706f 775f 6175 675f 6665  ).def pow_aug_fe
+00016e40: 6428 782c 2079 293a 0a20 2020 2022 2222  d(x, y):.    """
+00016e50: 4175 676d 656e 7465 6420 7468 6520 706f  Augmented the po
+00016e60: 7720 6f70 6572 6174 696f 6e2e 0a0a 2020  w operation...  
+00016e70: 2020 4172 6773 3a0a 2020 2020 2020 2020    Args:.        
+00016e80: 7820 2856 6172 6961 626c 6529 3a20 5465  x (Variable): Te
+00016e90: 6e73 6f72 2077 6974 6820 7468 6520 6261  nsor with the ba
+00016ea0: 7365 2074 6f20 6265 2065 7870 6f6e 656e  se to be exponen
+00016eb0: 7469 6174 6564 2e0a 2020 2020 2020 2020  tiated..        
+00016ec0: 7920 2856 6172 6961 626c 6529 3a20 5465  y (Variable): Te
+00016ed0: 6e73 6f72 2077 6974 6820 706f 7765 7220  nsor with power 
+00016ee0: 746f 2072 6169 7365 2074 6f2e 0a0a 2020  to raise to...  
+00016ef0: 2020 5265 7475 726e 733a 0a20 2020 2020    Returns:.     
+00016f00: 2020 2056 4a50 4475 616c 3a20 5072 696d     VJPDual: Prim
+00016f10: 616c 2061 6e64 2072 6573 6964 7561 6c73  al and residuals
+00016f20: 2e0a 2020 2020 2222 220a 2020 2020 7072  ..    """.    pr
+00016f30: 696d 616c 203d 2070 7269 6d73 2e70 6f77  imal = prims.pow
+00016f40: 2878 2c20 7929 0a20 2020 2072 6573 6964  (x, y).    resid
+00016f50: 7561 6c73 203d 2028 7072 696d 616c 2c20  uals = (primal, 
+00016f60: 782c 2079 290a 2020 2020 7265 7475 726e  x, y).    return
+00016f70: 2056 4a50 4475 616c 2870 7269 6d61 6c2c   VJPDual(primal,
+00016f80: 2072 6573 6964 7561 6c73 290a 0a0a 4072   residuals)...@r
+00016f90: 6567 6973 7465 725f 6261 636b 7761 7264  egister_backward
+00016fa0: 2870 7269 6d73 2e50 7269 6d49 4473 2e50  (prims.PrimIDs.P
+00016fb0: 4f57 290a 6465 6620 706f 775f 6261 636b  OW).def pow_back
+00016fc0: 7761 7264 2872 6573 756c 742c 2078 2c20  ward(result, x, 
+00016fd0: 792c 2067 293a 0a20 2020 2069 6d70 6f72  y, g):.    impor
+00016fe0: 7420 7468 756e 6465 722e 636c 616e 6720  t thunder.clang 
+00016ff0: 6173 2074 6c61 6e67 0a0a 2020 2020 6772  as tlang..    gr
+00017000: 6573 756c 7420 3d20 6720 2a20 7265 7375  esult = g * resu
+00017010: 6c74 2020 2320 7265 7573 6520 636f 6d6d  lt  # reuse comm
+00017020: 6f6e 2066 6163 746f 720a 2020 2020 6478  on factor.    dx
+00017030: 203d 2067 202a 2079 202a 2078 202a 2a20   = g * y * x ** 
+00017040: 2879 202d 2031 290a 2020 2020 6479 203d  (y - 1).    dy =
+00017050: 2067 7265 7375 6c74 202a 2074 6c61 6e67   gresult * tlang
+00017060: 2e6c 6f67 2878 290a 2020 2020 7265 7475  .log(x).    retu
+00017070: 726e 2064 782c 2064 790a 0a0a 4072 6567  rn dx, dy...@reg
+00017080: 6973 7465 725f 6175 676d 656e 7465 645f  ister_augmented_
+00017090: 666f 7277 6172 6428 7072 696d 732e 5072  forward(prims.Pr
+000170a0: 696d 4944 732e 5441 4e29 0a64 6566 2074  imIDs.TAN).def t
+000170b0: 616e 5f61 7567 5f66 7764 2878 293a 0a20  an_aug_fwd(x):. 
+000170c0: 2020 2022 2222 4175 676d 656e 7465 6420     """Augmented 
+000170d0: 7461 6e20 6f70 6572 6174 696f 6e2e 0a0a  tan operation...
+000170e0: 2020 2020 4172 6773 3a0a 2020 2020 2020      Args:.      
+000170f0: 2020 7820 2856 6172 6961 626c 6529 3a20    x (Variable): 
+00017100: 5465 6e73 6f72 2074 6f20 6265 2070 6173  Tensor to be pas
+00017110: 7365 6420 746f 2074 616e 2e0a 2020 2020  sed to tan..    
+00017120: 2222 220a 0a20 2020 2070 7269 6d61 6c20  """..    primal 
+00017130: 3d20 7072 696d 732e 7461 6e28 7829 0a20  = prims.tan(x). 
+00017140: 2020 2072 6573 6964 7561 6c73 203d 2028     residuals = (
+00017150: 7072 696d 616c 2c29 0a20 2020 2072 6574  primal,).    ret
+00017160: 7572 6e20 564a 5044 7561 6c28 7072 696d  urn VJPDual(prim
+00017170: 616c 2c20 7265 7369 6475 616c 7329 0a0a  al, residuals)..
+00017180: 0a40 7265 6769 7374 6572 5f62 6163 6b77  .@register_backw
+00017190: 6172 6428 7072 696d 732e 5072 696d 4944  ard(prims.PrimID
+000171a0: 732e 5441 4e29 0a64 6566 2074 616e 5f62  s.TAN).def tan_b
+000171b0: 6163 6b77 6172 6428 7265 7375 6c74 2c20  ackward(result, 
+000171c0: 6729 3a0a 2020 2020 7265 7475 726e 2067  g):.    return g
+000171d0: 202a 2028 3120 2b20 7265 7375 6c74 202a   * (1 + result *
+000171e0: 2072 6573 756c 7429 0a0a 0a23 204e 4f54   result)...# NOT
+000171f0: 453a 204a 6178 2075 7365 7320 6e70 2e61  E: Jax uses np.a
+00017200: 7267 736f 7274 2069 6e20 6974 7320 7472  rgsort in its tr
+00017210: 616e 7370 6f73 6520 766a 7020 636f 6d70  anspose vjp comp
+00017220: 7574 6174 696f 6e0a 6465 6620 5f61 7267  utation.def _arg
+00017230: 736f 7274 2873 6571 293a 0a20 2020 2072  sort(seq):.    r
+00017240: 6574 7572 6e20 736f 7274 6564 2872 616e  eturn sorted(ran
+00017250: 6765 286c 656e 2873 6571 2929 2c20 6b65  ge(len(seq)), ke
+00017260: 793d 7365 712e 5f5f 6765 7469 7465 6d5f  y=seq.__getitem_
+00017270: 5f29 0a0a 0a40 7265 6769 7374 6572 5f61  _)...@register_a
+00017280: 7567 6d65 6e74 6564 5f66 6f72 7761 7264  ugmented_forward
+00017290: 2870 7269 6d73 2e50 7269 6d49 4473 2e44  (prims.PrimIDs.D
+000172a0: 4556 4943 455f 5055 5429 0a64 6566 2064  EVICE_PUT).def d
+000172b0: 6576 6963 655f 7075 745f 6175 675f 6677  evice_put_aug_fw
+000172c0: 6428 613a 2054 656e 736f 7250 726f 7879  d(a: TensorProxy
+000172d0: 2c20 6465 7669 6365 3a20 4465 7669 6365  , device: Device
+000172e0: 2920 2d3e 2054 656e 736f 7250 726f 7879  ) -> TensorProxy
+000172f0: 3a0a 2020 2020 7072 696d 616c 203d 2070  :.    primal = p
+00017300: 7269 6d73 2e64 6576 6963 655f 7075 7428  rims.device_put(
+00017310: 612c 2064 6576 6963 6529 0a20 2020 2072  a, device).    r
+00017320: 6573 6964 7561 6c73 203d 2028 612e 6465  esiduals = (a.de
+00017330: 7669 6365 2c29 0a20 2020 2072 6574 7572  vice,).    retur
+00017340: 6e20 564a 5044 7561 6c28 7072 696d 616c  n VJPDual(primal
+00017350: 2c20 7265 7369 6475 616c 7329 0a0a 0a40  , residuals)...@
+00017360: 7265 6769 7374 6572 5f62 6163 6b77 6172  register_backwar
+00017370: 6428 7072 696d 732e 5072 696d 4944 732e  d(prims.PrimIDs.
+00017380: 4445 5649 4345 5f50 5554 290a 6465 6620  DEVICE_PUT).def 
+00017390: 6465 7669 6365 5f70 7574 5f62 6163 6b77  device_put_backw
+000173a0: 6172 6428 6f72 6967 5f64 6576 6963 652c  ard(orig_device,
+000173b0: 2067 293a 0a20 2020 2072 6574 7572 6e20   g):.    return 
+000173c0: 7072 696d 732e 6465 7669 6365 5f70 7574  prims.device_put
+000173d0: 2867 2c20 6f72 6967 5f64 6576 6963 6529  (g, orig_device)
+000173e0: 2c20 4e6f 6e65 0a0a 0a40 7265 6769 7374  , None...@regist
+000173f0: 6572 5f61 7567 6d65 6e74 6564 5f66 6f72  er_augmented_for
+00017400: 7761 7264 2870 7269 6d73 2e50 7269 6d49  ward(prims.PrimI
+00017410: 4473 2e43 4f4e 564f 4c55 5449 4f4e 290a  Ds.CONVOLUTION).
+00017420: 6465 6620 636f 6e76 6f6c 7574 696f 6e5f  def convolution_
+00017430: 6175 675f 6677 6428 0a20 2020 2061 3a20  aug_fwd(.    a: 
+00017440: 5072 6f78 792c 0a20 2020 2077 6569 6768  Proxy,.    weigh
+00017450: 742c 0a20 2020 2062 6961 732c 0a20 2020  t,.    bias,.   
+00017460: 2073 7472 6964 652c 0a20 2020 2070 6164   stride,.    pad
+00017470: 6469 6e67 2c0a 2020 2020 6469 6c61 7469  ding,.    dilati
+00017480: 6f6e 2c0a 2020 2020 7472 616e 7370 6f73  on,.    transpos
+00017490: 6564 2c0a 2020 2020 6f75 7470 7574 5f70  ed,.    output_p
+000174a0: 6164 6469 6e67 2c0a 2020 2020 6772 6f75  adding,.    grou
+000174b0: 7073 2c0a 293a 0a20 2020 2070 7269 6d61  ps,.):.    prima
+000174c0: 6c20 3d20 636f 6e76 6f6c 7574 696f 6e28  l = convolution(
+000174d0: 612c 2077 6569 6768 742c 2062 6961 732c  a, weight, bias,
+000174e0: 2073 7472 6964 652c 2070 6164 6469 6e67   stride, padding
+000174f0: 2c20 6469 6c61 7469 6f6e 2c20 7472 616e  , dilation, tran
+00017500: 7370 6f73 6564 2c20 6f75 7470 7574 5f70  sposed, output_p
+00017510: 6164 6469 6e67 2c20 6772 6f75 7073 290a  adding, groups).
+00017520: 2020 2020 7265 7369 6475 616c 7320 3d20      residuals = 
+00017530: 2870 7269 6d61 6c2c 2061 2c20 7765 6967  (primal, a, weig
+00017540: 6874 2c20 6269 6173 2c20 7374 7269 6465  ht, bias, stride
+00017550: 2c20 7061 6464 696e 672c 2064 696c 6174  , padding, dilat
+00017560: 696f 6e2c 2074 7261 6e73 706f 7365 642c  ion, transposed,
+00017570: 206f 7574 7075 745f 7061 6464 696e 672c   output_padding,
+00017580: 2067 726f 7570 7329 0a20 2020 2072 6574   groups).    ret
+00017590: 7572 6e20 564a 5044 7561 6c28 7072 696d  urn VJPDual(prim
+000175a0: 616c 2c20 7265 7369 6475 616c 7329 0a0a  al, residuals)..
+000175b0: 0a40 7265 6769 7374 6572 5f62 6163 6b77  .@register_backw
+000175c0: 6172 6428 7072 696d 732e 5072 696d 4944  ard(prims.PrimID
+000175d0: 732e 434f 4e56 4f4c 5554 494f 4e29 0a64  s.CONVOLUTION).d
+000175e0: 6566 2063 6f6e 766f 6c75 7469 6f6e 5f62  ef convolution_b
+000175f0: 6163 6b77 6172 6428 0a20 2020 206f 7574  ackward(.    out
+00017600: 7075 743a 2050 726f 7879 2c0a 2020 2020  put: Proxy,.    
+00017610: 696e 7075 743a 2050 726f 7879 2c0a 2020  input: Proxy,.  
+00017620: 2020 7765 6967 6874 2c0a 2020 2020 6269    weight,.    bi
+00017630: 6173 2c0a 2020 2020 7374 7269 6465 2c0a  as,.    stride,.
+00017640: 2020 2020 7061 6464 696e 672c 0a20 2020      padding,.   
+00017650: 2064 696c 6174 696f 6e2c 0a20 2020 2074   dilation,.    t
+00017660: 7261 6e73 706f 7365 642c 0a20 2020 206f  ransposed,.    o
+00017670: 7574 7075 745f 7061 6464 696e 672c 0a20  utput_padding,. 
+00017680: 2020 2067 726f 7570 732c 0a20 2020 2067     groups,.    g
+00017690: 7261 642c 0a29 3a0a 2020 2020 2320 5472  rad,.):.    # Tr
+000176a0: 616e 7370 6f73 6564 2063 6f6e 766f 6c75  ansposed convolu
+000176b0: 7469 6f6e 2069 7320 6e6f 7420 7375 7070  tion is not supp
+000176c0: 6f72 7465 6421 0a20 2020 2061 7373 6572  orted!.    asser
+000176d0: 7420 7472 616e 7370 6f73 6564 203d 3d20  t transposed == 
+000176e0: 300a 0a20 2020 2069 6e70 7574 5f67 7261  0..    input_gra
+000176f0: 6420 3d20 4e6f 6e65 0a20 2020 2077 6569  d = None.    wei
+00017700: 6768 745f 6772 6164 203d 204e 6f6e 650a  ght_grad = None.
+00017710: 2020 2020 6269 6173 5f67 7261 6420 3d20      bias_grad = 
+00017720: 4e6f 6e65 0a0a 2020 2020 2320 5368 6f72  None..    # Shor
+00017730: 7420 6369 7263 7569 7420 6f6e 207a 6572  t circuit on zer
+00017740: 6f2d 6469 6d20 6772 6164 0a20 2020 2069  o-dim grad.    i
+00017750: 6620 616e 7928 7320 3d3d 2030 2066 6f72  f any(s == 0 for
+00017760: 2073 2069 6e20 6772 6164 2e73 6861 7065   s in grad.shape
+00017770: 293a 0a20 2020 2020 2020 2069 6e70 7574  ):.        input
+00017780: 5f67 7261 6420 3d20 6675 6c6c 5f6c 696b  _grad = full_lik
+00017790: 6528 696e 7075 742c 2066 696c 6c5f 7661  e(input, fill_va
+000177a0: 6c75 653d 3029 0a20 2020 2020 2020 2077  lue=0).        w
+000177b0: 6569 6768 745f 6772 6164 203d 2066 756c  eight_grad = ful
+000177c0: 6c5f 6c69 6b65 2877 6569 6768 742c 2066  l_like(weight, f
+000177d0: 696c 6c5f 7661 6c75 653d 3029 0a20 2020  ill_value=0).   
+000177e0: 2020 2020 2069 6620 6269 6173 2069 7320       if bias is 
+000177f0: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
+00017800: 2020 2020 2020 6269 6173 5f67 7261 6420        bias_grad 
+00017810: 3d20 6675 6c6c 5f6c 696b 6528 6269 6173  = full_like(bias
+00017820: 2c20 6669 6c6c 5f76 616c 7565 3d30 290a  , fill_value=0).
+00017830: 2020 2020 2020 2020 7265 7475 726e 2028          return (
+00017840: 696e 7075 745f 6772 6164 2c20 7765 6967  input_grad, weig
+00017850: 6874 5f67 7261 642c 2062 6961 735f 6772  ht_grad, bias_gr
+00017860: 6164 2920 2b20 2828 4e6f 6e65 2c29 202a  ad) + ((None,) *
+00017870: 2036 290a 0a20 2020 2062 6174 6368 2c20   6)..    batch, 
+00017880: 696e 5f63 6861 6e6e 656c 732c 202a 7370  in_channels, *sp
+00017890: 6174 6961 6c5f 6469 6d73 203d 2069 6e70  atial_dims = inp
+000178a0: 7574 2e73 6861 7065 0a20 2020 206f 7574  ut.shape.    out
+000178b0: 5f63 6861 6e6e 656c 732c 2067 696e 5f63  _channels, gin_c
+000178c0: 6861 6e6e 656c 732c 202a 6b65 726e 656c  hannels, *kernel
+000178d0: 5f64 696d 7320 3d20 7765 6967 6874 2e73  _dims = weight.s
+000178e0: 6861 7065 0a20 2020 2064 696d 203d 206c  hape.    dim = l
+000178f0: 656e 2873 7061 7469 616c 5f64 696d 7329  en(spatial_dims)
+00017900: 0a0a 2020 2020 6465 6620 6d61 7962 655f  ..    def maybe_
+00017910: 6578 7061 6e64 5f73 6571 2873 2c20 6469  expand_seq(s, di
+00017920: 6d29 3a0a 2020 2020 2020 2020 6966 206c  m):.        if l
+00017930: 656e 2873 2920 3d3d 2031 3a0a 2020 2020  en(s) == 1:.    
+00017940: 2020 2020 2020 2020 7265 7475 726e 2028          return (
+00017950: 735b 305d 2c29 202a 2064 696d 0a20 2020  s[0],) * dim.   
+00017960: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00017970: 2020 2020 2020 2072 6574 7572 6e20 730a         return s.
+00017980: 0a20 2020 2073 7472 6964 6520 3d20 6d61  .    stride = ma
+00017990: 7962 655f 6578 7061 6e64 5f73 6571 2873  ybe_expand_seq(s
+000179a0: 7472 6964 652c 2064 696d 290a 2020 2020  tride, dim).    
+000179b0: 7061 6464 696e 6720 3d20 6d61 7962 655f  padding = maybe_
+000179c0: 6578 7061 6e64 5f73 6571 2870 6164 6469  expand_seq(paddi
+000179d0: 6e67 2c20 6469 6d29 0a20 2020 2064 696c  ng, dim).    dil
+000179e0: 6174 696f 6e20 3d20 6d61 7962 655f 6578  ation = maybe_ex
+000179f0: 7061 6e64 5f73 6571 2864 696c 6174 696f  pand_seq(dilatio
+00017a00: 6e2c 2064 696d 290a 0a20 2020 2064 6566  n, dim)..    def
+00017a10: 2063 6f6e 765f 7472 616e 7370 6f73 6528   conv_transpose(
+00017a20: 7429 3a0a 2020 2020 2020 2020 7265 7475  t):.        retu
+00017a30: 726e 2070 7269 6d73 2e74 7261 6e73 706f  rn prims.transpo
+00017a40: 7365 2874 2c20 2831 2c20 3029 202b 2074  se(t, (1, 0) + t
+00017a50: 7570 6c65 2872 616e 6765 2832 2c20 742e  uple(range(2, t.
+00017a60: 6e64 696d 2929 290a 0a20 2020 2023 2069  ndim)))..    # i
+00017a70: 6e70 7574 5f67 7261 6420 3d20 7b0a 2020  nput_grad = {.  
+00017a80: 2020 6465 6620 7472 616e 7370 6f73 655f    def transpose_
+00017a90: 616e 645f 666c 6970 5f77 6569 6768 7428  and_flip_weight(
+00017aa0: 7765 6967 6874 293a 0a20 2020 2020 2020  weight):.       
+00017ab0: 2023 2054 6865 206c 696e 6573 2062 656c   # The lines bel
+00017ac0: 6f77 2061 7265 2074 7261 6e73 706f 7369  ow are transposi
+00017ad0: 6e67 2074 6865 2063 6861 6e6e 656c 7320  ng the channels 
+00017ae0: 6469 6d73 2e0a 2020 2020 2020 2020 2320  dims..        # 
+00017af0: 5765 2061 6c73 6f20 6e65 6564 2074 6f20  We also need to 
+00017b00: 6578 7472 6163 7420 7468 6520 6772 6f75  extract the grou
+00017b10: 7020 696e 666f 726d 6174 696f 6e20 616e  p information an
+00017b20: 6420 6d65 7267 6520 6974 0a20 2020 2020  d merge it.     
+00017b30: 2020 2023 2077 6974 6820 7468 6520 6469     # with the di
+00017b40: 6d65 6e73 696f 6e20 636f 7272 6573 706f  mension correspo
+00017b50: 6e64 696e 6720 746f 2074 6865 2022 6f75  nding to the "ou
+00017b60: 745f 6368 616e 6e65 6c73 2220 6469 6d2e  t_channels" dim.
+00017b70: 0a20 2020 2020 2020 2023 2028 6f75 745f  .        # (out_
+00017b80: 6368 616e 6e65 6c73 2c20 6769 6e5f 6368  channels, gin_ch
+00017b90: 616e 6e65 6c73 2920 2d3e 2028 6769 6e5f  annels) -> (gin_
+00017ba0: 6368 616e 6e65 6c73 2c20 6f75 745f 6368  channels, out_ch
+00017bb0: 616e 6e65 6c73 290a 2020 2020 2020 2020  annels).        
+00017bc0: 7765 6967 6874 203d 2063 6f6e 765f 7472  weight = conv_tr
+00017bd0: 616e 7370 6f73 6528 7765 6967 6874 290a  anspose(weight).
+00017be0: 2020 2020 2020 2020 2320 5370 6c69 7420          # Split 
+00017bf0: 286f 7574 5f63 6861 6e6e 656c 732c 2920  (out_channels,) 
+00017c00: 2d3e 2028 6772 6f75 7073 2c20 6f75 745f  -> (groups, out_
+00017c10: 6368 616e 6e65 6c73 202f 2f20 6772 6f75  channels // grou
+00017c20: 7073 290a 2020 2020 2020 2020 7765 6967  ps).        weig
+00017c30: 6874 203d 2077 6569 6768 742e 7265 7368  ht = weight.resh
+00017c40: 6170 6528 5b67 696e 5f63 6861 6e6e 656c  ape([gin_channel
+00017c50: 732c 2067 726f 7570 732c 206f 7574 5f63  s, groups, out_c
+00017c60: 6861 6e6e 656c 7320 2f2f 2067 726f 7570  hannels // group
+00017c70: 735d 202b 206b 6572 6e65 6c5f 6469 6d73  s] + kernel_dims
+00017c80: 290a 2020 2020 2020 2020 2320 4d6f 7669  ).        # Movi
+00017c90: 6e67 2067 726f 7570 7320 746f 2074 6865  ng groups to the
+00017ca0: 206c 6566 742d 6d6f 7374 2070 6f73 6974   left-most posit
+00017cb0: 696f 6e2e 0a20 2020 2020 2020 2023 2028  ion..        # (
+00017cc0: 6769 6e5f 6368 616e 6e65 6c73 2c20 6772  gin_channels, gr
+00017cd0: 6f75 7073 2c20 6f75 745f 6368 616e 6e65  oups, out_channe
+00017ce0: 6c73 202f 2f20 6772 6f75 7073 2920 2d3e  ls // groups) ->
+00017cf0: 2028 6772 6f75 7073 2c20 6769 6e5f 6368   (groups, gin_ch
+00017d00: 616e 6e65 6c73 2c20 6f75 745f 6368 616e  annels, out_chan
+00017d10: 6e65 6c73 202f 2f20 6772 6f75 7073 290a  nels // groups).
+00017d20: 2020 2020 2020 2020 7765 6967 6874 203d          weight =
+00017d30: 2063 6f6e 765f 7472 616e 7370 6f73 6528   conv_transpose(
+00017d40: 7765 6967 6874 290a 2020 2020 2020 2020  weight).        
+00017d50: 2320 5371 7561 7368 2028 6772 6f75 7073  # Squash (groups
+00017d60: 2c20 6769 6e5f 6368 616e 6e65 6c73 2920  , gin_channels) 
+00017d70: 2d3e 2028 696e 5f63 6861 6e6e 656c 7329  -> (in_channels)
+00017d80: 0a20 2020 2020 2020 2077 6569 6768 7420  .        weight 
+00017d90: 3d20 7765 6967 6874 2e72 6573 6861 7065  = weight.reshape
+00017da0: 285b 696e 5f63 6861 6e6e 656c 732c 206f  ([in_channels, o
+00017db0: 7574 5f63 6861 6e6e 656c 7320 2f2f 2067  ut_channels // g
+00017dc0: 726f 7570 735d 202b 206b 6572 6e65 6c5f  roups] + kernel_
+00017dd0: 6469 6d73 290a 0a20 2020 2020 2020 2023  dims)..        #
+00017de0: 2046 6c69 7020 7370 6174 6961 6c20 6469   Flip spatial di
+00017df0: 6d65 6e73 696f 6e73 0a20 2020 2020 2020  mensions.       
+00017e00: 2077 6569 6768 7420 3d20 7072 696d 732e   weight = prims.
+00017e10: 666c 6970 2877 6569 6768 742c 2074 7570  flip(weight, tup
+00017e20: 6c65 2872 616e 6765 2832 2c20 7765 6967  le(range(2, weig
+00017e30: 6874 2e6e 6469 6d29 2929 0a20 2020 2020  ht.ndim))).     
+00017e40: 2020 2072 6574 7572 6e20 7765 6967 6874     return weight
+00017e50: 0a0a 2020 2020 2320 5765 206e 6565 6420  ..    # We need 
+00017e60: 746f 2070 6164 2074 6865 2067 7261 6469  to pad the gradi
+00017e70: 656e 7420 746f 2062 6520 6162 6c65 2074  ent to be able t
+00017e80: 6f20 6669 7420 6b65 726e 656c 2077 696e  o fit kernel win
+00017e90: 646f 7773 2e0a 2020 2020 696e 6974 6961  dows..    initia
+00017ea0: 6c5f 6772 6164 5f70 6164 6469 6e67 203d  l_grad_padding =
+00017eb0: 205b 6420 2a20 286b 202d 2031 2920 666f   [d * (k - 1) fo
+00017ec0: 7220 642c 206b 2069 6e20 7a69 7028 6469  r d, k in zip(di
+00017ed0: 6c61 7469 6f6e 2c20 6b65 726e 656c 5f64  lation, kernel_d
+00017ee0: 696d 7329 5d0a 0a20 2020 2069 6e70 7574  ims)]..    input
+00017ef0: 5f67 7261 6420 3d20 636f 6e76 6f6c 7574  _grad = convolut
+00017f00: 696f 6e28 0a20 2020 2020 2020 2070 7269  ion(.        pri
+00017f10: 6d73 2e70 6164 280a 2020 2020 2020 2020  ms.pad(.        
+00017f20: 2020 2020 6772 6164 2c0a 2020 2020 2020      grad,.      
+00017f30: 2020 2020 2020 302e 302c 0a20 2020 2020        0.0,.     
+00017f40: 2020 2020 2020 2023 2054 6865 2070 6978         # The pix
+00017f50: 6573 2061 7265 2073 7472 6964 6520 6177  es are stride aw
+00017f60: 6179 2066 726f 6d20 6561 6368 206f 7468  ay from each oth
+00017f70: 6572 2069 6e20 7468 6520 6f72 6967 696e  er in the origin
+00017f80: 616c 2069 6e70 7574 2e0a 2020 2020 2020  al input..      
+00017f90: 2020 2020 2020 2320 4865 6e63 6520 7765        # Hence we
+00017fa0: 206e 6565 6420 746f 2064 696c 6174 6520   need to dilate 
+00017fb0: 7468 6520 6772 6164 6965 6e74 2062 7920  the gradient by 
+00017fc0: 6469 6c61 7469 6f6e 3d73 7472 6964 6520  dilation=stride 
+00017fd0: 2d20 310a 2020 2020 2020 2020 2020 2020  - 1.            
+00017fe0: 2320 736f 2074 6861 7420 7468 6572 6520  # so that there 
+00017ff0: 6172 6520 7374 7269 6465 202d 2031 207a  are stride - 1 z
+00018000: 6572 6f73 2062 6574 7765 656e 2074 6865  eros between the
+00018010: 2070 6978 656c 732e 0a20 2020 2020 2020   pixels..       
+00018020: 2020 2020 205b 2830 2c20 302c 2030 292c       [(0, 0, 0),
+00018030: 2028 302c 2030 2c20 3029 5d20 2b20 5b28   (0, 0, 0)] + [(
+00018040: 302c 2030 2c20 7320 2d20 3129 2066 6f72  0, 0, s - 1) for
+00018050: 2073 2069 6e20 7374 7269 6465 5d2c 0a20   s in stride],. 
+00018060: 2020 2020 2020 2029 2c0a 2020 2020 2020         ),.      
+00018070: 2020 7472 616e 7370 6f73 655f 616e 645f    transpose_and_
+00018080: 666c 6970 5f77 6569 6768 7428 7765 6967  flip_weight(weig
+00018090: 6874 292c 0a20 2020 2020 2020 204e 6f6e  ht),.        Non
+000180a0: 652c 0a20 2020 2020 2020 2023 2053 6574  e,.        # Set
+000180b0: 7469 6e67 2073 7472 6964 6520 746f 2031  ting stride to 1
+000180c0: 2061 7320 7468 6520 6469 7374 616e 6365   as the distance
+000180d0: 2062 6574 7765 656e 2070 6978 656c 7320   between pixels 
+000180e0: 6973 2074 616b 656e 0a20 2020 2020 2020  is taken.       
+000180f0: 2023 2063 6172 6520 6279 2074 6865 2070   # care by the p
+00018100: 6164 2072 6967 6874 2061 626f 7665 2e0a  ad right above..
+00018110: 2020 2020 2020 2020 2831 2c29 2c0a 2020          (1,),.  
+00018120: 2020 2020 2020 696e 6974 6961 6c5f 6772        initial_gr
+00018130: 6164 5f70 6164 6469 6e67 2c0a 2020 2020  ad_padding,.    
+00018140: 2020 2020 6469 6c61 7469 6f6e 2c0a 2020      dilation,.  
+00018150: 2020 2020 2020 7472 616e 7370 6f73 6564        transposed
+00018160: 2c0a 2020 2020 2020 2020 6f75 7470 7574  ,.        output
+00018170: 5f70 6164 6469 6e67 2c0a 2020 2020 2020  _padding,.      
+00018180: 2020 6772 6f75 7073 2c0a 2020 2020 290a    groups,.    ).
+00018190: 0a20 2020 2064 6566 2070 6164 5f74 6f5f  .    def pad_to_
+000181a0: 696e 7075 7428 6772 6164 293a 0a20 2020  input(grad):.   
+000181b0: 2020 2020 2023 2057 6520 6e65 6564 2074       # We need t
+000181c0: 6f20 756e 7061 6420 7468 6520 7061 6464  o unpad the padd
+000181d0: 696e 6720 646f 6e65 2074 6f20 7468 6520  ing done to the 
+000181e0: 696e 7075 7420 7072 696f 7220 746f 2074  input prior to t
+000181f0: 6865 2063 6f6e 766f 6c75 7469 6f6e 2e0a  he convolution..
+00018200: 2020 2020 2020 2020 2320 4e6f 7465 2074          # Note t
+00018210: 6861 7420 6c6f 7720 616e 6420 6869 6768  hat low and high
+00018220: 2070 6164 6469 6e67 2061 7265 206e 6f74   padding are not
+00018230: 206e 6563 6573 7361 7269 6c79 2065 7175   necessarily equ
+00018240: 616c 2c20 736f 2077 6520 6361 6e6e 6f74  al, so we cannot
+00018250: 0a20 2020 2020 2020 2023 2061 6273 6f72  .        # absor
+00018260: 6220 6974 2069 6e74 6f20 7468 6520 636f  b it into the co
+00018270: 6e76 6f6c 7574 696f 6e20 6a75 7374 2079  nvolution just y
+00018280: 6574 2c20 756e 6c65 7373 2074 6865 2041  et, unless the A
+00018290: 5049 2069 7320 6d6f 6469 6669 6564 2e0a  PI is modified..
+000182a0: 2020 2020 2020 2020 7061 645f 636f 6e66          pad_conf
+000182b0: 6967 203d 205b 2830 2c20 302c 2030 292c  ig = [(0, 0, 0),
+000182c0: 2028 302c 2030 2c20 3029 5d0a 2020 2020   (0, 0, 0)].    
+000182d0: 2020 2020 666f 7220 6f2c 2069 2c20 672c      for o, i, g,
+000182e0: 2070 2069 6e20 7a69 7028 6772 6164 2e73   p in zip(grad.s
+000182f0: 6861 7065 5b32 3a5d 2c20 7370 6174 6961  hape[2:], spatia
+00018300: 6c5f 6469 6d73 2c20 696e 7075 745f 6772  l_dims, input_gr
+00018310: 6164 2e73 6861 7065 5b32 3a5d 2c20 7061  ad.shape[2:], pa
+00018320: 6464 696e 6729 3a0a 2020 2020 2020 2020  dding):.        
+00018330: 2020 2020 6c6f 203d 202d 700a 2020 2020      lo = -p.    
+00018340: 2020 2020 2020 2020 2320 4e6f 7465 2074          # Note t
+00018350: 6861 7420 2869 202b 2032 202a 2070 2920  hat (i + 2 * p) 
+00018360: 6973 2074 6865 2073 697a 6520 6f66 2074  is the size of t
+00018370: 6865 2070 6164 6465 6420 696e 7075 742c  he padded input,
+00018380: 0a20 2020 2020 2020 2020 2020 2023 2073  .            # s
+00018390: 6f20 7468 6520 7175 616e 7469 7479 2028  o the quantity (
+000183a0: 6920 2b20 3220 2a20 7029 202d 2067 2074  i + 2 * p) - g t
+000183b0: 656c 6c73 2075 7320 6279 2068 6f77 206d  ells us by how m
+000183c0: 7563 680a 2020 2020 2020 2020 2020 2020  uch.            
+000183d0: 2320 7765 206e 6565 6420 746f 2070 6164  # we need to pad
+000183e0: 2074 6865 2067 7261 6469 656e 7420 736f   the gradient so
+000183f0: 2074 6861 7420 7468 6520 656c 656d 656e   that the elemen
+00018400: 7473 206f 7574 7369 6465 0a20 2020 2020  ts outside.     
+00018410: 2020 2020 2020 2023 206f 6620 7468 6520         # of the 
+00018420: 636f 6e76 6f6c 7574 696f 6e20 7265 6365  convolution rece
+00018430: 6976 6520 7a65 726f 2067 7261 6469 656e  ive zero gradien
+00018440: 742e 0a20 2020 2020 2020 2020 2020 2023  t..            #
+00018450: 2070 2069 7320 6164 6469 7469 6f6e 616c   p is additional
+00018460: 6c79 2073 7562 7472 6163 7465 6420 746f  ly subtracted to
+00018470: 206e 6567 6174 6520 7468 6520 696e 7075   negate the inpu
+00018480: 7427 7320 7061 640a 2020 2020 2020 2020  t's pad.        
+00018490: 2020 2020 2320 696e 2066 6f72 7761 7264      # in forward
+000184a0: 2e0a 2020 2020 2020 2020 2020 2020 6869  ..            hi
+000184b0: 203d 2028 6920 2b20 3220 2a20 7029 202d   = (i + 2 * p) -
+000184c0: 2067 202d 2070 0a20 2020 2020 2020 2020   g - p.         
+000184d0: 2020 2070 6164 5f63 6f6e 6669 672e 6170     pad_config.ap
+000184e0: 7065 6e64 2828 6c6f 2c20 6869 2c20 3029  pend((lo, hi, 0)
+000184f0: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+00018500: 2070 7269 6d73 2e70 6164 2867 7261 642c   prims.pad(grad,
+00018510: 2030 2e30 2c20 7061 645f 636f 6e66 6967   0.0, pad_config
+00018520: 290a 0a20 2020 2069 6e70 7574 5f67 7261  )..    input_gra
+00018530: 6420 3d20 7061 645f 746f 5f69 6e70 7574  d = pad_to_input
+00018540: 2869 6e70 7574 5f67 7261 6429 0a20 2020  (input_grad).   
+00018550: 2023 207d 0a0a 2020 2020 2320 6269 6173   # }..    # bias
+00018560: 5f67 7261 6420 3d20 7b0a 2020 2020 6966  _grad = {.    if
+00018570: 2062 6961 7320 6973 206e 6f74 204e 6f6e   bias is not Non
+00018580: 653a 0a20 2020 2020 2020 2069 6d70 6f72  e:.        impor
+00018590: 7420 7468 756e 6465 722e 746f 7263 6820  t thunder.torch 
+000185a0: 6173 206c 746f 7263 680a 0a20 2020 2020  as ltorch..     
+000185b0: 2020 2062 6961 735f 6772 6164 203d 206c     bias_grad = l
+000185c0: 746f 7263 682e 7375 6d28 6772 6164 2c20  torch.sum(grad, 
+000185d0: 5b64 2066 6f72 2064 2069 6e20 7261 6e67  [d for d in rang
+000185e0: 6528 6772 6164 2e6e 6469 6d29 2069 6620  e(grad.ndim) if 
+000185f0: 6420 213d 2031 5d29 0a20 2020 2023 207d  d != 1]).    # }
+00018600: 0a0a 2020 2020 2320 7765 6967 6874 2067  ..    # weight g
+00018610: 7261 6420 3d20 7b0a 2020 2020 6465 6620  rad = {.    def 
+00018620: 7061 645f 7472 616e 7370 6f73 655f 616e  pad_transpose_an
+00018630: 645f 7075 7368 5f67 726f 7570 735f 696e  d_push_groups_in
+00018640: 746f 5f62 6174 6368 6573 2874 293a 0a20  to_batches(t):. 
+00018650: 2020 2020 2020 2023 2046 6972 7374 2070         # First p
+00018660: 6164 2c2e 2e2e 0a20 2020 2020 2020 2023  ad,....        #
+00018670: 2050 6164 2061 7320 6e65 6365 7373 6172   Pad as necessar
+00018680: 7920 736f 2074 6861 7420 696e 2063 6f6e  y so that in con
+00018690: 766f 6c75 7469 6f6e 7320 7765 206e 6576  volutions we nev
+000186a0: 6572 2061 6476 616e 6365 0a20 2020 2020  er advance.     
+000186b0: 2020 2023 2070 6173 7420 7265 6c65 7661     # past releva
+000186c0: 6e74 2069 6e70 7574 732e 0a20 2020 2020  nt inputs..     
+000186d0: 2020 2070 6164 5f63 6f6e 6669 6720 3d20     pad_config = 
+000186e0: 5b28 302c 2030 2c20 3029 2c20 2830 2c20  [(0, 0, 0), (0, 
+000186f0: 302c 2030 295d 0a20 2020 2020 2020 2066  0, 0)].        f
+00018700: 6f72 206f 2c20 692c 206b 2c20 702c 2073  or o, i, k, p, s
+00018710: 2c20 6420 696e 207a 6970 2867 7261 642e  , d in zip(grad.
+00018720: 7368 6170 655b 323a 5d2c 2073 7061 7469  shape[2:], spati
+00018730: 616c 5f64 696d 732c 206b 6572 6e65 6c5f  al_dims, kernel_
+00018740: 6469 6d73 2c20 7061 6464 696e 672c 2073  dims, padding, s
+00018750: 7472 6964 652c 2064 696c 6174 696f 6e29  tride, dilation)
+00018760: 3a0a 2020 2020 2020 2020 2020 2020 2320  :.            # 
+00018770: 5061 6464 696e 6720 6672 6f6d 2062 656c  Padding from bel
+00018780: 6f77 2069 7320 7468 6520 7361 6d65 2e0a  ow is the same..
+00018790: 2020 2020 2020 2020 2020 2020 6c6f 203d              lo =
+000187a0: 2070 0a20 2020 2020 2020 2020 2020 2023   p.            #
+000187b0: 2054 6865 7265 2069 7320 616c 7761 7973   There is always
+000187c0: 2074 6865 206d 6178 2069 6e64 6578 2069   the max index i
+000187d0: 6478 2069 6e20 7468 6520 696e 7075 740a  dx in the input.
+000187e0: 2020 2020 2020 2020 2020 2020 2320 7468              # th
+000187f0: 6520 7661 6c75 6520 6f66 2077 6869 6368  e value of which
+00018800: 2c20 696e 7075 745b 6964 785d 2c20 7468  , input[idx], th
+00018810: 6520 6b65 726e 656c 2074 6f75 6368 6573  e kernel touches
+00018820: 2e0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
+00018830: 5468 6520 6b65 726e 656c 2072 6561 6368  The kernel reach
+00018840: 2c20 6f72 206b 5f72 6561 6368 2c20 6973  , or k_reach, is
+00018850: 2065 7861 6374 6c79 2069 6478 202b 2031   exactly idx + 1
+00018860: 2e0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
+00018870: 5765 2075 7365 2069 7420 746f 2064 6563  We use it to dec
+00018880: 6964 6520 6279 2068 6f77 206d 7563 6820  ide by how much 
+00018890: 7765 206e 6565 6420 746f 2070 6164 2066  we need to pad f
+000188a0: 726f 6d20 6162 6f76 650a 2020 2020 2020  rom above.      
+000188b0: 2020 2020 2020 2320 6173 2074 6f20 6e6f        # as to no
+000188c0: 7420 6d6f 7665 2070 6173 7420 7265 6c65  t move past rele
+000188d0: 7661 6e74 2076 616c 7565 732e 0a20 2020  vant values..   
+000188e0: 2020 2020 2020 2020 206b 5f72 6561 6368           k_reach
+000188f0: 203d 2028 6f20 2d20 3129 202a 2073 202b   = (o - 1) * s +
+00018900: 2064 202a 2028 6b20 2d20 3129 202b 2031   d * (k - 1) + 1
+00018910: 0a20 2020 2020 2020 2020 2020 2023 2054  .            # T
+00018920: 6865 2070 6164 2066 726f 6d20 6162 6f76  he pad from abov
+00018930: 6520 6571 7561 6c73 206b 5f72 6561 6368  e equals k_reach
+00018940: 206d 696e 7573 2074 6865 206c 656e 6774   minus the lengt
+00018950: 680a 2020 2020 2020 2020 2020 2020 2320  h.            # 
+00018960: 6f66 2074 6865 2069 6e70 7574 2070 6164  of the input pad
+00018970: 6465 6420 6672 6f6d 2062 656c 6f77 2e0a  ded from below..
+00018980: 2020 2020 2020 2020 2020 2020 6869 203d              hi =
+00018990: 206b 5f72 6561 6368 202d 2028 6920 2b20   k_reach - (i + 
+000189a0: 7029 0a20 2020 2020 2020 2020 2020 2070  p).            p
+000189b0: 6164 5f63 6f6e 6669 672e 6170 7065 6e64  ad_config.append
+000189c0: 2828 6c6f 2c20 6869 2c20 3029 290a 2020  ((lo, hi, 0)).  
+000189d0: 2020 2020 2020 7420 3d20 7072 696d 732e        t = prims.
+000189e0: 7061 6428 742c 2030 2e30 2c20 7061 645f  pad(t, 0.0, pad_
+000189f0: 636f 6e66 6967 290a 0a20 2020 2020 2020  config)..       
+00018a00: 205f 2c20 5f2c 202a 745f 7370 6174 6961   _, _, *t_spatia
+00018a10: 6c5f 6469 6d73 203d 2074 2e73 6861 7065  l_dims = t.shape
+00018a20: 0a0a 2020 2020 2020 2020 2320 2e2e 2e20  ..        # ... 
+00018a30: 7468 656e 2064 6f20 7468 6520 7265 7374  then do the rest
+00018a40: 2e0a 2020 2020 2020 2020 2320 742e 7368  ..        # t.sh
+00018a50: 6170 6520 3d3d 2028 6261 7463 682c 2069  ape == (batch, i
+00018a60: 6e5f 6368 616e 6e65 6c73 2c20 2e2e 2e29  n_channels, ...)
+00018a70: 0a20 2020 2020 2020 2023 2054 6865 2072  .        # The r
+00018a80: 6573 756c 7420 6f66 2074 6869 7320 6675  esult of this fu
+00018a90: 6e63 7469 6f6e 2068 6173 2073 6861 7065  nction has shape
+00018aa0: 0a20 2020 2020 2020 2023 2028 696e 5f63  .        # (in_c
+00018ab0: 6861 6e6e 656c 732c 2062 6174 6368 202a  hannels, batch *
+00018ac0: 2067 726f 7570 7329 0a20 2020 2020 2020   groups).       
+00018ad0: 2023 2028 6261 7463 682c 2069 6e5f 6368   # (batch, in_ch
+00018ae0: 616e 6e65 6c73 2920 2d3e 2028 696e 5f63  annels) -> (in_c
+00018af0: 6861 6e6e 656c 732c 2062 6174 6368 290a  hannels, batch).
+00018b00: 2020 2020 2020 2020 7420 3d20 636f 6e76          t = conv
+00018b10: 5f74 7261 6e73 706f 7365 2874 290a 2020  _transpose(t).  
+00018b20: 2020 2020 2020 2320 5370 6c69 7420 2869        # Split (i
+00018b30: 6e5f 6368 616e 6e65 6c73 2c29 202d 3e20  n_channels,) -> 
+00018b40: 2867 726f 7570 732c 2067 696e 5f63 6861  (groups, gin_cha
+00018b50: 6e6e 656c 7329 0a20 2020 2020 2020 2074  nnels).        t
+00018b60: 203d 2074 2e72 6573 6861 7065 285b 6772   = t.reshape([gr
+00018b70: 6f75 7073 2c20 6769 6e5f 6368 616e 6e65  oups, gin_channe
+00018b80: 6c73 2c20 6261 7463 685d 202b 2074 5f73  ls, batch] + t_s
+00018b90: 7061 7469 616c 5f64 696d 7329 0a20 2020  patial_dims).   
+00018ba0: 2020 2020 2023 2054 7261 6e73 706f 7365       # Transpose
+00018bb0: 2028 6772 6f75 7073 2c20 6769 6e5f 6368   (groups, gin_ch
+00018bc0: 616e 6e65 6c73 2c20 6261 7463 6829 202d  annels, batch) -
+00018bd0: 3e20 2867 696e 5f63 6861 6e6e 656c 732c  > (gin_channels,
+00018be0: 2067 726f 7570 732c 2062 6174 6368 290a   groups, batch).
+00018bf0: 2020 2020 2020 2020 7420 3d20 636f 6e76          t = conv
+00018c00: 5f74 7261 6e73 706f 7365 2874 290a 2020  _transpose(t).  
+00018c10: 2020 2020 2020 2320 466c 6174 7465 6e20        # Flatten 
+00018c20: 2867 726f 7570 732c 2062 6174 6368 2920  (groups, batch) 
+00018c30: 2d3e 2028 6772 6f75 7073 202a 2062 6174  -> (groups * bat
+00018c40: 6368 2c29 0a20 2020 2020 2020 2074 203d  ch,).        t =
+00018c50: 2074 2e72 6573 6861 7065 285b 6769 6e5f   t.reshape([gin_
+00018c60: 6368 616e 6e65 6c73 2c20 6772 6f75 7073  channels, groups
+00018c70: 202a 2062 6174 6368 5d20 2b20 745f 7370   * batch] + t_sp
+00018c80: 6174 6961 6c5f 6469 6d73 290a 2020 2020  atial_dims).    
+00018c90: 2020 2020 7265 7475 726e 2074 0a0a 2020      return t..  
+00018ca0: 2020 2320 696e 7075 7420 7769 6c6c 2068    # input will h
+00018cb0: 6176 6520 7368 6170 6520 2867 696e 5f63  ave shape (gin_c
+00018cc0: 6861 6e6e 656c 732c 2067 726f 7570 7320  hannels, groups 
+00018cd0: 2a20 6261 7463 6829 0a20 2020 2069 6e70  * batch).    inp
+00018ce0: 7574 203d 2070 6164 5f74 7261 6e73 706f  ut = pad_transpo
+00018cf0: 7365 5f61 6e64 5f70 7573 685f 6772 6f75  se_and_push_grou
+00018d00: 7073 5f69 6e74 6f5f 6261 7463 6865 7328  ps_into_batches(
+00018d10: 696e 7075 7429 0a20 2020 2023 2067 7261  input).    # gra
+00018d20: 6420 7769 6c6c 2068 6176 6520 7368 6170  d will have shap
+00018d30: 6520 286f 7574 5f63 6861 6e6e 656c 732c  e (out_channels,
+00018d40: 2062 6174 6368 290a 2020 2020 2320 4e6f   batch).    # No
+00018d50: 7465 2074 6861 7420 7468 6573 6520 7368  te that these sh
+00018d60: 6170 6573 2061 7265 2063 6f6d 7061 7469  apes are compati
+00018d70: 626c 6520 666f 7220 6120 6772 6f75 7020  ble for a group 
+00018d80: 636f 6e76 6f6c 7574 696f 6e2e 0a20 2020  convolution..   
+00018d90: 2067 7261 6420 3d20 636f 6e76 5f74 7261   grad = conv_tra
+00018da0: 6e73 706f 7365 2867 7261 6429 0a0a 2020  nspose(grad)..  
+00018db0: 2020 2320 5768 7920 646f 2077 6520 666c    # Why do we fl
+00018dc0: 6970 2073 7472 6964 6520 616e 6420 6469  ip stride and di
+00018dd0: 6c61 7469 6f6e 3f0a 2020 2020 2320 6b65  lation?.    # ke
+00018de0: 726e 656c 5b69 5d20 616e 6420 6b65 726e  rnel[i] and kern
+00018df0: 656c 5b69 202b 2031 5d20 6172 6520 6469  el[i + 1] are di
+00018e00: 6c61 7469 6f6e 2061 7061 7274 2066 726f  lation apart fro
+00018e10: 6d20 6561 6368 206f 7468 6572 2c0a 2020  m each other,.  
+00018e20: 2020 2320 736f 2064 696c 6174 696f 6e20    # so dilation 
+00018e30: 6265 636f 6d65 7320 7468 6520 6e65 7720  becomes the new 
+00018e40: 7374 7269 6465 2e0a 2020 2020 2320 416c  stride..    # Al
+00018e50: 6c20 7468 6520 656c 656d 656e 7473 2074  l the elements t
+00018e60: 6861 7420 6b65 726e 656c 5b69 5d20 746f  hat kernel[i] to
+00018e70: 7563 6865 7320 6172 6520 7374 7269 6465  uches are stride
+00018e80: 2061 7761 7920 6672 6f6d 2065 6163 6820   away from each 
+00018e90: 6f74 6865 722c 0a20 2020 2023 2068 656e  other,.    # hen
+00018ea0: 6365 2073 7472 6964 6520 6265 636f 6d65  ce stride become
+00018eb0: 7320 7468 6520 6e65 7720 6469 6c61 7469  s the new dilati
+00018ec0: 6f6e 2e0a 2020 2020 7765 6967 6874 5f67  on..    weight_g
+00018ed0: 7261 6420 3d20 636f 6e76 6f6c 7574 696f  rad = convolutio
+00018ee0: 6e28 0a20 2020 2020 2020 2069 6e70 7574  n(.        input
+00018ef0: 2c0a 2020 2020 2020 2020 6772 6164 2c0a  ,.        grad,.
+00018f00: 2020 2020 2020 2020 4e6f 6e65 2c0a 2020          None,.  
+00018f10: 2020 2020 2020 6469 6c61 7469 6f6e 2c20        dilation, 
+00018f20: 2023 2073 6574 2073 7472 6964 653d 6469   # set stride=di
+00018f30: 6c61 7469 6f6e 0a20 2020 2020 2020 2028  lation.        (
+00018f40: 302c 292c 0a20 2020 2020 2020 2073 7472  0,),.        str
+00018f50: 6964 652c 2020 2320 7365 7420 6469 6c61  ide,  # set dila
+00018f60: 7469 6f6e 3d73 7472 6964 650a 2020 2020  tion=stride.    
+00018f70: 2020 2020 7472 616e 7370 6f73 6564 2c0a      transposed,.
+00018f80: 2020 2020 2020 2020 6f75 7470 7574 5f70          output_p
+00018f90: 6164 6469 6e67 2c0a 2020 2020 2020 2020  adding,.        
+00018fa0: 6772 6f75 7073 2c0a 2020 2020 290a 0a20  groups,.    ).. 
+00018fb0: 2020 2023 2054 6865 2072 6573 756c 7420     # The result 
+00018fc0: 6f66 2074 6865 2063 6f6e 766f 6c75 7469  of the convoluti
+00018fd0: 6f6e 2068 6173 2073 6861 7065 2028 6769  on has shape (gi
+00018fe0: 6e5f 6368 616e 6e65 6c73 2c20 6f75 745f  n_channels, out_
+00018ff0: 6368 616e 6e65 6c73 292c 0a20 2020 2023  channels),.    #
+00019000: 2073 6f20 7472 616e 7370 6f73 6974 696f   so transpositio
+00019010: 6e20 6973 2072 6571 7569 7265 642e 0a20  n is required.. 
+00019020: 2020 2077 6569 6768 745f 6772 6164 203d     weight_grad =
+00019030: 2063 6f6e 765f 7472 616e 7370 6f73 6528   conv_transpose(
+00019040: 7765 6967 6874 5f67 7261 6429 0a20 2020  weight_grad).   
+00019050: 2023 207d 0a0a 2020 2020 7265 7475 726e   # }..    return
+00019060: 2028 696e 7075 745f 6772 6164 2c20 7765   (input_grad, we
+00019070: 6967 6874 5f67 7261 642c 2062 6961 735f  ight_grad, bias_
+00019080: 6772 6164 290a 0a0a 4072 6567 6973 7465  grad)...@registe
+00019090: 725f 6175 676d 656e 7465 645f 666f 7277  r_augmented_forw
+000190a0: 6172 6428 2274 6f72 6368 2e6c 6f67 5f73  ard("torch.log_s
+000190b0: 6f66 746d 6178 2229 0a64 6566 206c 6f67  oftmax").def log
+000190c0: 5f73 6f66 746d 6178 5f61 7567 5f66 7764  _softmax_aug_fwd
+000190d0: 2869 6e70 7574 3a20 5465 6e73 6f72 5072  (input: TensorPr
+000190e0: 6f78 792c 2064 696d 3a20 696e 742c 202a  oxy, dim: int, *
+000190f0: 2c20 6474 7970 653d 4e6f 6e65 2920 2d3e  , dtype=None) ->
+00019100: 2056 4a50 4475 616c 3a0a 2020 2020 6672   VJPDual:.    fr
+00019110: 6f6d 2074 6875 6e64 6572 2e74 6f72 6368  om thunder.torch
+00019120: 2069 6d70 6f72 7420 6c6f 675f 736f 6674   import log_soft
+00019130: 6d61 780a 0a20 2020 2070 7269 6d61 6c20  max..    primal 
+00019140: 3d20 6c6f 675f 736f 6674 6d61 7828 696e  = log_softmax(in
+00019150: 7075 742c 2064 696d 3d64 696d 2c20 6474  put, dim=dim, dt
+00019160: 7970 653d 6474 7970 6529 0a20 2020 2072  ype=dtype).    r
+00019170: 6573 6964 7561 6c73 203d 2028 7072 696d  esiduals = (prim
+00019180: 616c 2c20 6469 6d2c 2069 6e70 7574 2e64  al, dim, input.d
+00019190: 7479 7065 290a 2020 2020 7265 7475 726e  type).    return
+000191a0: 2056 4a50 4475 616c 2870 7269 6d61 6c2c   VJPDual(primal,
+000191b0: 2072 6573 6964 7561 6c73 290a 0a0a 4072   residuals)...@r
+000191c0: 6567 6973 7465 725f 6261 636b 7761 7264  egister_backward
+000191d0: 2822 746f 7263 682e 6c6f 675f 736f 6674  ("torch.log_soft
+000191e0: 6d61 7822 290a 6465 6620 6c6f 675f 736f  max").def log_so
+000191f0: 6674 6d61 785f 6261 636b 7761 7264 2870  ftmax_backward(p
+00019200: 7269 6d61 6c2c 2064 696d 2c20 6474 7970  rimal, dim, dtyp
+00019210: 652c 2067 293a 0a20 2020 2066 726f 6d20  e, g):.    from 
+00019220: 7468 756e 6465 722e 746f 7263 6820 696d  thunder.torch im
+00019230: 706f 7274 206c 6f67 5f73 6f66 746d 6178  port log_softmax
+00019240: 5f62 6163 6b77 6172 640a 0a20 2020 2072  _backward..    r
+00019250: 6574 7572 6e20 6c6f 675f 736f 6674 6d61  eturn log_softma
+00019260: 785f 6261 636b 7761 7264 2867 2c20 7072  x_backward(g, pr
+00019270: 696d 616c 2c20 6469 6d2c 2064 7479 7065  imal, dim, dtype
+00019280: 290a 0a0a 4072 6567 6973 7465 725f 6175  )...@register_au
+00019290: 676d 656e 7465 645f 666f 7277 6172 6428  gmented_forward(
+000192a0: 2274 6f72 6368 2e6e 6e2e 6675 6e63 7469  "torch.nn.functi
+000192b0: 6f6e 616c 2e6e 6c6c 5f6c 6f73 7322 290a  onal.nll_loss").
+000192c0: 6465 6620 6e6c 6c5f 6c6f 7373 5f61 7567  def nll_loss_aug
+000192d0: 5f66 7764 280a 2020 2020 696e 7075 743a  _fwd(.    input:
+000192e0: 2050 726f 7879 2c0a 2020 2020 7461 7267   Proxy,.    targ
+000192f0: 6574 3a20 5072 6f78 792c 0a20 2020 2077  et: Proxy,.    w
+00019300: 6569 6768 743a 204e 6f6e 6520 7c20 5072  eight: None | Pr
+00019310: 6f78 792c 0a20 2020 2069 676e 6f72 655f  oxy,.    ignore_
+00019320: 696e 6465 783a 2069 6e74 2c0a 2020 2020  index: int,.    
+00019330: 7265 6475 6374 696f 6e3a 2073 7472 2c0a  reduction: str,.
+00019340: 2920 2d3e 2056 4a50 4475 616c 3a0a 2020  ) -> VJPDual:.  
+00019350: 2020 6672 6f6d 2074 6875 6e64 6572 2e74    from thunder.t
+00019360: 6f72 6368 2069 6d70 6f72 7420 5f6e 6c6c  orch import _nll
+00019370: 5f6c 6f73 735f 6865 6c70 6572 0a0a 2020  _loss_helper..  
+00019380: 2020 7072 696d 616c 2c20 746f 7461 6c5f    primal, total_
+00019390: 7765 6967 6874 203d 205f 6e6c 6c5f 6c6f  weight = _nll_lo
+000193a0: 7373 5f68 656c 7065 7228 0a20 2020 2020  ss_helper(.     
+000193b0: 2020 2069 6e70 7574 2c0a 2020 2020 2020     input,.      
+000193c0: 2020 7461 7267 6574 2c0a 2020 2020 2020    target,.      
+000193d0: 2020 7765 6967 6874 2c0a 2020 2020 2020    weight,.      
+000193e0: 2020 6967 6e6f 7265 5f69 6e64 6578 2c0a    ignore_index,.
+000193f0: 2020 2020 2020 2020 7265 6475 6374 696f          reductio
+00019400: 6e2c 0a20 2020 2029 0a20 2020 2072 6573  n,.    ).    res
+00019410: 6964 7561 6c73 203d 2028 696e 7075 742c  iduals = (input,
+00019420: 2074 6172 6765 742c 2077 6569 6768 742c   target, weight,
+00019430: 2072 6564 7563 7469 6f6e 2c20 6967 6e6f   reduction, igno
+00019440: 7265 5f69 6e64 6578 2c20 746f 7461 6c5f  re_index, total_
+00019450: 7765 6967 6874 290a 2020 2020 7265 7475  weight).    retu
+00019460: 726e 2056 4a50 4475 616c 2870 7269 6d61  rn VJPDual(prima
+00019470: 6c2c 2072 6573 6964 7561 6c73 290a 0a0a  l, residuals)...
+00019480: 4072 6567 6973 7465 725f 6261 636b 7761  @register_backwa
+00019490: 7264 2822 746f 7263 682e 6e6e 2e66 756e  rd("torch.nn.fun
+000194a0: 6374 696f 6e61 6c2e 6e6c 6c5f 6c6f 7373  ctional.nll_loss
+000194b0: 2229 0a64 6566 206e 6c6c 5f6c 6f73 735f  ").def nll_loss_
+000194c0: 6261 636b 7761 7264 2869 6e70 7574 2c20  backward(input, 
+000194d0: 7461 7267 6574 2c20 7765 6967 6874 2c20  target, weight, 
+000194e0: 7265 6475 6374 696f 6e2c 2069 676e 6f72  reduction, ignor
+000194f0: 655f 696e 6465 782c 2074 6f74 616c 5f77  e_index, total_w
+00019500: 6569 6768 742c 2067 293a 0a20 2020 2066  eight, g):.    f
+00019510: 726f 6d20 7468 756e 6465 722e 746f 7263  rom thunder.torc
+00019520: 6820 696d 706f 7274 206e 6c6c 5f6c 6f73  h import nll_los
+00019530: 735f 6261 636b 7761 7264 0a0a 2020 2020  s_backward..    
+00019540: 6769 6e70 7574 203d 206e 6c6c 5f6c 6f73  ginput = nll_los
+00019550: 735f 6261 636b 7761 7264 2867 2c20 696e  s_backward(g, in
+00019560: 7075 742c 2074 6172 6765 742c 2077 6569  put, target, wei
+00019570: 6768 742c 2072 6564 7563 7469 6f6e 2c20  ght, reduction, 
+00019580: 6967 6e6f 7265 5f69 6e64 6578 2c20 746f  ignore_index, to
+00019590: 7461 6c5f 7765 6967 6874 290a 2020 2020  tal_weight).    
+000195a0: 7265 7475 726e 2067 696e 7075 742c 202a  return ginput, *
+000195b0: 2828 4e6f 6e65 2c29 202a 2034 290a 0a0a  ((None,) * 4)...
+000195c0: 4072 6567 6973 7465 725f 6175 676d 656e  @register_augmen
+000195d0: 7465 645f 666f 7277 6172 6428 2274 6f72  ted_forward("tor
+000195e0: 6368 2e73 706c 6974 2229 0a64 6566 2073  ch.split").def s
+000195f0: 706c 6974 5f61 7567 5f66 7764 2861 3a20  plit_aug_fwd(a: 
+00019600: 5465 6e73 6f72 5072 6f78 792c 2073 706c  TensorProxy, spl
+00019610: 6974 5f73 697a 655f 6f72 5f73 6563 7469  it_size_or_secti
+00019620: 6f6e 733a 2069 6e74 207c 2053 6571 7565  ons: int | Seque
+00019630: 6e63 655b 696e 745d 2c20 6469 6d3a 2069  nce[int], dim: i
+00019640: 6e74 203d 2030 2920 2d3e 2056 4a50 4475  nt = 0) -> VJPDu
+00019650: 616c 3a0a 2020 2020 6672 6f6d 2074 6875  al:.    from thu
+00019660: 6e64 6572 2e74 6f72 6368 2069 6d70 6f72  nder.torch impor
+00019670: 7420 7370 6c69 740a 0a20 2020 2070 7269  t split..    pri
+00019680: 6d61 6c20 3d20 7370 6c69 7428 612c 2073  mal = split(a, s
+00019690: 706c 6974 5f73 697a 655f 6f72 5f73 6563  plit_size_or_sec
+000196a0: 7469 6f6e 732c 2064 696d 290a 2020 2020  tions, dim).    
+000196b0: 7265 7369 6475 616c 7320 3d20 2864 696d  residuals = (dim
+000196c0: 2c29 0a20 2020 2072 6574 7572 6e20 564a  ,).    return VJ
+000196d0: 5044 7561 6c28 7072 696d 616c 2c20 7265  PDual(primal, re
+000196e0: 7369 6475 616c 7329 0a0a 0a40 7265 6769  siduals)...@regi
+000196f0: 7374 6572 5f62 6163 6b77 6172 6428 2274  ster_backward("t
+00019700: 6f72 6368 2e73 706c 6974 2229 0a64 6566  orch.split").def
+00019710: 2073 706c 6974 5f62 6163 6b77 6172 6428   split_backward(
+00019720: 6469 6d2c 202a 6772 6164 7329 3a0a 2020  dim, *grads):.  
+00019730: 2020 6672 6f6d 2074 6875 6e64 6572 2e74    from thunder.t
+00019740: 6f72 6368 2069 6d70 6f72 7420 6361 740a  orch import cat.
+00019750: 0a20 2020 2072 6574 7572 6e20 6361 7428  .    return cat(
+00019760: 6772 6164 732c 2064 696d 290a 0a0a 4072  grads, dim)...@r
+00019770: 6567 6973 7465 725f 6175 676d 656e 7465  egister_augmente
+00019780: 645f 666f 7277 6172 6428 2274 6f72 6368  d_forward("torch
+00019790: 2e6e 6e2e 6675 6e63 7469 6f6e 616c 2e65  .nn.functional.e
+000197a0: 6d62 6564 6469 6e67 2229 0a64 6566 2065  mbedding").def e
+000197b0: 6d62 6564 6469 6e67 5f61 7567 5f66 7764  mbedding_aug_fwd
+000197c0: 280a 2020 2020 613a 2050 726f 7879 2c0a  (.    a: Proxy,.
+000197d0: 2020 2020 7765 6967 6874 3a20 5072 6f78      weight: Prox
+000197e0: 792c 0a20 2020 2070 6164 6469 6e67 5f69  y,.    padding_i
+000197f0: 6478 3a20 696e 7420 7c20 4e6f 6e65 2c0a  dx: int | None,.
+00019800: 2020 2020 6d61 785f 6e6f 726d 3a20 666c      max_norm: fl
+00019810: 6f61 7420 7c20 4e6f 6e65 2c0a 2020 2020  oat | None,.    
+00019820: 6e6f 726d 5f74 7970 653a 2066 6c6f 6174  norm_type: float
+00019830: 2c0a 2020 2020 7363 616c 655f 6772 6164  ,.    scale_grad
+00019840: 5f62 795f 6672 6571 3a20 626f 6f6c 2c0a  _by_freq: bool,.
+00019850: 2020 2020 7370 6172 7365 3a20 626f 6f6c      sparse: bool
+00019860: 2c0a 2920 2d3e 2056 4a50 4475 616c 3a0a  ,.) -> VJPDual:.
+00019870: 2020 2020 6672 6f6d 2074 6875 6e64 6572      from thunder
+00019880: 2e74 6f72 6368 2069 6d70 6f72 7420 656d  .torch import em
+00019890: 6265 6464 696e 670a 0a20 2020 2070 7269  bedding..    pri
+000198a0: 6d61 6c20 3d20 656d 6265 6464 696e 6728  mal = embedding(
+000198b0: 0a20 2020 2020 2020 2061 2c0a 2020 2020  .        a,.    
+000198c0: 2020 2020 7765 6967 6874 2c0a 2020 2020      weight,.    
+000198d0: 2020 2020 7061 6464 696e 675f 6964 783d      padding_idx=
+000198e0: 7061 6464 696e 675f 6964 782c 0a20 2020  padding_idx,.   
+000198f0: 2020 2020 206d 6178 5f6e 6f72 6d3d 6d61       max_norm=ma
+00019900: 785f 6e6f 726d 2c0a 2020 2020 2020 2020  x_norm,.        
+00019910: 6e6f 726d 5f74 7970 653d 6e6f 726d 5f74  norm_type=norm_t
+00019920: 7970 652c 0a20 2020 2020 2020 2073 6361  ype,.        sca
+00019930: 6c65 5f67 7261 645f 6279 5f66 7265 713d  le_grad_by_freq=
+00019940: 7363 616c 655f 6772 6164 5f62 795f 6672  scale_grad_by_fr
+00019950: 6571 2c0a 2020 2020 2020 2020 7370 6172  eq,.        spar
+00019960: 7365 3d73 7061 7273 652c 0a20 2020 2029  se=sparse,.    )
+00019970: 0a20 2020 2072 6573 6964 7561 6c73 203d  .    residuals =
+00019980: 2028 612c 2077 6569 6768 742e 7368 6170   (a, weight.shap
+00019990: 655b 305d 2c20 7061 6464 696e 675f 6964  e[0], padding_id
+000199a0: 782c 2073 6361 6c65 5f67 7261 645f 6279  x, scale_grad_by
+000199b0: 5f66 7265 712c 2073 7061 7273 6529 0a20  _freq, sparse). 
+000199c0: 2020 2072 6574 7572 6e20 564a 5044 7561     return VJPDua
+000199d0: 6c28 7072 696d 616c 2c20 7265 7369 6475  l(primal, residu
+000199e0: 616c 7329 0a0a 0a40 7265 6769 7374 6572  als)...@register
+000199f0: 5f62 6163 6b77 6172 6428 2274 6f72 6368  _backward("torch
+00019a00: 2e6e 6e2e 6675 6e63 7469 6f6e 616c 2e65  .nn.functional.e
+00019a10: 6d62 6564 6469 6e67 2229 0a64 6566 2065  mbedding").def e
+00019a20: 6d62 6564 6469 6e67 5f62 6163 6b77 6172  mbedding_backwar
+00019a30: 6428 612c 206e 756d 5f77 6569 6768 7473  d(a, num_weights
+00019a40: 2c20 7061 6464 696e 675f 6964 782c 2073  , padding_idx, s
+00019a50: 6361 6c65 5f67 7261 645f 6279 5f66 7265  cale_grad_by_fre
+00019a60: 712c 2073 7061 7273 652c 2067 293a 0a20  q, sparse, g):. 
+00019a70: 2020 2066 726f 6d20 7468 756e 6465 722e     from thunder.
+00019a80: 746f 7263 6820 696d 706f 7274 2065 6d62  torch import emb
+00019a90: 6564 6469 6e67 5f62 6163 6b77 6172 640a  edding_backward.
+00019aa0: 0a20 2020 2070 6164 6469 6e67 5f69 6478  .    padding_idx
+00019ab0: 203d 202d 3120 6966 2070 6164 6469 6e67   = -1 if padding
+00019ac0: 5f69 6478 2069 7320 4e6f 6e65 2065 6c73  _idx is None els
+00019ad0: 6520 7061 6464 696e 675f 6964 780a 2020  e padding_idx.  
+00019ae0: 2020 6777 6569 6768 7420 3d20 656d 6265    gweight = embe
+00019af0: 6464 696e 675f 6261 636b 7761 7264 2867  dding_backward(g
+00019b00: 2c20 612c 206e 756d 5f77 6569 6768 7473  , a, num_weights
+00019b10: 2c20 7061 6464 696e 675f 6964 782c 2073  , padding_idx, s
+00019b20: 6361 6c65 5f67 7261 645f 6279 5f66 7265  cale_grad_by_fre
+00019b30: 712c 2073 7061 7273 6529 0a20 2020 2072  q, sparse).    r
+00019b40: 6574 7572 6e20 6777 6569 6768 740a 0a0a  eturn gweight...
+00019b50: 4072 6567 6973 7465 725f 6175 676d 656e  @register_augmen
+00019b60: 7465 645f 666f 7277 6172 6428 2274 6f72  ted_forward("tor
+00019b70: 6368 2e63 756d 7375 6d22 290a 6465 6620  ch.cumsum").def 
+00019b80: 6375 6d73 756d 5f61 7567 5f66 7764 2861  cumsum_aug_fwd(a
+00019b90: 3a20 5072 6f78 792c 2064 696d 3a20 696e  : Proxy, dim: in
+00019ba0: 742c 202a 2c20 6474 7970 653a 204e 6f6e  t, *, dtype: Non
+00019bb0: 6520 7c20 6474 7970 6573 2e64 7479 7065  e | dtypes.dtype
+00019bc0: 203d 204e 6f6e 6529 202d 3e20 564a 5044   = None) -> VJPD
+00019bd0: 7561 6c3a 0a20 2020 2066 726f 6d20 7468  ual:.    from th
+00019be0: 756e 6465 722e 746f 7263 6820 696d 706f  under.torch impo
+00019bf0: 7274 2063 756d 7375 6d0a 0a20 2020 2070  rt cumsum..    p
+00019c00: 7269 6d61 6c20 3d20 6375 6d73 756d 2861  rimal = cumsum(a
+00019c10: 2c20 6469 6d2c 2064 7479 7065 3d64 7479  , dim, dtype=dty
+00019c20: 7065 290a 2020 2020 7265 7369 6475 616c  pe).    residual
+00019c30: 7320 3d20 280a 2020 2020 2020 2020 612e  s = (.        a.
+00019c40: 6474 7970 652c 0a20 2020 2020 2020 2064  dtype,.        d
+00019c50: 696d 2c0a 2020 2020 290a 2020 2020 7265  im,.    ).    re
+00019c60: 7475 726e 2056 4a50 4475 616c 2870 7269  turn VJPDual(pri
+00019c70: 6d61 6c2c 2072 6573 6964 7561 6c73 290a  mal, residuals).
+00019c80: 0a0a 4072 6567 6973 7465 725f 6261 636b  ..@register_back
+00019c90: 7761 7264 2822 746f 7263 682e 6375 6d73  ward("torch.cums
+00019ca0: 756d 2229 0a64 6566 2063 756d 7375 6d5f  um").def cumsum_
+00019cb0: 6261 636b 7761 7264 2861 5f64 7479 7065  backward(a_dtype
+00019cc0: 2c20 6469 6d2c 2067 293a 0a20 2020 2067  , dim, g):.    g
+00019cd0: 203d 2067 2e74 6f28 615f 6474 7970 6529   = g.to(a_dtype)
+00019ce0: 0a20 2020 2069 6620 672e 6e75 6d65 6c28  .    if g.numel(
+00019cf0: 2920 3c3d 2031 206f 7220 672e 7368 6170  ) <= 1 or g.shap
+00019d00: 655b 6469 6d5d 203d 3d20 313a 0a20 2020  e[dim] == 1:.   
+00019d10: 2020 2020 2072 6574 7572 6e20 670a 2020       return g.  
+00019d20: 2020 7265 7475 726e 2067 2e66 6c69 7028    return g.flip(
+00019d30: 6469 6d29 2e63 756d 7375 6d28 6469 6d29  dim).cumsum(dim)
+00019d40: 2e66 6c69 7028 6469 6d29 0a0a 0a40 7265  .flip(dim)...@re
+00019d50: 6769 7374 6572 5f61 7567 6d65 6e74 6564  gister_augmented
+00019d60: 5f66 6f72 7761 7264 2822 746f 7263 682e  _forward("torch.
+00019d70: 736f 6674 6d61 7822 290a 6465 6620 736f  softmax").def so
+00019d80: 6674 6d61 785f 6175 675f 6677 6428 613a  ftmax_aug_fwd(a:
+00019d90: 2050 726f 7879 2c20 6469 6d3a 2069 6e74   Proxy, dim: int
+00019da0: 2c20 6474 7970 653a 2064 7479 7065 732e  , dtype: dtypes.
+00019db0: 6474 7970 6520 7c20 4e6f 6e65 203d 204e  dtype | None = N
+00019dc0: 6f6e 6529 202d 3e20 564a 5044 7561 6c3a  one) -> VJPDual:
+00019dd0: 0a20 2020 2066 726f 6d20 7468 756e 6465  .    from thunde
+00019de0: 722e 746f 7263 6820 696d 706f 7274 2073  r.torch import s
+00019df0: 6f66 746d 6178 0a0a 2020 2020 7072 696d  oftmax..    prim
+00019e00: 616c 203d 2073 6f66 746d 6178 2861 2c20  al = softmax(a, 
+00019e10: 6469 6d2c 2064 7479 7065 3d64 7479 7065  dim, dtype=dtype
+00019e20: 290a 2020 2020 7265 7369 6475 616c 7320  ).    residuals 
+00019e30: 3d20 2870 7269 6d61 6c2c 2064 696d 290a  = (primal, dim).
+00019e40: 2020 2020 7265 7475 726e 2056 4a50 4475      return VJPDu
+00019e50: 616c 2870 7269 6d61 6c2c 2072 6573 6964  al(primal, resid
+00019e60: 7561 6c73 290a 0a0a 4072 6567 6973 7465  uals)...@registe
+00019e70: 725f 6261 636b 7761 7264 2822 746f 7263  r_backward("torc
+00019e80: 682e 736f 6674 6d61 7822 290a 6465 6620  h.softmax").def 
+00019e90: 736f 6674 6d61 785f 6261 636b 7761 7264  softmax_backward
+00019ea0: 2870 7269 6d61 6c2c 2064 696d 2c20 6729  (primal, dim, g)
+00019eb0: 3a0a 2020 2020 7265 7475 726e 2070 7269  :.    return pri
+00019ec0: 6d61 6c20 2a20 2867 202d 2028 7072 696d  mal * (g - (prim
+00019ed0: 616c 202a 2067 292e 7375 6d28 6469 6d2c  al * g).sum(dim,
+00019ee0: 206b 6565 7064 696d 3d54 7275 6529 290a   keepdim=True)).
+00019ef0: 0a0a 6465 6620 6974 6572 5f62 6f75 6e64  ..def iter_bound
+00019f00: 5f73 796d 626f 6c73 2862 6f75 6e64 5f73  _symbols(bound_s
+00019f10: 796d 626f 6c73 293a 0a20 2020 2022 2222  ymbols):.    """
+00019f20: 4974 6572 6174 6520 6f76 6572 2062 6f75  Iterate over bou
+00019f30: 6e64 2073 796d 626f 6c73 2c20 736b 6970  nd symbols, skip
+00019f40: 7069 6e67 2073 796d 626f 6c73 2074 6861  ping symbols tha
+00019f50: 7420 6172 6520 6e6f 7420 7375 7070 6f72  t are not suppor
+00019f60: 7465 6420 6279 0a20 2020 2074 6865 2074  ted by.    the t
+00019f70: 7261 6e73 666f 726d 7320 696e 6672 6173  ransforms infras
+00019f80: 7472 7563 7475 7265 2e0a 0a20 2020 2041  tructure...    A
+00019f90: 7267 733a 0a20 2020 2020 2020 2062 6f75  rgs:.        bou
+00019fa0: 6e64 5f73 796d 626f 6c73 2028 4c69 7374  nd_symbols (List
+00019fb0: 5b42 6f75 6e64 5379 6d62 6f6c 5d29 3a20  [BoundSymbol]): 
+00019fc0: 4c69 7374 206f 6620 626f 756e 6420 7379  List of bound sy
+00019fd0: 6d62 6f6c 730a 0a20 2020 2059 6965 6c64  mbols..    Yield
+00019fe0: 733a 0a20 2020 2020 2020 2042 6f75 6e64  s:.        Bound
+00019ff0: 5379 6d62 6f6c 3a20 426f 756e 6420 7379  Symbol: Bound sy
+0001a000: 6d62 6f6c 7320 7468 6174 2061 7265 2073  mbols that are s
+0001a010: 7570 706f 7274 6564 2062 7920 7468 6520  upported by the 
+0001a020: 7472 616e 7366 6f72 6d73 0a20 2020 2020  transforms.     
+0001a030: 2020 2069 6e66 7261 7374 7275 6374 7572     infrastructur
+0001a040: 650a 2020 2020 2222 220a 2020 2020 666f  e.    """.    fo
+0001a050: 7220 7379 6d62 6f6c 2069 6e20 626f 756e  r symbol in boun
+0001a060: 645f 7379 6d62 6f6c 733a 0a20 2020 2020  d_symbols:.     
+0001a070: 2020 2069 6620 7379 6d62 6f6c 2e73 796d     if symbol.sym
+0001a080: 2e69 6420 696e 2074 7261 6e73 666f 726d  .id in transform
+0001a090: 5f73 6b69 705f 6c69 7374 3a0a 2020 2020  _skip_list:.    
+0001a0a0: 2020 2020 2020 2020 636f 6e74 696e 7565          continue
+0001a0b0: 0a20 2020 2020 2020 2065 6c69 6620 7379  .        elif sy
+0001a0c0: 6d62 6f6c 2e6f 7574 7075 7420 6973 204e  mbol.output is N
+0001a0d0: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+0001a0e0: 2063 6f6e 7469 6e75 650a 2020 2020 2020   continue.      
+0001a0f0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0001a100: 2020 2020 7969 656c 6420 7379 6d62 6f6c      yield symbol
+0001a110: 0a0a 0a64 6566 2064 6563 6f6e 7374 7275  ...def deconstru
+0001a120: 6374 5f66 6f72 7761 7264 5f65 6e76 5f66  ct_forward_env_f
+0001a130: 6f72 5f62 6163 6b77 6172 6428 7472 6163  or_backward(trac
+0001a140: 652c 2065 6e76 293a 0a20 2020 2023 204e  e, env):.    # N
+0001a150: 6f74 6520 5b53 6176 696e 6720 7468 6520  ote [Saving the 
+0001a160: 666f 7277 6172 6420 656e 7669 726f 6e6d  forward environm
+0001a170: 656e 7420 696e 2074 6865 2062 6163 6b77  ent in the backw
+0001a180: 6172 6420 7275 6c65 5d0a 2020 2020 2320  ard rule].    # 
+0001a190: 5765 2063 616e 6e6f 7420 7361 7665 2074  We cannot save t
+0001a1a0: 6865 2074 7261 6365 206f 626a 6563 7420  he trace object 
+0001a1b0: 696e 2074 6865 2072 6573 6964 7561 6c73  in the residuals
+0001a1c0: 2062 6563 6175 7365 2065 7865 6375 746f   because executo
+0001a1d0: 7273 206d 6179 206e 6f74 0a20 2020 2023  rs may not.    #
+0001a1e0: 2062 6520 6162 6c65 2074 6f20 7265 7475   be able to retu
+0001a1f0: 726e 2069 7420 666f 7220 7468 6520 7370  rn it for the sp
+0001a200: 6c69 7474 6564 2066 6f72 7761 7264 2f62  litted forward/b
+0001a210: 6163 6b77 6172 6420 7061 7373 6573 2e20  ackward passes. 
+0001a220: 496e 7374 6561 642c 2077 650a 2020 2020  Instead, we.    
+0001a230: 2320 7361 7665 2061 7267 7320 616e 6420  # save args and 
+0001a240: 6b77 6172 6773 206f 6620 7468 6520 6f72  kwargs of the or
+0001a250: 6967 696e 616c 2066 756e 6374 696f 6e20  iginal function 
+0001a260: 6361 6c6c 2061 6e64 2072 6563 6f6e 7374  call and reconst
+0001a270: 7275 6374 2074 6865 0a20 2020 2023 2074  ruct the.    # t
+0001a280: 7261 6365 206f 626a 6563 7420 616e 6420  race object and 
+0001a290: 6974 7320 656e 7669 726f 6e6d 656e 7420  its environment 
+0001a2a0: 6469 6374 2069 6e20 7468 6520 6261 636b  dict in the back
+0001a2b0: 7761 7264 2072 756c 652e 2048 6572 6520  ward rule. Here 
+0001a2c0: 7765 2072 656c 790a 2020 2020 2320 6f6e  we rely.    # on
+0001a2d0: 2074 6865 2066 6163 7420 7468 6174 2074   the fact that t
+0001a2e0: 6865 206f 7264 6572 206f 6620 7468 6520  he order of the 
+0001a2f0: 7379 6d62 6f6c 7320 696e 2074 6865 2074  symbols in the t
+0001a300: 7261 6365 2069 7320 6465 7465 726d 696e  race is determin
+0001a310: 6973 7469 630a 2020 2020 2320 616e 6420  istic.    # and 
+0001a320: 616c 7761 7973 2074 6865 2073 616d 6520  always the same 
+0001a330: 666f 7220 7468 6520 7361 6d65 2066 756e  for the same fun
+0001a340: 6374 696f 6e20 6361 6c6c 2061 6e64 2074  ction call and t
+0001a350: 6865 2073 616d 6520 7365 7420 6f66 0a20  he same set of. 
+0001a360: 2020 2023 2061 7267 756d 656e 7473 2e20     # arguments. 
+0001a370: 5365 6520 7465 7374 5f67 7261 642e 7079  See test_grad.py
+0001a380: 3a74 6573 745f 746f 7263 685f 6175 746f  :test_torch_auto
+0001a390: 6772 6164 5f66 756e 6374 696f 6e20 666f  grad_function fo
+0001a3a0: 7220 616e 2065 7861 6d70 6c65 0a20 2020  r an example.   
+0001a3b0: 2023 2077 6865 7265 2074 6869 7320 6973   # where this is
+0001a3c0: 2074 6573 7465 642e 0a20 2020 2062 6f75   tested..    bou
+0001a3d0: 6e64 5f73 796d 626f 6c73 203d 2069 7465  nd_symbols = ite
+0001a3e0: 725f 626f 756e 645f 7379 6d62 6f6c 7328  r_bound_symbols(
+0001a3f0: 7472 6163 652e 626f 756e 645f 7379 6d62  trace.bound_symb
+0001a400: 6f6c 7329 0a20 2020 2073 6176 6564 5f66  ols).    saved_f
+0001a410: 6f72 5f62 6163 6b77 6172 6420 3d20 7475  or_backward = tu
+0001a420: 706c 6528 656e 765b 7365 7175 656e 6369  ple(env[sequenci
+0001a430: 6679 2873 796d 626f 6c2e 6f75 7470 7574  fy(symbol.output
+0001a440: 295b 305d 2e6e 616d 655d 2e72 6573 6964  )[0].name].resid
+0001a450: 7561 6c73 2066 6f72 2073 796d 626f 6c20  uals for symbol 
+0001a460: 696e 2062 6f75 6e64 5f73 796d 626f 6c73  in bound_symbols
+0001a470: 290a 2020 2020 7265 7475 726e 2073 6176  ).    return sav
+0001a480: 6564 5f66 6f72 5f62 6163 6b77 6172 640a  ed_for_backward.
+0001a490: 0a0a 6465 6620 7265 636f 6e73 7472 7563  ..def reconstruc
+0001a4a0: 745f 666f 7277 6172 645f 656e 765f 666f  t_forward_env_fo
+0001a4b0: 725f 6261 636b 7761 7264 2874 7261 6365  r_backward(trace
+0001a4c0: 2c20 7361 7665 645f 666f 725f 6261 636b  , saved_for_back
+0001a4d0: 7761 7264 293a 0a20 2020 2062 6f75 6e64  ward):.    bound
+0001a4e0: 5f73 796d 626f 6c73 203d 2069 7465 725f  _symbols = iter_
+0001a4f0: 626f 756e 645f 7379 6d62 6f6c 7328 7472  bound_symbols(tr
+0001a500: 6163 652e 626f 756e 645f 7379 6d62 6f6c  ace.bound_symbol
+0001a510: 7329 0a0a 2020 2020 7265 636f 6e73 7472  s)..    reconstr
+0001a520: 7563 7465 645f 656e 7620 3d20 7b7d 0a0a  ucted_env = {}..
+0001a530: 2020 2020 666f 7220 6964 782c 2073 796d      for idx, sym
+0001a540: 2069 6e20 656e 756d 6572 6174 6528 626f   in enumerate(bo
+0001a550: 756e 645f 7379 6d62 6f6c 7329 3a0a 2020  und_symbols):.  
+0001a560: 2020 2020 2020 6b20 3d20 7365 7175 656e        k = sequen
+0001a570: 6369 6679 2873 796d 2e6f 7574 7075 7429  cify(sym.output)
+0001a580: 5b30 5d2e 6e61 6d65 0a20 2020 2020 2020  [0].name.       
+0001a590: 2076 203d 2056 4a50 4475 616c 284e 6f6e   v = VJPDual(Non
+0001a5a0: 652c 2073 6176 6564 5f66 6f72 5f62 6163  e, saved_for_bac
+0001a5b0: 6b77 6172 645b 6964 785d 290a 2020 2020  kward[idx]).    
+0001a5c0: 2020 2020 7265 636f 6e73 7472 7563 7465      reconstructe
+0001a5d0: 645f 656e 765b 6b5d 203d 2076 0a0a 2020  d_env[k] = v..  
+0001a5e0: 2020 7265 7475 726e 2072 6563 6f6e 7374    return reconst
+0001a5f0: 7275 6374 6564 5f65 6e76 0a0a 0a64 6566  ructed_env...def
+0001a600: 2064 6563 6f6d 706f 7365 645f 666e 5f61   decomposed_fn_a
+0001a610: 7567 5f66 7764 5f72 756c 6528 2a61 7267  ug_fwd_rule(*arg
+0001a620: 732c 2064 6563 6f6d 706f 7365 645f 666e  s, decomposed_fn
+0001a630: 2c20 2a2a 6b77 6172 6773 293a 0a20 2020  , **kwargs):.   
+0001a640: 2022 2222 4175 676d 656e 7465 6420 666f   """Augmented fo
+0001a650: 7277 6172 6420 7275 6c65 2066 6f72 2063  rward rule for c
+0001a660: 6f6d 706f 7369 7465 2066 756e 6374 696f  omposite functio
+0001a670: 6e73 2069 6d70 6c65 6d65 6e74 6564 2069  ns implemented i
+0001a680: 6e20 7465 726d 7320 6f66 206f 7468 6572  n terms of other
+0001a690: 2066 756e 6374 696f 6e73 2074 6861 7420   functions that 
+0001a6a0: 6172 650a 2020 2020 7375 7070 6f73 6564  are.    supposed
+0001a6b0: 2074 6f20 6265 2073 7570 706f 7274 6564   to be supported
+0001a6c0: 2062 7920 7468 6520 564a 5020 696e 6672   by the VJP infr
+0001a6d0: 6173 7472 7563 7475 7265 2e0a 0a20 2020  astructure...   
+0001a6e0: 2041 7267 733a 0a20 2020 2020 2020 2064   Args:.        d
+0001a6f0: 6563 6f6d 706f 7365 645f 666e 2028 4361  ecomposed_fn (Ca
+0001a700: 6c6c 6162 6c65 293a 2064 6563 6f6d 706f  llable): decompo
+0001a710: 7365 6420 7665 7273 696f 6e20 6f66 2074  sed version of t
+0001a720: 6865 2066 756e 6374 696f 6e0a 0a20 2020  he function..   
+0001a730: 2052 6574 7572 6e73 3a0a 2020 2020 2020   Returns:.      
+0001a740: 2020 4361 6c6c 6162 6c65 3a20 4175 676d    Callable: Augm
+0001a750: 656e 7465 6420 666f 7277 6172 6420 7275  ented forward ru
+0001a760: 6c65 2066 6f72 2074 6865 2063 6f6d 706f  le for the compo
+0001a770: 7369 7465 2066 756e 6374 696f 6e0a 2020  site function.  
+0001a780: 2020 2222 220a 2020 2020 7472 6163 6520    """.    trace 
+0001a790: 3d20 636f 6e73 7472 7563 745f 7472 6163  = construct_trac
+0001a7a0: 6528 2928 6465 636f 6d70 6f73 6564 5f66  e()(decomposed_f
+0001a7b0: 6e2c 202a 6172 6773 2c20 2a2a 6b77 6172  n, *args, **kwar
+0001a7c0: 6773 290a 2020 2020 7472 6163 6520 3d20  gs).    trace = 
+0001a7d0: 756e 7772 6170 5f6f 6e65 5f6c 6576 656c  unwrap_one_level
+0001a7e0: 5f6f 665f 7375 6273 796d 626f 6c73 2874  _of_subsymbols(t
+0001a7f0: 7261 6365 290a 2020 2020 2320 5468 6572  race).    # Ther
+0001a800: 6520 6d61 7920 6265 2061 2064 6561 6420  e may be a dead 
+0001a810: 6e6f 6465 206c 696b 6520 225f 203d 2070  node like "_ = p
+0001a820: 7269 6d73 2e63 6f6e 7665 7274 5f65 6c65  rims.convert_ele
+0001a830: 6d65 6e74 5f74 7970 6528 302c 2066 6c6f  ment_type(0, flo
+0001a840: 6174 2922 0a20 2020 2023 2069 6e20 7468  at)".    # in th
+0001a850: 6520 7472 6163 652e 2057 6520 6e65 6564  e trace. We need
+0001a860: 2074 6f20 7265 6d6f 7665 2069 7420 6265   to remove it be
+0001a870: 666f 7265 2077 6520 6361 6e20 7573 6520  fore we can use 
+0001a880: 7468 6520 7472 6163 6520 666f 720a 2020  the trace for.  
+0001a890: 2020 2320 6175 676d 656e 7465 645f 666f    # augmented_fo
+0001a8a0: 7277 6172 645f 7061 7373 2e0a 2020 2020  rward_pass..    
+0001a8b0: 7472 6163 6520 3d20 6463 6528 7472 6163  trace = dce(trac
+0001a8c0: 6529 0a20 2020 2072 6573 756c 742c 2065  e).    result, e
+0001a8d0: 6e76 203d 2061 7567 6d65 6e74 6564 5f66  nv = augmented_f
+0001a8e0: 6f72 7761 7264 5f70 6173 7328 2a61 7267  orward_pass(*arg
+0001a8f0: 732c 2074 7261 6365 3d74 7261 6365 2c20  s, trace=trace, 
+0001a900: 2a2a 6b77 6172 6773 290a 2020 2020 7361  **kwargs).    sa
+0001a910: 7665 645f 666f 725f 6261 636b 7761 7264  ved_for_backward
+0001a920: 203d 2064 6563 6f6e 7374 7275 6374 5f66   = deconstruct_f
+0001a930: 6f72 7761 7264 5f65 6e76 5f66 6f72 5f62  orward_env_for_b
+0001a940: 6163 6b77 6172 6428 7472 6163 652c 2065  ackward(trace, e
+0001a950: 6e76 290a 2020 2020 2320 5374 6174 6963  nv).    # Static
+0001a960: 2063 6163 6869 6e67 2064 6f65 7320 6e6f   caching does no
+0001a970: 7420 7769 7468 2077 6974 6820 6b77 6172  t with with kwar
+0001a980: 6773 2064 6963 7473 2c20 736f 2077 6527  gs dicts, so we'
+0001a990: 7265 2063 6f6e 7665 7274 696e 6720 7468  re converting th
+0001a9a0: 656d 0a20 2020 2023 2074 6f20 4e6f 6e65  em.    # to None
+0001a9b0: 2066 6f72 206e 6f77 2077 6865 6e20 706f   for now when po
+0001a9c0: 7373 6962 6c65 2e0a 2020 2020 6b77 6172  ssible..    kwar
+0001a9d0: 6773 203d 204e 6f6e 6520 6966 206e 6f74  gs = None if not
+0001a9e0: 206b 7761 7267 7320 656c 7365 206b 7761   kwargs else kwa
+0001a9f0: 7267 730a 2020 2020 7265 7369 6475 616c  rgs.    residual
+0001aa00: 7320 3d20 2861 7267 732c 206b 7761 7267  s = (args, kwarg
+0001aa10: 732c 2073 6176 6564 5f66 6f72 5f62 6163  s, saved_for_bac
+0001aa20: 6b77 6172 6429 0a20 2020 2072 6574 7572  kward).    retur
+0001aa30: 6e20 564a 5044 7561 6c28 7265 7375 6c74  n VJPDual(result
+0001aa40: 2c20 7265 7369 6475 616c 7329 0a0a 0a64  , residuals)...d
+0001aa50: 6566 2064 6563 6f6d 706f 7365 645f 666e  ef decomposed_fn
+0001aa60: 5f62 6163 6b77 6172 645f 7275 6c65 2864  _backward_rule(d
+0001aa70: 6563 6f6d 706f 7365 645f 666e 2c20 6172  ecomposed_fn, ar
+0001aa80: 6773 2c20 6b77 6172 6773 2c20 7361 7665  gs, kwargs, save
+0001aa90: 645f 666f 725f 6261 636b 7761 7264 2c20  d_for_backward, 
+0001aaa0: 2a67 7261 6473 293a 0a20 2020 206b 7761  *grads):.    kwa
+0001aab0: 7267 7320 3d20 7b7d 2069 6620 6b77 6172  rgs = {} if kwar
+0001aac0: 6773 2069 7320 4e6f 6e65 2065 6c73 6520  gs is None else 
+0001aad0: 6b77 6172 6773 0a20 2020 2074 7261 6365  kwargs.    trace
+0001aae0: 203d 2063 6f6e 7374 7275 6374 5f74 7261   = construct_tra
+0001aaf0: 6365 2829 2864 6563 6f6d 706f 7365 645f  ce()(decomposed_
+0001ab00: 666e 2c20 2a61 7267 732c 202a 2a6b 7761  fn, *args, **kwa
+0001ab10: 7267 7329 0a20 2020 2074 7261 6365 203d  rgs).    trace =
+0001ab20: 2075 6e77 7261 705f 6f6e 655f 6c65 7665   unwrap_one_leve
+0001ab30: 6c5f 6f66 5f73 7562 7379 6d62 6f6c 7328  l_of_subsymbols(
+0001ab40: 7472 6163 6529 0a20 2020 2074 7261 6365  trace).    trace
+0001ab50: 203d 2064 6365 2874 7261 6365 290a 2020   = dce(trace).  
+0001ab60: 2020 2320 626f 756e 645f 7379 6d62 6f6c    # bound_symbol
+0001ab70: 7320 3d20 6974 6572 5f62 6f75 6e64 5f73  s = iter_bound_s
+0001ab80: 796d 626f 6c73 2874 7261 6365 2e62 6f75  ymbols(trace.bou
+0001ab90: 6e64 5f73 796d 626f 6c73 290a 2020 2020  nd_symbols).    
+0001aba0: 2320 7265 636f 6e73 7472 7563 7465 645f  # reconstructed_
+0001abb0: 656e 7620 3d20 7b0a 2020 2020 2320 2020  env = {.    #   
+0001abc0: 2020 7365 7175 656e 6369 6679 2873 796d    sequencify(sym
+0001abd0: 626f 6c2e 6f75 7470 7574 295b 305d 2e6e  bol.output)[0].n
+0001abe0: 616d 653a 2056 4a50 4475 616c 284e 6f6e  ame: VJPDual(Non
+0001abf0: 652c 2073 6176 6564 5f66 6f72 5f62 6163  e, saved_for_bac
+0001ac00: 6b77 6172 645b 695d 290a 2020 2020 2320  kward[i]).    # 
+0001ac10: 2020 2020 666f 7220 692c 2073 796d 626f      for i, symbo
+0001ac20: 6c20 696e 2065 6e75 6d65 7261 7465 2862  l in enumerate(b
+0001ac30: 6f75 6e64 5f73 796d 626f 6c73 290a 2020  ound_symbols).  
+0001ac40: 2020 2320 7d0a 2020 2020 7265 636f 6e73    # }.    recons
+0001ac50: 7472 7563 7465 645f 656e 7620 3d20 7265  tructed_env = re
+0001ac60: 636f 6e73 7472 7563 745f 666f 7277 6172  construct_forwar
+0001ac70: 645f 656e 765f 666f 725f 6261 636b 7761  d_env_for_backwa
+0001ac80: 7264 2874 7261 6365 2c20 7361 7665 645f  rd(trace, saved_
+0001ac90: 666f 725f 6261 636b 7761 7264 290a 2020  for_backward).  
+0001aca0: 2020 7265 7375 6c74 203d 2062 6163 6b77    result = backw
+0001acb0: 6172 645f 7061 7373 2872 6563 6f6e 7374  ard_pass(reconst
+0001acc0: 7275 6374 6564 5f65 6e76 2c20 7472 6163  ructed_env, trac
+0001acd0: 652c 2067 7261 6473 290a 2020 2020 6966  e, grads).    if
+0001ace0: 206c 656e 2861 7267 7329 203d 3d20 313a   len(args) == 1:
+0001acf0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0001ad00: 7265 7375 6c74 5b30 5d0a 2020 2020 2320  result[0].    # 
+0001ad10: 4261 636b 7761 7264 2070 6173 7320 6d69  Backward pass mi
+0001ad20: 6768 7420 7265 7475 726e 2061 2064 6963  ght return a dic
+0001ad30: 7420 7769 7468 2067 7261 6473 2062 7574  t with grads but
+0001ad40: 2063 7572 7265 6e74 2069 6e74 6572 6661   current interfa
+0001ad50: 6365 206f 660a 2020 2020 2320 6261 636b  ce of.    # back
+0001ad60: 7761 7264 2072 756c 6520 646f 6573 206e  ward rule does n
+0001ad70: 6f74 2073 7570 706f 7274 2069 742e 2053  ot support it. S
+0001ad80: 6f20 7765 206a 7573 7420 6472 6f70 2069  o we just drop i
+0001ad90: 7420 666f 7220 6e6f 772e 0a20 2020 2065  t for now..    e
+0001ada0: 6c69 6620 6973 696e 7374 616e 6365 2872  lif isinstance(r
+0001adb0: 6573 756c 745b 2d31 5d2c 2064 6963 7429  esult[-1], dict)
+0001adc0: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+0001add0: 2072 6573 756c 745b 3a2d 315d 0a20 2020   result[:-1].   
+0001ade0: 2072 6574 7572 6e20 7265 7375 6c74 0a0a   return result..
+0001adf0: 0a40 7265 6769 7374 6572 5f61 7567 6d65  .@register_augme
+0001ae00: 6e74 6564 5f66 6f72 7761 7264 2822 746f  nted_forward("to
+0001ae10: 7263 682e 5465 6e73 6f72 2e63 6f6e 7469  rch.Tensor.conti
+0001ae20: 6775 6f75 7322 290a 4072 6567 6973 7465  guous").@registe
+0001ae30: 725f 6175 676d 656e 7465 645f 666f 7277  r_augmented_forw
+0001ae40: 6172 6428 2274 6f72 6368 2e63 6f6e 7469  ard("torch.conti
+0001ae50: 6775 6f75 7322 290a 6465 6620 636f 6e74  guous").def cont
+0001ae60: 6967 756f 7573 5f61 7567 5f66 7764 2878  iguous_aug_fwd(x
+0001ae70: 3a20 5465 6e73 6f72 5072 6f78 792c 202f  : TensorProxy, /
+0001ae80: 2c20 2a2c 206d 656d 6f72 795f 666f 726d  , *, memory_form
+0001ae90: 6174 3a20 746f 7263 682e 6d65 6d6f 7279  at: torch.memory
+0001aea0: 5f66 6f72 6d61 7420 3d20 746f 7263 682e  _format = torch.
+0001aeb0: 636f 6e74 6967 756f 7573 5f66 6f72 6d61  contiguous_forma
+0001aec0: 7429 202d 3e20 564a 5044 7561 6c3a 0a20  t) -> VJPDual:. 
+0001aed0: 2020 2066 726f 6d20 7468 756e 6465 722e     from thunder.
+0001aee0: 746f 7263 6820 696d 706f 7274 2063 6f6e  torch import con
+0001aef0: 7469 6775 6f75 730a 0a20 2020 2072 6574  tiguous..    ret
+0001af00: 7572 6e20 564a 5044 7561 6c28 636f 6e74  urn VJPDual(cont
+0001af10: 6967 756f 7573 2878 2c20 6d65 6d6f 7279  iguous(x, memory
+0001af20: 5f66 6f72 6d61 743d 6d65 6d6f 7279 5f66  _format=memory_f
+0001af30: 6f72 6d61 7429 2c20 7475 706c 6528 2929  ormat), tuple())
+0001af40: 0a0a 0a40 7265 6769 7374 6572 5f62 6163  ...@register_bac
+0001af50: 6b77 6172 6428 2274 6f72 6368 2e54 656e  kward("torch.Ten
+0001af60: 736f 722e 636f 6e74 6967 756f 7573 2229  sor.contiguous")
+0001af70: 0a40 7265 6769 7374 6572 5f62 6163 6b77  .@register_backw
+0001af80: 6172 6428 2274 6f72 6368 2e63 6f6e 7469  ard("torch.conti
+0001af90: 6775 6f75 7322 290a 6465 6620 636f 6e74  guous").def cont
+0001afa0: 6967 756f 7573 5f62 6163 6b77 6172 6428  iguous_backward(
+0001afb0: 2a72 6573 6964 7561 6c73 5f61 6e64 5f67  *residuals_and_g
+0001afc0: 7261 6429 202d 3e20 5465 6e73 6f72 5072  rad) -> TensorPr
+0001afd0: 6f78 793a 0a20 2020 2023 2052 6573 6964  oxy:.    # Resid
+0001afe0: 7561 6c73 2069 7320 6e6f 7420 656d 7074  uals is not empt
+0001aff0: 7920 6265 6361 7573 6520 636f 6e74 6967  y because contig
+0001b000: 756f 7573 2073 796d 626f 6c20 6861 7320  uous symbol has 
+0001b010: 7468 6520 7361 6d65 206f 7574 7075 7420  the same output 
+0001b020: 6173 2069 7473 2069 6e70 7574 0a20 2020  as its input.   
+0001b030: 2067 203d 2072 6573 6964 7561 6c73 5f61   g = residuals_a
+0001b040: 6e64 5f67 7261 645b 2d31 5d0a 2020 2020  nd_grad[-1].    
+0001b050: 7265 7475 726e 2067 0a0a 0a64 6566 2072  return g...def r
+0001b060: 6563 6970 726f 6361 6c5f 6175 675f 6677  eciprocal_aug_fw
+0001b070: 6428 613a 2054 656e 736f 7250 726f 7879  d(a: TensorProxy
+0001b080: 2920 2d3e 2056 4a50 4475 616c 3a0a 2020  ) -> VJPDual:.  
+0001b090: 2020 7072 696d 616c 203d 2072 6563 6970    primal = recip
+0001b0a0: 726f 6361 6c28 6129 0a20 2020 2072 6574  rocal(a).    ret
+0001b0b0: 7572 6e20 564a 5044 7561 6c28 7072 696d  urn VJPDual(prim
+0001b0c0: 616c 2c20 2870 7269 6d61 6c2c 2929 0a0a  al, (primal,))..
+0001b0d0: 0a64 6566 2072 6563 6970 726f 6361 6c5f  .def reciprocal_
+0001b0e0: 6261 636b 7761 7264 2870 7269 6d61 6c2c  backward(primal,
+0001b0f0: 2067 293a 0a20 2020 2072 6574 7572 6e20   g):.    return 
+0001b100: 2d67 202a 2070 7269 6d61 6c20 2a20 7072  -g * primal * pr
+0001b110: 696d 616c 0a0a 0a40 7061 7274 6961 6c28  imal...@partial(
+0001b120: 7265 6769 7374 6572 5f67 7261 642c 2070  register_grad, p
+0001b130: 7269 6d73 2e50 7269 6d49 4473 2e52 4543  rims.PrimIDs.REC
+0001b140: 4950 524f 4341 4c29 0a64 6566 2072 6563  IPROCAL).def rec
+0001b150: 6970 726f 6361 6c5f 6a6f 696e 745f 666f  iprocal_joint_fo
+0001b160: 7277 6172 645f 6261 636b 7761 7264 5f72  rward_backward_r
+0001b170: 756c 6528 613a 2054 656e 736f 7250 726f  ule(a: TensorPro
+0001b180: 7879 2920 2d3e 2054 656e 736f 7250 726f  xy) -> TensorPro
+0001b190: 7879 3a0a 2020 2020 7265 7375 6c74 2c20  xy:.    result, 
+0001b1a0: 7361 7665 6420 3d20 7265 6369 7072 6f63  saved = reciproc
+0001b1b0: 616c 5f61 7567 5f66 7764 2861 290a 2020  al_aug_fwd(a).  
+0001b1c0: 2020 6720 3d20 6765 745f 6772 6164 2872    g = get_grad(r
+0001b1d0: 6573 756c 7429 0a20 2020 2067 6120 3d20  esult).    ga = 
+0001b1e0: 7265 6369 7072 6f63 616c 5f62 6163 6b77  reciprocal_backw
+0001b1f0: 6172 6428 2a73 6176 6564 2c20 6729 0a20  ard(*saved, g). 
+0001b200: 2020 2070 7574 5f67 7261 6428 612c 2067     put_grad(a, g
+0001b210: 6129 0a20 2020 2072 6574 7572 6e20 7265  a).    return re
+0001b220: 7375 6c74 0a0a 0a40 7265 6769 7374 6572  sult...@register
+0001b230: 5f61 7567 6d65 6e74 6564 5f66 6f72 7761  _augmented_forwa
+0001b240: 7264 2822 746f 7263 682e 696e 6465 785f  rd("torch.index_
+0001b250: 7075 7422 290a 6465 6620 696e 6465 785f  put").def index_
+0001b260: 7075 745f 6175 675f 6677 6428 0a20 2020  put_aug_fwd(.   
+0001b270: 2061 3a20 5465 6e73 6f72 5072 6f78 792c   a: TensorProxy,
+0001b280: 202f 2c20 696e 6469 6365 733a 2053 6571   /, indices: Seq
+0001b290: 7565 6e63 655b 5465 6e73 6f72 5072 6f78  uence[TensorProx
+0001b2a0: 795d 2c20 7661 6c75 6573 3a20 5465 6e73  y], values: Tens
+0001b2b0: 6f72 5072 6f78 792c 2061 6363 756d 756c  orProxy, accumul
+0001b2c0: 6174 653a 2062 6f6f 6c20 3d20 4661 6c73  ate: bool = Fals
+0001b2d0: 650a 2920 2d3e 2056 4a50 4475 616c 3a0a  e.) -> VJPDual:.
+0001b2e0: 2020 2020 7072 696d 616c 203d 2063 6c61      primal = cla
+0001b2f0: 6e67 2e69 6e64 6578 5f70 7574 2861 2c20  ng.index_put(a, 
+0001b300: 696e 6469 6365 732c 2076 616c 7565 732c  indices, values,
+0001b310: 2061 6363 756d 756c 6174 6529 0a20 2020   accumulate).   
+0001b320: 2072 6573 6964 7561 6c73 203d 2028 0a20   residuals = (. 
+0001b330: 2020 2020 2020 2069 6e64 6963 6573 2c0a         indices,.
+0001b340: 2020 2020 2020 2020 7661 6c75 6573 2c0a          values,.
+0001b350: 2020 2020 2020 2020 6163 6375 6d75 6c61          accumula
+0001b360: 7465 2c0a 2020 2020 290a 2020 2020 7265  te,.    ).    re
+0001b370: 7475 726e 2056 4a50 4475 616c 2870 7269  turn VJPDual(pri
+0001b380: 6d61 6c2c 2072 6573 6964 7561 6c73 290a  mal, residuals).
+0001b390: 0a0a 6465 6620 7375 6d5f 746f 2861 3a20  ..def sum_to(a: 
+0001b3a0: 5465 6e73 6f72 5072 6f78 792c 2073 6861  TensorProxy, sha
+0001b3b0: 7065 3a20 5365 7175 656e 6365 5b69 6e74  pe: Sequence[int
+0001b3c0: 5d29 202d 3e20 5465 6e73 6f72 5072 6f78  ]) -> TensorProx
+0001b3d0: 793a 0a20 2020 2069 6620 6e6f 7420 7368  y:.    if not sh
+0001b3e0: 6170 653a 0a20 2020 2020 2020 2072 6574  ape:.        ret
+0001b3f0: 7572 6e20 612e 7375 6d28 290a 2020 2020  urn a.sum().    
+0001b400: 6c65 6164 696e 675f 6469 6d73 203d 2061  leading_dims = a
+0001b410: 2e6e 6469 6d20 2d20 6c65 6e28 7368 6170  .ndim - len(shap
+0001b420: 6529 0a20 2020 2072 6564 7563 655f 6469  e).    reduce_di
+0001b430: 6d73 203d 2074 7570 6c65 2872 616e 6765  ms = tuple(range
+0001b440: 286c 6561 6469 6e67 5f64 696d 7329 2920  (leading_dims)) 
+0001b450: 2b20 7475 706c 6528 0a20 2020 2020 2020  + tuple(.       
+0001b460: 2069 2066 6f72 2069 2069 6e20 7261 6e67   i for i in rang
+0001b470: 6528 6c65 6164 696e 675f 6469 6d73 2c20  e(leading_dims, 
+0001b480: 612e 6e64 696d 2920 6966 2073 6861 7065  a.ndim) if shape
+0001b490: 5b69 202d 206c 6561 6469 6e67 5f64 696d  [i - leading_dim
+0001b4a0: 735d 203d 3d20 3120 616e 6420 612e 7368  s] == 1 and a.sh
+0001b4b0: 6170 655b 695d 2021 3d20 310a 2020 2020  ape[i] != 1.    
+0001b4c0: 290a 2020 2020 6120 3d20 6c74 6f72 6368  ).    a = ltorch
+0001b4d0: 2e73 756d 2861 2c20 6469 6d3d 7265 6475  .sum(a, dim=redu
+0001b4e0: 6365 5f64 696d 732c 206b 6565 7064 696d  ce_dims, keepdim
+0001b4f0: 3d54 7275 6529 0a20 2020 2069 6620 6c65  =True).    if le
+0001b500: 6164 696e 675f 6469 6d73 203e 2030 3a0a  ading_dims > 0:.
+0001b510: 2020 2020 2020 2020 7265 7475 726e 206c          return l
+0001b520: 746f 7263 682e 7669 6577 2861 2c20 7368  torch.view(a, sh
+0001b530: 6170 6529 0a20 2020 2072 6574 7572 6e20  ape).    return 
+0001b540: 610a 0a0a 4072 6567 6973 7465 725f 6261  a...@register_ba
+0001b550: 636b 7761 7264 2822 746f 7263 682e 696e  ckward("torch.in
+0001b560: 6465 785f 7075 7422 290a 6465 6620 696e  dex_put").def in
+0001b570: 6465 785f 7075 745f 6261 636b 7761 7264  dex_put_backward
+0001b580: 2869 6e64 6963 6573 3a20 5365 7175 656e  (indices: Sequen
+0001b590: 6365 5b54 656e 736f 7250 726f 7879 5d2c  ce[TensorProxy],
+0001b5a0: 2076 616c 7565 733a 2054 656e 736f 7250   values: TensorP
+0001b5b0: 726f 7879 2c20 6163 6375 6d75 6c61 7465  roxy, accumulate
+0001b5c0: 3a20 626f 6f6c 2c20 673a 2054 656e 736f  : bool, g: Tenso
+0001b5d0: 7250 726f 7879 293a 0a20 2020 2067 5f76  rProxy):.    g_v
+0001b5e0: 616c 7565 7320 3d20 675b 696e 6469 6365  alues = g[indice
+0001b5f0: 735d 0a20 2020 2023 2074 6f72 6368 2068  s].    # torch h
+0001b600: 6173 2065 7874 7261 206c 6f67 6963 2074  as extra logic t
+0001b610: 6f20 6861 6e64 6c65 2074 6865 2065 7870  o handle the exp
+0001b620: 616e 6465 6420 7661 6c75 6573 0a20 2020  anded values.   
+0001b630: 2069 6620 6e6f 7420 7574 696c 732e 7361   if not utils.sa
+0001b640: 6d65 5f73 6861 7065 2867 5f76 616c 7565  me_shape(g_value
+0001b650: 732e 7368 6170 652c 2076 616c 7565 732e  s.shape, values.
+0001b660: 7368 6170 6529 3a0a 2020 2020 2020 2020  shape):.        
+0001b670: 6966 2063 6c61 6e67 2e63 6f6d 7075 7465  if clang.compute
+0001b680: 5f62 726f 6164 6361 7374 5f73 6861 7065  _broadcast_shape
+0001b690: 2867 5f76 616c 7565 732e 7368 6170 652c  (g_values.shape,
+0001b6a0: 2076 616c 7565 732e 7368 6170 6529 3a0a   values.shape):.
+0001b6b0: 2020 2020 2020 2020 2020 2020 675f 7661              g_va
+0001b6c0: 6c75 6573 203d 2073 756d 5f74 6f28 675f  lues = sum_to(g_
+0001b6d0: 7661 6c75 6573 2c20 7661 6c75 6573 2e73  values, values.s
+0001b6e0: 6861 7065 290a 2020 2020 6966 2061 6363  hape).    if acc
+0001b6f0: 756d 756c 6174 653a 0a20 2020 2020 2020  umulate:.       
+0001b700: 2072 6574 7572 6e20 672c 2067 5f76 616c   return g, g_val
+0001b710: 7565 730a 2020 2020 7265 7475 726e 2063  ues.    return c
+0001b720: 6c61 6e67 2e69 6e64 6578 5f70 7574 2867  lang.index_put(g
+0001b730: 2c20 696e 6469 6365 732c 206c 746f 7263  , indices, ltorc
+0001b740: 682e 7a65 726f 735f 6c69 6b65 2876 616c  h.zeros_like(val
+0001b750: 7565 7329 2c20 4661 6c73 6529 2c20 675f  ues), False), g_
+0001b760: 7661 6c75 6573 0a0a 0a64 6566 2075 6e69  values...def uni
+0001b770: 666f 726d 5f61 7567 5f66 7764 2873 6861  form_aug_fwd(sha
+0001b780: 7065 2c20 6d69 6e76 616c 2c20 6d61 7876  pe, minval, maxv
+0001b790: 616c 2c20 2a2c 2064 6576 6963 652c 2064  al, *, device, d
+0001b7a0: 7479 7065 293a 0a20 2020 2070 7269 6d61  type):.    prima
+0001b7b0: 6c20 3d20 7072 696d 732e 756e 6966 6f72  l = prims.unifor
+0001b7c0: 6d28 7368 6170 652c 206d 696e 7661 6c2c  m(shape, minval,
+0001b7d0: 206d 6178 7661 6c2c 2064 6576 6963 653d   maxval, device=
+0001b7e0: 6465 7669 6365 2c20 6474 7970 653d 6474  device, dtype=dt
+0001b7f0: 7970 6529 0a20 2020 2072 6574 7572 6e20  ype).    return 
+0001b800: 564a 5044 7561 6c28 7072 696d 616c 2c20  VJPDual(primal, 
+0001b810: 2870 7269 6d61 6c2c 206d 696e 7661 6c2c  (primal, minval,
+0001b820: 206d 6178 7661 6c29 290a 0a0a 6465 6620   maxval))...def 
+0001b830: 756e 6966 6f72 6d5f 6261 636b 7761 7264  uniform_backward
+0001b840: 2870 7269 6d61 6c2c 206d 696e 7661 6c2c  (primal, minval,
+0001b850: 206d 6178 7661 6c2c 2067 293a 0a20 2020   maxval, g):.   
+0001b860: 2023 2075 6e69 666f 726d 2069 7320 696d   # uniform is im
+0001b870: 706c 656d 656e 7465 6420 6173 2028 6d61  plemented as (ma
+0001b880: 7876 616c 202d 206d 696e 7661 6c29 202a  xval - minval) *
+0001b890: 2075 6e69 666f 726d 2873 6861 7065 2c20   uniform(shape, 
+0001b8a0: 302c 2031 2920 2b20 6d69 6e76 616c 0a20  0, 1) + minval. 
+0001b8b0: 2020 2075 6e73 6361 6c65 645f 7072 696d     unscaled_prim
+0001b8c0: 616c 203d 2028 7072 696d 616c 202d 206d  al = (primal - m
+0001b8d0: 696e 7661 6c29 202f 2028 6d61 7876 616c  inval) / (maxval
+0001b8e0: 202d 206d 696e 7661 6c29 0a20 2020 2072   - minval).    r
+0001b8f0: 6564 7563 655f 616c 6c5f 6469 6d73 203d  educe_all_dims =
+0001b900: 2074 7570 6c65 2872 616e 6765 2867 2e6e   tuple(range(g.n
+0001b910: 6469 6d29 290a 2020 2020 7375 6d20 3d20  dim)).    sum = 
+0001b920: 7061 7274 6961 6c28 7072 696d 732e 7375  partial(prims.su
+0001b930: 6d2c 2064 696d 733d 7265 6475 6365 5f61  m, dims=reduce_a
+0001b940: 6c6c 5f64 696d 7329 0a20 2020 2072 6574  ll_dims).    ret
+0001b950: 7572 6e20 4e6f 6e65 2c20 7375 6d28 6720  urn None, sum(g 
+0001b960: 2a20 2831 202d 2075 6e73 6361 6c65 645f  * (1 - unscaled_
+0001b970: 7072 696d 616c 2929 2c20 7375 6d28 6720  primal)), sum(g 
+0001b980: 2a20 756e 7363 616c 6564 5f70 7269 6d61  * unscaled_prima
+0001b990: 6c29 0a0a 0a6e 6f6e 6469 6666 6572 656e  l)...nondifferen
+0001b9a0: 7469 6162 6c65 5f76 6a70 5f73 796d 626f  tiable_vjp_symbo
+0001b9b0: 6c73 203d 2028 7072 696d 732e 5072 696d  ls = (prims.Prim
+0001b9c0: 4944 732e 4249 5457 4953 455f 414e 442c  IDs.BITWISE_AND,
+0001b9d0: 2070 7269 6d73 2e50 7269 6d49 4473 2e53   prims.PrimIDs.S
+0001b9e0: 4947 4e42 4954 2c20 7072 696d 732e 5072  IGNBIT, prims.Pr
+0001b9f0: 696d 4944 732e 4655 4c4c 290a 0a0a 6465  imIDs.FULL)...de
+0001ba00: 6620 6973 5f63 6f6e 7374 616e 745f 666f  f is_constant_fo
+0001ba10: 725f 766a 7028 7379 6d62 6f6c 3a20 7072  r_vjp(symbol: pr
+0001ba20: 696d 732e 5379 6d62 6f6c 2920 2d3e 2062  ims.Symbol) -> b
+0001ba30: 6f6f 6c3a 0a20 2020 2022 2222 4368 6563  ool:.    """Chec
+0001ba40: 6b20 6966 2061 2073 796d 626f 6c20 6973  k if a symbol is
+0001ba50: 2063 6f6e 7374 616e 7420 666f 7220 7468   constant for th
+0001ba60: 6520 564a 5020 7472 616e 7366 6f72 6d2e  e VJP transform.
+0001ba70: 0a0a 2020 2020 4172 6773 3a0a 2020 2020  ..    Args:.    
+0001ba80: 2020 2020 7379 6d62 6f6c 2028 7072 696d      symbol (prim
+0001ba90: 732e 5379 6d62 6f6c 293a 2053 796d 626f  s.Symbol): Symbo
+0001baa0: 6c20 746f 2063 6865 636b 2e0a 0a20 2020  l to check...   
+0001bab0: 2052 6574 7572 6e73 3a0a 2020 2020 2020   Returns:.      
+0001bac0: 2020 626f 6f6c 3a20 5472 7565 2069 6620    bool: True if 
+0001bad0: 7468 6520 7379 6d62 6f6c 2069 7320 636f  the symbol is co
+0001bae0: 6e73 7461 6e74 2c20 4661 6c73 6520 6f74  nstant, False ot
+0001baf0: 6865 7277 6973 652e 0a20 2020 2022 2222  herwise..    """
+0001bb00: 0a20 2020 2061 7265 5f61 6c6c 5f61 7267  .    are_all_arg
+0001bb10: 735f 6e6f 6e5f 6469 6666 6572 656e 7469  s_non_differenti
+0001bb20: 6162 6c65 203d 206e 6f74 2061 6e79 2869  able = not any(i
+0001bb30: 7369 6e73 7461 6e63 6528 6172 672c 2028  sinstance(arg, (
+0001bb40: 466c 6f61 7450 726f 7879 2c20 5465 6e73  FloatProxy, Tens
+0001bb50: 6f72 5072 6f78 7929 2920 666f 7220 6172  orProxy)) for ar
+0001bb60: 6720 696e 2073 796d 626f 6c2e 666c 6174  g in symbol.flat
+0001bb70: 5f61 7267 7329 0a20 2020 2072 6574 7572  _args).    retur
+0001bb80: 6e20 280a 2020 2020 2020 2020 6172 655f  n (.        are_
+0001bb90: 616c 6c5f 6172 6773 5f6e 6f6e 5f64 6966  all_args_non_dif
+0001bba0: 6665 7265 6e74 6961 626c 650a 2020 2020  ferentiable.    
+0001bbb0: 2020 2020 6f72 2073 796d 626f 6c2e 6172      or symbol.ar
+0001bbc0: 655f 616c 6c5f 6172 6773 5f63 6f6e 7374  e_all_args_const
+0001bbd0: 616e 740a 2020 2020 2020 2020 6f72 2073  ant.        or s
+0001bbe0: 796d 626f 6c2e 7379 6d2e 6964 2069 6e20  ymbol.sym.id in 
+0001bbf0: 6e6f 6e64 6966 6665 7265 6e74 6961 626c  nondifferentiabl
+0001bc00: 655f 766a 705f 7379 6d62 6f6c 730a 2020  e_vjp_symbols.  
+0001bc10: 2020 290a 0a0a 6465 6620 766a 705f 7379    )...def vjp_sy
+0001bc20: 6d62 6f6c 5f6d 6170 7065 7228 7379 6d62  mbol_mapper(symb
+0001bc30: 6f6c 3a20 7072 696d 732e 5379 6d62 6f6c  ol: prims.Symbol
+0001bc40: 2c20 2a61 7267 732c 202a 2a6b 7761 7267  , *args, **kwarg
+0001bc50: 7329 3a0a 2020 2020 2222 2253 796d 626f  s):.    """Symbo
+0001bc60: 6c20 6d61 7070 6572 2066 6f72 2074 6865  l mapper for the
+0001bc70: 2056 4a50 2074 7261 6e73 666f 726d 2e0a   VJP transform..
+0001bc80: 0a20 2020 2041 7267 733a 0a20 2020 2020  .    Args:.     
+0001bc90: 2020 2073 796d 626f 6c20 2870 7269 6d73     symbol (prims
+0001bca0: 2e53 796d 626f 6c29 3a20 5379 6d62 6f6c  .Symbol): Symbol
+0001bcb0: 2074 6f20 6265 206d 6170 7065 642e 0a20   to be mapped.. 
+0001bcc0: 2020 2020 2020 2061 7267 7320 2854 7570         args (Tup
+0001bcd0: 6c65 5b56 6172 6961 626c 655d 293a 2041  le[Variable]): A
+0001bce0: 7267 756d 656e 7473 2074 6f20 7468 6520  rguments to the 
+0001bcf0: 7379 6d62 6f6c 2e0a 2020 2020 2020 2020  symbol..        
+0001bd00: 6b77 6172 6773 2028 4469 6374 5b73 7472  kwargs (Dict[str
+0001bd10: 2c20 5661 7269 6162 6c65 5d29 3a20 4b65  , Variable]): Ke
+0001bd20: 7977 6f72 6420 6172 6775 6d65 6e74 7320  yword arguments 
+0001bd30: 746f 2074 6865 2073 796d 626f 6c2e 0a0a  to the symbol...
+0001bd40: 2020 2020 5265 7475 726e 733a 0a20 2020      Returns:.   
+0001bd50: 2020 2020 2043 616c 6c61 626c 653a 2041       Callable: A
+0001bd60: 2066 756e 6374 696f 6e20 7468 6174 2063   function that c
+0001bd70: 6f6d 7075 7465 7320 7468 6520 564a 5020  omputes the VJP 
+0001bd80: 6f66 2074 6865 2073 796d 626f 6c2e 0a20  of the symbol.. 
+0001bd90: 2020 2022 2222 0a20 2020 2023 2043 6f6e     """.    # Con
+0001bda0: 7374 616e 7420 6361 7365 0a20 2020 2069  stant case.    i
+0001bdb0: 6620 6973 5f63 6f6e 7374 616e 745f 666f  f is_constant_fo
+0001bdc0: 725f 766a 7028 7379 6d62 6f6c 293a 0a0a  r_vjp(symbol):..
+0001bdd0: 2020 2020 2020 2020 6465 6620 766a 705f          def vjp_
+0001bde0: 696d 706c 5f63 6f6e 7374 2873 796d 626f  impl_const(symbo
+0001bdf0: 6c2c 202a 6172 6773 2c20 2a2a 6b77 6172  l, *args, **kwar
+0001be00: 6773 293a 0a20 2020 2020 2020 2020 2020  gs):.           
+0001be10: 2061 7267 732c 206b 7761 7267 7320 3d20   args, kwargs = 
+0001be20: 7472 6565 5f6d 6170 286c 616d 6264 6120  tree_map(lambda 
+0001be30: 783a 2078 2e70 7269 6d61 6c20 6966 2069  x: x.primal if i
+0001be40: 7369 6e73 7461 6e63 6528 782c 2056 4a50  sinstance(x, VJP
+0001be50: 4475 616c 2920 656c 7365 2078 2c20 2861  Dual) else x, (a
+0001be60: 7267 732c 206b 7761 7267 7329 290a 2020  rgs, kwargs)).  
+0001be70: 2020 2020 2020 2020 2020 7072 696d 616c            primal
+0001be80: 7320 3d20 7379 6d62 6f6c 5f74 6f5f 6576  s = symbol_to_ev
+0001be90: 616c 2873 796d 626f 6c29 282a 6172 6773  al(symbol)(*args
+0001bea0: 2c20 2a2a 6b77 6172 6773 290a 2020 2020  , **kwargs).    
+0001beb0: 2020 2020 2020 2020 6966 2069 7369 6e73          if isins
+0001bec0: 7461 6e63 6528 7072 696d 616c 732c 2053  tance(primals, S
+0001bed0: 6571 7565 6e63 6529 3a0a 2020 2020 2020  equence):.      
+0001bee0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+0001bef0: 2074 7265 655f 6d61 7028 6c61 6d62 6461   tree_map(lambda
+0001bf00: 2078 3a20 564a 5044 7561 6c28 782c 2074   x: VJPDual(x, t
+0001bf10: 7570 6c65 2829 292c 2070 7269 6d61 6c73  uple()), primals
+0001bf20: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+0001bf30: 7475 726e 2056 4a50 4475 616c 2870 7269  turn VJPDual(pri
+0001bf40: 6d61 6c73 2c20 7475 706c 6528 2929 0a0a  mals, tuple())..
+0001bf50: 2020 2020 2020 2020 7265 7475 726e 2070          return p
+0001bf60: 6172 7469 616c 2876 6a70 5f69 6d70 6c5f  artial(vjp_impl_
+0001bf70: 636f 6e73 742c 2073 796d 626f 6c29 0a0a  const, symbol)..
+0001bf80: 2020 2020 2320 4e6f 726d 616c 2063 6173      # Normal cas
+0001bf90: 652c 2077 6520 6861 7665 2061 2070 726f  e, we have a pro
+0001bfa0: 7879 2074 616e 6765 6e74 0a20 2020 2076  xy tangent.    v
+0001bfb0: 6a70 5f69 6d70 6c20 3d20 6175 676d 656e  jp_impl = augmen
+0001bfc0: 7465 645f 666f 7277 6172 645f 696d 706c  ted_forward_impl
+0001bfd0: 732e 6765 7428 7379 6d62 6f6c 2e73 796d  s.get(symbol.sym
+0001bfe0: 2e69 6429 0a0a 2020 2020 6966 205f 6765  .id)..    if _ge
+0001bff0: 745f 6772 6164 666e 5f61 6e64 5f65 7865  t_gradfn_and_exe
+0001c000: 6375 746f 7228 7379 6d62 6f6c 295b 305d  cutor(symbol)[0]
+0001c010: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2020   is not None:.  
+0001c020: 2020 2020 2020 766a 705f 696d 706c 2c20        vjp_impl, 
+0001c030: 6261 636b 7761 7264 5f66 6e20 3d20 6d61  backward_fn = ma
+0001c040: 6b65 5f61 7567 5f66 6f72 7761 7264 5f61  ke_aug_forward_a
+0001c050: 6e64 5f62 6163 6b77 6172 6428 7379 6d62  nd_backward(symb
+0001c060: 6f6c 290a 0a20 2020 2069 6620 766a 705f  ol)..    if vjp_
+0001c070: 696d 706c 2069 7320 4e6f 6e65 3a0a 2020  impl is None:.  
+0001c080: 2020 2020 2020 2320 5765 2063 6f75 6c64        # We could
+0001c090: 206e 6f74 2066 696e 6420 6120 564a 5020   not find a VJP 
+0001c0a0: 666f 7220 7468 6973 2073 796d 626f 6c2c  for this symbol,
+0001c0b0: 2073 6f20 7765 2074 7279 2074 6f20 6465   so we try to de
+0001c0c0: 636f 6d70 6f73 6520 6974 0a20 2020 2020  compose it.     
+0001c0d0: 2020 2069 6620 6c65 6e28 7379 6d62 6f6c     if len(symbol
+0001c0e0: 2e73 7562 7379 6d62 6f6c 7329 203e 2030  .subsymbols) > 0
+0001c0f0: 2061 6e64 206e 6f74 2069 7369 6e73 7461   and not isinsta
+0001c100: 6e63 6528 7379 6d62 6f6c 2e73 796d 2e69  nce(symbol.sym.i
+0001c110: 642c 2070 7269 6d73 2e50 7269 6d49 4473  d, prims.PrimIDs
+0001c120: 293a 0a20 2020 2020 2020 2020 2020 2076  ):.            v
+0001c130: 6a70 5f69 6d70 6c20 3d20 7061 7274 6961  jp_impl = partia
+0001c140: 6c28 6465 636f 6d70 6f73 6564 5f66 6e5f  l(decomposed_fn_
+0001c150: 6175 675f 6677 645f 7275 6c65 2c20 6465  aug_fwd_rule, de
+0001c160: 636f 6d70 6f73 6564 5f66 6e3d 7379 6d62  composed_fn=symb
+0001c170: 6f6c 2e73 796d 290a 2020 2020 2020 2020  ol.sym).        
+0001c180: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+0001c190: 2020 2320 5765 2063 6f75 6c64 206e 6f74    # We could not
+0001c1a0: 2066 696e 6420 6120 564a 5020 666f 7220   find a VJP for 
+0001c1b0: 7468 6973 2073 796d 626f 6c20 616e 6420  this symbol and 
+0001c1c0: 7765 2063 6f75 6c64 206e 6f74 2064 6563  we could not dec
+0001c1d0: 6f6d 706f 7365 2069 740a 2020 2020 2020  ompose it.      
+0001c1e0: 2020 2020 2020 2320 4974 2063 6f75 6c64        # It could
+0001c1f0: 2062 6520 6120 746f 7263 682e 6472 6f70   be a torch.drop
+0001c200: 6f75 7420 7769 7468 2030 2e30 2070 726f  out with 0.0 pro
+0001c210: 6261 6269 6c69 7479 2c20 736f 2077 6520  bability, so we 
+0001c220: 736b 6970 2069 740a 2020 2020 2020 2020  skip it.        
+0001c230: 2020 2020 6966 2073 796d 626f 6c2e 7379      if symbol.sy
+0001c240: 6d2e 6964 203d 3d20 2274 6f72 6368 2e6e  m.id == "torch.n
+0001c250: 6e2e 6675 6e63 7469 6f6e 616c 2e64 726f  n.functional.dro
+0001c260: 706f 7574 223a 0a20 2020 2020 2020 2020  pout":.         
+0001c270: 2020 2020 2020 2072 6574 7572 6e20 4e6f         return No
+0001c280: 6e65 0a20 2020 2020 2020 2020 2020 2070  ne.            p
+0001c290: 7269 6e74 2866 2256 4a50 2066 6f72 207b  rint(f"VJP for {
+0001c2a0: 7379 6d62 6f6c 7d20 6973 206e 6f74 2069  symbol} is not i
+0001c2b0: 6d70 6c65 6d65 6e74 6564 2229 0a20 2020  mplemented").   
+0001c2c0: 2020 2020 2020 2020 2072 6169 7365 204e           raise N
+0001c2d0: 6f74 496d 706c 656d 656e 7465 6445 7272  otImplementedErr
+0001c2e0: 6f72 2866 2256 4a50 2066 6f72 207b 7379  or(f"VJP for {sy
+0001c2f0: 6d62 6f6c 2e73 796d 2e69 647d 2069 7320  mbol.sym.id} is 
+0001c300: 6e6f 7420 696d 706c 656d 656e 7465 6422  not implemented"
+0001c310: 290a 0a20 2020 2064 6566 205f 766a 705f  )..    def _vjp_
+0001c320: 696d 706c 282a 6172 6773 2c20 2a2a 6b77  impl(*args, **kw
+0001c330: 6172 6773 293a 0a20 2020 2020 2020 2070  args):.        p
+0001c340: 7269 6d61 6c73 2c20 6b77 6172 6773 203d  rimals, kwargs =
+0001c350: 2074 7265 655f 6d61 7028 6c61 6d62 6461   tree_map(lambda
+0001c360: 2078 3a20 782e 7072 696d 616c 2069 6620   x: x.primal if 
+0001c370: 6973 696e 7374 616e 6365 2878 2c20 564a  isinstance(x, VJ
+0001c380: 5044 7561 6c29 2065 6c73 6520 782c 2028  PDual) else x, (
+0001c390: 6172 6773 2c20 6b77 6172 6773 2929 0a20  args, kwargs)). 
+0001c3a0: 2020 2020 2020 206f 7574 5f70 7269 6d61         out_prima
+0001c3b0: 6c2c 206f 7574 5f72 6573 6964 7561 6c73  l, out_residuals
+0001c3c0: 203d 2076 6a70 5f69 6d70 6c28 2a70 7269   = vjp_impl(*pri
+0001c3d0: 6d61 6c73 2c20 2a2a 6b77 6172 6773 290a  mals, **kwargs).
+0001c3e0: 0a20 2020 2020 2020 2023 2057 6520 6172  .        # We ar
+0001c3f0: 6520 7361 7669 6e67 2074 6865 2072 6573  e saving the res
+0001c400: 6964 7561 6c73 2061 6e64 2070 756c 6c62  iduals and pullb
+0001c410: 6163 6b20 6f6e 6c79 2069 6e20 7468 6520  ack only in the 
+0001c420: 6669 7273 7420 6f75 7470 7574 0a20 2020  first output.   
+0001c430: 2020 2020 2023 2062 6163 6b77 6172 645f       # backward_
+0001c440: 7061 7373 2074 6865 6e20 7265 7472 6965  pass then retrie
+0001c450: 7665 7320 7468 6520 7265 7369 6475 616c  ves the residual
+0001c460: 7320 616e 6420 7075 6c6c 6261 636b 2066  s and pullback f
+0001c470: 726f 6d20 7468 6520 6669 7273 7420 6f75  rom the first ou
+0001c480: 7470 7574 0a20 2020 2020 2020 2069 6620  tput.        if 
+0001c490: 6973 696e 7374 616e 6365 286f 7574 5f70  isinstance(out_p
+0001c4a0: 7269 6d61 6c2c 2053 6571 7565 6e63 6529  rimal, Sequence)
+0001c4b0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+0001c4c0: 7475 726e 2028 564a 5044 7561 6c28 6f75  turn (VJPDual(ou
+0001c4d0: 745f 7072 696d 616c 5b30 5d2c 206f 7574  t_primal[0], out
+0001c4e0: 5f72 6573 6964 7561 6c73 292c 202a 2856  _residuals), *(V
+0001c4f0: 4a50 4475 616c 286f 2c20 7475 706c 6528  JPDual(o, tuple(
+0001c500: 2929 2066 6f72 206f 2069 6e20 6f75 745f  )) for o in out_
+0001c510: 7072 696d 616c 5b31 3a5d 2929 0a0a 2020  primal[1:]))..  
+0001c520: 2020 2020 2020 7265 7475 726e 2028 564a        return (VJ
+0001c530: 5044 7561 6c28 6f75 745f 7072 696d 616c  PDual(out_primal
+0001c540: 2c20 6f75 745f 7265 7369 6475 616c 7329  , out_residuals)
+0001c550: 2c29 0a0a 2020 2020 7265 7475 726e 205f  ,)..    return _
+0001c560: 766a 705f 696d 706c 0a0a 0a64 6566 2063  vjp_impl...def c
+0001c570: 6865 636b 5f62 7379 6d5f 666f 725f 766a  heck_bsym_for_vj
+0001c580: 7028 6273 796d 293a 0a20 2020 2022 2222  p(bsym):.    """
+0001c590: 0a20 2020 2043 6865 636b 2069 6620 6120  .    Check if a 
+0001c5a0: 626f 756e 6420 7379 6d62 6f6c 2069 7320  bound symbol is 
+0001c5b0: 7375 7070 6f72 7465 6420 6279 2076 6a70  supported by vjp
+0001c5c0: 2e0a 0a20 2020 2041 7267 733a 0a20 2020  ...    Args:.   
+0001c5d0: 2020 2020 2062 7379 6d20 2842 6f75 6e64       bsym (Bound
+0001c5e0: 5379 6d62 6f6c 293a 2054 6865 2062 6f75  Symbol): The bou
+0001c5f0: 6e64 2073 796d 626f 6c20 746f 2063 6865  nd symbol to che
+0001c600: 636b 2e0a 0a20 2020 2052 6574 7572 6e73  ck...    Returns
+0001c610: 3a0a 2020 2020 2020 2020 626f 6f6c 3a20  :.        bool: 
+0001c620: 5472 7565 2069 6620 7468 6520 626f 756e  True if the boun
+0001c630: 6420 7379 6d62 6f6c 2069 7320 7375 7070  d symbol is supp
+0001c640: 6f72 7465 6420 6279 2076 6a70 2c20 4661  orted by vjp, Fa
+0001c650: 6c73 6520 6f74 6865 7277 6973 652e 0a20  lse otherwise.. 
+0001c660: 2020 2022 2222 0a0a 2020 2020 6966 2062     """..    if b
+0001c670: 7379 6d2e 7379 6d2e 6964 2069 6e20 7472  sym.sym.id in tr
+0001c680: 616e 7366 6f72 6d5f 736b 6970 5f6c 6973  ansform_skip_lis
+0001c690: 743a 0a20 2020 2020 2020 2072 6574 7572  t:.        retur
+0001c6a0: 6e20 5472 7565 0a0a 2020 2020 6966 2062  n True..    if b
+0001c6b0: 7379 6d2e 7379 6d2e 6964 2069 6e20 6261  sym.sym.id in ba
+0001c6c0: 636b 7761 7264 5f69 6d70 6c73 2061 6e64  ckward_impls and
+0001c6d0: 2062 7379 6d2e 7379 6d2e 6964 2069 6e20   bsym.sym.id in 
+0001c6e0: 6175 676d 656e 7465 645f 666f 7277 6172  augmented_forwar
+0001c6f0: 645f 696d 706c 733a 0a20 2020 2020 2020  d_impls:.       
+0001c700: 2072 6574 7572 6e20 5472 7565 0a0a 2020   return True..  
+0001c710: 2020 6966 2062 7379 6d2e 7379 6d2e 6964    if bsym.sym.id
+0001c720: 2069 6e20 5f67 7261 645f 666e 5f6d 6170   in _grad_fn_map
+0001c730: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+0001c740: 2054 7275 650a 0a20 2020 2023 2057 6520   True..    # We 
+0001c750: 636f 756c 6420 6e6f 7420 6669 6e64 2061  could not find a
+0001c760: 2056 4a50 2066 6f72 2074 6869 7320 7379   VJP for this sy
+0001c770: 6d62 6f6c 2c20 736f 2077 6520 7472 7920  mbol, so we try 
+0001c780: 746f 2064 6563 6f6d 706f 7365 2069 740a  to decompose it.
+0001c790: 2020 2020 2320 696e 746f 2073 7562 2d73      # into sub-s
+0001c7a0: 796d 626f 6c73 2061 6e64 2063 6865 636b  ymbols and check
+0001c7b0: 2069 6620 7468 6579 2061 7265 2073 7570   if they are sup
+0001c7c0: 706f 7274 6564 0a20 2020 2069 6620 6c65  ported.    if le
+0001c7d0: 6e28 6273 796d 2e73 7562 7379 6d62 6f6c  n(bsym.subsymbol
+0001c7e0: 7329 203e 2030 2061 6e64 206e 6f74 2062  s) > 0 and not b
+0001c7f0: 7379 6d2e 7379 6d2e 6973 5f70 7269 6d3a  sym.sym.is_prim:
+0001c800: 0a20 2020 2020 2020 2073 7562 7472 6163  .        subtrac
+0001c810: 6520 3d20 636f 6e73 7472 7563 745f 7472  e = construct_tr
+0001c820: 6163 6528 2928 6273 796d 2e73 796d 2c20  ace()(bsym.sym, 
+0001c830: 2a62 7379 6d2e 6172 6773 2c20 2a2a 6273  *bsym.args, **bs
+0001c840: 796d 2e6b 7761 7267 7329 0a20 2020 2020  ym.kwargs).     
+0001c850: 2020 2073 7562 7472 6163 6520 3d20 756e     subtrace = un
+0001c860: 7772 6170 5f6f 6e65 5f6c 6576 656c 5f6f  wrap_one_level_o
+0001c870: 665f 7375 6273 796d 626f 6c73 2873 7562  f_subsymbols(sub
+0001c880: 7472 6163 6529 0a20 2020 2020 2020 2061  trace).        a
+0001c890: 6c6c 5f73 7570 706f 7274 6564 203d 2061  ll_supported = a
+0001c8a0: 6c6c 2863 6865 636b 5f62 7379 6d5f 666f  ll(check_bsym_fo
+0001c8b0: 725f 766a 7028 7375 6262 7379 6d29 2066  r_vjp(subbsym) f
+0001c8c0: 6f72 2073 7562 6273 796d 2069 6e20 7375  or subbsym in su
+0001c8d0: 6274 7261 6365 2e62 6f75 6e64 5f73 796d  btrace.bound_sym
+0001c8e0: 626f 6c73 290a 2020 2020 2020 2020 7265  bols).        re
+0001c8f0: 7475 726e 2061 6c6c 5f73 7570 706f 7274  turn all_support
+0001c900: 6564 0a0a 2020 2020 7265 7475 726e 2046  ed..    return F
+0001c910: 616c 7365 0a0a 0a64 6566 2061 7567 6d65  alse...def augme
+0001c920: 6e74 6564 5f66 6f72 7761 7264 5f70 6173  nted_forward_pas
+0001c930: 7328 2a61 7267 732c 2074 7261 6365 3a20  s(*args, trace: 
+0001c940: 5472 6163 652c 202a 2a6b 7761 7267 7329  Trace, **kwargs)
+0001c950: 3a0a 2020 2020 2222 2241 7567 6d65 6e74  :.    """Augment
+0001c960: 6564 2066 6f72 7761 7264 2070 6173 7320  ed forward pass 
+0001c970: 666f 7220 7468 6520 564a 5020 7472 616e  for the VJP tran
+0001c980: 7366 6f72 6d2e 0a0a 2020 2020 5468 6520  sform...    The 
+0001c990: 6175 676d 656e 7465 6420 666f 7277 6172  augmented forwar
+0001c9a0: 6420 7061 7373 2069 7320 6120 666f 7277  d pass is a forw
+0001c9b0: 6172 6420 7061 7373 2074 6861 7420 7265  ard pass that re
+0001c9c0: 7475 726e 7320 7468 6520 7265 7369 6475  turns the residu
+0001c9d0: 616c 730a 2020 2020 6f66 2074 6865 2066  als.    of the f
+0001c9e0: 6f72 7761 7264 2070 6173 732e 0a20 2020  orward pass..   
+0001c9f0: 2054 6865 7365 2072 6573 6964 7561 6c73   These residuals
+0001ca00: 2061 7265 2075 7365 6420 696e 2074 6865   are used in the
+0001ca10: 2062 6163 6b77 6172 6420 7061 7373 2074   backward pass t
+0001ca20: 6f20 636f 6d70 7574 6520 7468 6520 564a  o compute the VJ
+0001ca30: 5020 616e 6420 7468 6579 0a20 2020 2061  P and they.    a
+0001ca40: 7265 2072 6563 6f72 6465 6420 696e 2074  re recorded in t
+0001ca50: 6865 2065 6e76 6972 6f6e 6d65 6e74 2064  he environment d
+0001ca60: 6963 7469 6f6e 6172 7920 666f 7220 6561  ictionary for ea
+0001ca70: 6368 2076 6172 6961 626c 652e 0a0a 2020  ch variable...  
+0001ca80: 2020 4172 6773 3a0a 2020 2020 2020 2020    Args:.        
+0001ca90: 6172 6773 2028 5475 706c 655b 5661 7269  args (Tuple[Vari
+0001caa0: 6162 6c65 5d29 3a20 4172 6775 6d65 6e74  able]): Argument
+0001cab0: 7320 746f 2074 6865 2066 756e 6374 696f  s to the functio
+0001cac0: 6e2e 0a20 2020 2020 2020 2074 7261 6365  n..        trace
+0001cad0: 2028 5472 6163 6529 3a20 5472 6163 6520   (Trace): Trace 
+0001cae0: 6f66 2074 6865 2066 756e 6374 696f 6e2e  of the function.
+0001caf0: 0a20 2020 2020 2020 206b 7761 7267 7320  .        kwargs 
+0001cb00: 2844 6963 745b 7374 722c 2056 6172 6961  (Dict[str, Varia
+0001cb10: 626c 655d 293a 204b 6579 776f 7264 2061  ble]): Keyword a
+0001cb20: 7267 756d 656e 7473 2074 6f20 7468 6520  rguments to the 
+0001cb30: 6675 6e63 7469 6f6e 2e0a 0a20 2020 2052  function...    R
+0001cb40: 6574 7572 6e73 3a0a 2020 2020 2020 2020  eturns:.        
+0001cb50: 5475 706c 655b 416e 792c 2044 6963 745b  Tuple[Any, Dict[
+0001cb60: 7374 722c 2041 6e79 5d5d 3a20 5475 706c  str, Any]]: Tupl
+0001cb70: 6520 6f66 2074 6865 2070 7269 6d61 6c20  e of the primal 
+0001cb80: 6f75 7470 7574 7320 616e 6420 7468 6520  outputs and the 
+0001cb90: 656e 7669 726f 6e6d 656e 742e 0a20 2020  environment..   
+0001cba0: 2022 2222 0a20 2020 2061 7267 732c 206b   """.    args, k
+0001cbb0: 7761 7267 7320 3d20 7472 6565 5f6d 6170  wargs = tree_map
+0001cbc0: 286c 616d 6264 6120 783a 2056 4a50 4475  (lambda x: VJPDu
+0001cbd0: 616c 2878 2c20 7475 706c 6528 2929 2c20  al(x, tuple()), 
+0001cbe0: 2861 7267 732c 206b 7761 7267 7329 290a  (args, kwargs)).
+0001cbf0: 2020 2020 7265 7375 6c74 2c20 656e 7620      result, env 
+0001cc00: 3d20 6576 616c 5f74 7261 6365 280a 2020  = eval_trace(.  
+0001cc10: 2020 2020 2020 7472 6163 652c 0a20 2020        trace,.   
+0001cc20: 2020 2020 202a 6172 6773 2c0a 2020 2020       *args,.    
+0001cc30: 2020 2020 2a2a 6b77 6172 6773 2c0a 2020      **kwargs,.  
+0001cc40: 2020 2020 2020 7769 7468 5f65 6e76 3d54        with_env=T
+0001cc50: 7275 652c 0a20 2020 2020 2020 2073 796d  rue,.        sym
+0001cc60: 626f 6c5f 6d61 7070 6572 3d76 6a70 5f73  bol_mapper=vjp_s
+0001cc70: 796d 626f 6c5f 6d61 7070 6572 2c0a 2020  ymbol_mapper,.  
+0001cc80: 2020 290a 2020 2020 7265 7375 6c74 203d    ).    result =
+0001cc90: 2074 7265 655f 6d61 7028 6c61 6d62 6461   tree_map(lambda
+0001cca0: 2078 3a20 782e 7072 696d 616c 2069 6620   x: x.primal if 
+0001ccb0: 6973 696e 7374 616e 6365 2878 2c20 564a  isinstance(x, VJ
+0001ccc0: 5044 7561 6c29 2065 6c73 6520 782c 2072  PDual) else x, r
+0001ccd0: 6573 756c 7429 0a20 2020 2072 6574 7572  esult).    retur
+0001cce0: 6e20 7265 7375 6c74 2c20 656e 760a 0a0a  n result, env...
+0001ccf0: 2320 544f 444f 3a20 496e 7374 6561 6420  # TODO: Instead 
+0001cd00: 6f66 2075 7369 6e67 2074 6865 2065 6e76  of using the env
+0001cd10: 6972 6f6e 6d65 6e74 2064 6963 7469 6f6e  ironment diction
+0001cd20: 6172 792c 2077 6520 636f 756c 6420 7573  ary, we could us
+0001cd30: 6520 7468 6520 7472 6163 650a 2320 7379  e the trace.# sy
+0001cd40: 6d62 6f6c 7320 6f72 6465 7220 2874 6861  mbols order (tha
+0001cd50: 7420 7368 6f75 6c64 2062 6520 6465 7465  t should be dete
+0001cd60: 726d 696e 6973 7469 6329 2074 6f20 7265  rministic) to re
+0001cd70: 7472 6965 7665 2074 6865 2072 6573 6964  trieve the resid
+0001cd80: 7561 6c73 206e 6565 6465 640a 2320 666f  uals needed.# fo
+0001cd90: 7220 7468 6520 6261 636b 7761 7264 2070  r the backward p
+0001cda0: 6173 732e 0a64 6566 2062 6163 6b77 6172  ass..def backwar
+0001cdb0: 645f 7061 7373 2866 6f72 7761 7264 5f65  d_pass(forward_e
+0001cdc0: 6e76 2c20 7472 6163 652c 2069 6e69 745f  nv, trace, init_
+0001cdd0: 636f 7461 6e67 656e 7473 293a 0a20 2020  cotangents):.   
+0001cde0: 2022 2222 4261 636b 7761 7264 2070 6173   """Backward pas
+0001cdf0: 7320 666f 7220 7468 6520 564a 5020 7472  s for the VJP tr
+0001ce00: 616e 7366 6f72 6d2e 0a0a 2020 2020 5468  ansform...    Th
+0001ce10: 6520 6261 636b 7761 7264 2070 6173 7320  e backward pass 
+0001ce20: 6973 2061 2072 6576 6572 7365 206d 6f64  is a reverse mod
+0001ce30: 6520 6175 746f 6d61 7469 6320 6469 6666  e automatic diff
+0001ce40: 6572 656e 7469 6174 696f 6e20 7061 7373  erentiation pass
+0001ce50: 2074 6861 740a 2020 2020 636f 6d70 7574   that.    comput
+0001ce60: 6573 2074 6865 2076 6563 746f 722d 4a61  es the vector-Ja
+0001ce70: 636f 6269 616e 2070 726f 6475 6374 2028  cobian product (
+0001ce80: 564a 5029 206f 6620 7468 6520 6675 6e63  VJP) of the func
+0001ce90: 7469 6f6e 2e0a 0a20 2020 2041 7267 733a  tion...    Args:
+0001cea0: 0a20 2020 2020 2020 2066 6f72 7761 7264  .        forward
+0001ceb0: 5f65 6e76 2028 4469 6374 5b73 7472 2c20  _env (Dict[str, 
+0001cec0: 416e 795d 293a 2045 6e76 6972 6f6e 6d65  Any]): Environme
+0001ced0: 6e74 206f 6620 7468 6520 666f 7277 6172  nt of the forwar
+0001cee0: 6420 7061 7373 2e0a 2020 2020 2020 2020  d pass..        
+0001cef0: 7472 6163 6520 2854 7261 6365 293a 2054  trace (Trace): T
+0001cf00: 7261 6365 206f 6620 7468 6520 6675 6e63  race of the func
+0001cf10: 7469 6f6e 2e0a 2020 2020 2020 2020 696e  tion..        in
+0001cf20: 6974 5f63 6f74 616e 6765 6e74 7320 2854  it_cotangents (T
+0001cf30: 7570 6c65 5b56 6172 6961 626c 655d 293a  uple[Variable]):
+0001cf40: 2049 6e69 7469 616c 2063 6f74 616e 6765   Initial cotange
+0001cf50: 6e74 732e 0a0a 2020 2020 5265 7475 726e  nts...    Return
+0001cf60: 733a 0a20 2020 2020 2020 2054 7570 6c65  s:.        Tuple
+0001cf70: 5b50 726f 7879 2c20 2e2e 2e5d 3a20 5475  [Proxy, ...]: Tu
+0001cf80: 706c 6520 6f66 2074 6865 2072 6573 756c  ple of the resul
+0001cf90: 7473 206f 6620 7468 6520 6261 636b 7761  ts of the backwa
+0001cfa0: 7264 2070 6173 7320 666f 7220 6561 6368  rd pass for each
+0001cfb0: 2069 6e70 7574 2e0a 2020 2020 2222 220a   input..    """.
+0001cfc0: 2020 2020 656e 7620 3d20 7b7d 0a0a 2020      env = {}..  
+0001cfd0: 2020 6465 6620 6765 745f 6772 6164 2878    def get_grad(x
+0001cfe0: 3a20 5661 7269 6162 6c65 293a 0a20 2020  : Variable):.   
+0001cff0: 2020 2020 2069 6620 6973 696e 7374 616e       if isinstan
+0001d000: 6365 2878 2c20 5661 7269 6162 6c65 293a  ce(x, Variable):
+0001d010: 0a20 2020 2020 2020 2020 2020 2023 2052  .            # R
+0001d020: 6574 7572 6e20 4e6f 6e65 2069 6620 7468  eturn None if th
+0001d030: 6520 7661 7269 6162 6c65 2077 6173 206e  e variable was n
+0001d040: 6f74 2075 7365 6420 696e 2074 6865 2063  ot used in the c
+0001d050: 6f6d 7075 7461 7469 6f6e 2061 6e64 0a20  omputation and. 
+0001d060: 2020 2020 2020 2020 2020 2023 2068 656e             # hen
+0001d070: 6365 206e 6f74 2069 6e20 7468 6520 656e  ce not in the en
+0001d080: 760a 2020 2020 2020 2020 2020 2020 7265  v.            re
+0001d090: 7475 726e 2065 6e76 2e67 6574 2878 2e6e  turn env.get(x.n
+0001d0a0: 616d 652c 204e 6f6e 6529 0a20 2020 2020  ame, None).     
+0001d0b0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0001d0c0: 2020 2020 2072 6574 7572 6e20 780a 0a20       return x.. 
+0001d0d0: 2020 2064 6566 2070 7574 5f67 7261 6428     def put_grad(
+0001d0e0: 763a 2056 6172 6961 626c 652c 2076 616c  v: Variable, val
+0001d0f0: 3a20 416e 7929 202d 3e20 4e6f 6e65 3a0a  : Any) -> None:.
+0001d100: 2020 2020 2020 2020 6966 2069 7369 6e73          if isins
+0001d110: 7461 6e63 6528 762c 2056 6172 6961 626c  tance(v, Variabl
+0001d120: 6529 3a0a 2020 2020 2020 2020 2020 2020  e):.            
+0001d130: 6966 2076 2e6e 616d 6520 696e 2065 6e76  if v.name in env
+0001d140: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0001d150: 2020 6966 2076 616c 2069 7320 4e6f 6e65    if val is None
+0001d160: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0001d170: 2020 2020 2020 7265 7475 726e 0a20 2020        return.   
+0001d180: 2020 2020 2020 2020 2020 2020 2023 2041               # A
+0001d190: 6363 756d 756c 6174 6520 636f 7461 6e67  ccumulate cotang
+0001d1a0: 656e 7473 0a20 2020 2020 2020 2020 2020  ents.           
+0001d1b0: 2020 2020 2065 6e76 5b76 2e6e 616d 655d       env[v.name]
+0001d1c0: 203d 2063 6c61 6e67 2e61 6464 2865 6e76   = clang.add(env
+0001d1d0: 5b76 2e6e 616d 655d 2c20 7661 6c29 2069  [v.name], val) i
+0001d1e0: 6620 656e 765b 762e 6e61 6d65 5d20 6973  f env[v.name] is
+0001d1f0: 206e 6f74 204e 6f6e 6520 656c 7365 2076   not None else v
+0001d200: 616c 0a20 2020 2020 2020 2020 2020 2020  al.             
+0001d210: 2020 2072 6574 7572 6e0a 2020 2020 2020     return.      
+0001d220: 2020 2020 2020 656e 765b 762e 6e61 6d65        env[v.name
+0001d230: 5d20 3d20 7661 6c0a 2020 2020 2020 2020  ] = val.        
+0001d240: 656c 6966 2069 7369 6e73 7461 6e63 6528  elif isinstance(
+0001d250: 762c 2053 6571 7565 6e63 6529 2061 6e64  v, Sequence) and
+0001d260: 2061 6c6c 2869 7369 6e73 7461 6e63 6528   all(isinstance(
+0001d270: 782c 2069 6e74 2920 666f 7220 7820 696e  x, int) for x in
+0001d280: 2076 293a 0a20 2020 2020 2020 2020 2020   v):.           
+0001d290: 2023 2054 4f44 4f3a 2072 656d 6f76 6520   # TODO: remove 
+0001d2a0: 7768 656e 2077 6520 6d6f 7665 2064 696d  when we move dim
+0001d2b0: 7320 746f 206b 7761 7267 730a 2020 2020  s to kwargs.    
+0001d2c0: 2020 2020 2020 2020 7061 7373 0a20 2020          pass.   
+0001d2d0: 2020 2020 2065 6c69 6620 6973 696e 7374       elif isinst
+0001d2e0: 616e 6365 2876 2c20 7374 7229 3a0a 2020  ance(v, str):.  
+0001d2f0: 2020 2020 2020 2020 2020 656e 765b 765d            env[v]
+0001d300: 203d 2076 616c 0a20 2020 2020 2020 2065   = val.        e
+0001d310: 6c69 6620 6973 696e 7374 616e 6365 2876  lif isinstance(v
+0001d320: 2c20 5365 7175 656e 6365 2920 616e 6420  , Sequence) and 
+0001d330: 7661 6c20 6973 204e 6f6e 653a 0a20 2020  val is None:.   
+0001d340: 2020 2020 2020 2020 2023 2062 726f 6164           # broad
+0001d350: 6361 7374 204e 6f6e 6520 746f 2074 6865  cast None to the
+0001d360: 2072 6967 6874 2073 6861 7065 0a20 2020   right shape.   
+0001d370: 2020 2020 2020 2020 2073 6166 655f 6d61           safe_ma
+0001d380: 7028 7075 745f 6772 6164 2c20 762c 205b  p(put_grad, v, [
+0001d390: 4e6f 6e65 5d20 2a20 6c65 6e28 7629 290a  None] * len(v)).
+0001d3a0: 2020 2020 2020 2020 656c 6966 2069 7369          elif isi
+0001d3b0: 6e73 7461 6e63 6528 762c 2053 6571 7565  nstance(v, Seque
+0001d3c0: 6e63 6529 2061 6e64 2069 7369 6e73 7461  nce) and isinsta
+0001d3d0: 6e63 6528 7661 6c2c 2053 6571 7565 6e63  nce(val, Sequenc
+0001d3e0: 6529 3a0a 2020 2020 2020 2020 2020 2020  e):.            
+0001d3f0: 7361 6665 5f6d 6170 5f66 6c61 7428 7075  safe_map_flat(pu
+0001d400: 745f 6772 6164 2c20 762c 2076 616c 290a  t_grad, v, val).
+0001d410: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+0001d420: 2020 2020 2020 2020 2020 2320 536b 6970            # Skip
+0001d430: 2077 7269 7469 6e67 2074 6f20 636f 6e73   writing to cons
+0001d440: 7461 6e74 730a 2020 2020 2020 2020 2020  tants.          
+0001d450: 2020 7061 7373 0a0a 2020 2020 6966 2069    pass..    if i
+0001d460: 7369 6e73 7461 6e63 6528 696e 6974 5f63  sinstance(init_c
+0001d470: 6f74 616e 6765 6e74 732c 2053 6571 7565  otangents, Seque
+0001d480: 6e63 6529 2061 6e64 206c 656e 2869 6e69  nce) and len(ini
+0001d490: 745f 636f 7461 6e67 656e 7473 2920 3d3d  t_cotangents) ==
+0001d4a0: 2031 2061 6e64 206e 6f74 2069 7369 6e73   1 and not isins
+0001d4b0: 7461 6e63 6528 7472 6163 652e 6f75 7470  tance(trace.outp
+0001d4c0: 7574 2c20 5365 7175 656e 6365 293a 0a20  ut, Sequence):. 
+0001d4d0: 2020 2020 2020 2069 6e69 745f 636f 7461         init_cota
+0001d4e0: 6e67 656e 7473 203d 2069 6e69 745f 636f  ngents = init_co
+0001d4f0: 7461 6e67 656e 7473 5b30 5d0a 2020 2020  tangents[0].    
+0001d500: 7361 6665 5f6d 6170 5f66 6c61 7428 7075  safe_map_flat(pu
+0001d510: 745f 6772 6164 2c20 7472 6163 652e 6f75  t_grad, trace.ou
+0001d520: 7470 7574 2c20 696e 6974 5f63 6f74 616e  tput, init_cotan
+0001d530: 6765 6e74 7329 0a0a 2020 2020 666f 7220  gents)..    for 
+0001d540: 7379 6d62 6f6c 2069 6e20 7265 7665 7273  symbol in revers
+0001d550: 6564 286c 6973 7428 6974 6572 5f62 6f75  ed(list(iter_bou
+0001d560: 6e64 5f73 796d 626f 6c73 2874 7261 6365  nd_symbols(trace
+0001d570: 2e62 6f75 6e64 5f73 796d 626f 6c73 2929  .bound_symbols))
+0001d580: 293a 0a20 2020 2020 2020 2073 796d 626f  ):.        symbo
+0001d590: 6c5f 6f75 7470 7574 203d 2073 6571 7565  l_output = seque
+0001d5a0: 6e63 6966 7928 7379 6d62 6f6c 2e6f 7574  ncify(symbol.out
+0001d5b0: 7075 7429 0a0a 2020 2020 2020 2020 636f  put)..        co
+0001d5c0: 7461 6e67 656e 7473 203d 2074 7265 655f  tangents = tree_
+0001d5d0: 6d61 7028 6765 745f 6772 6164 2c20 7379  map(get_grad, sy
+0001d5e0: 6d62 6f6c 5f6f 7574 7075 7429 0a20 2020  mbol_output).   
+0001d5f0: 2020 2020 2023 2048 6176 696e 6720 6120       # Having a 
+0001d600: 7369 6e67 6c65 2063 6f74 616e 6765 6e74  single cotangent
+0001d610: 2069 7320 6120 636f 6d6d 6f6e 2063 6173   is a common cas
+0001d620: 652c 2073 6f20 7765 2066 6c61 7474 656e  e, so we flatten
+0001d630: 2069 740a 2020 2020 2020 2020 2320 4f74   it.        # Ot
+0001d640: 6865 7277 6973 652c 2077 6520 7769 6c6c  herwise, we will
+0001d650: 206e 6565 6420 746f 2072 6577 7269 7465   need to rewrite
+0001d660: 2074 6865 2070 756c 6c62 6163 6b20 6675   the pullback fu
+0001d670: 6e63 7469 6f6e 730a 2020 2020 2020 2020  nctions.        
+0001d680: 636f 7461 6e67 656e 7473 203d 2074 7265  cotangents = tre
+0001d690: 655f 666c 6174 7465 6e28 636f 7461 6e67  e_flatten(cotang
+0001d6a0: 656e 7473 295b 305d 0a20 2020 2020 2020  ents)[0].       
+0001d6b0: 2072 6573 6964 7561 6c73 203d 2066 6f72   residuals = for
+0001d6c0: 7761 7264 5f65 6e76 5b73 796d 626f 6c5f  ward_env[symbol_
+0001d6d0: 6f75 7470 7574 5b30 5d2e 6e61 6d65 5d2e  output[0].name].
+0001d6e0: 7265 7369 6475 616c 730a 2020 2020 2020  residuals.      
+0001d6f0: 2020 6966 2069 735f 636f 6e73 7461 6e74    if is_constant
+0001d700: 5f66 6f72 5f76 6a70 2873 796d 626f 6c29  _for_vjp(symbol)
+0001d710: 3a0a 2020 2020 2020 2020 2020 2020 2320  :.            # 
+0001d720: 5765 2063 616e 2073 6b69 7020 7468 6520  We can skip the 
+0001d730: 7075 6c6c 6261 636b 2069 6620 616c 6c20  pullback if all 
+0001d740: 7468 6520 6172 6775 6d65 6e74 7320 6172  the arguments ar
+0001d750: 6520 636f 6e73 7461 6e74 0a20 2020 2020  e constant.     
+0001d760: 2020 2020 2020 2063 6f6e 7469 6e75 650a         continue.
+0001d770: 0a20 2020 2020 2020 2069 6620 616c 6c28  .        if all(
+0001d780: 636f 7461 6e67 656e 7420 6973 204e 6f6e  cotangent is Non
+0001d790: 6520 666f 7220 636f 7461 6e67 656e 7420  e for cotangent 
+0001d7a0: 696e 2063 6f74 616e 6765 6e74 7329 3a0a  in cotangents):.
+0001d7b0: 2020 2020 2020 2020 2020 2020 2320 5765              # We
+0001d7c0: 2063 616e 2073 6b69 7020 7468 6520 7075   can skip the pu
+0001d7d0: 6c6c 6261 636b 2069 6620 7468 6520 636f  llback if the co
+0001d7e0: 7461 6e67 656e 7420 6973 204e 6f6e 650a  tangent is None.
+0001d7f0: 2020 2020 2020 2020 2020 2020 7361 6665              safe
+0001d800: 5f6d 6170 2870 7574 5f67 7261 642c 2073  _map(put_grad, s
+0001d810: 796d 626f 6c2e 6172 6773 2c20 284e 6f6e  ymbol.args, (Non
+0001d820: 652c 2920 2a20 6c65 6e28 7379 6d62 6f6c  e,) * len(symbol
+0001d830: 2e61 7267 7329 290a 2020 2020 2020 2020  .args)).        
+0001d840: 2020 2020 636f 6e74 696e 7565 0a0a 2020      continue..  
+0001d850: 2020 2020 2020 6966 2073 796d 626f 6c2e        if symbol.
+0001d860: 7379 6d2e 6964 203d 3d20 2274 6f72 6368  sym.id == "torch
+0001d870: 2e6e 6e2e 6675 6e63 7469 6f6e 616c 2e64  .nn.functional.d
+0001d880: 726f 706f 7574 2220 616e 6420 6e6f 7420  ropout" and not 
+0001d890: 7379 6d62 6f6c 2e73 7562 7379 6d62 6f6c  symbol.subsymbol
+0001d8a0: 733a 0a20 2020 2020 2020 2020 2020 2023  s:.            #
+0001d8b0: 2057 6520 6361 6e20 736b 6970 2074 6865   We can skip the
+0001d8c0: 2070 756c 6c62 6163 6b20 6966 2074 6865   pullback if the
+0001d8d0: 2064 726f 706f 7574 2070 726f 6261 6269   dropout probabi
+0001d8e0: 6c69 7479 2069 7320 302e 300a 2020 2020  lity is 0.0.    
+0001d8f0: 2020 2020 2020 2020 2320 4173 7375 6d69          # Assumi
+0001d900: 6e67 2074 6861 7420 7468 6520 6472 6f70  ng that the drop
+0001d910: 6f75 7420 7379 6d62 6f6c 2068 6173 2074  out symbol has t
+0001d920: 6865 2073 616d 6520 6f75 7470 7574 2061  he same output a
+0001d930: 6e64 2061 7267 756d 656e 740a 2020 2020  nd argument.    
+0001d940: 2020 2020 2020 2020 6173 7365 7274 2073          assert s
+0001d950: 796d 626f 6c2e 6f75 7470 7574 2e6e 616d  ymbol.output.nam
+0001d960: 6520 3d3d 2073 796d 626f 6c2e 6172 6773  e == symbol.args
+0001d970: 5b30 5d2e 6e61 6d65 2c20 2244 726f 706f  [0].name, "Dropo
+0001d980: 7574 2073 796d 626f 6c20 6861 7320 6120  ut symbol has a 
+0001d990: 6469 6666 6572 656e 7420 6f75 7470 7574  different output
+0001d9a0: 2061 6e64 2061 7267 756d 656e 7422 0a20   and argument". 
+0001d9b0: 2020 2020 2020 2020 2020 2069 6620 7379             if sy
+0001d9c0: 6d62 6f6c 2e61 7267 735b 315d 203d 3d20  mbol.args[1] == 
+0001d9d0: 302e 3020 6f72 2073 796d 626f 6c2e 6172  0.0 or symbol.ar
+0001d9e0: 6773 5b32 5d20 6973 2046 616c 7365 3a0a  gs[2] is False:.
+0001d9f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001da00: 636f 6e74 696e 7565 0a0a 2020 2020 2020  continue..      
+0001da10: 2020 6261 636b 7761 7264 203d 2062 6163    backward = bac
+0001da20: 6b77 6172 645f 696d 706c 732e 6765 7428  kward_impls.get(
+0001da30: 7379 6d62 6f6c 2e73 796d 2e69 6429 0a20  symbol.sym.id). 
+0001da40: 2020 2020 2020 2061 7567 5f66 6f72 7761         aug_forwa
+0001da50: 7264 203d 2061 7567 6d65 6e74 6564 5f66  rd = augmented_f
+0001da60: 6f72 7761 7264 5f69 6d70 6c73 2e67 6574  orward_impls.get
+0001da70: 2873 796d 626f 6c2e 7379 6d2e 6964 290a  (symbol.sym.id).
+0001da80: 0a20 2020 2020 2020 2069 6620 5f67 6574  .        if _get
+0001da90: 5f67 7261 6466 6e5f 616e 645f 6578 6563  _gradfn_and_exec
+0001daa0: 7574 6f72 2873 796d 626f 6c29 5b30 5d20  utor(symbol)[0] 
+0001dab0: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
+0001dac0: 2020 2020 2020 2020 2061 7567 5f66 6f72           aug_for
+0001dad0: 7761 7264 2c20 6261 636b 7761 7264 203d  ward, backward =
+0001dae0: 206d 616b 655f 6175 675f 666f 7277 6172   make_aug_forwar
+0001daf0: 645f 616e 645f 6261 636b 7761 7264 2873  d_and_backward(s
+0001db00: 796d 626f 6c29 0a0a 2020 2020 2020 2020  ymbol)..        
+0001db10: 6966 2062 6163 6b77 6172 6420 6973 204e  if backward is N
+0001db20: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+0001db30: 2069 6620 6c65 6e28 7379 6d62 6f6c 2e73   if len(symbol.s
+0001db40: 7562 7379 6d62 6f6c 7329 203e 2030 2061  ubsymbols) > 0 a
+0001db50: 6e64 206e 6f74 2069 7369 6e73 7461 6e63  nd not isinstanc
+0001db60: 6528 7379 6d62 6f6c 2e73 796d 2e69 642c  e(symbol.sym.id,
+0001db70: 2070 7269 6d73 2e50 7269 6d49 4473 293a   prims.PrimIDs):
+0001db80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001db90: 2023 2057 6520 636f 756c 6420 6e6f 7420   # We could not 
+0001dba0: 6669 6e64 2061 2062 6163 6b77 6172 6420  find a backward 
+0001dbb0: 666f 7220 7468 6973 2073 796d 626f 6c2c  for this symbol,
+0001dbc0: 2073 6f20 7765 2074 7279 2074 6f20 6465   so we try to de
+0001dbd0: 636f 6d70 6f73 6520 6974 0a20 2020 2020  compose it.     
+0001dbe0: 2020 2020 2020 2020 2020 2062 6163 6b77             backw
+0001dbf0: 6172 6420 3d20 7061 7274 6961 6c28 6465  ard = partial(de
+0001dc00: 636f 6d70 6f73 6564 5f66 6e5f 6261 636b  composed_fn_back
+0001dc10: 7761 7264 5f72 756c 652c 2073 796d 626f  ward_rule, symbo
+0001dc20: 6c2e 7379 6d29 0a20 2020 2020 2020 2020  l.sym).         
+0001dc30: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0001dc40: 2020 2020 2020 2020 2023 2057 6520 636f           # We co
+0001dc50: 756c 6420 6e6f 7420 6669 6e64 2061 2062  uld not find a b
+0001dc60: 6163 6b77 6172 6420 666f 7220 7468 6973  ackward for this
+0001dc70: 2073 796d 626f 6c20 616e 6420 7765 2063   symbol and we c
+0001dc80: 6f75 6c64 206e 6f74 2064 6563 6f6d 706f  ould not decompo
+0001dc90: 7365 2069 740a 2020 2020 2020 2020 2020  se it.          
+0001dca0: 2020 2020 2020 7261 6973 6520 4e6f 7449        raise NotI
+0001dcb0: 6d70 6c65 6d65 6e74 6564 4572 726f 7228  mplementedError(
+0001dcc0: 6622 4261 636b 7761 7264 2066 6f72 207b  f"Backward for {
+0001dcd0: 7379 6d62 6f6c 2e73 796d 2e69 647d 2069  symbol.sym.id} i
+0001dce0: 7320 6e6f 7420 696d 706c 656d 656e 7465  s not implemente
+0001dcf0: 6422 290a 0a20 2020 2020 2020 2072 6573  d")..        res
+0001dd00: 756c 7420 3d20 6261 636b 7761 7264 282a  ult = backward(*
+0001dd10: 7265 7369 6475 616c 732c 202a 636f 7461  residuals, *cota
+0001dd20: 6e67 656e 7473 290a 2020 2020 2020 2020  ngents).        
+0001dd30: 6966 2069 7369 6e73 7461 6e63 6528 7265  if isinstance(re
+0001dd40: 7375 6c74 2c20 6469 6374 293a 0a20 2020  sult, dict):.   
+0001dd50: 2020 2020 2020 2020 2023 2049 6620 7468           # If th
+0001dd60: 6520 6261 636b 7761 7264 2072 6574 7572  e backward retur
+0001dd70: 6e73 2061 2064 6963 742c 2077 6520 6173  ns a dict, we as
+0001dd80: 7375 6d65 2074 6861 7420 6974 2069 7320  sume that it is 
+0001dd90: 6120 6469 6374 206f 660a 2020 2020 2020  a dict of.      
+0001dda0: 2020 2020 2020 2320 666f 7277 6172 6420        # forward 
+0001ddb0: 6172 6775 6d65 6e74 7320 746f 2074 6865  arguments to the
+0001ddc0: 2063 6f72 7265 7370 6f6e 6469 6e67 0a20   corresponding. 
+0001ddd0: 2020 2020 2020 2020 2020 2023 2067 7261             # gra
+0001dde0: 6469 656e 7473 2f63 6f74 616e 6765 6e74  dients/cotangent
+0001ddf0: 732f 6164 6a6f 696e 7473 2f73 656e 7369  s/adjoints/sensi
+0001de00: 7469 7669 7469 6573 2e0a 2020 2020 2020  tivities..      
+0001de10: 2020 2020 2020 7573 6564 5f6e 616d 6573        used_names
+0001de20: 203d 2073 6574 2829 0a20 2020 2020 2020   = set().       
+0001de30: 2020 2020 2066 6f72 2069 2c20 286b 2c20       for i, (k, 
+0001de40: 7629 2069 6e20 656e 756d 6572 6174 6528  v) in enumerate(
+0001de50: 696e 7370 6563 742e 7369 676e 6174 7572  inspect.signatur
+0001de60: 6528 6175 675f 666f 7277 6172 6429 2e70  e(aug_forward).p
+0001de70: 6172 616d 6574 6572 732e 6974 656d 7328  arameters.items(
+0001de80: 2929 3a0a 2020 2020 2020 2020 2020 2020  )):.            
+0001de90: 2020 2020 6966 2076 2e6b 696e 6420 696e      if v.kind in
+0001dea0: 2028 696e 7370 6563 742e 5061 7261 6d65   (inspect.Parame
+0001deb0: 7465 722e 504f 5349 5449 4f4e 414c 5f4f  ter.POSITIONAL_O
+0001dec0: 4e4c 592c 2069 6e73 7065 6374 2e50 6172  NLY, inspect.Par
+0001ded0: 616d 6574 6572 2e50 4f53 4954 494f 4e41  ameter.POSITIONA
+0001dee0: 4c5f 4f52 5f4b 4559 574f 5244 293a 0a20  L_OR_KEYWORD):. 
+0001def0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001df00: 2020 2070 7574 5f67 7261 6428 7379 6d62     put_grad(symb
+0001df10: 6f6c 2e61 7267 735b 695d 2c20 7265 7375  ol.args[i], resu
+0001df20: 6c74 2e67 6574 286b 2c20 4e6f 6e65 2929  lt.get(k, None))
 0001df30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001df40: 2020 2020 2069 6620 6b20 6e6f 7420 696e       if k not in
-0001df50: 2075 7365 645f 6e61 6d65 733a 0a20 2020   used_names:.   
-0001df60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001df70: 2020 2020 2070 7574 5f67 7261 6428 7379       put_grad(sy
-0001df80: 6d62 6f6c 2e61 7267 735b 695d 2c20 7265  mbol.args[i], re
-0001df90: 7375 6c74 2e67 6574 286b 2c20 4e6f 6e65  sult.get(k, None
-0001dfa0: 2929 0a20 2020 2020 2020 2020 2020 2063  )).            c
-0001dfb0: 6f6e 7469 6e75 650a 0a20 2020 2020 2020  ontinue..       
-0001dfc0: 2069 6620 6e6f 7420 6973 696e 7374 616e   if not isinstan
-0001dfd0: 6365 2872 6573 756c 742c 2053 6571 7565  ce(result, Seque
-0001dfe0: 6e63 6529 3a0a 2020 2020 2020 2020 2020  nce):.          
-0001dff0: 2020 7265 7375 6c74 203d 2028 7265 7375    result = (resu
-0001e000: 6c74 2c29 0a0a 2020 2020 2020 2020 6465  lt,)..        de
-0001e010: 6620 6973 5f64 6966 6665 7265 6e74 6961  f is_differentia
-0001e020: 626c 6528 6172 6729 3a0a 2020 2020 2020  ble(arg):.      
-0001e030: 2020 2020 2020 6d61 7463 6820 6172 673a        match arg:
-0001e040: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001e050: 2063 6173 6520 5465 6e73 6f72 5072 6f78   case TensorProx
-0001e060: 7928 293a 0a20 2020 2020 2020 2020 2020  y():.           
-0001e070: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0001e080: 6474 7970 6573 2e69 735f 696e 6578 6163  dtypes.is_inexac
-0001e090: 745f 6474 7970 6528 6172 672e 6474 7970  t_dtype(arg.dtyp
-0001e0a0: 6529 0a20 2020 2020 2020 2020 2020 2020  e).             
-0001e0b0: 2020 2063 6173 6520 5365 7175 656e 6365     case Sequence
-0001e0c0: 2829 3a0a 2020 2020 2020 2020 2020 2020  ():.            
-0001e0d0: 2020 2020 2020 2020 7265 7475 726e 2061          return a
-0001e0e0: 7267 2061 6e64 2061 6c6c 2869 7369 6e73  rg and all(isins
-0001e0f0: 7461 6e63 6528 782c 2054 656e 736f 7250  tance(x, TensorP
-0001e100: 726f 7879 2920 616e 6420 6474 7970 6573  roxy) and dtypes
-0001e110: 2e69 735f 696e 6578 6163 745f 6474 7970  .is_inexact_dtyp
-0001e120: 6528 782e 6474 7970 6529 2066 6f72 2078  e(x.dtype) for x
-0001e130: 2069 6e20 6172 6729 0a20 2020 2020 2020   in arg).       
-0001e140: 2020 2020 2020 2020 2063 6173 6520 5f3a           case _:
-0001e150: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001e160: 2020 2020 2072 6574 7572 6e20 4661 6c73       return Fals
-0001e170: 650a 0a20 2020 2020 2020 2069 6620 6c65  e..        if le
-0001e180: 6e28 7379 6d62 6f6c 2e61 7267 7329 2021  n(symbol.args) !
-0001e190: 3d20 286f 7269 675f 7265 735f 6c65 6e20  = (orig_res_len 
-0001e1a0: 3a3d 206c 656e 2872 6573 756c 7429 293a  := len(result)):
-0001e1b0: 0a20 2020 2020 2020 2020 2020 2063 6865  .            che
-0001e1c0: 636b 280a 2020 2020 2020 2020 2020 2020  ck(.            
-0001e1d0: 2020 2020 6f72 6967 5f72 6573 5f6c 656e      orig_res_len
-0001e1e0: 203c 3d20 6c65 6e28 7379 6d62 6f6c 2e61   <= len(symbol.a
-0001e1f0: 7267 7329 2c0a 2020 2020 2020 2020 2020  rgs),.          
-0001e200: 2020 2020 2020 6c61 6d62 6461 3a20 6622        lambda: f"
-0001e210: 4261 636b 7761 7264 2066 6f72 207b 7379  Backward for {sy
-0001e220: 6d62 6f6c 2e73 796d 2e69 647d 2072 6574  mbol.sym.id} ret
-0001e230: 7572 6e65 6420 7b6f 7269 675f 7265 735f  urned {orig_res_
-0001e240: 6c65 6e7d 2076 616c 7565 732c 2022 0a20  len} values, ". 
-0001e250: 2020 2020 2020 2020 2020 2020 2020 202b                 +
-0001e260: 2066 2262 7574 2065 7870 6563 7465 6420   f"but expected 
-0001e270: 6174 206d 6f73 7420 7b6c 656e 2873 796d  at most {len(sym
-0001e280: 626f 6c2e 6172 6773 297d 222c 0a20 2020  bol.args)}",.   
-0001e290: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
-0001e2a0: 2020 2020 2020 2023 2041 7373 756d 696e         # Assumin
-0001e2b0: 6720 7468 6174 2074 6865 206e 6f6e 2d64  g that the non-d
-0001e2c0: 6966 6665 7265 6e74 6961 626c 6520 6172  ifferentiable ar
-0001e2d0: 6775 6d65 6e74 7320 7765 7265 2064 726f  guments were dro
-0001e2e0: 7070 6564 2066 726f 6d0a 2020 2020 2020  pped from.      
-0001e2f0: 2020 2020 2020 2320 7468 6520 6261 636b        # the back
-0001e300: 7761 7264 2066 756e 6374 696f 6e2c 2077  ward function, w
-0001e310: 6520 6172 6520 676f 696e 6720 746f 2061  e are going to a
-0001e320: 7070 656e 6420 4e6f 6e65 2074 6f20 7468  ppend None to th
-0001e330: 6520 7265 7375 6c74 0a20 2020 2020 2020  e result.       
-0001e340: 2020 2020 2023 2074 6f20 6d61 7463 6820       # to match 
-0001e350: 7468 6520 6e75 6d62 6572 206f 6620 6172  the number of ar
-0001e360: 6775 6d65 6e74 732e 2041 6c74 6572 6e61  guments. Alterna
-0001e370: 7469 7665 6c79 2c20 7765 2063 6f75 6c64  tively, we could
-0001e380: 206a 7573 740a 2020 2020 2020 2020 2020   just.          
-0001e390: 2020 2320 6861 7665 2061 2066 6f72 2d6c    # have a for-l
-0001e3a0: 6f6f 7020 7769 7468 2061 2063 6f6e 6469  oop with a condi
-0001e3b0: 7469 6f6e 616c 2077 6865 6e20 7772 6974  tional when writ
-0001e3c0: 696e 6720 746f 2074 6865 0a20 2020 2020  ing to the.     
-0001e3d0: 2020 2020 2020 2023 2065 6e76 6972 6f6e         # environ
-0001e3e0: 6d65 6e74 2e0a 0a20 2020 2020 2020 2020  ment...         
-0001e3f0: 2020 2069 7465 725f 7265 7375 6c74 203d     iter_result =
-0001e400: 2069 7465 7228 7265 7375 6c74 290a 2020   iter(result).  
-0001e410: 2020 2020 2020 2020 2020 6e5f 6469 6666            n_diff
-0001e420: 6572 656e 7469 6162 6c65 5f61 7267 7320  erentiable_args 
-0001e430: 3d20 7375 6d28 626f 6f6c 2869 735f 6469  = sum(bool(is_di
-0001e440: 6666 6572 656e 7469 6162 6c65 2861 7267  fferentiable(arg
-0001e450: 2929 2066 6f72 2061 7267 2069 6e20 7379  )) for arg in sy
-0001e460: 6d62 6f6c 2e61 7267 7329 0a20 2020 2020  mbol.args).     
-0001e470: 2020 2020 2020 2063 6865 636b 280a 2020         check(.  
-0001e480: 2020 2020 2020 2020 2020 2020 2020 6e5f                n_
-0001e490: 6469 6666 6572 656e 7469 6162 6c65 5f61  differentiable_a
-0001e4a0: 7267 7320 3c3d 206f 7269 675f 7265 735f  rgs <= orig_res_
-0001e4b0: 6c65 6e2c 0a20 2020 2020 2020 2020 2020  len,.           
-0001e4c0: 2020 2020 206c 616d 6264 613a 2066 2242       lambda: f"B
-0001e4d0: 6163 6b77 6172 6420 666f 7220 7b73 796d  ackward for {sym
-0001e4e0: 626f 6c2e 7379 6d2e 6964 7d20 7265 7475  bol.sym.id} retu
-0001e4f0: 726e 6564 207b 6f72 6967 5f72 6573 5f6c  rned {orig_res_l
-0001e500: 656e 7d20 7661 6c75 6528 7329 2c20 220a  en} value(s), ".
-0001e510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001e520: 2b20 6622 6275 7420 6578 7065 6374 6564  + f"but expected
-0001e530: 207b 6e5f 6469 6666 6572 656e 7469 6162   {n_differentiab
-0001e540: 6c65 5f61 7267 737d 222c 0a20 2020 2020  le_args}",.     
-0001e550: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
-0001e560: 2020 2020 2020 7265 7375 6c74 203d 2074        result = t
-0001e570: 7570 6c65 286e 6578 7428 6974 6572 5f72  uple(next(iter_r
-0001e580: 6573 756c 7429 2069 6620 6973 5f64 6966  esult) if is_dif
-0001e590: 6665 7265 6e74 6961 626c 6528 6172 6729  ferentiable(arg)
-0001e5a0: 2065 6c73 6520 4e6f 6e65 2066 6f72 2061   else None for a
-0001e5b0: 7267 2069 6e20 7379 6d62 6f6c 2e61 7267  rg in symbol.arg
-0001e5c0: 7329 0a0a 2020 2020 2020 2020 2320 5365  s)..        # Se
-0001e5d0: 6520 2242 6163 6b77 6172 6420 696d 706c  e "Backward impl
-0001e5e0: 2066 6f72 206f 7073 206f 6620 7468 6520   for ops of the 
-0001e5f0: 7479 7065 2053 6571 7565 6e63 655b 5465  type Sequence[Te
-0001e600: 6e73 6f72 5072 6f78 795d 2c20 2e2e 2e20  nsorProxy], ... 
-0001e610: 2d3e 202e 2e2e 2072 6573 756c 7473 2069  -> ... results i
-0001e620: 6e20 4e6f 6e65 2067 7261 6473 2e22 0a20  n None grads.". 
-0001e630: 2020 2020 2020 2023 2054 6869 7320 6973         # This is
-0001e640: 2061 2074 656d 706f 7261 7279 2077 6f72   a temporary wor
-0001e650: 6b61 726f 756e 642e 0a20 2020 2020 2020  karound..       
-0001e660: 2069 6620 7379 6d62 6f6c 2e73 796d 2e69   if symbol.sym.i
-0001e670: 6420 696e 2028 7072 696d 732e 5072 696d  d in (prims.Prim
-0001e680: 4944 732e 4341 542c 2022 746f 7263 682e  IDs.CAT, "torch.
-0001e690: 6361 7422 2c20 2274 6f72 6368 2e73 7461  cat", "torch.sta
-0001e6a0: 636b 2229 3a0a 2020 2020 2020 2020 2020  ck"):.          
-0001e6b0: 2020 7361 6665 5f6d 6170 5f66 6c61 7428    safe_map_flat(
-0001e6c0: 7075 745f 6772 6164 2c20 7379 6d62 6f6c  put_grad, symbol
-0001e6d0: 2e61 7267 732c 2072 6573 756c 7429 0a20  .args, result). 
-0001e6e0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-0001e6f0: 2020 2020 2020 2020 2073 6166 655f 6d61           safe_ma
-0001e700: 7028 7075 745f 6772 6164 2c20 7379 6d62  p(put_grad, symb
-0001e710: 6f6c 2e61 7267 732c 2072 6573 756c 7429  ol.args, result)
-0001e720: 0a0a 2020 2020 6465 6620 6765 745f 696e  ..    def get_in
-0001e730: 6578 6163 745f 6474 7970 655f 6f72 5f6e  exact_dtype_or_n
-0001e740: 6f6e 6528 7829 3a0a 2020 2020 2020 2020  one(x):.        
-0001e750: 6966 2069 7369 6e73 7461 6e63 6528 782c  if isinstance(x,
-0001e760: 2028 5465 6e73 6f72 5072 6f78 792c 2046   (TensorProxy, F
-0001e770: 7574 7572 6554 656e 736f 7250 726f 7879  utureTensorProxy
-0001e780: 2929 2061 6e64 2064 7479 7065 732e 6973  )) and dtypes.is
-0001e790: 5f69 6e65 7861 6374 5f64 7479 7065 2878  _inexact_dtype(x
-0001e7a0: 2e64 7479 7065 293a 0a20 2020 2020 2020  .dtype):.       
-0001e7b0: 2020 2020 2072 6574 7572 6e20 780a 2020       return x.  
-0001e7c0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-0001e7d0: 2020 2020 2020 2020 7265 7475 726e 204e          return N
-0001e7e0: 6f6e 650a 0a20 2020 2067 6172 6773 203d  one..    gargs =
-0001e7f0: 2074 7265 655f 6d61 7028 6765 745f 6772   tree_map(get_gr
-0001e800: 6164 2c20 7475 706c 6528 7472 6163 652e  ad, tuple(trace.
-0001e810: 6172 6773 2929 0a20 2020 2067 6b77 6172  args)).    gkwar
-0001e820: 6773 203d 2074 7265 655f 6d61 7028 6765  gs = tree_map(ge
-0001e830: 745f 6772 6164 2c20 7472 6163 652e 6b77  t_grad, trace.kw
-0001e840: 6172 6773 290a 2020 2020 676b 7761 7267  args).    gkwarg
-0001e850: 7320 3d20 7b6b 3a20 7620 666f 7220 6b2c  s = {k: v for k,
-0001e860: 2076 2069 6e20 676b 7761 7267 732e 6974   v in gkwargs.it
-0001e870: 656d 7328 2920 6966 2076 2069 7320 6e6f  ems() if v is no
-0001e880: 7420 4e6f 6e65 7d0a 2020 2020 6761 7267  t None}.    garg
-0001e890: 732c 2067 6b77 6172 6773 203d 2074 7265  s, gkwargs = tre
-0001e8a0: 655f 6d61 7028 6765 745f 696e 6578 6163  e_map(get_inexac
-0001e8b0: 745f 6474 7970 655f 6f72 5f6e 6f6e 652c  t_dtype_or_none,
-0001e8c0: 2028 6761 7267 732c 2067 6b77 6172 6773   (gargs, gkwargs
-0001e8d0: 2929 0a20 2020 2072 6574 7572 6e20 6761  )).    return ga
-0001e8e0: 7267 7320 2b20 2867 6b77 6172 6773 2c29  rgs + (gkwargs,)
-0001e8f0: 2069 6620 6c65 6e28 676b 7761 7267 7329   if len(gkwargs)
-0001e900: 2021 3d20 3020 656c 7365 2067 6172 6773   != 0 else gargs
-0001e910: 0a0a 0a64 6566 2076 6a70 5f63 616c 6c5f  ...def vjp_call_
-0001e920: 6d65 7461 6675 6e63 2864 6574 6163 6865  metafunc(detache
-0001e930: 643a 2062 6f6f 6c2c 2070 7269 6d61 6c73  d: bool, primals
-0001e940: 2c20 636f 7461 6e67 656e 7473 2c20 7472  , cotangents, tr
-0001e950: 6163 653a 2054 7261 6365 2c20 2a2a 6b77  ace: Trace, **kw
-0001e960: 6172 6773 293a 0a20 2020 2023 2041 7373  args):.    # Ass
-0001e970: 756d 696e 6720 7072 696d 616c 7320 6973  uming primals is
-0001e980: 2066 6c61 740a 0a20 2020 2069 6620 6e6f   flat..    if no
-0001e990: 7420 6973 696e 7374 616e 6365 2870 7269  t isinstance(pri
-0001e9a0: 6d61 6c73 2c20 5365 7175 656e 6365 293a  mals, Sequence):
-0001e9b0: 0a20 2020 2020 2020 2070 7269 6d61 6c73  .        primals
-0001e9c0: 203d 2028 7072 696d 616c 732c 290a 0a20   = (primals,).. 
-0001e9d0: 2020 2063 7478 203d 2064 6574 6163 6865     ctx = detache
-0001e9e0: 645f 7472 6163 6528 2920 6966 2064 6574  d_trace() if det
-0001e9f0: 6163 6865 6420 656c 7365 206e 756c 6c63  ached else nullc
-0001ea00: 6f6e 7465 7874 2829 0a20 2020 2077 6974  ontext().    wit
-0001ea10: 6820 6374 783a 0a20 2020 2020 2020 2072  h ctx:.        r
-0001ea20: 6573 756c 742c 2065 6e76 203d 2061 7567  esult, env = aug
-0001ea30: 6d65 6e74 6564 5f66 6f72 7761 7264 5f70  mented_forward_p
-0001ea40: 6173 7328 2a70 7269 6d61 6c73 2c20 7472  ass(*primals, tr
-0001ea50: 6163 653d 7472 6163 652c 202a 2a6b 7761  ace=trace, **kwa
-0001ea60: 7267 7329 0a20 2020 2020 2020 2063 6865  rgs).        che
-0001ea70: 636b 280a 2020 2020 2020 2020 2020 2020  ck(.            
-0001ea80: 6c65 6e28 7265 7375 6c74 2920 3d3d 206c  len(result) == l
-0001ea90: 656e 2863 6f74 616e 6765 6e74 7329 2069  en(cotangents) i
-0001eaa0: 6620 6973 696e 7374 616e 6365 2872 6573  f isinstance(res
-0001eab0: 756c 742c 2053 6571 7565 6e63 6529 2065  ult, Sequence) e
-0001eac0: 6c73 6520 5472 7565 2c0a 2020 2020 2020  lse True,.      
-0001ead0: 2020 2020 2020 6c61 6d62 6461 3a20 6622        lambda: f"
-0001eae0: 4578 7065 6374 6564 2063 6f74 616e 6765  Expected cotange
-0001eaf0: 6e74 7320 746f 2062 6520 6120 7365 7175  nts to be a sequ
-0001eb00: 656e 6365 206f 6620 6c65 6e67 7468 207b  ence of length {
-0001eb10: 6c65 6e28 7265 7375 6c74 297d 2c20 676f  len(result)}, go
-0001eb20: 7420 6120 7365 7175 656e 6365 206f 6620  t a sequence of 
-0001eb30: 6c65 6e67 7468 207b 6c65 6e28 636f 7461  length {len(cota
-0001eb40: 6e67 656e 7473 297d 222c 0a20 2020 2020  ngents)}",.     
-0001eb50: 2020 2029 0a20 2020 2020 2020 2072 6574     ).        ret
-0001eb60: 7572 6e20 7265 7375 6c74 2c20 6261 636b  urn result, back
-0001eb70: 7761 7264 5f70 6173 7328 656e 762c 2074  ward_pass(env, t
-0001eb80: 7261 6365 2c20 636f 7461 6e67 656e 7473  race, cotangents
-0001eb90: 290a 0a0a 2320 544f 444f 3a20 4361 6e27  )...# TODO: Can'
-0001eba0: 7420 7573 6520 6120 5379 6d62 6f6c 2068  t use a Symbol h
-0001ebb0: 6572 6520 6265 6361 7573 6520 6d69 7865  ere because mixe
-0001ebc0: 6420 6578 6563 7574 6f72 2073 7962 7379  d executor sybsy
-0001ebd0: 6d62 6f6c 7320 7365 656d 2074 6f20 6265  mbols seem to be
-0001ebe0: 0a23 2075 6e73 7570 706f 7274 6564 2e20  .# unsupported. 
-0001ebf0: 5365 6520 6973 7375 6520 2243 6f75 6c64  See issue "Could
-0001ec00: 206e 6f74 2066 696e 6420 616e 2065 7865   not find an exe
-0001ec10: 6375 746f 7220 666f 7220 626f 756e 6420  cutor for bound 
-0001ec20: 7379 6d62 6f6c 2077 6865 6e20 6974 7320  symbol when its 
-0001ec30: 7375 6273 796d 626f 6c73 0a23 2061 7265  subsymbols.# are
-0001ec40: 206e 6f74 2066 756c 6c79 2073 7570 706f   not fully suppo
-0001ec50: 7274 6564 2062 7920 6120 7369 6e67 6c65  rted by a single
-0001ec60: 2065 7865 6375 746f 7222 0a76 6a70 5f63   executor".vjp_c
-0001ec70: 616c 6c20 3d20 7061 7274 6961 6c28 0a20  all = partial(. 
-0001ec80: 2020 2076 6a70 5f63 616c 6c5f 6d65 7461     vjp_call_meta
-0001ec90: 6675 6e63 2c20 4661 6c73 650a 2920 2023  func, False.)  #
-0001eca0: 2053 796d 626f 6c28 6964 3d54 7261 6e73   Symbol(id=Trans
-0001ecb0: 666f 726d 732e 566a 704f 702c 206e 616d  forms.VjpOp, nam
-0001ecc0: 653d 2276 6a70 5f63 616c 6c22 2c20 6d65  e="vjp_call", me
-0001ecd0: 7461 3d70 6172 7469 616c 2876 6a70 5f63  ta=partial(vjp_c
-0001ece0: 616c 6c5f 6d65 7461 6675 6e63 2c20 4661  all_metafunc, Fa
-0001ecf0: 6c73 6529 290a 0a0a 6465 6620 766a 7028  lse))...def vjp(
-0001ed00: 6675 6e63 293a 0a20 2020 2022 2222 436f  func):.    """Co
-0001ed10: 6d70 7574 6573 2074 6865 2056 4a50 206f  mputes the VJP o
-0001ed20: 6620 6120 6675 6e63 7469 6f6e 2e0a 0a20  f a function... 
-0001ed30: 2020 2041 7267 733a 0a20 2020 2020 2020     Args:.       
-0001ed40: 2066 756e 6320 2843 616c 6c61 626c 6529   func (Callable)
-0001ed50: 3a20 4675 6e63 7469 6f6e 2074 6f20 6265  : Function to be
-0001ed60: 2064 6966 6665 7265 6e74 6961 7465 642e   differentiated.
-0001ed70: 0a20 2020 2022 2222 0a0a 2020 2020 6465  .    """..    de
-0001ed80: 6620 5f76 6a70 2870 7269 6d61 6c73 2c20  f _vjp(primals, 
-0001ed90: 636f 7461 6e67 656e 7473 2c20 2a2a 6b77  cotangents, **kw
-0001eda0: 6172 6773 293a 0a20 2020 2020 2020 2066  args):.        f
-0001edb0: 6c61 745f 6675 6e63 2c20 666c 6174 5f61  lat_func, flat_a
-0001edc0: 7267 732c 2073 7065 6320 3d20 666c 6174  rgs, spec = flat
-0001edd0: 7465 6e5f 6675 6e63 2866 756e 632c 2070  ten_func(func, p
-0001ede0: 7269 6d61 6c73 2c20 6b77 6172 6773 290a  rimals, kwargs).
-0001edf0: 2020 2020 2020 2020 7472 6163 6520 3d20          trace = 
-0001ee00: 636f 6e73 7472 7563 745f 7472 6163 6528  construct_trace(
-0001ee10: 2928 666c 6174 5f66 756e 632c 202a 666c  )(flat_func, *fl
-0001ee20: 6174 5f61 7267 7329 0a20 2020 2020 2020  at_args).       
-0001ee30: 2072 6573 756c 742c 2076 6a70 5f72 6573   result, vjp_res
-0001ee40: 756c 7420 3d20 766a 705f 6361 6c6c 2866  ult = vjp_call(f
-0001ee50: 6c61 745f 6172 6773 2c20 636f 7461 6e67  lat_args, cotang
-0001ee60: 656e 7473 2c20 7472 6163 653d 7472 6163  ents, trace=trac
-0001ee70: 6529 0a20 2020 2020 2020 2067 7072 696d  e).        gprim
-0001ee80: 616c 732c 2067 6b77 6172 6773 203d 2074  als, gkwargs = t
-0001ee90: 7265 655f 756e 666c 6174 7465 6e28 766a  ree_unflatten(vj
-0001eea0: 705f 7265 7375 6c74 2c20 7370 6563 290a  p_result, spec).
-0001eeb0: 2020 2020 2020 2020 6772 6164 7320 3d20          grads = 
-0001eec0: 6770 7269 6d61 6c73 202b 2028 676b 7761  gprimals + (gkwa
-0001eed0: 7267 732c 2920 6966 206c 656e 2867 6b77  rgs,) if len(gkw
-0001eee0: 6172 6773 2920 213d 2030 2065 6c73 6520  args) != 0 else 
-0001eef0: 6770 7269 6d61 6c73 0a20 2020 2020 2020  gprimals.       
-0001ef00: 2072 6574 7572 6e20 7265 7375 6c74 2c20   return result, 
-0001ef10: 6772 6164 730a 0a20 2020 2072 6574 7572  grads..    retur
-0001ef20: 6e20 5f76 6a70 0a0a 0a64 6566 2076 616c  n _vjp...def val
-0001ef30: 7565 5f61 6e64 5f67 7261 6428 6675 6e63  ue_and_grad(func
-0001ef40: 293a 0a20 2020 2022 2222 436f 6d70 7574  ):.    """Comput
-0001ef50: 6573 2074 6865 2076 616c 7565 2061 6e64  es the value and
-0001ef60: 2067 7261 6469 656e 7420 6f66 2061 2066   gradient of a f
-0001ef70: 756e 6374 696f 6e2e 0a0a 2020 2020 5468  unction...    Th
-0001ef80: 6973 2069 7320 6120 636f 6e76 656e 6965  is is a convenie
-0001ef90: 6e63 6520 6675 6e63 7469 6f6e 2074 6861  nce function tha
-0001efa0: 7420 636f 6d62 696e 6573 2074 6865 2066  t combines the f
-0001efb0: 756e 6374 696f 6e61 6c69 7479 206f 660a  unctionality of.
-0001efc0: 2020 2020 6076 6a70 5f63 616c 6c60 2077      `vjp_call` w
-0001efd0: 6974 6820 696d 706c 6963 6974 2069 6e69  ith implicit ini
-0001efe0: 7469 616c 697a 6174 696f 6e20 6f66 2074  tialization of t
-0001eff0: 6865 2063 6f74 616e 6765 6e74 2074 6f20  he cotangent to 
-0001f000: 312e 0a0a 2020 2020 4172 6773 3a0a 2020  1...    Args:.  
-0001f010: 2020 2020 2020 6675 6e63 2028 4361 6c6c        func (Call
-0001f020: 6162 6c65 293a 2046 756e 6374 696f 6e20  able): Function 
-0001f030: 746f 2062 6520 6469 6666 6572 656e 7469  to be differenti
-0001f040: 6174 6564 2e0a 2020 2020 2222 220a 0a20  ated..    """.. 
-0001f050: 2020 2064 6566 206f 6e65 735f 6c69 6b65     def ones_like
-0001f060: 2878 293a 0a20 2020 2020 2020 2069 6620  (x):.        if 
-0001f070: 6973 696e 7374 616e 6365 2878 2c20 5465  isinstance(x, Te
-0001f080: 6e73 6f72 5072 6f78 7929 3a0a 2020 2020  nsorProxy):.    
-0001f090: 2020 2020 2020 2020 7265 7475 726e 2066          return f
-0001f0a0: 756c 6c5f 6c69 6b65 2878 2c20 6669 6c6c  ull_like(x, fill
-0001f0b0: 5f76 616c 7565 3d31 290a 2020 2020 2020  _value=1).      
-0001f0c0: 2020 656c 6966 2069 7369 6e73 7461 6e63    elif isinstanc
-0001f0d0: 6528 782c 204e 756d 6265 7250 726f 7879  e(x, NumberProxy
-0001f0e0: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
-0001f0f0: 6574 7572 6e20 7479 7065 2878 2e76 616c  eturn type(x.val
-0001f100: 7565 2928 3129 0a20 2020 2020 2020 2065  ue)(1).        e
-0001f110: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-0001f120: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-0001f130: 7228 6622 6f6e 6573 5f6c 696b 6520 696e  r(f"ones_like in
-0001f140: 7369 6465 2076 616c 7565 5f61 6e64 5f67  side value_and_g
-0001f150: 7261 6420 676f 7420 616e 2075 6e73 7570  rad got an unsup
-0001f160: 706f 7274 6564 2074 7970 6520 7b74 7970  ported type {typ
-0001f170: 6528 7829 7d22 290a 0a20 2020 2064 6566  e(x)}")..    def
-0001f180: 205f 7661 6c75 655f 616e 645f 6772 6164   _value_and_grad
-0001f190: 282a 6172 6773 2c20 2a2a 6b77 6172 6773  (*args, **kwargs
-0001f1a0: 293a 0a20 2020 2020 2020 2074 7261 6365  ):.        trace
-0001f1b0: 203d 2063 6f6e 7374 7275 6374 5f74 7261   = construct_tra
-0001f1c0: 6365 2829 2866 756e 632c 202a 6172 6773  ce()(func, *args
-0001f1d0: 2c20 2a2a 6b77 6172 6773 290a 2020 2020  , **kwargs).    
-0001f1e0: 2020 2020 636f 7461 6e67 656e 7473 203d      cotangents =
-0001f1f0: 2074 7265 655f 6d61 7028 6c61 6d62 6461   tree_map(lambda
-0001f200: 2076 3a20 6f6e 6573 5f6c 696b 6528 7629   v: ones_like(v)
-0001f210: 2c20 7472 6163 652e 6f75 7470 7574 290a  , trace.output).
-0001f220: 2020 2020 2020 2020 7265 7475 726e 2076          return v
-0001f230: 6a70 2866 756e 6329 2861 7267 732c 2063  jp(func)(args, c
-0001f240: 6f74 616e 6765 6e74 732c 202a 2a6b 7761  otangents, **kwa
-0001f250: 7267 7329 0a0a 2020 2020 7265 7475 726e  rgs)..    return
-0001f260: 205f 7661 6c75 655f 616e 645f 6772 6164   _value_and_grad
-0001f270: 0a0a 0a46 6f72 7761 7264 4261 636b 7761  ...ForwardBackwa
-0001f280: 7264 5472 6163 6573 203d 206e 616d 6564  rdTraces = named
-0001f290: 7475 706c 6528 2246 6f72 7761 7264 4261  tuple("ForwardBa
-0001f2a0: 636b 7761 7264 5472 6163 6573 222c 205b  ckwardTraces", [
-0001f2b0: 2266 6f72 7761 7264 5f74 7261 6365 222c  "forward_trace",
-0001f2c0: 2022 6261 636b 7761 7264 5f74 7261 6365   "backward_trace
-0001f2d0: 225d 290a 0a0a 6465 6620 5f73 706c 6974  "])...def _split
-0001f2e0: 5f73 6176 6564 5f66 6f72 5f62 6163 6b77  _saved_for_backw
-0001f2f0: 6172 645f 696e 746f 5f74 656e 736f 7273  ard_into_tensors
-0001f300: 5f61 6e64 5f6f 7468 6572 280a 2020 2020  _and_other(.    
-0001f310: 7361 7665 645f 666f 725f 6261 636b 7761  saved_for_backwa
-0001f320: 7264 3a20 5365 7175 656e 6365 5b56 6172  rd: Sequence[Var
-0001f330: 6961 626c 655d 2c0a 2920 2d3e 2074 7570  iable],.) -> tup
-0001f340: 6c65 5b53 6571 7565 6e63 655b 5661 7269  le[Sequence[Vari
-0001f350: 6162 6c65 5d2c 2053 6571 7565 6e63 655b  able], Sequence[
-0001f360: 5661 7269 6162 6c65 5d5d 3a0a 2020 2020  Variable]]:.    
-0001f370: 2222 2253 706c 6974 7320 7361 7665 645f  """Splits saved_
-0001f380: 666f 725f 6261 636b 7761 7264 2069 6e74  for_backward int
-0001f390: 6f20 7465 6e73 6f72 7320 616e 6420 6f74  o tensors and ot
-0001f3a0: 6865 722e 0a0a 2020 2020 4172 6773 3a0a  her...    Args:.
-0001f3b0: 2020 2020 2020 2020 7361 7665 645f 666f          saved_fo
-0001f3c0: 725f 6261 636b 7761 7264 2028 5365 7175  r_backward (Sequ
-0001f3d0: 656e 6365 5b56 6172 6961 626c 655d 293a  ence[Variable]):
-0001f3e0: 2053 6176 6564 5f66 6f72 5f62 6163 6b77   Saved_for_backw
-0001f3f0: 6172 6420 746f 2073 706c 6974 2e0a 0a20  ard to split... 
-0001f400: 2020 2052 6574 7572 6e73 3a0a 2020 2020     Returns:.    
-0001f410: 2020 2020 7475 706c 655b 5365 7175 656e      tuple[Sequen
-0001f420: 6365 5b56 6172 6961 626c 655d 2c20 5365  ce[Variable], Se
-0001f430: 7175 656e 6365 5b56 6172 6961 626c 655d  quence[Variable]
-0001f440: 5d3a 2054 7570 6c65 206f 6620 7465 6e73  ]: Tuple of tens
-0001f450: 6f72 7320 616e 6420 6f74 6865 722e 0a20  ors and other.. 
-0001f460: 2020 2022 2222 0a20 2020 2069 735f 7465     """.    is_te
-0001f470: 6e73 6f72 203d 206c 616d 6264 6120 783a  nsor = lambda x:
-0001f480: 2069 7369 6e73 7461 6e63 6528 782c 2054   isinstance(x, T
-0001f490: 656e 736f 7250 726f 7879 290a 2020 2020  ensorProxy).    
-0001f4a0: 6f74 6865 722c 2074 656e 736f 7273 203d  other, tensors =
-0001f4b0: 2075 7469 6c73 2e70 6172 7469 7469 6f6e   utils.partition
-0001f4c0: 2869 735f 7465 6e73 6f72 2c20 7361 7665  (is_tensor, save
-0001f4d0: 645f 666f 725f 6261 636b 7761 7264 290a  d_for_backward).
-0001f4e0: 2020 2020 7265 7475 726e 2074 7570 6c65      return tuple
-0001f4f0: 2874 656e 736f 7273 292c 2074 7570 6c65  (tensors), tuple
-0001f500: 286f 7468 6572 290a 0a0a 6465 6620 5f75  (other)...def _u
-0001f510: 7064 6174 655f 666f 7277 6172 645f 7769  pdate_forward_wi
-0001f520: 7468 5f6e 6577 5f73 6176 6564 5f66 6f72  th_new_saved_for
-0001f530: 5f62 6163 6b77 6172 6428 666f 7277 6172  _backward(forwar
-0001f540: 645f 7472 6163 653a 2054 7261 6365 2c20  d_trace: Trace, 
-0001f550: 7361 7665 645f 666f 725f 6261 636b 7761  saved_for_backwa
-0001f560: 7264 3a20 5365 7175 656e 6365 5b56 6172  rd: Sequence[Var
-0001f570: 6961 626c 655d 2920 2d3e 204e 6f6e 653a  iable]) -> None:
-0001f580: 0a20 2020 2022 2222 5570 6461 7465 7320  .    """Updates 
-0001f590: 7468 6520 666f 7277 6172 6420 7472 6163  the forward trac
-0001f5a0: 6520 7769 7468 206e 6577 2073 6176 6564  e with new saved
-0001f5b0: 5f66 6f72 5f62 6163 6b77 6172 642e 0a0a  _for_backward...
-0001f5c0: 2020 2020 5468 6973 2069 7320 6e65 6365      This is nece
-0001f5d0: 7373 6172 7920 6265 6361 7573 6520 7468  ssary because th
-0001f5e0: 6520 7570 6461 7465 6420 7361 7665 645f  e updated saved_
-0001f5f0: 666f 725f 6261 636b 7761 7264 2069 7320  for_backward is 
-0001f600: 6e6f 7420 6176 6169 6c61 626c 650a 2020  not available.  
-0001f610: 2020 7768 656e 2074 6865 2066 6f72 7761    when the forwa
-0001f620: 7264 2061 6e64 2062 6163 6b77 6172 6420  rd and backward 
-0001f630: 7472 6163 6573 2061 7265 2063 6f6e 7374  traces are const
-0001f640: 7275 6374 6564 2e0a 0a20 2020 2041 7267  ructed...    Arg
-0001f650: 733a 0a20 2020 2020 2020 2066 6f72 7761  s:.        forwa
-0001f660: 7264 5f74 7261 6365 2028 5472 6163 6529  rd_trace (Trace)
-0001f670: 3a20 466f 7277 6172 6420 7472 6163 6520  : Forward trace 
-0001f680: 746f 2075 7064 6174 652e 0a20 2020 2020  to update..     
-0001f690: 2020 2073 6176 6564 5f66 6f72 5f62 6163     saved_for_bac
-0001f6a0: 6b77 6172 6420 2853 6571 7565 6e63 655b  kward (Sequence[
-0001f6b0: 5661 7269 6162 6c65 5d29 3a20 5361 7665  Variable]): Save
-0001f6c0: 645f 666f 725f 6261 636b 7761 7264 2074  d_for_backward t
-0001f6d0: 6f20 7573 6520 746f 0a20 2020 2020 2020  o use to.       
-0001f6e0: 2020 2020 2075 7064 6174 6520 7468 6520       update the 
-0001f6f0: 666f 7277 6172 6420 7472 6163 652e 0a20  forward trace.. 
-0001f700: 2020 2022 2222 0a20 2020 2073 6176 6564     """.    saved
-0001f710: 5f66 6f72 5f62 6163 6b77 6172 6420 3d20  _for_backward = 
-0001f720: 7472 6565 5f6d 6170 286c 616d 6264 6120  tree_map(lambda 
-0001f730: 783a 2078 2e76 616c 7565 2069 6620 6973  x: x.value if is
-0001f740: 696e 7374 616e 6365 2878 2c20 4e75 6d62  instance(x, Numb
-0001f750: 6572 5072 6f78 7929 2065 6c73 6520 782c  erProxy) else x,
-0001f760: 2073 6176 6564 5f66 6f72 5f62 6163 6b77   saved_for_backw
-0001f770: 6172 6429 0a20 2020 2073 6176 6564 5f74  ard).    saved_t
-0001f780: 656e 736f 7273 2c20 7361 7665 645f 6f74  ensors, saved_ot
-0001f790: 6865 7220 3d20 5f73 706c 6974 5f73 6176  her = _split_sav
-0001f7a0: 6564 5f66 6f72 5f62 6163 6b77 6172 645f  ed_for_backward_
-0001f7b0: 696e 746f 5f74 656e 736f 7273 5f61 6e64  into_tensors_and
-0001f7c0: 5f6f 7468 6572 2873 6176 6564 5f66 6f72  _other(saved_for
-0001f7d0: 5f62 6163 6b77 6172 6429 0a20 2020 2061  _backward).    a
-0001f7e0: 7373 6572 7420 666f 7277 6172 645f 7472  ssert forward_tr
-0001f7f0: 6163 652e 626f 756e 645f 7379 6d62 6f6c  ace.bound_symbol
-0001f800: 735b 2d31 5d2e 7379 6d2e 6964 203d 3d20  s[-1].sym.id == 
-0001f810: 7072 696d 732e 5072 696d 4944 732e 5245  prims.PrimIDs.RE
-0001f820: 5455 524e 0a20 2020 206e 6577 5f72 6574  TURN.    new_ret
-0001f830: 7572 6e20 3d20 2866 6f72 7761 7264 5f74  urn = (forward_t
-0001f840: 7261 6365 2e6f 7574 7075 745b 305d 2c20  race.output[0], 
-0001f850: 2873 6176 6564 5f74 656e 736f 7273 2c20  (saved_tensors, 
-0001f860: 7361 7665 645f 6f74 6865 7229 290a 2020  saved_other)).  
-0001f870: 2020 666f 7277 6172 645f 7472 6163 652e    forward_trace.
-0001f880: 626f 756e 645f 7379 6d62 6f6c 735b 2d31  bound_symbols[-1
-0001f890: 5d20 3d20 7265 706c 6163 6528 666f 7277  ] = replace(forw
-0001f8a0: 6172 645f 7472 6163 652e 626f 756e 645f  ard_trace.bound_
-0001f8b0: 7379 6d62 6f6c 735b 2d31 5d2c 2061 7267  symbols[-1], arg
-0001f8c0: 733d 6e65 775f 7265 7475 726e 290a 0a0a  s=new_return)...
-0001f8d0: 6465 6620 5f75 7064 6174 655f 6261 636b  def _update_back
-0001f8e0: 7761 7264 5f77 6974 685f 6e65 775f 7361  ward_with_new_sa
-0001f8f0: 7665 645f 666f 725f 6261 636b 7761 7264  ved_for_backward
-0001f900: 2862 6163 6b77 6172 645f 7472 6163 653a  (backward_trace:
-0001f910: 2054 7261 6365 2c20 7361 7665 645f 666f   Trace, saved_fo
-0001f920: 725f 6261 636b 7761 7264 3a20 5365 7175  r_backward: Sequ
-0001f930: 656e 6365 5b56 6172 6961 626c 655d 2920  ence[Variable]) 
-0001f940: 2d3e 204e 6f6e 653a 0a20 2020 2022 2222  -> None:.    """
-0001f950: 5570 6461 7465 7320 7468 6520 6261 636b  Updates the back
-0001f960: 7761 7264 2074 7261 6365 2077 6974 6820  ward trace with 
-0001f970: 6e65 7720 7361 7665 645f 666f 725f 6261  new saved_for_ba
-0001f980: 636b 7761 7264 2e0a 0a20 2020 2054 6869  ckward...    Thi
-0001f990: 7320 6973 206e 6563 6573 7361 7279 2062  s is necessary b
-0001f9a0: 6563 6175 7365 2074 6865 2075 7064 6174  ecause the updat
-0001f9b0: 6564 2073 6176 6564 5f66 6f72 5f62 6163  ed saved_for_bac
-0001f9c0: 6b77 6172 6420 6973 0a20 2020 206e 6f74  kward is.    not
-0001f9d0: 2061 7661 696c 6162 6c65 2077 6865 6e20   available when 
-0001f9e0: 7468 6520 6261 636b 7761 7264 2074 7261  the backward tra
-0001f9f0: 6365 2069 7320 636f 6e73 7472 7563 7465  ce is constructe
-0001fa00: 642e 0a0a 2020 2020 4172 6773 3a0a 2020  d...    Args:.  
-0001fa10: 2020 2020 2020 6261 636b 7761 7264 5f74        backward_t
-0001fa20: 7261 6365 2028 5472 6163 6529 3a20 4261  race (Trace): Ba
-0001fa30: 636b 7761 7264 2074 7261 6365 2074 6f20  ckward trace to 
-0001fa40: 7570 6461 7465 2e0a 2020 2020 2020 2020  update..        
-0001fa50: 7361 7665 645f 666f 725f 6261 636b 7761  saved_for_backwa
-0001fa60: 7264 2028 5365 7175 656e 6365 5b56 6172  rd (Sequence[Var
-0001fa70: 6961 626c 655d 293a 2053 6176 6564 5f66  iable]): Saved_f
-0001fa80: 6f72 5f62 6163 6b77 6172 6420 746f 2075  or_backward to u
-0001fa90: 7365 2074 6f0a 2020 2020 2020 2020 2020  se to.          
-0001faa0: 2020 7570 6461 7465 2074 6865 2062 6163    update the bac
-0001fab0: 6b77 6172 6420 7472 6163 652e 0a20 2020  kward trace..   
-0001fac0: 2022 2222 0a0a 2020 2020 6465 6620 756e   """..    def un
-0001fad0: 7061 636b 696e 675f 666e 2873 6176 6564  packing_fn(saved
-0001fae0: 5f66 6f72 5f62 6163 6b77 6172 642c 2063  _for_backward, c
-0001faf0: 6f74 616e 6765 6e74 7329 3a0a 2020 2020  otangents):.    
-0001fb00: 2020 2020 7061 7373 0a0a 2020 2020 636f      pass..    co
-0001fb10: 7461 6e67 656e 7473 203d 2062 6163 6b77  tangents = backw
-0001fb20: 6172 645f 7472 6163 652e 6172 6773 5b31  ard_trace.args[1
-0001fb30: 5d0a 2020 2020 7361 7665 645f 7465 6e73  ].    saved_tens
-0001fb40: 6f72 732c 2073 6176 6564 5f6f 7468 6572  ors, saved_other
-0001fb50: 203d 205f 7370 6c69 745f 7361 7665 645f   = _split_saved_
-0001fb60: 666f 725f 6261 636b 7761 7264 5f69 6e74  for_backward_int
-0001fb70: 6f5f 7465 6e73 6f72 735f 616e 645f 6f74  o_tensors_and_ot
-0001fb80: 6865 7228 7361 7665 645f 666f 725f 6261  her(saved_for_ba
-0001fb90: 636b 7761 7264 290a 2020 2020 756e 7061  ckward).    unpa
-0001fba0: 636b 696e 675f 7472 6163 6520 3d20 636f  cking_trace = co
-0001fbb0: 6e73 7472 7563 745f 7472 6163 6528 7265  nstruct_trace(re
-0001fbc0: 6e61 6d65 5f70 726f 7869 6573 3d46 616c  name_proxies=Fal
-0001fbd0: 7365 2c20 7573 655f 6463 653d 4661 6c73  se, use_dce=Fals
-0001fbe0: 6529 280a 2020 2020 2020 2020 756e 7061  e)(.        unpa
-0001fbf0: 636b 696e 675f 666e 2c20 2873 6176 6564  cking_fn, (saved
-0001fc00: 5f74 656e 736f 7273 2c20 7361 7665 645f  _tensors, saved_
-0001fc10: 6f74 6865 7229 2c20 636f 7461 6e67 656e  other), cotangen
-0001fc20: 7473 0a20 2020 2029 0a20 2020 2061 7373  ts.    ).    ass
-0001fc30: 6572 7420 756e 7061 636b 696e 675f 7472  ert unpacking_tr
-0001fc40: 6163 652e 626f 756e 645f 7379 6d62 6f6c  ace.bound_symbol
-0001fc50: 735b 2d31 5d2e 7379 6d2e 6964 203d 3d20  s[-1].sym.id == 
-0001fc60: 7072 696d 732e 5072 696d 4944 732e 5245  prims.PrimIDs.RE
-0001fc70: 5455 524e 0a0a 2020 2020 6261 636b 7761  TURN..    backwa
-0001fc80: 7264 5f74 7261 6365 2e61 7267 7320 3d20  rd_trace.args = 
-0001fc90: 756e 7061 636b 696e 675f 7472 6163 652e  unpacking_trace.
-0001fca0: 6172 6773 0a20 2020 2062 6163 6b77 6172  args.    backwar
-0001fcb0: 645f 7472 6163 655f 6273 796d 735f 7769  d_trace_bsyms_wi
-0001fcc0: 7468 6f75 745f 756e 7061 636b 696e 6720  thout_unpacking 
-0001fcd0: 3d20 280a 2020 2020 2020 2020 6273 796d  = (.        bsym
-0001fce0: 0a20 2020 2020 2020 2066 6f72 2062 7379  .        for bsy
-0001fcf0: 6d20 696e 2062 6163 6b77 6172 645f 7472  m in backward_tr
-0001fd00: 6163 652e 626f 756e 645f 7379 6d62 6f6c  ace.bound_symbol
-0001fd10: 730a 2020 2020 2020 2020 6966 2062 7379  s.        if bsy
-0001fd20: 6d2e 7379 6d2e 6964 0a20 2020 2020 2020  m.sym.id.       
-0001fd30: 206e 6f74 2069 6e20 280a 2020 2020 2020   not in (.      
-0001fd40: 2020 2020 2020 7072 696d 732e 5072 696d        prims.Prim
-0001fd50: 4944 732e 554e 5041 434b 5f45 4d50 5459  IDs.UNPACK_EMPTY
-0001fd60: 5f44 4943 542c 0a20 2020 2020 2020 2020  _DICT,.         
-0001fd70: 2020 2070 7269 6d73 2e50 7269 6d49 4473     prims.PrimIDs
-0001fd80: 2e55 4e50 4143 4b5f 4b45 592c 0a20 2020  .UNPACK_KEY,.   
-0001fd90: 2020 2020 2020 2020 2070 7269 6d73 2e50           prims.P
-0001fda0: 7269 6d49 4473 2e55 4e50 4143 4b5f 5345  rimIDs.UNPACK_SE
-0001fdb0: 5155 454e 4345 2c0a 2020 2020 2020 2020  QUENCE,.        
-0001fdc0: 2020 2020 7072 696d 732e 5072 696d 4944      prims.PrimID
-0001fdd0: 732e 554e 5041 434b 5f54 5249 5649 414c  s.UNPACK_TRIVIAL
-0001fde0: 2c0a 2020 2020 2020 2020 290a 2020 2020  ,.        ).    
-0001fdf0: 290a 2020 2020 6261 636b 7761 7264 5f74  ).    backward_t
-0001fe00: 7261 6365 2e62 6f75 6e64 5f73 796d 626f  race.bound_symbo
-0001fe10: 6c73 203d 206c 6973 7428 282a 756e 7061  ls = list((*unpa
-0001fe20: 636b 696e 675f 7472 6163 652e 626f 756e  cking_trace.boun
-0001fe30: 645f 7379 6d62 6f6c 735b 3a2d 315d 2c20  d_symbols[:-1], 
-0001fe40: 2a62 6163 6b77 6172 645f 7472 6163 655f  *backward_trace_
-0001fe50: 6273 796d 735f 7769 7468 6f75 745f 756e  bsyms_without_un
-0001fe60: 7061 636b 696e 6729 290a 0a0a 2320 4e4f  packing))...# NO
-0001fe70: 5445 3a20 5265 7475 726e 696e 6720 6e61  TE: Returning na
-0001fe80: 6d65 6474 7570 6c65 7320 6672 6f6d 2063  medtuples from c
-0001fe90: 6f6d 7069 6c65 6420 6675 6e63 7469 6f6e  ompiled function
-0001fea0: 7320 646f 6573 6e27 7420 776f 726b 2e20  s doesn't work. 
-0001feb0: 5365 653a 0a23 2022 416c 6c6f 7720 7265  See:.# "Allow re
-0001fec0: 7475 726e 696e 6720 6e61 6d65 6474 7570  turning namedtup
-0001fed0: 6c65 7320 6672 6f6d 2063 6f6d 7069 6c65  les from compile
-0001fee0: 6420 6675 6e63 7469 6f6e 7322 0a23 204e  d functions".# N
-0001fef0: 6f74 6520 5b47 7261 6420 666f 7277 6172  ote [Grad forwar
-0001ff00: 6420 6f75 7470 7574 2073 7065 635d 0a23  d output spec].#
-0001ff10: 2049 6620 6974 2064 6964 2077 6f72 6b20   If it did work 
-0001ff20: 6974 2077 6f75 6c64 2062 6520 6e69 6365  it would be nice
-0001ff30: 2074 6f20 7573 6520 7468 6973 206e 616d   to use this nam
-0001ff40: 6564 7475 706c 650a 2320 696e 7374 6561  edtuple.# instea
-0001ff50: 6420 6f66 2074 6865 2070 6c61 696e 2074  d of the plain t
-0001ff60: 7570 6c65 206f 7220 6469 6374 2074 6861  uple or dict tha
-0001ff70: 7420 7765 2772 6520 7573 696e 6720 6e6f  t we're using no
-0001ff80: 772e 0a54 6f72 6368 4175 746f 6772 6164  w..TorchAutograd
-0001ff90: 466f 7277 6172 6444 6174 6120 3d20 6e61  ForwardData = na
-0001ffa0: 6d65 6474 7570 6c65 280a 2020 2020 2254  medtuple(.    "T
-0001ffb0: 6f72 6368 4175 746f 6772 6164 466f 7277  orchAutogradForw
-0001ffc0: 6172 6444 6174 6122 2c0a 2020 2020 5b22  ardData",.    ["
-0001ffd0: 6f75 7470 7574 222c 2022 666c 6174 5f61  output", "flat_a
-0001ffe0: 7267 7322 2c20 2266 6c61 745f 6f75 7470  rgs", "flat_outp
-0001fff0: 7574 225d 2c0a 290a 0a0a 6465 6620 666f  ut"],.)...def fo
-00020000: 7277 6172 645f 616e 645f 6261 636b 7761  rward_and_backwa
-00020010: 7264 5f66 726f 6d5f 7472 6163 6528 7472  rd_from_trace(tr
-00020020: 6163 653a 2054 7261 6365 2c20 746f 7263  ace: Trace, torc
-00020030: 685f 6175 746f 6772 6164 3d46 616c 7365  h_autograd=False
-00020040: 2920 2d3e 2046 6f72 7761 7264 4261 636b  ) -> ForwardBack
-00020050: 7761 7264 5472 6163 6573 3a0a 2020 2020  wardTraces:.    
-00020060: 2222 2247 656e 6572 6174 6573 2074 6865  """Generates the
-00020070: 2066 6f72 7761 7264 2061 6e64 2062 6163   forward and bac
-00020080: 6b77 6172 6420 7061 7373 6573 2066 726f  kward passes fro
-00020090: 6d20 6120 7472 6163 652e 0a0a 2020 2020  m a trace...    
-000200a0: 5468 6973 2069 7320 6120 636f 6e76 656e  This is a conven
-000200b0: 6965 6e63 6520 6675 6e63 7469 6f6e 2074  ience function t
-000200c0: 6861 7420 636f 6d62 696e 6573 2074 6865  hat combines the
-000200d0: 2066 756e 6374 696f 6e61 6c69 7479 206f   functionality o
-000200e0: 660a 2020 2020 6061 7567 6d65 6e74 6564  f.    `augmented
-000200f0: 5f66 6f72 7761 7264 5f70 6173 7360 2061  _forward_pass` a
-00020100: 6e64 2060 6261 636b 7761 7264 5f70 6173  nd `backward_pas
-00020110: 7360 2e20 5468 6520 6d61 696e 2064 6966  s`. The main dif
-00020120: 6665 7265 6e63 6520 6973 2074 6861 740a  ference is that.
-00020130: 2020 2020 7468 6973 2066 756e 6374 696f      this functio
-00020140: 6e20 646f 6573 206e 6f74 2072 6571 7569  n does not requi
-00020150: 7265 2074 6865 2075 7365 7220 746f 2070  re the user to p
-00020160: 726f 7669 6465 206e 6577 2069 6e70 7574  rovide new input
-00020170: 7320 666f 7220 7468 650a 2020 2020 7472  s for the.    tr
-00020180: 6163 6520 6576 616c 7561 7469 6f6e 2e20  ace evaluation. 
-00020190: 496e 7374 6561 6420 6974 2075 7365 7320  Instead it uses 
-000201a0: 7468 6520 696e 7075 7473 2074 6861 7420  the inputs that 
-000201b0: 7765 7265 2075 7365 6420 746f 2063 6f6e  were used to con
-000201c0: 7374 7275 6374 0a20 2020 2074 6865 2074  struct.    the t
-000201d0: 7261 6365 2e0a 0a20 2020 2041 7267 733a  race...    Args:
-000201e0: 0a20 2020 2020 2020 2074 7261 6365 2028  .        trace (
-000201f0: 5472 6163 6529 3a20 5472 6163 6520 746f  Trace): Trace to
-00020200: 2067 656e 6572 6174 6520 7468 6520 666f   generate the fo
-00020210: 7277 6172 6420 616e 6420 6261 636b 7761  rward and backwa
-00020220: 7264 2070 6173 7365 7320 6672 6f6d 2e0a  rd passes from..
-00020230: 0a20 2020 2052 6574 7572 6e73 3a0a 2020  .    Returns:.  
-00020240: 2020 2020 2020 466f 7277 6172 6442 6163        ForwardBac
-00020250: 6b77 6172 6454 7261 6365 733a 2041 206e  kwardTraces: A n
-00020260: 616d 6564 2074 7570 6c65 2063 6f6e 7461  amed tuple conta
-00020270: 696e 696e 6720 7468 6520 666f 7277 6172  ining the forwar
-00020280: 6420 616e 6420 6261 636b 7761 7264 0a20  d and backward. 
-00020290: 2020 2020 2020 2020 2020 2074 7261 6365             trace
-000202a0: 732e 0a0a 2020 2020 4578 616d 706c 653a  s...    Example:
-000202b0: 0a20 2020 2020 2020 203e 3e3e 2069 6d70  .        >>> imp
-000202c0: 6f72 7420 746f 7263 680a 2020 2020 2020  ort torch.      
-000202d0: 2020 3e3e 3e20 6672 6f6d 2074 6875 6e64    >>> from thund
-000202e0: 6572 2069 6d70 6f72 7420 636f 6d70 696c  er import compil
-000202f0: 652c 206c 6173 745f 7472 6163 6573 0a20  e, last_traces. 
-00020300: 2020 2020 2020 203e 3e3e 2066 726f 6d20         >>> from 
-00020310: 7468 756e 6465 722e 636f 7265 2e74 7261  thunder.core.tra
-00020320: 6e73 666f 726d 7320 696d 706f 7274 2066  nsforms import f
-00020330: 6f72 7761 7264 5f61 6e64 5f62 6163 6b77  orward_and_backw
-00020340: 6172 645f 6672 6f6d 5f74 7261 6365 0a20  ard_from_trace. 
-00020350: 2020 2020 2020 203e 3e3e 2064 6566 2066         >>> def f
-00020360: 2878 293a 0a20 2020 2020 2020 202e 2e2e  (x):.        ...
-00020370: 2020 2020 2072 6574 7572 6e20 746f 7263       return torc
-00020380: 682e 7369 6e28 7829 0a20 2020 2020 2020  h.sin(x).       
-00020390: 203e 3e3e 2078 203d 2074 6f72 6368 2e74   >>> x = torch.t
-000203a0: 656e 736f 7228 332e 3029 0a20 2020 2020  ensor(3.0).     
-000203b0: 2020 203e 3e3e 2063 6620 3d20 636f 6d70     >>> cf = comp
-000203c0: 696c 6528 6629 0a20 2020 2020 2020 203e  ile(f).        >
-000203d0: 3e3e 206f 7574 203d 2063 6628 7829 0a20  >> out = cf(x). 
-000203e0: 2020 2020 2020 203e 3e3e 2074 7261 6365         >>> trace
-000203f0: 203d 206c 6173 745f 7472 6163 6573 2863   = last_traces(c
-00020400: 6629 5b30 5d0a 2020 2020 2020 2020 3e3e  f)[0].        >>
-00020410: 3e20 666f 7277 6172 645f 616e 645f 6261  > forward_and_ba
-00020420: 636b 7761 7264 5f66 726f 6d5f 7472 6163  ckward_from_trac
-00020430: 6528 7472 6163 6529 0a20 2020 2020 2020  e(trace).       
-00020440: 202e 2e2e 2046 6f72 7761 7264 4261 636b   ... ForwardBack
-00020450: 7761 7264 5472 6163 6573 280a 2020 2020  wardTraces(.    
-00020460: 2020 2020 2e2e 2e20 666f 7277 6172 645f      ... forward_
-00020470: 7472 6163 653d 2320 696d 706f 7274 2074  trace=# import t
-00020480: 6875 6e64 6572 2061 7320 7468 756e 6465  hunder as thunde
-00020490: 720a 2020 2020 2020 2020 2e2e 2e20 2320  r.        ... # 
-000204a0: 696d 706f 7274 2074 6875 6e64 6572 2e63  import thunder.c
-000204b0: 6f72 652e 7072 696d 7320 6173 2070 7269  ore.prims as pri
-000204c0: 6d73 0a20 2020 2020 2020 202e 2e2e 2069  ms.        ... i
-000204d0: 6d70 6f72 7420 746f 7263 680a 2020 2020  mport torch.    
-000204e0: 2020 2020 2e2e 2e0a 2020 2020 2020 2020      ....        
-000204f0: 2e2e 2e20 4074 6f72 6368 2e6e 6f5f 6772  ... @torch.no_gr
-00020500: 6164 2829 0a20 2020 2020 2020 202e 2e2e  ad().        ...
-00020510: 2064 6566 2061 7567 6d65 6e74 6564 5f66   def augmented_f
-00020520: 6f72 7761 7264 5f66 6e28 2a61 7267 7329  orward_fn(*args)
-00020530: 3a0a 2020 2020 2020 2020 2e2e 2e20 2020  :.        ...   
-00020540: 2320 6172 6773 3a20 2243 6f6c 6c65 6374  # args: "Collect
-00020550: 696f 6e22 203d 2020 2874 302c 2920 2028  ion" =  (t0,)  (
-00020560: 7472 6976 6961 6c20 756e 7061 636b 290a  trivial unpack).
-00020570: 2020 2020 2020 2020 2e2e 2e20 2020 7430          ...   t0
-00020580: 2c20 5c0a 2020 2020 2020 2020 2e2e 2e20  , \.        ... 
-00020590: 2020 3d20 6172 6773 0a20 2020 2020 2020    = args.       
-000205a0: 202e 2e2e 2020 2074 3120 3d20 7072 696d   ...   t1 = prim
-000205b0: 732e 7369 6e28 7430 2920 2023 2074 313a  s.sin(t0)  # t1:
-000205c0: 2022 6370 7520 6633 325b 5d22 0a20 2020   "cpu f32[]".   
-000205d0: 2020 2020 202e 2e2e 2020 2072 6574 7572       ...   retur
-000205e0: 6e20 7431 2c20 2874 302c 292c 0a20 2020  n t1, (t0,),.   
-000205f0: 2020 2020 202e 2e2e 2062 6163 6b77 6172       ... backwar
-00020600: 645f 7472 6163 653d 2320 696d 706f 7274  d_trace=# import
-00020610: 2074 6875 6e64 6572 2061 7320 7468 756e   thunder as thun
-00020620: 6465 720a 2020 2020 2020 2020 2e2e 2e20  der.        ... 
-00020630: 2320 696d 706f 7274 2074 6875 6e64 6572  # import thunder
-00020640: 2e63 6f72 652e 7072 696d 7320 6173 2070  .core.prims as p
-00020650: 7269 6d73 0a20 2020 2020 2020 202e 2e2e  rims.        ...
-00020660: 2069 6d70 6f72 7420 746f 7263 680a 2020   import torch.  
-00020670: 2020 2020 2020 2e2e 2e0a 2020 2020 2020        ....      
-00020680: 2020 2e2e 2e20 4074 6f72 6368 2e6e 6f5f    ... @torch.no_
-00020690: 6772 6164 2829 0a20 2020 2020 2020 202e  grad().        .
-000206a0: 2e2e 2064 6566 2062 6163 6b77 6172 645f  .. def backward_
-000206b0: 666e 2873 6176 6564 5f66 6f72 5f62 6163  fn(saved_for_bac
-000206c0: 6b77 6172 642c 2063 6f74 616e 6765 6e74  kward, cotangent
-000206d0: 7329 3a0a 2020 2020 2020 2020 2e2e 2e20  s):.        ... 
-000206e0: 2020 2320 7361 7665 645f 666f 725f 6261    # saved_for_ba
-000206f0: 636b 7761 7264 3a20 2243 6f6c 6c65 6374  ckward: "Collect
-00020700: 696f 6e22 203d 2020 2874 302c 2920 2028  ion" =  (t0,)  (
-00020710: 7472 6976 6961 6c20 756e 7061 636b 290a  trivial unpack).
-00020720: 2020 2020 2020 2020 2e2e 2e20 2020 2320          ...   # 
-00020730: 636f 7461 6e67 656e 7473 3a20 2263 7075  cotangents: "cpu
-00020740: 2066 3332 5b5d 2220 3d20 2063 6f74 616e   f32[]" =  cotan
-00020750: 6765 6e74 7320 2028 7472 6976 6961 6c20  gents  (trivial 
-00020760: 756e 7061 636b 290a 2020 2020 2020 2020  unpack).        
-00020770: 2e2e 2e20 2020 7430 2c20 5c0a 2020 2020  ...   t0, \.    
-00020780: 2020 2020 2e2e 2e20 2020 3d20 7361 7665      ...   = save
-00020790: 645f 666f 725f 6261 636b 7761 7264 0a20  d_for_backward. 
-000207a0: 2020 2020 2020 202e 2e2e 2020 2074 3120         ...   t1 
-000207b0: 3d20 7072 696d 732e 636f 7328 7430 2920  = prims.cos(t0) 
-000207c0: 2023 2074 313a 2022 6370 7520 6633 325b   # t1: "cpu f32[
-000207d0: 5d22 0a20 2020 2020 2020 202e 2e2e 2020  ]".        ...  
-000207e0: 2074 3220 3d20 7072 696d 732e 6d75 6c28   t2 = prims.mul(
-000207f0: 636f 7461 6e67 656e 7473 2c20 7431 2920  cotangents, t1) 
-00020800: 2023 2074 323a 2022 6370 7520 6633 325b   # t2: "cpu f32[
-00020810: 5d22 0a20 2020 2020 2020 202e 2e2e 2020  ]".        ...  
-00020820: 2072 6574 7572 6e20 2874 322c 2929 0a20   return (t2,)). 
-00020830: 2020 2022 2222 0a0a 2020 2020 6f75 7470     """..    outp
-00020840: 7574 5f73 7065 6320 3d20 4e6f 6e65 0a0a  ut_spec = None..
-00020850: 2020 2020 6465 6620 6175 676d 656e 7465      def augmente
-00020860: 645f 666f 7277 6172 645f 666e 282a 6172  d_forward_fn(*ar
-00020870: 6773 2c20 2a2a 6b77 6172 6773 293a 0a20  gs, **kwargs):. 
-00020880: 2020 2020 2020 2072 6573 756c 742c 2065         result, e
-00020890: 6e76 203d 2061 7567 6d65 6e74 6564 5f66  nv = augmented_f
-000208a0: 6f72 7761 7264 5f70 6173 7328 2a61 7267  orward_pass(*arg
-000208b0: 732c 2074 7261 6365 3d74 7261 6365 2c20  s, trace=trace, 
-000208c0: 2a2a 6b77 6172 6773 290a 2020 2020 2020  **kwargs).      
-000208d0: 2020 7361 7665 645f 666f 725f 6261 636b    saved_for_back
-000208e0: 7761 7264 203d 2064 6563 6f6e 7374 7275  ward = deconstru
-000208f0: 6374 5f66 6f72 7761 7264 5f65 6e76 5f66  ct_forward_env_f
-00020900: 6f72 5f62 6163 6b77 6172 6428 7472 6163  or_backward(trac
-00020910: 652c 2065 6e76 290a 2020 2020 2020 2020  e, env).        
-00020920: 6966 2074 6f72 6368 5f61 7574 6f67 7261  if torch_autogra
-00020930: 643a 0a20 2020 2020 2020 2020 2020 206e  d:.            n
-00020940: 6f6e 6c6f 6361 6c20 6f75 7470 7574 5f73  onlocal output_s
-00020950: 7065 630a 2020 2020 2020 2020 2020 2020  pec.            
-00020960: 666c 6174 5f61 7267 732c 205f 203d 2074  flat_args, _ = t
-00020970: 7265 655f 666c 6174 7465 6e28 2861 7267  ree_flatten((arg
-00020980: 732c 206b 7761 7267 7329 290a 2020 2020  s, kwargs)).    
-00020990: 2020 2020 2020 2020 666c 6174 5f6f 7574          flat_out
-000209a0: 7075 742c 206f 7574 7075 745f 7370 6563  put, output_spec
-000209b0: 203d 2074 7265 655f 666c 6174 7465 6e28   = tree_flatten(
-000209c0: 7265 7375 6c74 290a 2020 2020 2020 2020  result).        
-000209d0: 2020 2020 666c 6174 5f6f 7574 7075 7420      flat_output 
-000209e0: 3d20 7475 706c 6528 666c 6174 5f6f 7574  = tuple(flat_out
-000209f0: 7075 7429 0a20 2020 2020 2020 2020 2020  put).           
-00020a00: 2023 2053 6565 204e 6f74 6520 5b47 7261   # See Note [Gra
-00020a10: 6420 666f 7277 6172 6420 6f75 7470 7574  d forward output
-00020a20: 2073 7065 635d 0a20 2020 2020 2020 2020   spec].         
-00020a30: 2020 2066 6f72 5f61 7574 6f67 7261 6420     for_autograd 
-00020a40: 3d20 546f 7263 6841 7574 6f67 7261 6446  = TorchAutogradF
-00020a50: 6f72 7761 7264 4461 7461 280a 2020 2020  orwardData(.    
-00020a60: 2020 2020 2020 2020 2020 2020 7265 7375              resu
-00020a70: 6c74 2c0a 2020 2020 2020 2020 2020 2020  lt,.            
-00020a80: 2020 2020 666c 6174 5f61 7267 732c 0a20      flat_args,. 
-00020a90: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-00020aa0: 6c61 745f 6f75 7470 7574 2c0a 2020 2020  lat_output,.    
-00020ab0: 2020 2020 2020 2020 292e 5f61 7364 6963          )._asdic
-00020ac0: 7428 290a 2020 2020 2020 2020 2020 2020  t().            
-00020ad0: 7265 7475 726e 2028 666f 725f 6175 746f  return (for_auto
-00020ae0: 6772 6164 2c20 7361 7665 645f 666f 725f  grad, saved_for_
-00020af0: 6261 636b 7761 7264 290a 2020 2020 2020  backward).      
-00020b00: 2020 7265 7475 726e 2072 6573 756c 742c    return result,
-00020b10: 2073 6176 6564 5f66 6f72 5f62 6163 6b77   saved_for_backw
-00020b20: 6172 640a 0a20 2020 2023 2043 6f70 7920  ard..    # Copy 
-00020b30: 7468 6520 7369 676e 6174 7572 6520 6f66  the signature of
-00020b40: 2074 6865 206f 7269 6769 6e61 6c20 6675   the original fu
-00020b50: 6e63 7469 6f6e 2073 6f20 7468 6174 2074  nction so that t
-00020b60: 6865 2061 7267 756d 656e 7473 2061 7265  he arguments are
-00020b70: 0a20 2020 2023 206e 616d 6564 2063 6f72  .    # named cor
-00020b80: 7265 6374 6c79 2069 6e20 7468 6520 6175  rectly in the au
-00020b90: 676d 656e 7465 6420 666f 7277 6172 6420  gmented forward 
-00020ba0: 7061 7373 2069 6e73 7465 6164 206f 6620  pass instead of 
-00020bb0: 6265 696e 6720 6e61 6d65 640a 2020 2020  being named.    
-00020bc0: 2320 2261 7267 7322 2061 6e64 2022 6b77  # "args" and "kw
-00020bd0: 6172 6773 222e 0a20 2020 2061 7567 6d65  args"..    augme
-00020be0: 6e74 6564 5f66 6f72 7761 7264 5f66 6e2e  nted_forward_fn.
-00020bf0: 5f5f 7369 676e 6174 7572 655f 5f20 3d20  __signature__ = 
-00020c00: 696e 7370 6563 742e 7369 676e 6174 7572  inspect.signatur
-00020c10: 6528 7472 6163 652e 666e 206f 7220 7472  e(trace.fn or tr
-00020c20: 6163 652e 7079 7468 6f6e 5f63 616c 6c61  ace.python_calla
-00020c30: 626c 6528 2929 0a0a 2020 2020 6465 6620  ble())..    def 
-00020c40: 6f6e 6573 5f6c 696b 6528 7829 3a0a 2020  ones_like(x):.  
-00020c50: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
-00020c60: 6e63 6528 782c 2054 656e 736f 7250 726f  nce(x, TensorPro
-00020c70: 7879 293a 0a20 2020 2020 2020 2020 2020  xy):.           
-00020c80: 2072 6574 7572 6e20 6675 6c6c 5f6c 696b   return full_lik
-00020c90: 6528 782c 2066 696c 6c5f 7661 6c75 653d  e(x, fill_value=
-00020ca0: 3129 0a20 2020 2020 2020 2065 6c69 6620  1).        elif 
-00020cb0: 6973 696e 7374 616e 6365 2878 2c20 4e75  isinstance(x, Nu
-00020cc0: 6d62 6572 5072 6f78 7929 3a0a 2020 2020  mberProxy):.    
-00020cd0: 2020 2020 2020 2020 7265 7475 726e 2074          return t
-00020ce0: 7970 6528 782e 7661 6c75 6529 2831 290a  ype(x.value)(1).
-00020cf0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00020d00: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00020d10: 204e 6f6e 650a 0a20 2020 2066 6f72 7761   None..    forwa
-00020d20: 7264 5f74 7261 6365 203d 2063 6f6e 7374  rd_trace = const
-00020d30: 7275 6374 5f74 7261 6365 2829 2861 7567  ruct_trace()(aug
-00020d40: 6d65 6e74 6564 5f66 6f72 7761 7264 5f66  mented_forward_f
-00020d50: 6e2c 202a 7472 6163 652e 6172 6773 2c20  n, *trace.args, 
-00020d60: 2a2a 7472 6163 652e 6b77 6172 6773 290a  **trace.kwargs).
-00020d70: 2020 2020 2320 5765 2073 6574 2066 6f72      # We set for
-00020d80: 7761 7264 2074 7261 6365 2074 6f20 636f  ward trace to co
-00020d90: 6e73 7472 7563 7420 7072 6f78 6965 7320  nstruct proxies 
-00020da0: 6265 6361 7573 6520 7765 206e 6565 6420  because we need 
-00020db0: 7468 6573 6520 7072 6f78 6965 7320 746f  these proxies to
-00020dc0: 0a20 2020 2023 2068 6176 6520 6469 6666  .    # have diff
-00020dd0: 6572 656e 7420 6e61 6d65 7320 7468 616e  erent names than
-00020de0: 2074 6865 206f 6e65 7320 696e 2074 6865   the ones in the
-00020df0: 2066 6f72 7761 7264 2074 7261 6365 2e0a   forward trace..
-00020e00: 2020 2020 7472 793a 0a20 2020 2020 2020      try:.       
-00020e10: 2074 7261 6365 6374 785f 746f 6b65 6e20   tracectx_token 
-00020e20: 3d20 7365 745f 7472 6163 6563 7478 2866  = set_tracectx(f
-00020e30: 6f72 7761 7264 5f74 7261 6365 290a 2020  orward_trace).  
-00020e40: 2020 2020 2020 2320 5765 2064 6f6e 2774        # We don't
-00020e50: 2077 616e 7420 746f 2072 6563 6f72 6420   want to record 
-00020e60: 7468 6f73 6520 6f6e 6573 5f6c 696b 6520  those ones_like 
-00020e70: 6361 6c6c 7320 696e 2074 6865 2066 6f72  calls in the for
-00020e80: 7761 7264 2074 7261 6365 2e0a 2020 2020  ward trace..    
-00020e90: 2020 2020 7769 7468 2064 6574 6163 6865      with detache
-00020ea0: 645f 7472 6163 6528 293a 0a20 2020 2020  d_trace():.     
-00020eb0: 2020 2020 2020 2069 6620 746f 7263 685f         if torch_
-00020ec0: 6175 746f 6772 6164 3a0a 2020 2020 2020  autograd:.      
-00020ed0: 2020 2020 2020 2020 2020 2320 4974 2773            # It's
-00020ee0: 2061 7373 756d 6564 2074 6861 7420 666f   assumed that fo
-00020ef0: 7277 6172 645f 7472 6163 652e 6f75 7470  rward_trace.outp
-00020f00: 7574 5b30 5d20 6973 2061 2064 6963 7420  ut[0] is a dict 
-00020f10: 6672 6f6d 2054 6f72 6368 4175 746f 6772  from TorchAutogr
-00020f20: 6164 466f 7277 6172 6444 6174 610a 2020  adForwardData.  
-00020f30: 2020 2020 2020 2020 2020 2020 2020 666c                fl
-00020f40: 6174 5f6f 7574 7075 7420 3d20 666f 7277  at_output = forw
-00020f50: 6172 645f 7472 6163 652e 6f75 7470 7574  ard_trace.output
-00020f60: 5b30 5d5b 2266 6c61 745f 6f75 7470 7574  [0]["flat_output
-00020f70: 225d 0a20 2020 2020 2020 2020 2020 2020  "].             
-00020f80: 2020 2063 6f74 616e 6765 6e74 7320 3d20     cotangents = 
-00020f90: 7574 696c 732e 7365 7175 656e 6369 6679  utils.sequencify
-00020fa0: 2874 7265 655f 6d61 7028 6c61 6d62 6461  (tree_map(lambda
-00020fb0: 2076 3a20 6f6e 6573 5f6c 696b 6528 7629   v: ones_like(v)
-00020fc0: 2c20 666c 6174 5f6f 7574 7075 7429 290a  , flat_output)).
-00020fd0: 2020 2020 2020 2020 2020 2020 656c 7365              else
-00020fe0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00020ff0: 2020 636f 7461 6e67 656e 7473 203d 2075    cotangents = u
-00021000: 7469 6c73 2e73 6571 7565 6e63 6966 7928  tils.sequencify(
-00021010: 7472 6565 5f6d 6170 286c 616d 6264 6120  tree_map(lambda 
-00021020: 763a 206f 6e65 735f 6c69 6b65 2876 292c  v: ones_like(v),
-00021030: 2074 7261 6365 2e6f 7574 7075 7429 290a   trace.output)).
-00021040: 2020 2020 6669 6e61 6c6c 793a 0a20 2020      finally:.   
-00021050: 2020 2020 2072 6573 6574 5f74 7261 6365       reset_trace
-00021060: 6374 7828 7472 6163 6563 7478 5f74 6f6b  ctx(tracectx_tok
-00021070: 656e 290a 0a20 2020 2064 6566 2062 6163  en)..    def bac
-00021080: 6b77 6172 645f 666e 2873 6176 6564 5f66  kward_fn(saved_f
-00021090: 6f72 5f62 6163 6b77 6172 642c 2063 6f74  or_backward, cot
-000210a0: 616e 6765 6e74 7329 3a0a 2020 2020 2020  angents):.      
-000210b0: 2020 656e 7620 3d20 7265 636f 6e73 7472    env = reconstr
-000210c0: 7563 745f 666f 7277 6172 645f 656e 765f  uct_forward_env_
-000210d0: 666f 725f 6261 636b 7761 7264 2874 7261  for_backward(tra
-000210e0: 6365 2c20 7361 7665 645f 666f 725f 6261  ce, saved_for_ba
-000210f0: 636b 7761 7264 290a 2020 2020 2020 2020  ckward).        
-00021100: 6966 2074 6f72 6368 5f61 7574 6f67 7261  if torch_autogra
-00021110: 643a 0a20 2020 2020 2020 2020 2020 2063  d:.            c
-00021120: 6f74 616e 6765 6e74 7320 3d20 7472 6565  otangents = tree
-00021130: 5f75 6e66 6c61 7474 656e 2863 6f74 616e  _unflatten(cotan
-00021140: 6765 6e74 732c 206f 7574 7075 745f 7370  gents, output_sp
-00021150: 6563 290a 2020 2020 2020 2020 6f75 7420  ec).        out 
-00021160: 3d20 6261 636b 7761 7264 5f70 6173 7328  = backward_pass(
-00021170: 656e 762c 2074 7261 6365 2c20 636f 7461  env, trace, cota
-00021180: 6e67 656e 7473 290a 2020 2020 2020 2020  ngents).        
-00021190: 6966 2074 6f72 6368 5f61 7574 6f67 7261  if torch_autogra
-000211a0: 643a 0a20 2020 2020 2020 2020 2020 2067  d:.            g
-000211b0: 6b77 6172 6773 203d 206f 7574 5b2d 315d  kwargs = out[-1]
-000211c0: 2069 6620 6973 696e 7374 616e 6365 286f   if isinstance(o
-000211d0: 7574 5b2d 315d 2c20 6469 6374 2920 656c  ut[-1], dict) el
-000211e0: 7365 207b 7d0a 2020 2020 2020 2020 2020  se {}.          
-000211f0: 2020 6761 7267 7320 3d20 6f75 745b 3a2d    gargs = out[:-
-00021200: 315d 2069 6620 6973 696e 7374 616e 6365  1] if isinstance
-00021210: 286f 7574 5b2d 315d 2c20 6469 6374 2920  (out[-1], dict) 
-00021220: 656c 7365 206f 7574 0a20 2020 2020 2020  else out.       
-00021230: 2020 2020 2067 6b77 6172 6773 203d 207b       gkwargs = {
-00021240: 6b3a 2067 6b77 6172 6773 2e67 6574 286b  k: gkwargs.get(k
-00021250: 2c20 4e6f 6e65 2920 666f 7220 6b20 696e  , None) for k in
-00021260: 2074 7261 6365 2e6b 7761 7267 737d 0a20   trace.kwargs}. 
-00021270: 2020 2020 2020 2020 2020 206f 7574 203d             out =
-00021280: 2028 2a67 6172 6773 2c20 676b 7761 7267   (*gargs, gkwarg
-00021290: 7329 0a20 2020 2020 2020 2020 2020 206f  s).            o
-000212a0: 7574 203d 2074 7265 655f 666c 6174 7465  ut = tree_flatte
-000212b0: 6e28 6f75 7429 5b30 5d0a 2020 2020 2020  n(out)[0].      
-000212c0: 2020 7265 7475 726e 206f 7574 0a0a 2020    return out..  
-000212d0: 2020 7361 7665 645f 666f 725f 6261 636b    saved_for_back
-000212e0: 7761 7264 203d 2066 6f72 7761 7264 5f74  ward = forward_t
-000212f0: 7261 6365 2e6f 7574 7075 745b 315d 0a20  race.output[1]. 
-00021300: 2020 2062 6163 6b77 6172 645f 7472 6163     backward_trac
-00021310: 6520 3d20 636f 6e73 7472 7563 745f 7472  e = construct_tr
-00021320: 6163 6528 7265 6e61 6d65 5f70 726f 7869  ace(rename_proxi
-00021330: 6573 3d46 616c 7365 2928 6261 636b 7761  es=False)(backwa
-00021340: 7264 5f66 6e2c 2073 6176 6564 5f66 6f72  rd_fn, saved_for
-00021350: 5f62 6163 6b77 6172 642c 2063 6f74 616e  _backward, cotan
-00021360: 6765 6e74 7329 0a0a 2020 2020 2320 5765  gents)..    # We
-00021370: 2061 7265 2064 6f6e 6520 7769 7468 2063   are done with c
-00021380: 6f6e 7374 7275 6374 696e 6720 7468 6520  onstructing the 
-00021390: 666f 7277 6172 6420 616e 6420 6261 636b  forward and back
-000213a0: 7761 7264 2070 6173 7365 7320 6174 2074  ward passes at t
-000213b0: 6869 730a 2020 2020 2320 7374 6167 652e  his.    # stage.
-000213c0: 2054 6865 2066 6f6c 6c6f 7769 6e67 2069   The following i
-000213d0: 7320 6e6f 7420 7374 7269 6374 6c79 206e  s not strictly n
-000213e0: 6563 6573 7361 7279 2c20 6275 7420 6974  ecessary, but it
-000213f0: 2773 2067 6f6f 6420 746f 2066 696c 7465  's good to filte
-00021400: 720a 2020 2020 2320 6f75 7420 7468 6520  r.    # out the 
-00021410: 756e 7573 6564 2065 6c65 6d65 6e74 7320  unused elements 
-00021420: 6f66 2074 6865 2073 6176 6564 5f66 6f72  of the saved_for
-00021430: 5f62 6163 6b77 6172 6420 616e 6420 666c  _backward and fl
-00021440: 6174 7465 6e20 6974 2066 6f72 206d 6f72  atten it for mor
-00021450: 650a 2020 2020 2320 636f 6d70 6163 7420  e.    # compact 
-00021460: 6261 636b 7761 7264 2074 7261 6365 2e0a  backward trace..
-00021470: 0a20 2020 2023 204e 6f77 2077 6520 6361  .    # Now we ca
-00021480: 6e20 6465 7465 726d 696e 6520 6578 6163  n determine exac
-00021490: 746c 7920 7768 6174 2773 2075 7365 6420  tly what's used 
-000214a0: 696e 2074 6865 2062 6163 6b77 6172 6420  in the backward 
-000214b0: 7061 7373 2066 726f 6d20 7468 650a 2020  pass from the.  
-000214c0: 2020 2320 7361 7665 645f 666f 725f 6261    # saved_for_ba
-000214d0: 636b 7761 7264 2e20 5765 2063 616e 2066  ckward. We can f
-000214e0: 6c61 7474 656e 2061 6e64 2066 696c 7465  latten and filte
-000214f0: 7220 7468 6520 7361 7665 645f 666f 725f  r the saved_for_
-00021500: 6261 636b 7761 7264 0a20 2020 2063 6f6e  backward.    con
-00021510: 7375 6d65 7273 203d 2075 7469 6c73 2e63  sumers = utils.c
-00021520: 6f6e 7375 6d65 7273 2862 6163 6b77 6172  onsumers(backwar
-00021530: 645f 7472 6163 6529 0a0a 2020 2020 2320  d_trace)..    # 
-00021540: 466f 7277 6172 6427 7320 616e 6420 6261  Forward's and ba
-00021550: 636b 7761 7264 2773 2022 7361 7665 645f  ckward's "saved_
-00021560: 666f 725f 6261 636b 7761 7264 2220 6172  for_backward" ar
-00021570: 6520 6e6f 7420 6e65 6365 7373 6172 696c  e not necessaril
-00021580: 7920 7468 6520 7361 6d65 0a20 2020 2023  y the same.    #
-00021590: 2061 7320 7468 6520 7361 7665 645f 666f   as the saved_fo
-000215a0: 725f 6261 636b 7761 7264 2c20 6265 6361  r_backward, beca
-000215b0: 7573 6520 736f 6d65 206f 7220 616c 6c20  use some or all 
-000215c0: 656c 656d 656e 7473 206f 6620 7468 650a  elements of the.
-000215d0: 2020 2020 2320 7361 7665 645f 666f 725f      # saved_for_
-000215e0: 6261 636b 7761 7264 2072 6573 756c 7473  backward results
-000215f0: 206d 6967 6874 2062 6520 7265 2d70 726f   might be re-pro
-00021600: 7869 6669 6564 2e0a 2020 2020 6277 5f66  xified..    bw_f
-00021610: 6c61 745f 7361 7665 645f 666f 725f 6261  lat_saved_for_ba
-00021620: 636b 7761 7264 2c20 7370 6563 203d 2074  ckward, spec = t
-00021630: 7265 655f 666c 6174 7465 6e28 6261 636b  ree_flatten(back
-00021640: 7761 7264 5f74 7261 6365 2e61 7267 735b  ward_trace.args[
-00021650: 305d 290a 2020 2020 6677 5f66 6c61 745f  0]).    fw_flat_
-00021660: 7361 7665 645f 666f 725f 6261 636b 7761  saved_for_backwa
-00021670: 7264 2c20 5f20 3d20 7472 6565 5f66 6c61  rd, _ = tree_fla
-00021680: 7474 656e 2866 6f72 7761 7264 5f74 7261  tten(forward_tra
-00021690: 6365 2e6f 7574 7075 745b 315d 290a 2020  ce.output[1]).  
-000216a0: 2020 7573 6564 5f6d 6173 6b20 3d20 6c69    used_mask = li
-000216b0: 7374 286c 656e 2863 6f6e 7375 6d65 7273  st(len(consumers
-000216c0: 2e67 6574 2878 2c20 2829 2929 203e 2030  .get(x, ())) > 0
-000216d0: 2066 6f72 2078 2069 6e20 6277 5f66 6c61   for x in bw_fla
-000216e0: 745f 7361 7665 645f 666f 725f 6261 636b  t_saved_for_back
-000216f0: 7761 7264 290a 0a20 2020 2023 2044 6f6e  ward)..    # Don
-00021700: 2774 2075 7365 2074 6865 2073 616d 6520  't use the same 
-00021710: 7661 7269 6162 6c65 2074 7769 6365 2069  variable twice i
-00021720: 6e20 7468 6520 6261 636b 7761 7264 2070  n the backward p
-00021730: 6173 730a 2020 2020 7365 656e 203d 2073  ass.    seen = s
-00021740: 6574 2829 0a20 2020 2066 726f 6d20 7468  et().    from th
-00021750: 756e 6465 722e 636f 7265 2e70 726f 7869  under.core.proxi
-00021760: 6573 2069 6d70 6f72 7420 5661 7269 6162  es import Variab
-00021770: 6c65 0a0a 2020 2020 666f 7220 692c 2078  le..    for i, x
-00021780: 2069 6e20 656e 756d 6572 6174 6528 6677   in enumerate(fw
-00021790: 5f66 6c61 745f 7361 7665 645f 666f 725f  _flat_saved_for_
-000217a0: 6261 636b 7761 7264 293a 0a20 2020 2020  backward):.     
-000217b0: 2020 2078 203d 2076 6172 6961 626c 6569     x = variablei
-000217c0: 6679 2878 290a 2020 2020 2020 2020 6966  fy(x).        if
-000217d0: 206e 6f74 2069 7369 6e73 7461 6e63 6528   not isinstance(
-000217e0: 782c 2056 6172 6961 626c 6529 3a0a 2020  x, Variable):.  
-000217f0: 2020 2020 2020 2020 2020 636f 6e74 696e            contin
-00021800: 7565 0a20 2020 2020 2020 2069 6620 7820  ue.        if x 
-00021810: 696e 2073 6565 6e3a 0a20 2020 2020 2020  in seen:.       
-00021820: 2020 2020 2075 7365 645f 6d61 736b 5b69       used_mask[i
-00021830: 5d20 3d20 4661 6c73 650a 2020 2020 2020  ] = False.      
-00021840: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00021850: 2020 2020 7365 656e 2e61 6464 2878 290a      seen.add(x).
-00021860: 0a20 2020 206f 6e6c 795f 7573 6564 5f66  .    only_used_f
-00021870: 775f 7361 7665 645f 666f 725f 6261 636b  w_saved_for_back
-00021880: 7761 7264 203d 2074 7570 6c65 2863 6f6d  ward = tuple(com
-00021890: 7072 6573 7328 6677 5f66 6c61 745f 7361  press(fw_flat_sa
-000218a0: 7665 645f 666f 725f 6261 636b 7761 7264  ved_for_backward
-000218b0: 2c20 7573 6564 5f6d 6173 6b29 290a 2020  , used_mask)).  
-000218c0: 2020 6f6e 6c79 5f75 7365 645f 6277 5f73    only_used_bw_s
-000218d0: 6176 6564 5f66 6f72 5f62 6163 6b77 6172  aved_for_backwar
-000218e0: 6420 3d20 7475 706c 6528 636f 6d70 7265  d = tuple(compre
-000218f0: 7373 2862 775f 666c 6174 5f73 6176 6564  ss(bw_flat_saved
-00021900: 5f66 6f72 5f62 6163 6b77 6172 642c 2075  _for_backward, u
-00021910: 7365 645f 6d61 736b 2929 0a0a 2020 2020  sed_mask))..    
-00021920: 2320 5765 206e 6565 6420 746f 2075 7064  # We need to upd
-00021930: 6174 6520 7468 6520 7472 6163 6573 2077  ate the traces w
-00021940: 6974 6820 7468 6520 6e65 7720 7361 7665  ith the new save
-00021950: 645f 666f 725f 6261 636b 7761 7264 0a20  d_for_backward. 
-00021960: 2020 205f 7570 6461 7465 5f66 6f72 7761     _update_forwa
-00021970: 7264 5f77 6974 685f 6e65 775f 7361 7665  rd_with_new_save
-00021980: 645f 666f 725f 6261 636b 7761 7264 2866  d_for_backward(f
-00021990: 6f72 7761 7264 5f74 7261 6365 2c20 6f6e  orward_trace, on
-000219a0: 6c79 5f75 7365 645f 6677 5f73 6176 6564  ly_used_fw_saved
-000219b0: 5f66 6f72 5f62 6163 6b77 6172 6429 0a20  _for_backward). 
-000219c0: 2020 205f 7570 6461 7465 5f62 6163 6b77     _update_backw
-000219d0: 6172 645f 7769 7468 5f6e 6577 5f73 6176  ard_with_new_sav
-000219e0: 6564 5f66 6f72 5f62 6163 6b77 6172 6428  ed_for_backward(
-000219f0: 6261 636b 7761 7264 5f74 7261 6365 2c20  backward_trace, 
-00021a00: 6f6e 6c79 5f75 7365 645f 6277 5f73 6176  only_used_bw_sav
-00021a10: 6564 5f66 6f72 5f62 6163 6b77 6172 6429  ed_for_backward)
-00021a20: 0a20 2020 2066 6f72 7761 7264 5f74 7261  .    forward_tra
-00021a30: 6365 2e73 6574 5f70 726f 7665 6e61 6e63  ce.set_provenanc
-00021a40: 6528 5472 6163 6550 726f 7665 6e61 6e63  e(TraceProvenanc
-00021a50: 6528 2241 7567 6d65 6e74 6564 2066 6f72  e("Augmented for
-00021a60: 7761 7264 2070 6173 7322 2929 0a20 2020  ward pass")).   
-00021a70: 2062 6163 6b77 6172 645f 7472 6163 652e   backward_trace.
-00021a80: 7365 745f 7072 6f76 656e 616e 6365 2854  set_provenance(T
-00021a90: 7261 6365 5072 6f76 656e 616e 6365 2822  raceProvenance("
-00021aa0: 4261 636b 7761 7264 2070 6173 7322 2929  Backward pass"))
-00021ab0: 0a20 2020 2072 6574 7572 6e20 466f 7277  .    return Forw
-00021ac0: 6172 6442 6163 6b77 6172 6454 7261 6365  ardBackwardTrace
-00021ad0: 7328 666f 7277 6172 645f 7472 6163 652c  s(forward_trace,
-00021ae0: 2062 6163 6b77 6172 645f 7472 6163 6529   backward_trace)
-00021af0: 0a0a 0a23 2064 6f20 7765 2068 6170 7065  ...# do we happe
-00021b00: 6e20 746f 2077 616e 7420 746f 2072 6567  n to want to reg
-00021b10: 6973 7465 7220 606c 746f 7263 6860 206f  ister `ltorch` o
-00021b20: 7073 2073 7563 6820 6173 2060 6c74 6f72  ps such as `ltor
-00021b30: 6368 2e6c 6179 6572 5f6e 6f72 6d60 2061  ch.layer_norm` a
-00021b40: 7320 7765 6c6c 3f0a 6175 746f 6361 7374  s well?.autocast
-00021b50: 5f69 6d70 6c73 3a20 6469 6374 5b70 7269  _impls: dict[pri
-00021b60: 6d73 2e50 7269 6d49 4473 2c20 4361 6c6c  ms.PrimIDs, Call
-00021b70: 6162 6c65 5d20 3d20 7b7d 0a0a 0a64 6566  able] = {}...def
-00021b80: 2072 6567 6973 7465 725f 6175 746f 6361   register_autoca
-00021b90: 7374 5f72 756c 6528 6f70 293a 0a20 2020  st_rule(op):.   
-00021ba0: 2064 6566 2064 6563 6f72 6174 6f72 2866   def decorator(f
-00021bb0: 756e 6329 3a0a 2020 2020 2020 2020 6175  unc):.        au
-00021bc0: 746f 6361 7374 5f69 6d70 6c73 5b6f 705d  tocast_impls[op]
-00021bd0: 203d 2066 756e 630a 2020 2020 2020 2020   = func.        
-00021be0: 7265 7475 726e 2066 756e 630a 0a20 2020  return func..   
-00021bf0: 2072 6574 7572 6e20 6465 636f 7261 746f   return decorato
-00021c00: 720a 0a0a 6465 6620 6d61 7962 655f 646f  r...def maybe_do
-00021c10: 776e 6361 7374 5f74 6f28 6474 7970 652c  wncast_to(dtype,
-00021c20: 2061 7267 7329 3a0a 2020 2020 616c 6c6f   args):.    allo
-00021c30: 7765 645f 646f 776e 6361 7374 5f74 7970  wed_downcast_typ
-00021c40: 6573 203d 2028 6474 7970 6573 2e66 6c6f  es = (dtypes.flo
-00021c50: 6174 3136 2c20 6474 7970 6573 2e62 666c  at16, dtypes.bfl
-00021c60: 6f61 7431 362c 2064 7479 7065 732e 666c  oat16, dtypes.fl
-00021c70: 6f61 7433 3229 0a0a 2020 2020 6465 6620  oat32)..    def 
-00021c80: 6d61 705f 666e 2861 293a 0a20 2020 2020  map_fn(a):.     
-00021c90: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
-00021ca0: 2861 2c20 5465 6e73 6f72 5072 6f78 7929  (a, TensorProxy)
-00021cb0: 2061 6e64 2061 2e64 7479 7065 2069 6e20   and a.dtype in 
-00021cc0: 616c 6c6f 7765 645f 646f 776e 6361 7374  allowed_downcast
-00021cd0: 5f74 7970 6573 3a0a 2020 2020 2020 2020  _types:.        
-00021ce0: 2020 2020 7265 7475 726e 206d 6179 6265      return maybe
-00021cf0: 5f63 6f6e 7665 7274 5f74 6f5f 6474 7970  _convert_to_dtyp
-00021d00: 6528 612c 2064 7479 7065 290a 2020 2020  e(a, dtype).    
-00021d10: 2020 2020 7265 7475 726e 2061 0a0a 2020      return a..  
-00021d20: 2020 7265 7475 726e 2074 7265 655f 6d61    return tree_ma
-00021d30: 7028 6d61 705f 666e 2c20 6172 6773 290a  p(map_fn, args).
-00021d40: 0a0a 4072 6567 6973 7465 725f 6175 746f  ..@register_auto
-00021d50: 6361 7374 5f72 756c 6528 2274 6f72 6368  cast_rule("torch
-00021d60: 2e6d 6174 6d75 6c22 290a 4072 6567 6973  .matmul").@regis
-00021d70: 7465 725f 6175 746f 6361 7374 5f72 756c  ter_autocast_rul
-00021d80: 6528 7072 696d 732e 5072 696d 4944 732e  e(prims.PrimIDs.
-00021d90: 4d41 544d 554c 290a 6465 6620 6175 746f  MATMUL).def auto
-00021da0: 6361 7374 5f6d 6174 6d75 6c5f 7275 6c65  cast_matmul_rule
-00021db0: 2861 2c20 622c 2064 7479 7065 293a 0a20  (a, b, dtype):. 
-00021dc0: 2020 2022 2222 4175 746f 6361 7374 2072     """Autocast r
-00021dd0: 756c 6520 666f 7220 6d61 746d 756c 2222  ule for matmul""
-00021de0: 220a 2020 2020 7265 7475 726e 2070 7269  ".    return pri
-00021df0: 6d73 2e6d 6174 6d75 6c28 2a28 6d61 7962  ms.matmul(*(mayb
-00021e00: 655f 646f 776e 6361 7374 5f74 6f28 6474  e_downcast_to(dt
-00021e10: 7970 652c 2028 612c 2062 2929 2929 0a0a  ype, (a, b))))..
-00021e20: 0a40 7265 6769 7374 6572 5f61 7574 6f63  .@register_autoc
-00021e30: 6173 745f 7275 6c65 2822 746f 7263 682e  ast_rule("torch.
-00021e40: 6e6e 2e66 756e 6374 696f 6e61 6c2e 6c69  nn.functional.li
-00021e50: 6e65 6172 2229 0a40 7265 6769 7374 6572  near").@register
-00021e60: 5f61 7574 6f63 6173 745f 7275 6c65 2870  _autocast_rule(p
-00021e70: 7269 6d73 2e50 7269 6d49 4473 2e4c 494e  rims.PrimIDs.LIN
-00021e80: 4541 5229 0a64 6566 2061 7574 6f63 6173  EAR).def autocas
-00021e90: 745f 6c69 6e65 6172 5f72 756c 6528 612c  t_linear_rule(a,
-00021ea0: 2077 2c20 6269 6173 2c20 6474 7970 6529   w, bias, dtype)
-00021eb0: 3a0a 2020 2020 6966 2062 6961 7320 6973  :.    if bias is
-00021ec0: 204e 6f6e 653a 0a20 2020 2020 2020 2023   None:.        #
-00021ed0: 2044 6f6e 2774 2070 6173 7320 6062 6961   Don't pass `bia
-00021ee0: 7360 2074 6f20 6d61 7962 655f 646f 776e  s` to maybe_down
-00021ef0: 6361 7374 5f74 6f2e 0a20 2020 2020 2020  cast_to..       
-00021f00: 2064 6f77 6e63 6173 745f 6172 6773 203d   downcast_args =
-00021f10: 206d 6179 6265 5f64 6f77 6e63 6173 745f   maybe_downcast_
-00021f20: 746f 2864 7479 7065 2c20 2861 2c20 7729  to(dtype, (a, w)
-00021f30: 2920 2b20 2862 6961 732c 290a 2020 2020  ) + (bias,).    
-00021f40: 656c 7365 3a0a 2020 2020 2020 2020 646f  else:.        do
-00021f50: 776e 6361 7374 5f61 7267 7320 3d20 6d61  wncast_args = ma
-00021f60: 7962 655f 646f 776e 6361 7374 5f74 6f28  ybe_downcast_to(
-00021f70: 6474 7970 652c 2028 612c 2077 2c20 6269  dtype, (a, w, bi
-00021f80: 6173 2929 0a0a 2020 2020 7265 7475 726e  as))..    return
-00021f90: 2070 7269 6d73 2e6c 696e 6561 7228 2a64   prims.linear(*d
-00021fa0: 6f77 6e63 6173 745f 6172 6773 290a 0a0a  owncast_args)...
-00021fb0: 4072 6567 6973 7465 725f 6175 746f 6361  @register_autoca
-00021fc0: 7374 5f72 756c 6528 2274 6f72 6368 2e6e  st_rule("torch.n
-00021fd0: 6e2e 6675 6e63 7469 6f6e 616c 2e73 6361  n.functional.sca
-00021fe0: 6c65 645f 646f 745f 7072 6f64 7563 745f  led_dot_product_
-00021ff0: 6174 7465 6e74 696f 6e22 290a 6465 6620  attention").def 
-00022000: 6175 746f 6361 7374 5f73 6361 6c65 645f  autocast_scaled_
-00022010: 646f 745f 7072 6f64 7563 745f 6174 7465  dot_product_atte
-00022020: 6e74 696f 6e28 0a20 2020 2071 7565 7279  ntion(.    query
-00022030: 2c0a 2020 2020 6b65 792c 0a20 2020 2076  ,.    key,.    v
-00022040: 616c 7565 2c0a 2020 2020 6174 746e 5f6d  alue,.    attn_m
-00022050: 6173 6b2c 0a20 2020 2064 726f 706f 7574  ask,.    dropout
-00022060: 5f70 2c0a 2020 2020 6973 5f63 6175 7361  _p,.    is_causa
-00022070: 6c2c 0a20 2020 202a 2c0a 2020 2020 6474  l,.    *,.    dt
-00022080: 7970 652c 0a20 2020 2073 6361 6c65 2c0a  ype,.    scale,.
-00022090: 293a 0a20 2020 2066 726f 6d20 7468 756e  ):.    from thun
-000220a0: 6465 722e 746f 7263 6820 696d 706f 7274  der.torch import
-000220b0: 2073 6361 6c65 645f 646f 745f 7072 6f64   scaled_dot_prod
-000220c0: 7563 745f 6174 7465 6e74 696f 6e0a 0a20  uct_attention.. 
-000220d0: 2020 2071 2c20 6b2c 2076 203d 206d 6179     q, k, v = may
-000220e0: 6265 5f64 6f77 6e63 6173 745f 746f 2864  be_downcast_to(d
-000220f0: 7479 7065 2c20 2871 7565 7279 2c20 6b65  type, (query, ke
-00022100: 792c 2076 616c 7565 2929 0a20 2020 2072  y, value)).    r
-00022110: 6574 7572 6e20 7363 616c 6564 5f64 6f74  eturn scaled_dot
-00022120: 5f70 726f 6475 6374 5f61 7474 656e 7469  _product_attenti
-00022130: 6f6e 2871 2c20 6b2c 2076 2c20 6174 746e  on(q, k, v, attn
-00022140: 5f6d 6173 6b2c 2064 726f 706f 7574 5f70  _mask, dropout_p
-00022150: 2c20 6973 5f63 6175 7361 6c2c 2073 6361  , is_causal, sca
-00022160: 6c65 3d73 6361 6c65 290a 0a0a 6465 6620  le=scale)...def 
-00022170: 6175 746f 6361 7374 5f73 796d 626f 6c5f  autocast_symbol_
-00022180: 6d61 7070 6572 2862 6f75 6e64 5f73 796d  mapper(bound_sym
-00022190: 626f 6c3a 2042 6f75 6e64 5379 6d62 6f6c  bol: BoundSymbol
-000221a0: 496e 7465 7266 6163 652c 2064 7479 7065  Interface, dtype
-000221b0: 3a20 6474 7970 6573 2e64 7479 7065 293a  : dtypes.dtype):
-000221c0: 0a20 2020 2022 2222 5265 7475 726e 2074  .    """Return t
-000221d0: 6865 2063 616c 6c61 626c 6520 696d 706c  he callable impl
-000221e0: 656d 656e 7469 6e67 2074 6865 2061 7574  ementing the aut
-000221f0: 6f63 6173 7420 7275 6c65 2066 6f72 2074  ocast rule for t
-00022200: 6865 2073 796d 626f 6c2e 0a0a 2020 2020  he symbol...    
-00022210: 4172 6773 3a0a 2020 2020 2020 2020 626f  Args:.        bo
-00022220: 756e 645f 7379 6d62 6f6c 3a20 4d61 7070  und_symbol: Mapp
-00022230: 6564 2074 6f20 6974 7320 6175 746f 6361  ed to its autoca
-00022240: 7374 2072 756c 652e 0a0a 2020 2020 5265  st rule...    Re
-00022250: 7475 726e 733a 0a20 2020 2020 2020 2043  turns:.        C
-00022260: 616c 6c61 626c 653a 2054 6865 2063 616c  allable: The cal
-00022270: 6c61 626c 6520 696d 706c 656d 656e 7469  lable implementi
-00022280: 6e67 2074 6865 2061 7574 6f63 6173 7420  ng the autocast 
-00022290: 7275 6c65 2066 6f72 2074 6865 2073 796d  rule for the sym
-000222a0: 626f 6c2e 0a20 2020 2022 2222 0a20 2020  bol..    """.   
-000222b0: 2061 7574 6f63 6173 745f 696d 706c 3a20   autocast_impl: 
-000222c0: 4361 6c6c 6162 6c65 207c 204e 6f6e 6520  Callable | None 
-000222d0: 3d20 6175 746f 6361 7374 5f69 6d70 6c73  = autocast_impls
-000222e0: 2e67 6574 2862 6f75 6e64 5f73 796d 626f  .get(bound_symbo
-000222f0: 6c2e 7379 6d2e 6964 290a 2020 2020 7265  l.sym.id).    re
-00022300: 7475 726e 2062 6f75 6e64 5f73 796d 626f  turn bound_symbo
-00022310: 6c2e 7379 6d20 6966 2061 7574 6f63 6173  l.sym if autocas
-00022320: 745f 696d 706c 2069 7320 4e6f 6e65 2065  t_impl is None e
-00022330: 6c73 6520 7061 7274 6961 6c28 6175 746f  lse partial(auto
-00022340: 6361 7374 5f69 6d70 6c2c 2064 7479 7065  cast_impl, dtype
-00022350: 3d64 7479 7065 290a 0a0a 6465 6620 6175  =dtype)...def au
-00022360: 746f 6361 7374 2866 756e 633a 2043 616c  tocast(func: Cal
-00022370: 6c61 626c 652c 2064 7479 7065 3a20 6474  lable, dtype: dt
-00022380: 7970 6573 2e64 7479 7065 293a 0a20 2020  ypes.dtype):.   
-00022390: 2022 2222 5472 616e 7366 6f72 6d73 2061   """Transforms a
-000223a0: 2066 756e 6374 696f 6e20 746f 2061 7574   function to aut
-000223b0: 6f63 6173 7420 6365 7274 6169 6e20 6f70  ocast certain op
-000223c0: 6572 6174 696f 6e73 2e0a 0a20 2020 2041  erations...    A
-000223d0: 7267 733a 0a20 2020 2020 2020 2066 756e  rgs:.        fun
-000223e0: 633a 2054 6865 2066 756e 6374 696f 6e20  c: The function 
-000223f0: 746f 2062 6520 7472 616e 7366 6f72 6d65  to be transforme
-00022400: 642e 0a20 2020 2020 2020 2064 7479 7065  d..        dtype
-00022410: 3a20 5468 6520 6461 7461 2074 7970 6520  : The data type 
-00022420: 746f 2077 6869 6368 2061 7267 756d 656e  to which argumen
-00022430: 7473 206f 6620 7468 6520 6675 6e63 7469  ts of the functi
-00022440: 6f6e 206f 7220 7375 6220 6675 6e63 7469  on or sub functi
-00022450: 6f6e 7320 636f 756c 6420 6765 7420 6361  ons could get ca
-00022460: 7374 2069 660a 2020 2020 2020 2020 2020  st if.          
-00022470: 2020 7468 6579 2061 7265 2060 6474 7970    they are `dtyp
-00022480: 6573 2e66 6c6f 6174 3332 602e 0a0a 2020  es.float32`...  
-00022490: 2020 5265 7475 726e 733a 0a20 2020 2020    Returns:.     
-000224a0: 2020 2043 616c 6c61 626c 653a 2054 6865     Callable: The
-000224b0: 2074 7261 6e73 666f 726d 6564 2066 756e   transformed fun
-000224c0: 6374 696f 6e0a 2020 2020 2222 220a 0a20  ction.    """.. 
-000224d0: 2020 2069 6620 6e6f 7420 6973 696e 7374     if not isinst
-000224e0: 616e 6365 2864 7479 7065 2c20 6474 7970  ance(dtype, dtyp
-000224f0: 6573 2e64 7479 7065 293a 0a20 2020 2020  es.dtype):.     
-00022500: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
-00022510: 726f 7228 6622 6064 7479 7065 6020 6973  ror(f"`dtype` is
-00022520: 2065 7870 6563 7465 6420 746f 2062 6520   expected to be 
-00022530: 6074 6875 6e64 6572 2e64 7479 7065 2e64  `thunder.dtype.d
-00022540: 7479 7065 6020 6275 7420 7b74 7970 6528  type` but {type(
-00022550: 6474 7970 6529 7d22 290a 2020 2020 6966  dtype)}").    if
-00022560: 2064 7479 7065 206e 6f74 2069 6e20 7b64   dtype not in {d
-00022570: 7479 7065 732e 666c 6f61 7431 362c 2064  types.float16, d
-00022580: 7479 7065 732e 6266 6c6f 6174 3136 7d3a  types.bfloat16}:
-00022590: 0a20 2020 2020 2020 2072 6169 7365 2056  .        raise V
-000225a0: 616c 7565 4572 726f 7228 6622 6064 7479  alueError(f"`dty
-000225b0: 7065 6020 6973 2065 7870 6563 7465 6420  pe` is expected 
-000225c0: 746f 2062 6520 6569 7468 6572 2060 7468  to be either `th
-000225d0: 756e 6465 722e 666c 6f61 7431 3660 206f  under.float16` o
-000225e0: 7220 6074 6875 6e64 6572 2e62 666c 6f61  r `thunder.bfloa
-000225f0: 7431 3660 2c20 6275 7420 7b64 7479 7065  t16`, but {dtype
-00022600: 7d22 290a 0a20 2020 2040 7772 6170 7328  }")..    @wraps(
-00022610: 6675 6e63 290a 2020 2020 6465 6620 7772  func).    def wr
-00022620: 6170 7065 7228 2a61 7267 732c 202a 2a6b  apper(*args, **k
-00022630: 7761 7267 7329 3a0a 2020 2020 2020 2020  wargs):.        
-00022640: 7472 6163 6520 3d20 636f 6e73 7472 7563  trace = construc
-00022650: 745f 7472 6163 6528 2928 6675 6e63 2c20  t_trace()(func, 
-00022660: 2a61 7267 732c 202a 2a6b 7761 7267 7329  *args, **kwargs)
-00022670: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00022680: 6576 616c 5f74 7261 6365 2874 7261 6365  eval_trace(trace
-00022690: 2c20 2a61 7267 732c 202a 2a6b 7761 7267  , *args, **kwarg
-000226a0: 732c 2073 796d 626f 6c5f 6d61 7070 6572  s, symbol_mapper
-000226b0: 3d70 6172 7469 616c 2861 7574 6f63 6173  =partial(autocas
-000226c0: 745f 7379 6d62 6f6c 5f6d 6170 7065 722c  t_symbol_mapper,
-000226d0: 2064 7479 7065 3d64 7479 7065 2929 0a0a   dtype=dtype))..
-000226e0: 2020 2020 7265 7475 726e 2077 7261 7070      return wrapp
-000226f0: 6572 0a                                  er.
+0001df40: 2020 2020 2075 7365 645f 6e61 6d65 732e       used_names.
+0001df50: 6164 6428 6b29 0a0a 2020 2020 2020 2020  add(k)..        
+0001df60: 2020 2020 2320 466f 7220 6465 7665 6c6f      # For develo
+0001df70: 7065 7220 636f 6e76 656e 6965 6e63 652c  per convenience,
+0001df80: 2077 6520 616c 6c6f 7720 7573 696e 6720   we allow using 
+0001df90: 7468 6520 6e61 6d65 2066 726f 6d20 7468  the name from th
+0001dfa0: 650a 2020 2020 2020 2020 2020 2020 2320  e.            # 
+0001dfb0: 666f 7277 6172 6420 6d65 7461 2069 6e20  forward meta in 
+0001dfc0: 6164 6469 7469 6f6e 2074 6f20 7468 6520  addition to the 
+0001dfd0: 6e61 6d65 2066 726f 6d20 7468 6520 6175  name from the au
+0001dfe0: 676d 656e 7465 6420 666f 7277 6172 640a  gmented forward.
+0001dff0: 2020 2020 2020 2020 2020 2020 2320 7369              # si
+0001e000: 676e 6174 7572 652e 0a20 2020 2020 2020  gnature..       
+0001e010: 2020 2020 2023 2049 6620 626f 7468 206e       # If both n
+0001e020: 616d 6573 2061 7265 2075 7365 642c 2074  ames are used, t
+0001e030: 6865 206f 6e65 2066 726f 6d20 7468 6520  he one from the 
+0001e040: 666f 7277 6172 6420 6d65 7461 2074 616b  forward meta tak
+0001e050: 6573 0a20 2020 2020 2020 2020 2020 2023  es.            #
+0001e060: 2070 7265 6365 6465 6e63 652e 0a20 2020   precedence..   
+0001e070: 2020 2020 2020 2020 2066 6f72 2069 2c20           for i, 
+0001e080: 286b 2c20 7629 2069 6e20 656e 756d 6572  (k, v) in enumer
+0001e090: 6174 6528 696e 7370 6563 742e 7369 676e  ate(inspect.sign
+0001e0a0: 6174 7572 6528 7379 6d62 6f6c 2e73 796d  ature(symbol.sym
+0001e0b0: 2e6d 6574 6129 2e70 6172 616d 6574 6572  .meta).parameter
+0001e0c0: 732e 6974 656d 7328 2929 3a0a 2020 2020  s.items()):.    
+0001e0d0: 2020 2020 2020 2020 2020 2020 6966 2076              if v
+0001e0e0: 2e6b 696e 6420 696e 2028 696e 7370 6563  .kind in (inspec
+0001e0f0: 742e 5061 7261 6d65 7465 722e 504f 5349  t.Parameter.POSI
+0001e100: 5449 4f4e 414c 5f4f 4e4c 592c 2069 6e73  TIONAL_ONLY, ins
+0001e110: 7065 6374 2e50 6172 616d 6574 6572 2e50  pect.Parameter.P
+0001e120: 4f53 4954 494f 4e41 4c5f 4f52 5f4b 4559  OSITIONAL_OR_KEY
+0001e130: 574f 5244 293a 0a20 2020 2020 2020 2020  WORD):.         
+0001e140: 2020 2020 2020 2020 2020 2069 6620 6b20             if k 
+0001e150: 6e6f 7420 696e 2075 7365 645f 6e61 6d65  not in used_name
+0001e160: 733a 0a20 2020 2020 2020 2020 2020 2020  s:.             
+0001e170: 2020 2020 2020 2020 2020 2070 7574 5f67             put_g
+0001e180: 7261 6428 7379 6d62 6f6c 2e61 7267 735b  rad(symbol.args[
+0001e190: 695d 2c20 7265 7375 6c74 2e67 6574 286b  i], result.get(k
+0001e1a0: 2c20 4e6f 6e65 2929 0a20 2020 2020 2020  , None)).       
+0001e1b0: 2020 2020 2063 6f6e 7469 6e75 650a 0a20       continue.. 
+0001e1c0: 2020 2020 2020 2069 6620 6e6f 7420 6973         if not is
+0001e1d0: 696e 7374 616e 6365 2872 6573 756c 742c  instance(result,
+0001e1e0: 2053 6571 7565 6e63 6529 3a0a 2020 2020   Sequence):.    
+0001e1f0: 2020 2020 2020 2020 7265 7375 6c74 203d          result =
+0001e200: 2028 7265 7375 6c74 2c29 0a0a 2020 2020   (result,)..    
+0001e210: 2020 2020 6465 6620 6973 5f64 6966 6665      def is_diffe
+0001e220: 7265 6e74 6961 626c 6528 6172 6729 3a0a  rentiable(arg):.
+0001e230: 2020 2020 2020 2020 2020 2020 6d61 7463              matc
+0001e240: 6820 6172 673a 0a20 2020 2020 2020 2020  h arg:.         
+0001e250: 2020 2020 2020 2063 6173 6520 5465 6e73         case Tens
+0001e260: 6f72 5072 6f78 7928 293a 0a20 2020 2020  orProxy():.     
+0001e270: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+0001e280: 6574 7572 6e20 6474 7970 6573 2e69 735f  eturn dtypes.is_
+0001e290: 696e 6578 6163 745f 6474 7970 6528 6172  inexact_dtype(ar
+0001e2a0: 672e 6474 7970 6529 0a20 2020 2020 2020  g.dtype).       
+0001e2b0: 2020 2020 2020 2020 2063 6173 6520 5365           case Se
+0001e2c0: 7175 656e 6365 2829 3a0a 2020 2020 2020  quence():.      
+0001e2d0: 2020 2020 2020 2020 2020 2020 2020 7265                re
+0001e2e0: 7475 726e 2061 7267 2061 6e64 2061 6c6c  turn arg and all
+0001e2f0: 2869 7369 6e73 7461 6e63 6528 782c 2054  (isinstance(x, T
+0001e300: 656e 736f 7250 726f 7879 2920 616e 6420  ensorProxy) and 
+0001e310: 6474 7970 6573 2e69 735f 696e 6578 6163  dtypes.is_inexac
+0001e320: 745f 6474 7970 6528 782e 6474 7970 6529  t_dtype(x.dtype)
+0001e330: 2066 6f72 2078 2069 6e20 6172 6729 0a20   for x in arg). 
+0001e340: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+0001e350: 6173 6520 5f3a 0a20 2020 2020 2020 2020  ase _:.         
+0001e360: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0001e370: 6e20 4661 6c73 650a 0a20 2020 2020 2020  n False..       
+0001e380: 2069 6620 6c65 6e28 7379 6d62 6f6c 2e61   if len(symbol.a
+0001e390: 7267 7329 2021 3d20 286f 7269 675f 7265  rgs) != (orig_re
+0001e3a0: 735f 6c65 6e20 3a3d 206c 656e 2872 6573  s_len := len(res
+0001e3b0: 756c 7429 293a 0a20 2020 2020 2020 2020  ult)):.         
+0001e3c0: 2020 2063 6865 636b 280a 2020 2020 2020     check(.      
+0001e3d0: 2020 2020 2020 2020 2020 6f72 6967 5f72            orig_r
+0001e3e0: 6573 5f6c 656e 203c 3d20 6c65 6e28 7379  es_len <= len(sy
+0001e3f0: 6d62 6f6c 2e61 7267 7329 2c0a 2020 2020  mbol.args),.    
+0001e400: 2020 2020 2020 2020 2020 2020 6c61 6d62              lamb
+0001e410: 6461 3a20 6622 4261 636b 7761 7264 2066  da: f"Backward f
+0001e420: 6f72 207b 7379 6d62 6f6c 2e73 796d 2e69  or {symbol.sym.i
+0001e430: 647d 2072 6574 7572 6e65 6420 7b6f 7269  d} returned {ori
+0001e440: 675f 7265 735f 6c65 6e7d 2076 616c 7565  g_res_len} value
+0001e450: 732c 2022 0a20 2020 2020 2020 2020 2020  s, ".           
+0001e460: 2020 2020 202b 2066 2262 7574 2065 7870       + f"but exp
+0001e470: 6563 7465 6420 6174 206d 6f73 7420 7b6c  ected at most {l
+0001e480: 656e 2873 796d 626f 6c2e 6172 6773 297d  en(symbol.args)}
+0001e490: 222c 0a20 2020 2020 2020 2020 2020 2029  ",.            )
+0001e4a0: 0a20 2020 2020 2020 2020 2020 2023 2041  .            # A
+0001e4b0: 7373 756d 696e 6720 7468 6174 2074 6865  ssuming that the
+0001e4c0: 206e 6f6e 2d64 6966 6665 7265 6e74 6961   non-differentia
+0001e4d0: 626c 6520 6172 6775 6d65 6e74 7320 7765  ble arguments we
+0001e4e0: 7265 2064 726f 7070 6564 2066 726f 6d0a  re dropped from.
+0001e4f0: 2020 2020 2020 2020 2020 2020 2320 7468              # th
+0001e500: 6520 6261 636b 7761 7264 2066 756e 6374  e backward funct
+0001e510: 696f 6e2c 2077 6520 6172 6520 676f 696e  ion, we are goin
+0001e520: 6720 746f 2061 7070 656e 6420 4e6f 6e65  g to append None
+0001e530: 2074 6f20 7468 6520 7265 7375 6c74 0a20   to the result. 
+0001e540: 2020 2020 2020 2020 2020 2023 2074 6f20             # to 
+0001e550: 6d61 7463 6820 7468 6520 6e75 6d62 6572  match the number
+0001e560: 206f 6620 6172 6775 6d65 6e74 732e 2041   of arguments. A
+0001e570: 6c74 6572 6e61 7469 7665 6c79 2c20 7765  lternatively, we
+0001e580: 2063 6f75 6c64 206a 7573 740a 2020 2020   could just.    
+0001e590: 2020 2020 2020 2020 2320 6861 7665 2061          # have a
+0001e5a0: 2066 6f72 2d6c 6f6f 7020 7769 7468 2061   for-loop with a
+0001e5b0: 2063 6f6e 6469 7469 6f6e 616c 2077 6865   conditional whe
+0001e5c0: 6e20 7772 6974 696e 6720 746f 2074 6865  n writing to the
+0001e5d0: 0a20 2020 2020 2020 2020 2020 2023 2065  .            # e
+0001e5e0: 6e76 6972 6f6e 6d65 6e74 2e0a 0a20 2020  nvironment...   
+0001e5f0: 2020 2020 2020 2020 2069 7465 725f 7265           iter_re
+0001e600: 7375 6c74 203d 2069 7465 7228 7265 7375  sult = iter(resu
+0001e610: 6c74 290a 2020 2020 2020 2020 2020 2020  lt).            
+0001e620: 6e5f 6469 6666 6572 656e 7469 6162 6c65  n_differentiable
+0001e630: 5f61 7267 7320 3d20 7375 6d28 626f 6f6c  _args = sum(bool
+0001e640: 2869 735f 6469 6666 6572 656e 7469 6162  (is_differentiab
+0001e650: 6c65 2861 7267 2929 2066 6f72 2061 7267  le(arg)) for arg
+0001e660: 2069 6e20 7379 6d62 6f6c 2e61 7267 7329   in symbol.args)
+0001e670: 0a20 2020 2020 2020 2020 2020 2063 6865  .            che
+0001e680: 636b 280a 2020 2020 2020 2020 2020 2020  ck(.            
+0001e690: 2020 2020 6e5f 6469 6666 6572 656e 7469      n_differenti
+0001e6a0: 6162 6c65 5f61 7267 7320 3c3d 206f 7269  able_args <= ori
+0001e6b0: 675f 7265 735f 6c65 6e2c 0a20 2020 2020  g_res_len,.     
+0001e6c0: 2020 2020 2020 2020 2020 206c 616d 6264             lambd
+0001e6d0: 613a 2066 2242 6163 6b77 6172 6420 666f  a: f"Backward fo
+0001e6e0: 7220 7b73 796d 626f 6c2e 7379 6d2e 6964  r {symbol.sym.id
+0001e6f0: 7d20 7265 7475 726e 6564 207b 6f72 6967  } returned {orig
+0001e700: 5f72 6573 5f6c 656e 7d20 7661 6c75 6528  _res_len} value(
+0001e710: 7329 2c20 220a 2020 2020 2020 2020 2020  s), ".          
+0001e720: 2020 2020 2020 2b20 6622 6275 7420 6578        + f"but ex
+0001e730: 7065 6374 6564 207b 6e5f 6469 6666 6572  pected {n_differ
+0001e740: 656e 7469 6162 6c65 5f61 7267 737d 222c  entiable_args}",
+0001e750: 0a20 2020 2020 2020 2020 2020 2029 0a0a  .            )..
+0001e760: 2020 2020 2020 2020 2020 2020 7265 7375              resu
+0001e770: 6c74 203d 2074 7570 6c65 286e 6578 7428  lt = tuple(next(
+0001e780: 6974 6572 5f72 6573 756c 7429 2069 6620  iter_result) if 
+0001e790: 6973 5f64 6966 6665 7265 6e74 6961 626c  is_differentiabl
+0001e7a0: 6528 6172 6729 2065 6c73 6520 4e6f 6e65  e(arg) else None
+0001e7b0: 2066 6f72 2061 7267 2069 6e20 7379 6d62   for arg in symb
+0001e7c0: 6f6c 2e61 7267 7329 0a0a 2020 2020 2020  ol.args)..      
+0001e7d0: 2020 2320 5365 6520 2242 6163 6b77 6172    # See "Backwar
+0001e7e0: 6420 696d 706c 2066 6f72 206f 7073 206f  d impl for ops o
+0001e7f0: 6620 7468 6520 7479 7065 2053 6571 7565  f the type Seque
+0001e800: 6e63 655b 5465 6e73 6f72 5072 6f78 795d  nce[TensorProxy]
+0001e810: 2c20 2e2e 2e20 2d3e 202e 2e2e 2072 6573  , ... -> ... res
+0001e820: 756c 7473 2069 6e20 4e6f 6e65 2067 7261  ults in None gra
+0001e830: 6473 2e22 0a20 2020 2020 2020 2023 2054  ds.".        # T
+0001e840: 6869 7320 6973 2061 2074 656d 706f 7261  his is a tempora
+0001e850: 7279 2077 6f72 6b61 726f 756e 642e 0a20  ry workaround.. 
+0001e860: 2020 2020 2020 2069 6620 7379 6d62 6f6c         if symbol
+0001e870: 2e73 796d 2e69 6420 696e 2028 7072 696d  .sym.id in (prim
+0001e880: 732e 5072 696d 4944 732e 4341 542c 2022  s.PrimIDs.CAT, "
+0001e890: 746f 7263 682e 6361 7422 2c20 2274 6f72  torch.cat", "tor
+0001e8a0: 6368 2e73 7461 636b 2229 3a0a 2020 2020  ch.stack"):.    
+0001e8b0: 2020 2020 2020 2020 7361 6665 5f6d 6170          safe_map
+0001e8c0: 5f66 6c61 7428 7075 745f 6772 6164 2c20  _flat(put_grad, 
+0001e8d0: 7379 6d62 6f6c 2e61 7267 732c 2072 6573  symbol.args, res
+0001e8e0: 756c 7429 0a20 2020 2020 2020 2065 6c73  ult).        els
+0001e8f0: 653a 0a20 2020 2020 2020 2020 2020 2073  e:.            s
+0001e900: 6166 655f 6d61 7028 7075 745f 6772 6164  afe_map(put_grad
+0001e910: 2c20 7379 6d62 6f6c 2e61 7267 732c 2072  , symbol.args, r
+0001e920: 6573 756c 7429 0a0a 2020 2020 6465 6620  esult)..    def 
+0001e930: 6765 745f 696e 6578 6163 745f 6474 7970  get_inexact_dtyp
+0001e940: 655f 6f72 5f6e 6f6e 6528 7829 3a0a 2020  e_or_none(x):.  
+0001e950: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
+0001e960: 6e63 6528 782c 2028 5465 6e73 6f72 5072  nce(x, (TensorPr
+0001e970: 6f78 792c 2046 7574 7572 6554 656e 736f  oxy, FutureTenso
+0001e980: 7250 726f 7879 2929 2061 6e64 2064 7479  rProxy)) and dty
+0001e990: 7065 732e 6973 5f69 6e65 7861 6374 5f64  pes.is_inexact_d
+0001e9a0: 7479 7065 2878 2e64 7479 7065 293a 0a20  type(x.dtype):. 
+0001e9b0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0001e9c0: 6e20 780a 2020 2020 2020 2020 656c 7365  n x.        else
+0001e9d0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+0001e9e0: 7475 726e 204e 6f6e 650a 0a20 2020 2067  turn None..    g
+0001e9f0: 6172 6773 203d 2074 7265 655f 6d61 7028  args = tree_map(
+0001ea00: 6765 745f 6772 6164 2c20 7475 706c 6528  get_grad, tuple(
+0001ea10: 7472 6163 652e 6172 6773 2929 0a20 2020  trace.args)).   
+0001ea20: 2067 6b77 6172 6773 203d 2074 7265 655f   gkwargs = tree_
+0001ea30: 6d61 7028 6765 745f 6772 6164 2c20 7472  map(get_grad, tr
+0001ea40: 6163 652e 6b77 6172 6773 290a 2020 2020  ace.kwargs).    
+0001ea50: 676b 7761 7267 7320 3d20 7b6b 3a20 7620  gkwargs = {k: v 
+0001ea60: 666f 7220 6b2c 2076 2069 6e20 676b 7761  for k, v in gkwa
+0001ea70: 7267 732e 6974 656d 7328 2920 6966 2076  rgs.items() if v
+0001ea80: 2069 7320 6e6f 7420 4e6f 6e65 7d0a 2020   is not None}.  
+0001ea90: 2020 6761 7267 732c 2067 6b77 6172 6773    gargs, gkwargs
+0001eaa0: 203d 2074 7265 655f 6d61 7028 6765 745f   = tree_map(get_
+0001eab0: 696e 6578 6163 745f 6474 7970 655f 6f72  inexact_dtype_or
+0001eac0: 5f6e 6f6e 652c 2028 6761 7267 732c 2067  _none, (gargs, g
+0001ead0: 6b77 6172 6773 2929 0a20 2020 2072 6574  kwargs)).    ret
+0001eae0: 7572 6e20 6761 7267 7320 2b20 2867 6b77  urn gargs + (gkw
+0001eaf0: 6172 6773 2c29 2069 6620 6c65 6e28 676b  args,) if len(gk
+0001eb00: 7761 7267 7329 2021 3d20 3020 656c 7365  wargs) != 0 else
+0001eb10: 2067 6172 6773 0a0a 0a64 6566 2076 6a70   gargs...def vjp
+0001eb20: 5f63 616c 6c5f 6d65 7461 6675 6e63 2864  _call_metafunc(d
+0001eb30: 6574 6163 6865 643a 2062 6f6f 6c2c 2070  etached: bool, p
+0001eb40: 7269 6d61 6c73 2c20 636f 7461 6e67 656e  rimals, cotangen
+0001eb50: 7473 2c20 7472 6163 653a 2054 7261 6365  ts, trace: Trace
+0001eb60: 2c20 2a2a 6b77 6172 6773 293a 0a20 2020  , **kwargs):.   
+0001eb70: 2023 2041 7373 756d 696e 6720 7072 696d   # Assuming prim
+0001eb80: 616c 7320 6973 2066 6c61 740a 0a20 2020  als is flat..   
+0001eb90: 2069 6620 6e6f 7420 6973 696e 7374 616e   if not isinstan
+0001eba0: 6365 2870 7269 6d61 6c73 2c20 5365 7175  ce(primals, Sequ
+0001ebb0: 656e 6365 293a 0a20 2020 2020 2020 2070  ence):.        p
+0001ebc0: 7269 6d61 6c73 203d 2028 7072 696d 616c  rimals = (primal
+0001ebd0: 732c 290a 0a20 2020 2063 7478 203d 2064  s,)..    ctx = d
+0001ebe0: 6574 6163 6865 645f 7472 6163 6528 2920  etached_trace() 
+0001ebf0: 6966 2064 6574 6163 6865 6420 656c 7365  if detached else
+0001ec00: 206e 756c 6c63 6f6e 7465 7874 2829 0a20   nullcontext(). 
+0001ec10: 2020 2077 6974 6820 6374 783a 0a20 2020     with ctx:.   
+0001ec20: 2020 2020 2072 6573 756c 742c 2065 6e76       result, env
+0001ec30: 203d 2061 7567 6d65 6e74 6564 5f66 6f72   = augmented_for
+0001ec40: 7761 7264 5f70 6173 7328 2a70 7269 6d61  ward_pass(*prima
+0001ec50: 6c73 2c20 7472 6163 653d 7472 6163 652c  ls, trace=trace,
+0001ec60: 202a 2a6b 7761 7267 7329 0a20 2020 2020   **kwargs).     
+0001ec70: 2020 2063 6865 636b 280a 2020 2020 2020     check(.      
+0001ec80: 2020 2020 2020 6c65 6e28 7265 7375 6c74        len(result
+0001ec90: 2920 3d3d 206c 656e 2863 6f74 616e 6765  ) == len(cotange
+0001eca0: 6e74 7329 2069 6620 6973 696e 7374 616e  nts) if isinstan
+0001ecb0: 6365 2872 6573 756c 742c 2053 6571 7565  ce(result, Seque
+0001ecc0: 6e63 6529 2065 6c73 6520 5472 7565 2c0a  nce) else True,.
+0001ecd0: 2020 2020 2020 2020 2020 2020 6c61 6d62              lamb
+0001ece0: 6461 3a20 6622 4578 7065 6374 6564 2063  da: f"Expected c
+0001ecf0: 6f74 616e 6765 6e74 7320 746f 2062 6520  otangents to be 
+0001ed00: 6120 7365 7175 656e 6365 206f 6620 6c65  a sequence of le
+0001ed10: 6e67 7468 207b 6c65 6e28 7265 7375 6c74  ngth {len(result
+0001ed20: 297d 2c20 676f 7420 6120 7365 7175 656e  )}, got a sequen
+0001ed30: 6365 206f 6620 6c65 6e67 7468 207b 6c65  ce of length {le
+0001ed40: 6e28 636f 7461 6e67 656e 7473 297d 222c  n(cotangents)}",
+0001ed50: 0a20 2020 2020 2020 2029 0a20 2020 2020  .        ).     
+0001ed60: 2020 2072 6574 7572 6e20 7265 7375 6c74     return result
+0001ed70: 2c20 6261 636b 7761 7264 5f70 6173 7328  , backward_pass(
+0001ed80: 656e 762c 2074 7261 6365 2c20 636f 7461  env, trace, cota
+0001ed90: 6e67 656e 7473 290a 0a0a 2320 544f 444f  ngents)...# TODO
+0001eda0: 3a20 4361 6e27 7420 7573 6520 6120 5379  : Can't use a Sy
+0001edb0: 6d62 6f6c 2068 6572 6520 6265 6361 7573  mbol here becaus
+0001edc0: 6520 6d69 7865 6420 6578 6563 7574 6f72  e mixed executor
+0001edd0: 2073 7962 7379 6d62 6f6c 7320 7365 656d   sybsymbols seem
+0001ede0: 2074 6f20 6265 0a23 2075 6e73 7570 706f   to be.# unsuppo
+0001edf0: 7274 6564 2e20 5365 6520 6973 7375 6520  rted. See issue 
+0001ee00: 2243 6f75 6c64 206e 6f74 2066 696e 6420  "Could not find 
+0001ee10: 616e 2065 7865 6375 746f 7220 666f 7220  an executor for 
+0001ee20: 626f 756e 6420 7379 6d62 6f6c 2077 6865  bound symbol whe
+0001ee30: 6e20 6974 7320 7375 6273 796d 626f 6c73  n its subsymbols
+0001ee40: 0a23 2061 7265 206e 6f74 2066 756c 6c79  .# are not fully
+0001ee50: 2073 7570 706f 7274 6564 2062 7920 6120   supported by a 
+0001ee60: 7369 6e67 6c65 2065 7865 6375 746f 7222  single executor"
+0001ee70: 0a76 6a70 5f63 616c 6c20 3d20 7061 7274  .vjp_call = part
+0001ee80: 6961 6c28 0a20 2020 2076 6a70 5f63 616c  ial(.    vjp_cal
+0001ee90: 6c5f 6d65 7461 6675 6e63 2c20 4661 6c73  l_metafunc, Fals
+0001eea0: 650a 2920 2023 2053 796d 626f 6c28 6964  e.)  # Symbol(id
+0001eeb0: 3d54 7261 6e73 666f 726d 732e 566a 704f  =Transforms.VjpO
+0001eec0: 702c 206e 616d 653d 2276 6a70 5f63 616c  p, name="vjp_cal
+0001eed0: 6c22 2c20 6d65 7461 3d70 6172 7469 616c  l", meta=partial
+0001eee0: 2876 6a70 5f63 616c 6c5f 6d65 7461 6675  (vjp_call_metafu
+0001eef0: 6e63 2c20 4661 6c73 6529 290a 0a0a 6465  nc, False))...de
+0001ef00: 6620 766a 7028 6675 6e63 293a 0a20 2020  f vjp(func):.   
+0001ef10: 2022 2222 436f 6d70 7574 6573 2074 6865   """Computes the
+0001ef20: 2056 4a50 206f 6620 6120 6675 6e63 7469   VJP of a functi
+0001ef30: 6f6e 2e0a 0a20 2020 2041 7267 733a 0a20  on...    Args:. 
+0001ef40: 2020 2020 2020 2066 756e 6320 2843 616c         func (Cal
+0001ef50: 6c61 626c 6529 3a20 4675 6e63 7469 6f6e  lable): Function
+0001ef60: 2074 6f20 6265 2064 6966 6665 7265 6e74   to be different
+0001ef70: 6961 7465 642e 0a20 2020 2022 2222 0a0a  iated..    """..
+0001ef80: 2020 2020 6465 6620 5f76 6a70 2870 7269      def _vjp(pri
+0001ef90: 6d61 6c73 2c20 636f 7461 6e67 656e 7473  mals, cotangents
+0001efa0: 2c20 2a2a 6b77 6172 6773 293a 0a20 2020  , **kwargs):.   
+0001efb0: 2020 2020 2066 6c61 745f 6675 6e63 2c20       flat_func, 
+0001efc0: 666c 6174 5f61 7267 732c 2073 7065 6320  flat_args, spec 
+0001efd0: 3d20 666c 6174 7465 6e5f 6675 6e63 2866  = flatten_func(f
+0001efe0: 756e 632c 2070 7269 6d61 6c73 2c20 6b77  unc, primals, kw
+0001eff0: 6172 6773 290a 2020 2020 2020 2020 7472  args).        tr
+0001f000: 6163 6520 3d20 636f 6e73 7472 7563 745f  ace = construct_
+0001f010: 7472 6163 6528 2928 666c 6174 5f66 756e  trace()(flat_fun
+0001f020: 632c 202a 666c 6174 5f61 7267 7329 0a20  c, *flat_args). 
+0001f030: 2020 2020 2020 2072 6573 756c 742c 2076         result, v
+0001f040: 6a70 5f72 6573 756c 7420 3d20 766a 705f  jp_result = vjp_
+0001f050: 6361 6c6c 2866 6c61 745f 6172 6773 2c20  call(flat_args, 
+0001f060: 636f 7461 6e67 656e 7473 2c20 7472 6163  cotangents, trac
+0001f070: 653d 7472 6163 6529 0a20 2020 2020 2020  e=trace).       
+0001f080: 2067 7072 696d 616c 732c 2067 6b77 6172   gprimals, gkwar
+0001f090: 6773 203d 2074 7265 655f 756e 666c 6174  gs = tree_unflat
+0001f0a0: 7465 6e28 766a 705f 7265 7375 6c74 2c20  ten(vjp_result, 
+0001f0b0: 7370 6563 290a 2020 2020 2020 2020 6772  spec).        gr
+0001f0c0: 6164 7320 3d20 6770 7269 6d61 6c73 202b  ads = gprimals +
+0001f0d0: 2028 676b 7761 7267 732c 2920 6966 206c   (gkwargs,) if l
+0001f0e0: 656e 2867 6b77 6172 6773 2920 213d 2030  en(gkwargs) != 0
+0001f0f0: 2065 6c73 6520 6770 7269 6d61 6c73 0a20   else gprimals. 
+0001f100: 2020 2020 2020 2072 6574 7572 6e20 7265         return re
+0001f110: 7375 6c74 2c20 6772 6164 730a 0a20 2020  sult, grads..   
+0001f120: 2072 6574 7572 6e20 5f76 6a70 0a0a 0a64   return _vjp...d
+0001f130: 6566 2076 616c 7565 5f61 6e64 5f67 7261  ef value_and_gra
+0001f140: 6428 6675 6e63 293a 0a20 2020 2022 2222  d(func):.    """
+0001f150: 436f 6d70 7574 6573 2074 6865 2076 616c  Computes the val
+0001f160: 7565 2061 6e64 2067 7261 6469 656e 7420  ue and gradient 
+0001f170: 6f66 2061 2066 756e 6374 696f 6e2e 0a0a  of a function...
+0001f180: 2020 2020 5468 6973 2069 7320 6120 636f      This is a co
+0001f190: 6e76 656e 6965 6e63 6520 6675 6e63 7469  nvenience functi
+0001f1a0: 6f6e 2074 6861 7420 636f 6d62 696e 6573  on that combines
+0001f1b0: 2074 6865 2066 756e 6374 696f 6e61 6c69   the functionali
+0001f1c0: 7479 206f 660a 2020 2020 6076 6a70 5f63  ty of.    `vjp_c
+0001f1d0: 616c 6c60 2077 6974 6820 696d 706c 6963  all` with implic
+0001f1e0: 6974 2069 6e69 7469 616c 697a 6174 696f  it initializatio
+0001f1f0: 6e20 6f66 2074 6865 2063 6f74 616e 6765  n of the cotange
+0001f200: 6e74 2074 6f20 312e 0a0a 2020 2020 4172  nt to 1...    Ar
+0001f210: 6773 3a0a 2020 2020 2020 2020 6675 6e63  gs:.        func
+0001f220: 2028 4361 6c6c 6162 6c65 293a 2046 756e   (Callable): Fun
+0001f230: 6374 696f 6e20 746f 2062 6520 6469 6666  ction to be diff
+0001f240: 6572 656e 7469 6174 6564 2e0a 2020 2020  erentiated..    
+0001f250: 2222 220a 0a20 2020 2064 6566 206f 6e65  """..    def one
+0001f260: 735f 6c69 6b65 2878 293a 0a20 2020 2020  s_like(x):.     
+0001f270: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
+0001f280: 2878 2c20 5465 6e73 6f72 5072 6f78 7929  (x, TensorProxy)
+0001f290: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+0001f2a0: 7475 726e 2066 756c 6c5f 6c69 6b65 2878  turn full_like(x
+0001f2b0: 2c20 6669 6c6c 5f76 616c 7565 3d31 290a  , fill_value=1).
+0001f2c0: 2020 2020 2020 2020 656c 6966 2069 7369          elif isi
+0001f2d0: 6e73 7461 6e63 6528 782c 204e 756d 6265  nstance(x, Numbe
+0001f2e0: 7250 726f 7879 293a 0a20 2020 2020 2020  rProxy):.       
+0001f2f0: 2020 2020 2072 6574 7572 6e20 7479 7065       return type
+0001f300: 2878 2e76 616c 7565 2928 3129 0a20 2020  (x.value)(1).   
+0001f310: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+0001f320: 2020 2020 2020 2072 6574 7572 6e20 4e6f         return No
+0001f330: 6e65 0a0a 2020 2020 6465 6620 5f76 616c  ne..    def _val
+0001f340: 7565 5f61 6e64 5f67 7261 6428 2a61 7267  ue_and_grad(*arg
+0001f350: 732c 202a 2a6b 7761 7267 7329 3a0a 2020  s, **kwargs):.  
+0001f360: 2020 2020 2020 7472 6163 6520 3d20 636f        trace = co
+0001f370: 6e73 7472 7563 745f 7472 6163 6528 2928  nstruct_trace()(
+0001f380: 6675 6e63 2c20 2a61 7267 732c 202a 2a6b  func, *args, **k
+0001f390: 7761 7267 7329 0a20 2020 2020 2020 2063  wargs).        c
+0001f3a0: 6f74 616e 6765 6e74 7320 3d20 7472 6565  otangents = tree
+0001f3b0: 5f6d 6170 286c 616d 6264 6120 763a 206f  _map(lambda v: o
+0001f3c0: 6e65 735f 6c69 6b65 2876 292c 2074 7261  nes_like(v), tra
+0001f3d0: 6365 2e6f 7574 7075 7429 0a20 2020 2020  ce.output).     
+0001f3e0: 2020 2072 6574 7572 6e20 766a 7028 6675     return vjp(fu
+0001f3f0: 6e63 2928 6172 6773 2c20 636f 7461 6e67  nc)(args, cotang
+0001f400: 656e 7473 2c20 2a2a 6b77 6172 6773 290a  ents, **kwargs).
+0001f410: 0a20 2020 2072 6574 7572 6e20 5f76 616c  .    return _val
+0001f420: 7565 5f61 6e64 5f67 7261 640a 0a0a 466f  ue_and_grad...Fo
+0001f430: 7277 6172 6442 6163 6b77 6172 6454 7261  rwardBackwardTra
+0001f440: 6365 7320 3d20 6e61 6d65 6474 7570 6c65  ces = namedtuple
+0001f450: 2822 466f 7277 6172 6442 6163 6b77 6172  ("ForwardBackwar
+0001f460: 6454 7261 6365 7322 2c20 5b22 666f 7277  dTraces", ["forw
+0001f470: 6172 645f 7472 6163 6522 2c20 2262 6163  ard_trace", "bac
+0001f480: 6b77 6172 645f 7472 6163 6522 5d29 0a0a  kward_trace"])..
+0001f490: 0a64 6566 205f 7370 6c69 745f 7361 7665  .def _split_save
+0001f4a0: 645f 666f 725f 6261 636b 7761 7264 5f69  d_for_backward_i
+0001f4b0: 6e74 6f5f 7465 6e73 6f72 735f 616e 645f  nto_tensors_and_
+0001f4c0: 6f74 6865 7228 0a20 2020 2073 6176 6564  other(.    saved
+0001f4d0: 5f66 6f72 5f62 6163 6b77 6172 643a 2053  _for_backward: S
+0001f4e0: 6571 7565 6e63 655b 5661 7269 6162 6c65  equence[Variable
+0001f4f0: 5d2c 0a29 202d 3e20 7475 706c 655b 5365  ],.) -> tuple[Se
+0001f500: 7175 656e 6365 5b56 6172 6961 626c 655d  quence[Variable]
+0001f510: 2c20 5365 7175 656e 6365 5b56 6172 6961  , Sequence[Varia
+0001f520: 626c 655d 5d3a 0a20 2020 2022 2222 5370  ble]]:.    """Sp
+0001f530: 6c69 7473 2073 6176 6564 5f66 6f72 5f62  lits saved_for_b
+0001f540: 6163 6b77 6172 6420 696e 746f 2074 656e  ackward into ten
+0001f550: 736f 7273 2061 6e64 206f 7468 6572 2e0a  sors and other..
+0001f560: 0a20 2020 2041 7267 733a 0a20 2020 2020  .    Args:.     
+0001f570: 2020 2073 6176 6564 5f66 6f72 5f62 6163     saved_for_bac
+0001f580: 6b77 6172 6420 2853 6571 7565 6e63 655b  kward (Sequence[
+0001f590: 5661 7269 6162 6c65 5d29 3a20 5361 7665  Variable]): Save
+0001f5a0: 645f 666f 725f 6261 636b 7761 7264 2074  d_for_backward t
+0001f5b0: 6f20 7370 6c69 742e 0a0a 2020 2020 5265  o split...    Re
+0001f5c0: 7475 726e 733a 0a20 2020 2020 2020 2074  turns:.        t
+0001f5d0: 7570 6c65 5b53 6571 7565 6e63 655b 5661  uple[Sequence[Va
+0001f5e0: 7269 6162 6c65 5d2c 2053 6571 7565 6e63  riable], Sequenc
+0001f5f0: 655b 5661 7269 6162 6c65 5d5d 3a20 5475  e[Variable]]: Tu
+0001f600: 706c 6520 6f66 2074 656e 736f 7273 2061  ple of tensors a
+0001f610: 6e64 206f 7468 6572 2e0a 2020 2020 2222  nd other..    ""
+0001f620: 220a 2020 2020 6973 5f74 656e 736f 7220  ".    is_tensor 
+0001f630: 3d20 6c61 6d62 6461 2078 3a20 6973 696e  = lambda x: isin
+0001f640: 7374 616e 6365 2878 2c20 5465 6e73 6f72  stance(x, Tensor
+0001f650: 5072 6f78 7929 0a20 2020 206f 7468 6572  Proxy).    other
+0001f660: 2c20 7465 6e73 6f72 7320 3d20 7574 696c  , tensors = util
+0001f670: 732e 7061 7274 6974 696f 6e28 6973 5f74  s.partition(is_t
+0001f680: 656e 736f 722c 2073 6176 6564 5f66 6f72  ensor, saved_for
+0001f690: 5f62 6163 6b77 6172 6429 0a20 2020 2072  _backward).    r
+0001f6a0: 6574 7572 6e20 7475 706c 6528 7465 6e73  eturn tuple(tens
+0001f6b0: 6f72 7329 2c20 7475 706c 6528 6f74 6865  ors), tuple(othe
+0001f6c0: 7229 0a0a 0a64 6566 205f 7570 6461 7465  r)...def _update
+0001f6d0: 5f66 6f72 7761 7264 5f77 6974 685f 6e65  _forward_with_ne
+0001f6e0: 775f 7361 7665 645f 666f 725f 6261 636b  w_saved_for_back
+0001f6f0: 7761 7264 2866 6f72 7761 7264 5f74 7261  ward(forward_tra
+0001f700: 6365 3a20 5472 6163 652c 2073 6176 6564  ce: Trace, saved
+0001f710: 5f66 6f72 5f62 6163 6b77 6172 643a 2053  _for_backward: S
+0001f720: 6571 7565 6e63 655b 5661 7269 6162 6c65  equence[Variable
+0001f730: 5d29 202d 3e20 4e6f 6e65 3a0a 2020 2020  ]) -> None:.    
+0001f740: 2222 2255 7064 6174 6573 2074 6865 2066  """Updates the f
+0001f750: 6f72 7761 7264 2074 7261 6365 2077 6974  orward trace wit
+0001f760: 6820 6e65 7720 7361 7665 645f 666f 725f  h new saved_for_
+0001f770: 6261 636b 7761 7264 2e0a 0a20 2020 2054  backward...    T
+0001f780: 6869 7320 6973 206e 6563 6573 7361 7279  his is necessary
+0001f790: 2062 6563 6175 7365 2074 6865 2075 7064   because the upd
+0001f7a0: 6174 6564 2073 6176 6564 5f66 6f72 5f62  ated saved_for_b
+0001f7b0: 6163 6b77 6172 6420 6973 206e 6f74 2061  ackward is not a
+0001f7c0: 7661 696c 6162 6c65 0a20 2020 2077 6865  vailable.    whe
+0001f7d0: 6e20 7468 6520 666f 7277 6172 6420 616e  n the forward an
+0001f7e0: 6420 6261 636b 7761 7264 2074 7261 6365  d backward trace
+0001f7f0: 7320 6172 6520 636f 6e73 7472 7563 7465  s are constructe
+0001f800: 642e 0a0a 2020 2020 4172 6773 3a0a 2020  d...    Args:.  
+0001f810: 2020 2020 2020 666f 7277 6172 645f 7472        forward_tr
+0001f820: 6163 6520 2854 7261 6365 293a 2046 6f72  ace (Trace): For
+0001f830: 7761 7264 2074 7261 6365 2074 6f20 7570  ward trace to up
+0001f840: 6461 7465 2e0a 2020 2020 2020 2020 7361  date..        sa
+0001f850: 7665 645f 666f 725f 6261 636b 7761 7264  ved_for_backward
+0001f860: 2028 5365 7175 656e 6365 5b56 6172 6961   (Sequence[Varia
+0001f870: 626c 655d 293a 2053 6176 6564 5f66 6f72  ble]): Saved_for
+0001f880: 5f62 6163 6b77 6172 6420 746f 2075 7365  _backward to use
+0001f890: 2074 6f0a 2020 2020 2020 2020 2020 2020   to.            
+0001f8a0: 7570 6461 7465 2074 6865 2066 6f72 7761  update the forwa
+0001f8b0: 7264 2074 7261 6365 2e0a 2020 2020 2222  rd trace..    ""
+0001f8c0: 220a 2020 2020 7361 7665 645f 666f 725f  ".    saved_for_
+0001f8d0: 6261 636b 7761 7264 203d 2074 7265 655f  backward = tree_
+0001f8e0: 6d61 7028 6c61 6d62 6461 2078 3a20 782e  map(lambda x: x.
+0001f8f0: 7661 6c75 6520 6966 2069 7369 6e73 7461  value if isinsta
+0001f900: 6e63 6528 782c 204e 756d 6265 7250 726f  nce(x, NumberPro
+0001f910: 7879 2920 656c 7365 2078 2c20 7361 7665  xy) else x, save
+0001f920: 645f 666f 725f 6261 636b 7761 7264 290a  d_for_backward).
+0001f930: 2020 2020 7361 7665 645f 7465 6e73 6f72      saved_tensor
+0001f940: 732c 2073 6176 6564 5f6f 7468 6572 203d  s, saved_other =
+0001f950: 205f 7370 6c69 745f 7361 7665 645f 666f   _split_saved_fo
+0001f960: 725f 6261 636b 7761 7264 5f69 6e74 6f5f  r_backward_into_
+0001f970: 7465 6e73 6f72 735f 616e 645f 6f74 6865  tensors_and_othe
+0001f980: 7228 7361 7665 645f 666f 725f 6261 636b  r(saved_for_back
+0001f990: 7761 7264 290a 2020 2020 6173 7365 7274  ward).    assert
+0001f9a0: 2066 6f72 7761 7264 5f74 7261 6365 2e62   forward_trace.b
+0001f9b0: 6f75 6e64 5f73 796d 626f 6c73 5b2d 315d  ound_symbols[-1]
+0001f9c0: 2e73 796d 2e69 6420 3d3d 2070 7269 6d73  .sym.id == prims
+0001f9d0: 2e50 7269 6d49 4473 2e52 4554 5552 4e0a  .PrimIDs.RETURN.
+0001f9e0: 2020 2020 6e65 775f 7265 7475 726e 203d      new_return =
+0001f9f0: 2028 666f 7277 6172 645f 7472 6163 652e   (forward_trace.
+0001fa00: 6f75 7470 7574 5b30 5d2c 2028 7361 7665  output[0], (save
+0001fa10: 645f 7465 6e73 6f72 732c 2073 6176 6564  d_tensors, saved
+0001fa20: 5f6f 7468 6572 2929 0a20 2020 2066 6f72  _other)).    for
+0001fa30: 7761 7264 5f74 7261 6365 2e62 6f75 6e64  ward_trace.bound
+0001fa40: 5f73 796d 626f 6c73 5b2d 315d 203d 2072  _symbols[-1] = r
+0001fa50: 6570 6c61 6365 2866 6f72 7761 7264 5f74  eplace(forward_t
+0001fa60: 7261 6365 2e62 6f75 6e64 5f73 796d 626f  race.bound_symbo
+0001fa70: 6c73 5b2d 315d 2c20 6172 6773 3d6e 6577  ls[-1], args=new
+0001fa80: 5f72 6574 7572 6e29 0a0a 0a64 6566 205f  _return)...def _
+0001fa90: 7570 6461 7465 5f62 6163 6b77 6172 645f  update_backward_
+0001faa0: 7769 7468 5f6e 6577 5f73 6176 6564 5f66  with_new_saved_f
+0001fab0: 6f72 5f62 6163 6b77 6172 6428 6261 636b  or_backward(back
+0001fac0: 7761 7264 5f74 7261 6365 3a20 5472 6163  ward_trace: Trac
+0001fad0: 652c 2073 6176 6564 5f66 6f72 5f62 6163  e, saved_for_bac
+0001fae0: 6b77 6172 643a 2053 6571 7565 6e63 655b  kward: Sequence[
+0001faf0: 5661 7269 6162 6c65 5d29 202d 3e20 4e6f  Variable]) -> No
+0001fb00: 6e65 3a0a 2020 2020 2222 2255 7064 6174  ne:.    """Updat
+0001fb10: 6573 2074 6865 2062 6163 6b77 6172 6420  es the backward 
+0001fb20: 7472 6163 6520 7769 7468 206e 6577 2073  trace with new s
+0001fb30: 6176 6564 5f66 6f72 5f62 6163 6b77 6172  aved_for_backwar
+0001fb40: 642e 0a0a 2020 2020 5468 6973 2069 7320  d...    This is 
+0001fb50: 6e65 6365 7373 6172 7920 6265 6361 7573  necessary becaus
+0001fb60: 6520 7468 6520 7570 6461 7465 6420 7361  e the updated sa
+0001fb70: 7665 645f 666f 725f 6261 636b 7761 7264  ved_for_backward
+0001fb80: 2069 730a 2020 2020 6e6f 7420 6176 6169   is.    not avai
+0001fb90: 6c61 626c 6520 7768 656e 2074 6865 2062  lable when the b
+0001fba0: 6163 6b77 6172 6420 7472 6163 6520 6973  ackward trace is
+0001fbb0: 2063 6f6e 7374 7275 6374 6564 2e0a 0a20   constructed... 
+0001fbc0: 2020 2041 7267 733a 0a20 2020 2020 2020     Args:.       
+0001fbd0: 2062 6163 6b77 6172 645f 7472 6163 6520   backward_trace 
+0001fbe0: 2854 7261 6365 293a 2042 6163 6b77 6172  (Trace): Backwar
+0001fbf0: 6420 7472 6163 6520 746f 2075 7064 6174  d trace to updat
+0001fc00: 652e 0a20 2020 2020 2020 2073 6176 6564  e..        saved
+0001fc10: 5f66 6f72 5f62 6163 6b77 6172 6420 2853  _for_backward (S
+0001fc20: 6571 7565 6e63 655b 5661 7269 6162 6c65  equence[Variable
+0001fc30: 5d29 3a20 5361 7665 645f 666f 725f 6261  ]): Saved_for_ba
+0001fc40: 636b 7761 7264 2074 6f20 7573 6520 746f  ckward to use to
+0001fc50: 0a20 2020 2020 2020 2020 2020 2075 7064  .            upd
+0001fc60: 6174 6520 7468 6520 6261 636b 7761 7264  ate the backward
+0001fc70: 2074 7261 6365 2e0a 2020 2020 2222 220a   trace..    """.
+0001fc80: 0a20 2020 2064 6566 2075 6e70 6163 6b69  .    def unpacki
+0001fc90: 6e67 5f66 6e28 7361 7665 645f 666f 725f  ng_fn(saved_for_
+0001fca0: 6261 636b 7761 7264 2c20 636f 7461 6e67  backward, cotang
+0001fcb0: 656e 7473 293a 0a20 2020 2020 2020 2070  ents):.        p
+0001fcc0: 6173 730a 0a20 2020 2063 6f74 616e 6765  ass..    cotange
+0001fcd0: 6e74 7320 3d20 6261 636b 7761 7264 5f74  nts = backward_t
+0001fce0: 7261 6365 2e61 7267 735b 315d 0a20 2020  race.args[1].   
+0001fcf0: 2073 6176 6564 5f74 656e 736f 7273 2c20   saved_tensors, 
+0001fd00: 7361 7665 645f 6f74 6865 7220 3d20 5f73  saved_other = _s
+0001fd10: 706c 6974 5f73 6176 6564 5f66 6f72 5f62  plit_saved_for_b
+0001fd20: 6163 6b77 6172 645f 696e 746f 5f74 656e  ackward_into_ten
+0001fd30: 736f 7273 5f61 6e64 5f6f 7468 6572 2873  sors_and_other(s
+0001fd40: 6176 6564 5f66 6f72 5f62 6163 6b77 6172  aved_for_backwar
+0001fd50: 6429 0a20 2020 2075 6e70 6163 6b69 6e67  d).    unpacking
+0001fd60: 5f74 7261 6365 203d 2063 6f6e 7374 7275  _trace = constru
+0001fd70: 6374 5f74 7261 6365 2872 656e 616d 655f  ct_trace(rename_
+0001fd80: 7072 6f78 6965 733d 4661 6c73 652c 2075  proxies=False, u
+0001fd90: 7365 5f64 6365 3d46 616c 7365 2928 0a20  se_dce=False)(. 
+0001fda0: 2020 2020 2020 2075 6e70 6163 6b69 6e67         unpacking
+0001fdb0: 5f66 6e2c 2028 7361 7665 645f 7465 6e73  _fn, (saved_tens
+0001fdc0: 6f72 732c 2073 6176 6564 5f6f 7468 6572  ors, saved_other
+0001fdd0: 292c 2063 6f74 616e 6765 6e74 730a 2020  ), cotangents.  
+0001fde0: 2020 290a 2020 2020 6173 7365 7274 2075    ).    assert u
+0001fdf0: 6e70 6163 6b69 6e67 5f74 7261 6365 2e62  npacking_trace.b
+0001fe00: 6f75 6e64 5f73 796d 626f 6c73 5b2d 315d  ound_symbols[-1]
+0001fe10: 2e73 796d 2e69 6420 3d3d 2070 7269 6d73  .sym.id == prims
+0001fe20: 2e50 7269 6d49 4473 2e52 4554 5552 4e0a  .PrimIDs.RETURN.
+0001fe30: 0a20 2020 2062 6163 6b77 6172 645f 7472  .    backward_tr
+0001fe40: 6163 652e 6172 6773 203d 2075 6e70 6163  ace.args = unpac
+0001fe50: 6b69 6e67 5f74 7261 6365 2e61 7267 730a  king_trace.args.
+0001fe60: 2020 2020 6261 636b 7761 7264 5f74 7261      backward_tra
+0001fe70: 6365 5f62 7379 6d73 5f77 6974 686f 7574  ce_bsyms_without
+0001fe80: 5f75 6e70 6163 6b69 6e67 203d 2028 0a20  _unpacking = (. 
+0001fe90: 2020 2020 2020 2062 7379 6d0a 2020 2020         bsym.    
+0001fea0: 2020 2020 666f 7220 6273 796d 2069 6e20      for bsym in 
+0001feb0: 6261 636b 7761 7264 5f74 7261 6365 2e62  backward_trace.b
+0001fec0: 6f75 6e64 5f73 796d 626f 6c73 0a20 2020  ound_symbols.   
+0001fed0: 2020 2020 2069 6620 6273 796d 2e73 796d       if bsym.sym
+0001fee0: 2e69 640a 2020 2020 2020 2020 6e6f 7420  .id.        not 
+0001fef0: 696e 2028 0a20 2020 2020 2020 2020 2020  in (.           
+0001ff00: 2070 7269 6d73 2e50 7269 6d49 4473 2e55   prims.PrimIDs.U
+0001ff10: 4e50 4143 4b5f 454d 5054 595f 4449 4354  NPACK_EMPTY_DICT
+0001ff20: 2c0a 2020 2020 2020 2020 2020 2020 7072  ,.            pr
+0001ff30: 696d 732e 5072 696d 4944 732e 554e 5041  ims.PrimIDs.UNPA
+0001ff40: 434b 5f4b 4559 2c0a 2020 2020 2020 2020  CK_KEY,.        
+0001ff50: 2020 2020 7072 696d 732e 5072 696d 4944      prims.PrimID
+0001ff60: 732e 554e 5041 434b 5f53 4551 5545 4e43  s.UNPACK_SEQUENC
+0001ff70: 452c 0a20 2020 2020 2020 2020 2020 2070  E,.            p
+0001ff80: 7269 6d73 2e50 7269 6d49 4473 2e55 4e50  rims.PrimIDs.UNP
+0001ff90: 4143 4b5f 5452 4956 4941 4c2c 0a20 2020  ACK_TRIVIAL,.   
+0001ffa0: 2020 2020 2029 0a20 2020 2029 0a20 2020       ).    ).   
+0001ffb0: 2062 6163 6b77 6172 645f 7472 6163 652e   backward_trace.
+0001ffc0: 626f 756e 645f 7379 6d62 6f6c 7320 3d20  bound_symbols = 
+0001ffd0: 6c69 7374 2828 2a75 6e70 6163 6b69 6e67  list((*unpacking
+0001ffe0: 5f74 7261 6365 2e62 6f75 6e64 5f73 796d  _trace.bound_sym
+0001fff0: 626f 6c73 5b3a 2d31 5d2c 202a 6261 636b  bols[:-1], *back
+00020000: 7761 7264 5f74 7261 6365 5f62 7379 6d73  ward_trace_bsyms
+00020010: 5f77 6974 686f 7574 5f75 6e70 6163 6b69  _without_unpacki
+00020020: 6e67 2929 0a0a 0a23 204e 4f54 453a 2052  ng))...# NOTE: R
+00020030: 6574 7572 6e69 6e67 206e 616d 6564 7475  eturning namedtu
+00020040: 706c 6573 2066 726f 6d20 636f 6d70 696c  ples from compil
+00020050: 6564 2066 756e 6374 696f 6e73 2064 6f65  ed functions doe
+00020060: 736e 2774 2077 6f72 6b2e 2053 6565 3a0a  sn't work. See:.
+00020070: 2320 2241 6c6c 6f77 2072 6574 7572 6e69  # "Allow returni
+00020080: 6e67 206e 616d 6564 7475 706c 6573 2066  ng namedtuples f
+00020090: 726f 6d20 636f 6d70 696c 6564 2066 756e  rom compiled fun
+000200a0: 6374 696f 6e73 220a 2320 4e6f 7465 205b  ctions".# Note [
+000200b0: 4772 6164 2066 6f72 7761 7264 206f 7574  Grad forward out
+000200c0: 7075 7420 7370 6563 5d0a 2320 4966 2069  put spec].# If i
+000200d0: 7420 6469 6420 776f 726b 2069 7420 776f  t did work it wo
+000200e0: 756c 6420 6265 206e 6963 6520 746f 2075  uld be nice to u
+000200f0: 7365 2074 6869 7320 6e61 6d65 6474 7570  se this namedtup
+00020100: 6c65 0a23 2069 6e73 7465 6164 206f 6620  le.# instead of 
+00020110: 7468 6520 706c 6169 6e20 7475 706c 6520  the plain tuple 
+00020120: 6f72 2064 6963 7420 7468 6174 2077 6527  or dict that we'
+00020130: 7265 2075 7369 6e67 206e 6f77 2e0a 546f  re using now..To
+00020140: 7263 6841 7574 6f67 7261 6446 6f72 7761  rchAutogradForwa
+00020150: 7264 4461 7461 203d 206e 616d 6564 7475  rdData = namedtu
+00020160: 706c 6528 0a20 2020 2022 546f 7263 6841  ple(.    "TorchA
+00020170: 7574 6f67 7261 6446 6f72 7761 7264 4461  utogradForwardDa
+00020180: 7461 222c 0a20 2020 205b 226f 7574 7075  ta",.    ["outpu
+00020190: 7422 2c20 2266 6c61 745f 6172 6773 222c  t", "flat_args",
+000201a0: 2022 666c 6174 5f6f 7574 7075 7422 5d2c   "flat_output"],
+000201b0: 0a29 0a0a 0a64 6566 2066 6f72 7761 7264  .)...def forward
+000201c0: 5f61 6e64 5f62 6163 6b77 6172 645f 6672  _and_backward_fr
+000201d0: 6f6d 5f74 7261 6365 2874 7261 6365 3a20  om_trace(trace: 
+000201e0: 5472 6163 652c 2074 6f72 6368 5f61 7574  Trace, torch_aut
+000201f0: 6f67 7261 643d 4661 6c73 6529 202d 3e20  ograd=False) -> 
+00020200: 466f 7277 6172 6442 6163 6b77 6172 6454  ForwardBackwardT
+00020210: 7261 6365 733a 0a20 2020 2022 2222 4765  races:.    """Ge
+00020220: 6e65 7261 7465 7320 7468 6520 666f 7277  nerates the forw
+00020230: 6172 6420 616e 6420 6261 636b 7761 7264  ard and backward
+00020240: 2070 6173 7365 7320 6672 6f6d 2061 2074   passes from a t
+00020250: 7261 6365 2e0a 0a20 2020 2054 6869 7320  race...    This 
+00020260: 6973 2061 2063 6f6e 7665 6e69 656e 6365  is a convenience
+00020270: 2066 756e 6374 696f 6e20 7468 6174 2063   function that c
+00020280: 6f6d 6269 6e65 7320 7468 6520 6675 6e63  ombines the func
+00020290: 7469 6f6e 616c 6974 7920 6f66 0a20 2020  tionality of.   
+000202a0: 2060 6175 676d 656e 7465 645f 666f 7277   `augmented_forw
+000202b0: 6172 645f 7061 7373 6020 616e 6420 6062  ard_pass` and `b
+000202c0: 6163 6b77 6172 645f 7061 7373 602e 2054  ackward_pass`. T
+000202d0: 6865 206d 6169 6e20 6469 6666 6572 656e  he main differen
+000202e0: 6365 2069 7320 7468 6174 0a20 2020 2074  ce is that.    t
+000202f0: 6869 7320 6675 6e63 7469 6f6e 2064 6f65  his function doe
+00020300: 7320 6e6f 7420 7265 7175 6972 6520 7468  s not require th
+00020310: 6520 7573 6572 2074 6f20 7072 6f76 6964  e user to provid
+00020320: 6520 6e65 7720 696e 7075 7473 2066 6f72  e new inputs for
+00020330: 2074 6865 0a20 2020 2074 7261 6365 2065   the.    trace e
+00020340: 7661 6c75 6174 696f 6e2e 2049 6e73 7465  valuation. Inste
+00020350: 6164 2069 7420 7573 6573 2074 6865 2069  ad it uses the i
+00020360: 6e70 7574 7320 7468 6174 2077 6572 6520  nputs that were 
+00020370: 7573 6564 2074 6f20 636f 6e73 7472 7563  used to construc
+00020380: 740a 2020 2020 7468 6520 7472 6163 652e  t.    the trace.
+00020390: 0a0a 2020 2020 4172 6773 3a0a 2020 2020  ..    Args:.    
+000203a0: 2020 2020 7472 6163 6520 2854 7261 6365      trace (Trace
+000203b0: 293a 2054 7261 6365 2074 6f20 6765 6e65  ): Trace to gene
+000203c0: 7261 7465 2074 6865 2066 6f72 7761 7264  rate the forward
+000203d0: 2061 6e64 2062 6163 6b77 6172 6420 7061   and backward pa
+000203e0: 7373 6573 2066 726f 6d2e 0a0a 2020 2020  sses from...    
+000203f0: 5265 7475 726e 733a 0a20 2020 2020 2020  Returns:.       
+00020400: 2046 6f72 7761 7264 4261 636b 7761 7264   ForwardBackward
+00020410: 5472 6163 6573 3a20 4120 6e61 6d65 6420  Traces: A named 
+00020420: 7475 706c 6520 636f 6e74 6169 6e69 6e67  tuple containing
+00020430: 2074 6865 2066 6f72 7761 7264 2061 6e64   the forward and
+00020440: 2062 6163 6b77 6172 640a 2020 2020 2020   backward.      
+00020450: 2020 2020 2020 7472 6163 6573 2e0a 0a20        traces... 
+00020460: 2020 2045 7861 6d70 6c65 3a0a 2020 2020     Example:.    
+00020470: 2020 2020 3e3e 3e20 696d 706f 7274 2074      >>> import t
+00020480: 6f72 6368 0a20 2020 2020 2020 203e 3e3e  orch.        >>>
+00020490: 2066 726f 6d20 7468 756e 6465 7220 696d   from thunder im
+000204a0: 706f 7274 2063 6f6d 7069 6c65 2c20 6c61  port compile, la
+000204b0: 7374 5f74 7261 6365 730a 2020 2020 2020  st_traces.      
+000204c0: 2020 3e3e 3e20 6672 6f6d 2074 6875 6e64    >>> from thund
+000204d0: 6572 2e63 6f72 652e 7472 616e 7366 6f72  er.core.transfor
+000204e0: 6d73 2069 6d70 6f72 7420 666f 7277 6172  ms import forwar
+000204f0: 645f 616e 645f 6261 636b 7761 7264 5f66  d_and_backward_f
+00020500: 726f 6d5f 7472 6163 650a 2020 2020 2020  rom_trace.      
+00020510: 2020 3e3e 3e20 6465 6620 6628 7829 3a0a    >>> def f(x):.
+00020520: 2020 2020 2020 2020 2e2e 2e20 2020 2020          ...     
+00020530: 7265 7475 726e 2074 6f72 6368 2e73 696e  return torch.sin
+00020540: 2878 290a 2020 2020 2020 2020 3e3e 3e20  (x).        >>> 
+00020550: 7820 3d20 746f 7263 682e 7465 6e73 6f72  x = torch.tensor
+00020560: 2833 2e30 290a 2020 2020 2020 2020 3e3e  (3.0).        >>
+00020570: 3e20 6366 203d 2063 6f6d 7069 6c65 2866  > cf = compile(f
+00020580: 290a 2020 2020 2020 2020 3e3e 3e20 6f75  ).        >>> ou
+00020590: 7420 3d20 6366 2878 290a 2020 2020 2020  t = cf(x).      
+000205a0: 2020 3e3e 3e20 7472 6163 6520 3d20 6c61    >>> trace = la
+000205b0: 7374 5f74 7261 6365 7328 6366 295b 305d  st_traces(cf)[0]
+000205c0: 0a20 2020 2020 2020 203e 3e3e 2066 6f72  .        >>> for
+000205d0: 7761 7264 5f61 6e64 5f62 6163 6b77 6172  ward_and_backwar
+000205e0: 645f 6672 6f6d 5f74 7261 6365 2874 7261  d_from_trace(tra
+000205f0: 6365 290a 2020 2020 2020 2020 2e2e 2e20  ce).        ... 
+00020600: 466f 7277 6172 6442 6163 6b77 6172 6454  ForwardBackwardT
+00020610: 7261 6365 7328 0a20 2020 2020 2020 202e  races(.        .
+00020620: 2e2e 2066 6f72 7761 7264 5f74 7261 6365  .. forward_trace
+00020630: 3d23 2069 6d70 6f72 7420 7468 756e 6465  =# import thunde
+00020640: 7220 6173 2074 6875 6e64 6572 0a20 2020  r as thunder.   
+00020650: 2020 2020 202e 2e2e 2023 2069 6d70 6f72       ... # impor
+00020660: 7420 7468 756e 6465 722e 636f 7265 2e70  t thunder.core.p
+00020670: 7269 6d73 2061 7320 7072 696d 730a 2020  rims as prims.  
+00020680: 2020 2020 2020 2e2e 2e20 696d 706f 7274        ... import
+00020690: 2074 6f72 6368 0a20 2020 2020 2020 202e   torch.        .
+000206a0: 2e2e 0a20 2020 2020 2020 202e 2e2e 2040  ...        ... @
+000206b0: 746f 7263 682e 6e6f 5f67 7261 6428 290a  torch.no_grad().
+000206c0: 2020 2020 2020 2020 2e2e 2e20 6465 6620          ... def 
+000206d0: 6175 676d 656e 7465 645f 666f 7277 6172  augmented_forwar
+000206e0: 645f 666e 282a 6172 6773 293a 0a20 2020  d_fn(*args):.   
+000206f0: 2020 2020 202e 2e2e 2020 2023 2061 7267       ...   # arg
+00020700: 733a 2022 436f 6c6c 6563 7469 6f6e 2220  s: "Collection" 
+00020710: 3d20 2028 7430 2c29 2020 2874 7269 7669  =  (t0,)  (trivi
+00020720: 616c 2075 6e70 6163 6b29 0a20 2020 2020  al unpack).     
+00020730: 2020 202e 2e2e 2020 2074 302c 205c 0a20     ...   t0, \. 
+00020740: 2020 2020 2020 202e 2e2e 2020 203d 2061         ...   = a
+00020750: 7267 730a 2020 2020 2020 2020 2e2e 2e20  rgs.        ... 
+00020760: 2020 7431 203d 2070 7269 6d73 2e73 696e    t1 = prims.sin
+00020770: 2874 3029 2020 2320 7431 3a20 2263 7075  (t0)  # t1: "cpu
+00020780: 2066 3332 5b5d 220a 2020 2020 2020 2020   f32[]".        
+00020790: 2e2e 2e20 2020 7265 7475 726e 2074 312c  ...   return t1,
+000207a0: 2028 7430 2c29 2c0a 2020 2020 2020 2020   (t0,),.        
+000207b0: 2e2e 2e20 6261 636b 7761 7264 5f74 7261  ... backward_tra
+000207c0: 6365 3d23 2069 6d70 6f72 7420 7468 756e  ce=# import thun
+000207d0: 6465 7220 6173 2074 6875 6e64 6572 0a20  der as thunder. 
+000207e0: 2020 2020 2020 202e 2e2e 2023 2069 6d70         ... # imp
+000207f0: 6f72 7420 7468 756e 6465 722e 636f 7265  ort thunder.core
+00020800: 2e70 7269 6d73 2061 7320 7072 696d 730a  .prims as prims.
+00020810: 2020 2020 2020 2020 2e2e 2e20 696d 706f          ... impo
+00020820: 7274 2074 6f72 6368 0a20 2020 2020 2020  rt torch.       
+00020830: 202e 2e2e 0a20 2020 2020 2020 202e 2e2e   ....        ...
+00020840: 2040 746f 7263 682e 6e6f 5f67 7261 6428   @torch.no_grad(
+00020850: 290a 2020 2020 2020 2020 2e2e 2e20 6465  ).        ... de
+00020860: 6620 6261 636b 7761 7264 5f66 6e28 7361  f backward_fn(sa
+00020870: 7665 645f 666f 725f 6261 636b 7761 7264  ved_for_backward
+00020880: 2c20 636f 7461 6e67 656e 7473 293a 0a20  , cotangents):. 
+00020890: 2020 2020 2020 202e 2e2e 2020 2023 2073         ...   # s
+000208a0: 6176 6564 5f66 6f72 5f62 6163 6b77 6172  aved_for_backwar
+000208b0: 643a 2022 436f 6c6c 6563 7469 6f6e 2220  d: "Collection" 
+000208c0: 3d20 2028 7430 2c29 2020 2874 7269 7669  =  (t0,)  (trivi
+000208d0: 616c 2075 6e70 6163 6b29 0a20 2020 2020  al unpack).     
+000208e0: 2020 202e 2e2e 2020 2023 2063 6f74 616e     ...   # cotan
+000208f0: 6765 6e74 733a 2022 6370 7520 6633 325b  gents: "cpu f32[
+00020900: 5d22 203d 2020 636f 7461 6e67 656e 7473  ]" =  cotangents
+00020910: 2020 2874 7269 7669 616c 2075 6e70 6163    (trivial unpac
+00020920: 6b29 0a20 2020 2020 2020 202e 2e2e 2020  k).        ...  
+00020930: 2074 302c 205c 0a20 2020 2020 2020 202e   t0, \.        .
+00020940: 2e2e 2020 203d 2073 6176 6564 5f66 6f72  ..   = saved_for
+00020950: 5f62 6163 6b77 6172 640a 2020 2020 2020  _backward.      
+00020960: 2020 2e2e 2e20 2020 7431 203d 2070 7269    ...   t1 = pri
+00020970: 6d73 2e63 6f73 2874 3029 2020 2320 7431  ms.cos(t0)  # t1
+00020980: 3a20 2263 7075 2066 3332 5b5d 220a 2020  : "cpu f32[]".  
+00020990: 2020 2020 2020 2e2e 2e20 2020 7432 203d        ...   t2 =
+000209a0: 2070 7269 6d73 2e6d 756c 2863 6f74 616e   prims.mul(cotan
+000209b0: 6765 6e74 732c 2074 3129 2020 2320 7432  gents, t1)  # t2
+000209c0: 3a20 2263 7075 2066 3332 5b5d 220a 2020  : "cpu f32[]".  
+000209d0: 2020 2020 2020 2e2e 2e20 2020 7265 7475        ...   retu
+000209e0: 726e 2028 7432 2c29 290a 2020 2020 2222  rn (t2,)).    ""
+000209f0: 220a 0a20 2020 206f 7574 7075 745f 7370  "..    output_sp
+00020a00: 6563 203d 204e 6f6e 650a 0a20 2020 2064  ec = None..    d
+00020a10: 6566 2061 7567 6d65 6e74 6564 5f66 6f72  ef augmented_for
+00020a20: 7761 7264 5f66 6e28 2a61 7267 732c 202a  ward_fn(*args, *
+00020a30: 2a6b 7761 7267 7329 3a0a 2020 2020 2020  *kwargs):.      
+00020a40: 2020 7265 7375 6c74 2c20 656e 7620 3d20    result, env = 
+00020a50: 6175 676d 656e 7465 645f 666f 7277 6172  augmented_forwar
+00020a60: 645f 7061 7373 282a 6172 6773 2c20 7472  d_pass(*args, tr
+00020a70: 6163 653d 7472 6163 652c 202a 2a6b 7761  ace=trace, **kwa
+00020a80: 7267 7329 0a20 2020 2020 2020 2073 6176  rgs).        sav
+00020a90: 6564 5f66 6f72 5f62 6163 6b77 6172 6420  ed_for_backward 
+00020aa0: 3d20 6465 636f 6e73 7472 7563 745f 666f  = deconstruct_fo
+00020ab0: 7277 6172 645f 656e 765f 666f 725f 6261  rward_env_for_ba
+00020ac0: 636b 7761 7264 2874 7261 6365 2c20 656e  ckward(trace, en
+00020ad0: 7629 0a20 2020 2020 2020 2069 6620 746f  v).        if to
+00020ae0: 7263 685f 6175 746f 6772 6164 3a0a 2020  rch_autograd:.  
+00020af0: 2020 2020 2020 2020 2020 6e6f 6e6c 6f63            nonloc
+00020b00: 616c 206f 7574 7075 745f 7370 6563 0a20  al output_spec. 
+00020b10: 2020 2020 2020 2020 2020 2066 6c61 745f             flat_
+00020b20: 6172 6773 2c20 5f20 3d20 7472 6565 5f66  args, _ = tree_f
+00020b30: 6c61 7474 656e 2828 6172 6773 2c20 6b77  latten((args, kw
+00020b40: 6172 6773 2929 0a20 2020 2020 2020 2020  args)).         
+00020b50: 2020 2066 6c61 745f 6f75 7470 7574 2c20     flat_output, 
+00020b60: 6f75 7470 7574 5f73 7065 6320 3d20 7472  output_spec = tr
+00020b70: 6565 5f66 6c61 7474 656e 2872 6573 756c  ee_flatten(resul
+00020b80: 7429 0a20 2020 2020 2020 2020 2020 2066  t).            f
+00020b90: 6c61 745f 6f75 7470 7574 203d 2074 7570  lat_output = tup
+00020ba0: 6c65 2866 6c61 745f 6f75 7470 7574 290a  le(flat_output).
+00020bb0: 2020 2020 2020 2020 2020 2020 2320 5365              # Se
+00020bc0: 6520 4e6f 7465 205b 4772 6164 2066 6f72  e Note [Grad for
+00020bd0: 7761 7264 206f 7574 7075 7420 7370 6563  ward output spec
+00020be0: 5d0a 2020 2020 2020 2020 2020 2020 666f  ].            fo
+00020bf0: 725f 6175 746f 6772 6164 203d 2054 6f72  r_autograd = Tor
+00020c00: 6368 4175 746f 6772 6164 466f 7277 6172  chAutogradForwar
+00020c10: 6444 6174 6128 0a20 2020 2020 2020 2020  dData(.         
+00020c20: 2020 2020 2020 2072 6573 756c 742c 0a20         result,. 
+00020c30: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00020c40: 6c61 745f 6172 6773 2c0a 2020 2020 2020  lat_args,.      
+00020c50: 2020 2020 2020 2020 2020 666c 6174 5f6f            flat_o
+00020c60: 7574 7075 742c 0a20 2020 2020 2020 2020  utput,.         
+00020c70: 2020 2029 2e5f 6173 6469 6374 2829 0a20     )._asdict(). 
+00020c80: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00020c90: 6e20 2866 6f72 5f61 7574 6f67 7261 642c  n (for_autograd,
+00020ca0: 2073 6176 6564 5f66 6f72 5f62 6163 6b77   saved_for_backw
+00020cb0: 6172 6429 0a20 2020 2020 2020 2072 6574  ard).        ret
+00020cc0: 7572 6e20 7265 7375 6c74 2c20 7361 7665  urn result, save
+00020cd0: 645f 666f 725f 6261 636b 7761 7264 0a0a  d_for_backward..
+00020ce0: 2020 2020 2320 436f 7079 2074 6865 2073      # Copy the s
+00020cf0: 6967 6e61 7475 7265 206f 6620 7468 6520  ignature of the 
+00020d00: 6f72 6967 696e 616c 2066 756e 6374 696f  original functio
+00020d10: 6e20 736f 2074 6861 7420 7468 6520 6172  n so that the ar
+00020d20: 6775 6d65 6e74 7320 6172 650a 2020 2020  guments are.    
+00020d30: 2320 6e61 6d65 6420 636f 7272 6563 746c  # named correctl
+00020d40: 7920 696e 2074 6865 2061 7567 6d65 6e74  y in the augment
+00020d50: 6564 2066 6f72 7761 7264 2070 6173 7320  ed forward pass 
+00020d60: 696e 7374 6561 6420 6f66 2062 6569 6e67  instead of being
+00020d70: 206e 616d 6564 0a20 2020 2023 2022 6172   named.    # "ar
+00020d80: 6773 2220 616e 6420 226b 7761 7267 7322  gs" and "kwargs"
+00020d90: 2e0a 2020 2020 6175 676d 656e 7465 645f  ..    augmented_
+00020da0: 666f 7277 6172 645f 666e 2e5f 5f73 6967  forward_fn.__sig
+00020db0: 6e61 7475 7265 5f5f 203d 2069 6e73 7065  nature__ = inspe
+00020dc0: 6374 2e73 6967 6e61 7475 7265 2874 7261  ct.signature(tra
+00020dd0: 6365 2e66 6e20 6f72 2074 7261 6365 2e70  ce.fn or trace.p
+00020de0: 7974 686f 6e5f 6361 6c6c 6162 6c65 2829  ython_callable()
+00020df0: 290a 0a20 2020 2064 6566 206f 6e65 735f  )..    def ones_
+00020e00: 6c69 6b65 2878 293a 0a20 2020 2020 2020  like(x):.       
+00020e10: 2069 6620 6973 696e 7374 616e 6365 2878   if isinstance(x
+00020e20: 2c20 5465 6e73 6f72 5072 6f78 7929 3a0a  , TensorProxy):.
+00020e30: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00020e40: 726e 2066 756c 6c5f 6c69 6b65 2878 2c20  rn full_like(x, 
+00020e50: 6669 6c6c 5f76 616c 7565 3d31 290a 2020  fill_value=1).  
+00020e60: 2020 2020 2020 656c 6966 2069 7369 6e73        elif isins
+00020e70: 7461 6e63 6528 782c 204e 756d 6265 7250  tance(x, NumberP
+00020e80: 726f 7879 293a 0a20 2020 2020 2020 2020  roxy):.         
+00020e90: 2020 2072 6574 7572 6e20 7479 7065 2878     return type(x
+00020ea0: 2e76 616c 7565 2928 3129 0a20 2020 2020  .value)(1).     
+00020eb0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00020ec0: 2020 2020 2072 6574 7572 6e20 4e6f 6e65       return None
+00020ed0: 0a0a 2020 2020 666f 7277 6172 645f 7472  ..    forward_tr
+00020ee0: 6163 6520 3d20 636f 6e73 7472 7563 745f  ace = construct_
+00020ef0: 7472 6163 6528 2928 6175 676d 656e 7465  trace()(augmente
+00020f00: 645f 666f 7277 6172 645f 666e 2c20 2a74  d_forward_fn, *t
+00020f10: 7261 6365 2e61 7267 732c 202a 2a74 7261  race.args, **tra
+00020f20: 6365 2e6b 7761 7267 7329 0a20 2020 2023  ce.kwargs).    #
+00020f30: 2057 6520 7365 7420 666f 7277 6172 6420   We set forward 
+00020f40: 7472 6163 6520 746f 2063 6f6e 7374 7275  trace to constru
+00020f50: 6374 2070 726f 7869 6573 2062 6563 6175  ct proxies becau
+00020f60: 7365 2077 6520 6e65 6564 2074 6865 7365  se we need these
+00020f70: 2070 726f 7869 6573 2074 6f0a 2020 2020   proxies to.    
+00020f80: 2320 6861 7665 2064 6966 6665 7265 6e74  # have different
+00020f90: 206e 616d 6573 2074 6861 6e20 7468 6520   names than the 
+00020fa0: 6f6e 6573 2069 6e20 7468 6520 666f 7277  ones in the forw
+00020fb0: 6172 6420 7472 6163 652e 0a20 2020 2074  ard trace..    t
+00020fc0: 7279 3a0a 2020 2020 2020 2020 7472 6163  ry:.        trac
+00020fd0: 6563 7478 5f74 6f6b 656e 203d 2073 6574  ectx_token = set
+00020fe0: 5f74 7261 6365 6374 7828 666f 7277 6172  _tracectx(forwar
+00020ff0: 645f 7472 6163 6529 0a20 2020 2020 2020  d_trace).       
+00021000: 2023 2057 6520 646f 6e27 7420 7761 6e74   # We don't want
+00021010: 2074 6f20 7265 636f 7264 2074 686f 7365   to record those
+00021020: 206f 6e65 735f 6c69 6b65 2063 616c 6c73   ones_like calls
+00021030: 2069 6e20 7468 6520 666f 7277 6172 6420   in the forward 
+00021040: 7472 6163 652e 0a20 2020 2020 2020 2077  trace..        w
+00021050: 6974 6820 6465 7461 6368 6564 5f74 7261  ith detached_tra
+00021060: 6365 2829 3a0a 2020 2020 2020 2020 2020  ce():.          
+00021070: 2020 6966 2074 6f72 6368 5f61 7574 6f67    if torch_autog
+00021080: 7261 643a 0a20 2020 2020 2020 2020 2020  rad:.           
+00021090: 2020 2020 2023 2049 7427 7320 6173 7375       # It's assu
+000210a0: 6d65 6420 7468 6174 2066 6f72 7761 7264  med that forward
+000210b0: 5f74 7261 6365 2e6f 7574 7075 745b 305d  _trace.output[0]
+000210c0: 2069 7320 6120 6469 6374 2066 726f 6d20   is a dict from 
+000210d0: 546f 7263 6841 7574 6f67 7261 6446 6f72  TorchAutogradFor
+000210e0: 7761 7264 4461 7461 0a20 2020 2020 2020  wardData.       
+000210f0: 2020 2020 2020 2020 2066 6c61 745f 6f75           flat_ou
+00021100: 7470 7574 203d 2066 6f72 7761 7264 5f74  tput = forward_t
+00021110: 7261 6365 2e6f 7574 7075 745b 305d 5b22  race.output[0]["
+00021120: 666c 6174 5f6f 7574 7075 7422 5d0a 2020  flat_output"].  
+00021130: 2020 2020 2020 2020 2020 2020 2020 636f                co
+00021140: 7461 6e67 656e 7473 203d 2075 7469 6c73  tangents = utils
+00021150: 2e73 6571 7565 6e63 6966 7928 7472 6565  .sequencify(tree
+00021160: 5f6d 6170 286c 616d 6264 6120 763a 206f  _map(lambda v: o
+00021170: 6e65 735f 6c69 6b65 2876 292c 2066 6c61  nes_like(v), fla
+00021180: 745f 6f75 7470 7574 2929 0a20 2020 2020  t_output)).     
+00021190: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+000211a0: 2020 2020 2020 2020 2020 2020 2063 6f74               cot
+000211b0: 616e 6765 6e74 7320 3d20 7574 696c 732e  angents = utils.
+000211c0: 7365 7175 656e 6369 6679 2874 7265 655f  sequencify(tree_
+000211d0: 6d61 7028 6c61 6d62 6461 2076 3a20 6f6e  map(lambda v: on
+000211e0: 6573 5f6c 696b 6528 7629 2c20 7472 6163  es_like(v), trac
+000211f0: 652e 6f75 7470 7574 2929 0a20 2020 2066  e.output)).    f
+00021200: 696e 616c 6c79 3a0a 2020 2020 2020 2020  inally:.        
+00021210: 7265 7365 745f 7472 6163 6563 7478 2874  reset_tracectx(t
+00021220: 7261 6365 6374 785f 746f 6b65 6e29 0a0a  racectx_token)..
+00021230: 2020 2020 6465 6620 6261 636b 7761 7264      def backward
+00021240: 5f66 6e28 7361 7665 645f 666f 725f 6261  _fn(saved_for_ba
+00021250: 636b 7761 7264 2c20 636f 7461 6e67 656e  ckward, cotangen
+00021260: 7473 293a 0a20 2020 2020 2020 2065 6e76  ts):.        env
+00021270: 203d 2072 6563 6f6e 7374 7275 6374 5f66   = reconstruct_f
+00021280: 6f72 7761 7264 5f65 6e76 5f66 6f72 5f62  orward_env_for_b
+00021290: 6163 6b77 6172 6428 7472 6163 652c 2073  ackward(trace, s
+000212a0: 6176 6564 5f66 6f72 5f62 6163 6b77 6172  aved_for_backwar
+000212b0: 6429 0a20 2020 2020 2020 2069 6620 746f  d).        if to
+000212c0: 7263 685f 6175 746f 6772 6164 3a0a 2020  rch_autograd:.  
+000212d0: 2020 2020 2020 2020 2020 636f 7461 6e67            cotang
+000212e0: 656e 7473 203d 2074 7265 655f 756e 666c  ents = tree_unfl
+000212f0: 6174 7465 6e28 636f 7461 6e67 656e 7473  atten(cotangents
+00021300: 2c20 6f75 7470 7574 5f73 7065 6329 0a20  , output_spec). 
+00021310: 2020 2020 2020 206f 7574 203d 2062 6163         out = bac
+00021320: 6b77 6172 645f 7061 7373 2865 6e76 2c20  kward_pass(env, 
+00021330: 7472 6163 652c 2063 6f74 616e 6765 6e74  trace, cotangent
+00021340: 7329 0a20 2020 2020 2020 2069 6620 746f  s).        if to
+00021350: 7263 685f 6175 746f 6772 6164 3a0a 2020  rch_autograd:.  
+00021360: 2020 2020 2020 2020 2020 676b 7761 7267            gkwarg
+00021370: 7320 3d20 6f75 745b 2d31 5d20 6966 2069  s = out[-1] if i
+00021380: 7369 6e73 7461 6e63 6528 6f75 745b 2d31  sinstance(out[-1
+00021390: 5d2c 2064 6963 7429 2065 6c73 6520 7b7d  ], dict) else {}
+000213a0: 0a20 2020 2020 2020 2020 2020 2067 6172  .            gar
+000213b0: 6773 203d 206f 7574 5b3a 2d31 5d20 6966  gs = out[:-1] if
+000213c0: 2069 7369 6e73 7461 6e63 6528 6f75 745b   isinstance(out[
+000213d0: 2d31 5d2c 2064 6963 7429 2065 6c73 6520  -1], dict) else 
+000213e0: 6f75 740a 2020 2020 2020 2020 2020 2020  out.            
+000213f0: 676b 7761 7267 7320 3d20 7b6b 3a20 676b  gkwargs = {k: gk
+00021400: 7761 7267 732e 6765 7428 6b2c 204e 6f6e  wargs.get(k, Non
+00021410: 6529 2066 6f72 206b 2069 6e20 7472 6163  e) for k in trac
+00021420: 652e 6b77 6172 6773 7d0a 2020 2020 2020  e.kwargs}.      
+00021430: 2020 2020 2020 6f75 7420 3d20 282a 6761        out = (*ga
+00021440: 7267 732c 2067 6b77 6172 6773 290a 2020  rgs, gkwargs).  
+00021450: 2020 2020 2020 2020 2020 6f75 7420 3d20            out = 
+00021460: 7472 6565 5f66 6c61 7474 656e 286f 7574  tree_flatten(out
+00021470: 295b 305d 0a20 2020 2020 2020 2072 6574  )[0].        ret
+00021480: 7572 6e20 6f75 740a 0a20 2020 2073 6176  urn out..    sav
+00021490: 6564 5f66 6f72 5f62 6163 6b77 6172 6420  ed_for_backward 
+000214a0: 3d20 666f 7277 6172 645f 7472 6163 652e  = forward_trace.
+000214b0: 6f75 7470 7574 5b31 5d0a 2020 2020 6261  output[1].    ba
+000214c0: 636b 7761 7264 5f74 7261 6365 203d 2063  ckward_trace = c
+000214d0: 6f6e 7374 7275 6374 5f74 7261 6365 2872  onstruct_trace(r
+000214e0: 656e 616d 655f 7072 6f78 6965 733d 4661  ename_proxies=Fa
+000214f0: 6c73 6529 2862 6163 6b77 6172 645f 666e  lse)(backward_fn
+00021500: 2c20 7361 7665 645f 666f 725f 6261 636b  , saved_for_back
+00021510: 7761 7264 2c20 636f 7461 6e67 656e 7473  ward, cotangents
+00021520: 290a 0a20 2020 2023 2057 6520 6172 6520  )..    # We are 
+00021530: 646f 6e65 2077 6974 6820 636f 6e73 7472  done with constr
+00021540: 7563 7469 6e67 2074 6865 2066 6f72 7761  ucting the forwa
+00021550: 7264 2061 6e64 2062 6163 6b77 6172 6420  rd and backward 
+00021560: 7061 7373 6573 2061 7420 7468 6973 0a20  passes at this. 
+00021570: 2020 2023 2073 7461 6765 2e20 5468 6520     # stage. The 
+00021580: 666f 6c6c 6f77 696e 6720 6973 206e 6f74  following is not
+00021590: 2073 7472 6963 746c 7920 6e65 6365 7373   strictly necess
+000215a0: 6172 792c 2062 7574 2069 7427 7320 676f  ary, but it's go
+000215b0: 6f64 2074 6f20 6669 6c74 6572 0a20 2020  od to filter.   
+000215c0: 2023 206f 7574 2074 6865 2075 6e75 7365   # out the unuse
+000215d0: 6420 656c 656d 656e 7473 206f 6620 7468  d elements of th
+000215e0: 6520 7361 7665 645f 666f 725f 6261 636b  e saved_for_back
+000215f0: 7761 7264 2061 6e64 2066 6c61 7474 656e  ward and flatten
+00021600: 2069 7420 666f 7220 6d6f 7265 0a20 2020   it for more.   
+00021610: 2023 2063 6f6d 7061 6374 2062 6163 6b77   # compact backw
+00021620: 6172 6420 7472 6163 652e 0a0a 2020 2020  ard trace...    
+00021630: 2320 4e6f 7720 7765 2063 616e 2064 6574  # Now we can det
+00021640: 6572 6d69 6e65 2065 7861 6374 6c79 2077  ermine exactly w
+00021650: 6861 7427 7320 7573 6564 2069 6e20 7468  hat's used in th
+00021660: 6520 6261 636b 7761 7264 2070 6173 7320  e backward pass 
+00021670: 6672 6f6d 2074 6865 0a20 2020 2023 2073  from the.    # s
+00021680: 6176 6564 5f66 6f72 5f62 6163 6b77 6172  aved_for_backwar
+00021690: 642e 2057 6520 6361 6e20 666c 6174 7465  d. We can flatte
+000216a0: 6e20 616e 6420 6669 6c74 6572 2074 6865  n and filter the
+000216b0: 2073 6176 6564 5f66 6f72 5f62 6163 6b77   saved_for_backw
+000216c0: 6172 640a 2020 2020 636f 6e73 756d 6572  ard.    consumer
+000216d0: 7320 3d20 7574 696c 732e 636f 6e73 756d  s = utils.consum
+000216e0: 6572 7328 6261 636b 7761 7264 5f74 7261  ers(backward_tra
+000216f0: 6365 290a 0a20 2020 2023 2046 6f72 7761  ce)..    # Forwa
+00021700: 7264 2773 2061 6e64 2062 6163 6b77 6172  rd's and backwar
+00021710: 6427 7320 2273 6176 6564 5f66 6f72 5f62  d's "saved_for_b
+00021720: 6163 6b77 6172 6422 2061 7265 206e 6f74  ackward" are not
+00021730: 206e 6563 6573 7361 7269 6c79 2074 6865   necessarily the
+00021740: 2073 616d 650a 2020 2020 2320 6173 2074   same.    # as t
+00021750: 6865 2073 6176 6564 5f66 6f72 5f62 6163  he saved_for_bac
+00021760: 6b77 6172 642c 2062 6563 6175 7365 2073  kward, because s
+00021770: 6f6d 6520 6f72 2061 6c6c 2065 6c65 6d65  ome or all eleme
+00021780: 6e74 7320 6f66 2074 6865 0a20 2020 2023  nts of the.    #
+00021790: 2073 6176 6564 5f66 6f72 5f62 6163 6b77   saved_for_backw
+000217a0: 6172 6420 7265 7375 6c74 7320 6d69 6768  ard results migh
+000217b0: 7420 6265 2072 652d 7072 6f78 6966 6965  t be re-proxifie
+000217c0: 642e 0a20 2020 2062 775f 666c 6174 5f73  d..    bw_flat_s
+000217d0: 6176 6564 5f66 6f72 5f62 6163 6b77 6172  aved_for_backwar
+000217e0: 642c 2073 7065 6320 3d20 7472 6565 5f66  d, spec = tree_f
+000217f0: 6c61 7474 656e 2862 6163 6b77 6172 645f  latten(backward_
+00021800: 7472 6163 652e 6172 6773 5b30 5d29 0a20  trace.args[0]). 
+00021810: 2020 2066 775f 666c 6174 5f73 6176 6564     fw_flat_saved
+00021820: 5f66 6f72 5f62 6163 6b77 6172 642c 205f  _for_backward, _
+00021830: 203d 2074 7265 655f 666c 6174 7465 6e28   = tree_flatten(
+00021840: 666f 7277 6172 645f 7472 6163 652e 6f75  forward_trace.ou
+00021850: 7470 7574 5b31 5d29 0a20 2020 2075 7365  tput[1]).    use
+00021860: 645f 6d61 736b 203d 206c 6973 7428 6c65  d_mask = list(le
+00021870: 6e28 636f 6e73 756d 6572 732e 6765 7428  n(consumers.get(
+00021880: 782c 2028 2929 2920 3e20 3020 666f 7220  x, ())) > 0 for 
+00021890: 7820 696e 2062 775f 666c 6174 5f73 6176  x in bw_flat_sav
+000218a0: 6564 5f66 6f72 5f62 6163 6b77 6172 6429  ed_for_backward)
+000218b0: 0a0a 2020 2020 2320 446f 6e27 7420 7573  ..    # Don't us
+000218c0: 6520 7468 6520 7361 6d65 2076 6172 6961  e the same varia
+000218d0: 626c 6520 7477 6963 6520 696e 2074 6865  ble twice in the
+000218e0: 2062 6163 6b77 6172 6420 7061 7373 0a20   backward pass. 
+000218f0: 2020 2073 6565 6e20 3d20 7365 7428 290a     seen = set().
+00021900: 2020 2020 6672 6f6d 2074 6875 6e64 6572      from thunder
+00021910: 2e63 6f72 652e 7072 6f78 6965 7320 696d  .core.proxies im
+00021920: 706f 7274 2056 6172 6961 626c 650a 0a20  port Variable.. 
+00021930: 2020 2066 6f72 2069 2c20 7820 696e 2065     for i, x in e
+00021940: 6e75 6d65 7261 7465 2866 775f 666c 6174  numerate(fw_flat
+00021950: 5f73 6176 6564 5f66 6f72 5f62 6163 6b77  _saved_for_backw
+00021960: 6172 6429 3a0a 2020 2020 2020 2020 7820  ard):.        x 
+00021970: 3d20 7661 7269 6162 6c65 6966 7928 7829  = variableify(x)
+00021980: 0a20 2020 2020 2020 2069 6620 6e6f 7420  .        if not 
+00021990: 6973 696e 7374 616e 6365 2878 2c20 5661  isinstance(x, Va
+000219a0: 7269 6162 6c65 293a 0a20 2020 2020 2020  riable):.       
+000219b0: 2020 2020 2063 6f6e 7469 6e75 650a 2020       continue.  
+000219c0: 2020 2020 2020 6966 2078 2069 6e20 7365        if x in se
+000219d0: 656e 3a0a 2020 2020 2020 2020 2020 2020  en:.            
+000219e0: 7573 6564 5f6d 6173 6b5b 695d 203d 2046  used_mask[i] = F
+000219f0: 616c 7365 0a20 2020 2020 2020 2065 6c73  alse.        els
+00021a00: 653a 0a20 2020 2020 2020 2020 2020 2073  e:.            s
+00021a10: 6565 6e2e 6164 6428 7829 0a0a 2020 2020  een.add(x)..    
+00021a20: 6f6e 6c79 5f75 7365 645f 6677 5f73 6176  only_used_fw_sav
+00021a30: 6564 5f66 6f72 5f62 6163 6b77 6172 6420  ed_for_backward 
+00021a40: 3d20 7475 706c 6528 636f 6d70 7265 7373  = tuple(compress
+00021a50: 2866 775f 666c 6174 5f73 6176 6564 5f66  (fw_flat_saved_f
+00021a60: 6f72 5f62 6163 6b77 6172 642c 2075 7365  or_backward, use
+00021a70: 645f 6d61 736b 2929 0a20 2020 206f 6e6c  d_mask)).    onl
+00021a80: 795f 7573 6564 5f62 775f 7361 7665 645f  y_used_bw_saved_
+00021a90: 666f 725f 6261 636b 7761 7264 203d 2074  for_backward = t
+00021aa0: 7570 6c65 2863 6f6d 7072 6573 7328 6277  uple(compress(bw
+00021ab0: 5f66 6c61 745f 7361 7665 645f 666f 725f  _flat_saved_for_
+00021ac0: 6261 636b 7761 7264 2c20 7573 6564 5f6d  backward, used_m
+00021ad0: 6173 6b29 290a 0a20 2020 2023 2057 6520  ask))..    # We 
+00021ae0: 6e65 6564 2074 6f20 7570 6461 7465 2074  need to update t
+00021af0: 6865 2074 7261 6365 7320 7769 7468 2074  he traces with t
+00021b00: 6865 206e 6577 2073 6176 6564 5f66 6f72  he new saved_for
+00021b10: 5f62 6163 6b77 6172 640a 2020 2020 5f75  _backward.    _u
+00021b20: 7064 6174 655f 666f 7277 6172 645f 7769  pdate_forward_wi
+00021b30: 7468 5f6e 6577 5f73 6176 6564 5f66 6f72  th_new_saved_for
+00021b40: 5f62 6163 6b77 6172 6428 666f 7277 6172  _backward(forwar
+00021b50: 645f 7472 6163 652c 206f 6e6c 795f 7573  d_trace, only_us
+00021b60: 6564 5f66 775f 7361 7665 645f 666f 725f  ed_fw_saved_for_
+00021b70: 6261 636b 7761 7264 290a 2020 2020 5f75  backward).    _u
+00021b80: 7064 6174 655f 6261 636b 7761 7264 5f77  pdate_backward_w
+00021b90: 6974 685f 6e65 775f 7361 7665 645f 666f  ith_new_saved_fo
+00021ba0: 725f 6261 636b 7761 7264 2862 6163 6b77  r_backward(backw
+00021bb0: 6172 645f 7472 6163 652c 206f 6e6c 795f  ard_trace, only_
+00021bc0: 7573 6564 5f62 775f 7361 7665 645f 666f  used_bw_saved_fo
+00021bd0: 725f 6261 636b 7761 7264 290a 2020 2020  r_backward).    
+00021be0: 666f 7277 6172 645f 7472 6163 652e 7365  forward_trace.se
+00021bf0: 745f 7072 6f76 656e 616e 6365 2854 7261  t_provenance(Tra
+00021c00: 6365 5072 6f76 656e 616e 6365 2822 4175  ceProvenance("Au
+00021c10: 676d 656e 7465 6420 666f 7277 6172 6420  gmented forward 
+00021c20: 7061 7373 2229 290a 2020 2020 6261 636b  pass")).    back
+00021c30: 7761 7264 5f74 7261 6365 2e73 6574 5f70  ward_trace.set_p
+00021c40: 726f 7665 6e61 6e63 6528 5472 6163 6550  rovenance(TraceP
+00021c50: 726f 7665 6e61 6e63 6528 2242 6163 6b77  rovenance("Backw
+00021c60: 6172 6420 7061 7373 2229 290a 2020 2020  ard pass")).    
+00021c70: 7265 7475 726e 2046 6f72 7761 7264 4261  return ForwardBa
+00021c80: 636b 7761 7264 5472 6163 6573 2866 6f72  ckwardTraces(for
+00021c90: 7761 7264 5f74 7261 6365 2c20 6261 636b  ward_trace, back
+00021ca0: 7761 7264 5f74 7261 6365 290a 0a0a 2320  ward_trace)...# 
+00021cb0: 646f 2077 6520 6861 7070 656e 2074 6f20  do we happen to 
+00021cc0: 7761 6e74 2074 6f20 7265 6769 7374 6572  want to register
+00021cd0: 2060 6c74 6f72 6368 6020 6f70 7320 7375   `ltorch` ops su
+00021ce0: 6368 2061 7320 606c 746f 7263 682e 6c61  ch as `ltorch.la
+00021cf0: 7965 725f 6e6f 726d 6020 6173 2077 656c  yer_norm` as wel
+00021d00: 6c3f 0a61 7574 6f63 6173 745f 696d 706c  l?.autocast_impl
+00021d10: 733a 2064 6963 745b 7072 696d 732e 5072  s: dict[prims.Pr
+00021d20: 696d 4944 732c 2043 616c 6c61 626c 655d  imIDs, Callable]
+00021d30: 203d 207b 7d0a 0a0a 6465 6620 7265 6769   = {}...def regi
+00021d40: 7374 6572 5f61 7574 6f63 6173 745f 7275  ster_autocast_ru
+00021d50: 6c65 286f 7029 3a0a 2020 2020 6465 6620  le(op):.    def 
+00021d60: 6465 636f 7261 746f 7228 6675 6e63 293a  decorator(func):
+00021d70: 0a20 2020 2020 2020 2061 7574 6f63 6173  .        autocas
+00021d80: 745f 696d 706c 735b 6f70 5d20 3d20 6675  t_impls[op] = fu
+00021d90: 6e63 0a20 2020 2020 2020 2072 6574 7572  nc.        retur
+00021da0: 6e20 6675 6e63 0a0a 2020 2020 7265 7475  n func..    retu
+00021db0: 726e 2064 6563 6f72 6174 6f72 0a0a 0a64  rn decorator...d
+00021dc0: 6566 206d 6179 6265 5f64 6f77 6e63 6173  ef maybe_downcas
+00021dd0: 745f 746f 2864 7479 7065 2c20 6172 6773  t_to(dtype, args
+00021de0: 293a 0a20 2020 2061 6c6c 6f77 6564 5f64  ):.    allowed_d
+00021df0: 6f77 6e63 6173 745f 7479 7065 7320 3d20  owncast_types = 
+00021e00: 2864 7479 7065 732e 666c 6f61 7431 362c  (dtypes.float16,
+00021e10: 2064 7479 7065 732e 6266 6c6f 6174 3136   dtypes.bfloat16
+00021e20: 2c20 6474 7970 6573 2e66 6c6f 6174 3332  , dtypes.float32
+00021e30: 290a 0a20 2020 2064 6566 206d 6170 5f66  )..    def map_f
+00021e40: 6e28 6129 3a0a 2020 2020 2020 2020 6966  n(a):.        if
+00021e50: 2069 7369 6e73 7461 6e63 6528 612c 2054   isinstance(a, T
+00021e60: 656e 736f 7250 726f 7879 2920 616e 6420  ensorProxy) and 
+00021e70: 612e 6474 7970 6520 696e 2061 6c6c 6f77  a.dtype in allow
+00021e80: 6564 5f64 6f77 6e63 6173 745f 7479 7065  ed_downcast_type
+00021e90: 733a 0a20 2020 2020 2020 2020 2020 2072  s:.            r
+00021ea0: 6574 7572 6e20 6d61 7962 655f 636f 6e76  eturn maybe_conv
+00021eb0: 6572 745f 746f 5f64 7479 7065 2861 2c20  ert_to_dtype(a, 
+00021ec0: 6474 7970 6529 0a20 2020 2020 2020 2072  dtype).        r
+00021ed0: 6574 7572 6e20 610a 0a20 2020 2072 6574  eturn a..    ret
+00021ee0: 7572 6e20 7472 6565 5f6d 6170 286d 6170  urn tree_map(map
+00021ef0: 5f66 6e2c 2061 7267 7329 0a0a 0a40 7265  _fn, args)...@re
+00021f00: 6769 7374 6572 5f61 7574 6f63 6173 745f  gister_autocast_
+00021f10: 7275 6c65 2822 746f 7263 682e 6d61 746d  rule("torch.matm
+00021f20: 756c 2229 0a40 7265 6769 7374 6572 5f61  ul").@register_a
+00021f30: 7574 6f63 6173 745f 7275 6c65 2870 7269  utocast_rule(pri
+00021f40: 6d73 2e50 7269 6d49 4473 2e4d 4154 4d55  ms.PrimIDs.MATMU
+00021f50: 4c29 0a64 6566 2061 7574 6f63 6173 745f  L).def autocast_
+00021f60: 6d61 746d 756c 5f72 756c 6528 612c 2062  matmul_rule(a, b
+00021f70: 2c20 6474 7970 6529 3a0a 2020 2020 2222  , dtype):.    ""
+00021f80: 2241 7574 6f63 6173 7420 7275 6c65 2066  "Autocast rule f
+00021f90: 6f72 206d 6174 6d75 6c22 2222 0a20 2020  or matmul""".   
+00021fa0: 2072 6574 7572 6e20 7072 696d 732e 6d61   return prims.ma
+00021fb0: 746d 756c 282a 286d 6179 6265 5f64 6f77  tmul(*(maybe_dow
+00021fc0: 6e63 6173 745f 746f 2864 7479 7065 2c20  ncast_to(dtype, 
+00021fd0: 2861 2c20 6229 2929 290a 0a0a 4072 6567  (a, b))))...@reg
+00021fe0: 6973 7465 725f 6175 746f 6361 7374 5f72  ister_autocast_r
+00021ff0: 756c 6528 2274 6f72 6368 2e6e 6e2e 6675  ule("torch.nn.fu
+00022000: 6e63 7469 6f6e 616c 2e6c 696e 6561 7222  nctional.linear"
+00022010: 290a 4072 6567 6973 7465 725f 6175 746f  ).@register_auto
+00022020: 6361 7374 5f72 756c 6528 7072 696d 732e  cast_rule(prims.
+00022030: 5072 696d 4944 732e 4c49 4e45 4152 290a  PrimIDs.LINEAR).
+00022040: 6465 6620 6175 746f 6361 7374 5f6c 696e  def autocast_lin
+00022050: 6561 725f 7275 6c65 2861 2c20 772c 2062  ear_rule(a, w, b
+00022060: 6961 732c 2064 7479 7065 293a 0a20 2020  ias, dtype):.   
+00022070: 2069 6620 6269 6173 2069 7320 4e6f 6e65   if bias is None
+00022080: 3a0a 2020 2020 2020 2020 2320 446f 6e27  :.        # Don'
+00022090: 7420 7061 7373 2060 6269 6173 6020 746f  t pass `bias` to
+000220a0: 206d 6179 6265 5f64 6f77 6e63 6173 745f   maybe_downcast_
+000220b0: 746f 2e0a 2020 2020 2020 2020 646f 776e  to..        down
+000220c0: 6361 7374 5f61 7267 7320 3d20 6d61 7962  cast_args = mayb
+000220d0: 655f 646f 776e 6361 7374 5f74 6f28 6474  e_downcast_to(dt
+000220e0: 7970 652c 2028 612c 2077 2929 202b 2028  ype, (a, w)) + (
+000220f0: 6269 6173 2c29 0a20 2020 2065 6c73 653a  bias,).    else:
+00022100: 0a20 2020 2020 2020 2064 6f77 6e63 6173  .        downcas
+00022110: 745f 6172 6773 203d 206d 6179 6265 5f64  t_args = maybe_d
+00022120: 6f77 6e63 6173 745f 746f 2864 7479 7065  owncast_to(dtype
+00022130: 2c20 2861 2c20 772c 2062 6961 7329 290a  , (a, w, bias)).
+00022140: 0a20 2020 2072 6574 7572 6e20 7072 696d  .    return prim
+00022150: 732e 6c69 6e65 6172 282a 646f 776e 6361  s.linear(*downca
+00022160: 7374 5f61 7267 7329 0a0a 0a40 7265 6769  st_args)...@regi
+00022170: 7374 6572 5f61 7574 6f63 6173 745f 7275  ster_autocast_ru
+00022180: 6c65 2822 746f 7263 682e 6e6e 2e66 756e  le("torch.nn.fun
+00022190: 6374 696f 6e61 6c2e 7363 616c 6564 5f64  ctional.scaled_d
+000221a0: 6f74 5f70 726f 6475 6374 5f61 7474 656e  ot_product_atten
+000221b0: 7469 6f6e 2229 0a64 6566 2061 7574 6f63  tion").def autoc
+000221c0: 6173 745f 7363 616c 6564 5f64 6f74 5f70  ast_scaled_dot_p
+000221d0: 726f 6475 6374 5f61 7474 656e 7469 6f6e  roduct_attention
+000221e0: 280a 2020 2020 7175 6572 792c 0a20 2020  (.    query,.   
+000221f0: 206b 6579 2c0a 2020 2020 7661 6c75 652c   key,.    value,
+00022200: 0a20 2020 2061 7474 6e5f 6d61 736b 2c0a  .    attn_mask,.
+00022210: 2020 2020 6472 6f70 6f75 745f 702c 0a20      dropout_p,. 
+00022220: 2020 2069 735f 6361 7573 616c 2c0a 2020     is_causal,.  
+00022230: 2020 2a2c 0a20 2020 2064 7479 7065 2c0a    *,.    dtype,.
+00022240: 2020 2020 7363 616c 652c 0a29 3a0a 2020      scale,.):.  
+00022250: 2020 6672 6f6d 2074 6875 6e64 6572 2e74    from thunder.t
+00022260: 6f72 6368 2069 6d70 6f72 7420 7363 616c  orch import scal
+00022270: 6564 5f64 6f74 5f70 726f 6475 6374 5f61  ed_dot_product_a
+00022280: 7474 656e 7469 6f6e 0a0a 2020 2020 712c  ttention..    q,
+00022290: 206b 2c20 7620 3d20 6d61 7962 655f 646f   k, v = maybe_do
+000222a0: 776e 6361 7374 5f74 6f28 6474 7970 652c  wncast_to(dtype,
+000222b0: 2028 7175 6572 792c 206b 6579 2c20 7661   (query, key, va
+000222c0: 6c75 6529 290a 2020 2020 7265 7475 726e  lue)).    return
+000222d0: 2073 6361 6c65 645f 646f 745f 7072 6f64   scaled_dot_prod
+000222e0: 7563 745f 6174 7465 6e74 696f 6e28 712c  uct_attention(q,
+000222f0: 206b 2c20 762c 2061 7474 6e5f 6d61 736b   k, v, attn_mask
+00022300: 2c20 6472 6f70 6f75 745f 702c 2069 735f  , dropout_p, is_
+00022310: 6361 7573 616c 2c20 7363 616c 653d 7363  causal, scale=sc
+00022320: 616c 6529 0a0a 0a64 6566 2061 7574 6f63  ale)...def autoc
+00022330: 6173 745f 7379 6d62 6f6c 5f6d 6170 7065  ast_symbol_mappe
+00022340: 7228 626f 756e 645f 7379 6d62 6f6c 3a20  r(bound_symbol: 
+00022350: 426f 756e 6453 796d 626f 6c49 6e74 6572  BoundSymbolInter
+00022360: 6661 6365 2c20 6474 7970 653a 2064 7479  face, dtype: dty
+00022370: 7065 732e 6474 7970 6529 3a0a 2020 2020  pes.dtype):.    
+00022380: 2222 2252 6574 7572 6e20 7468 6520 6361  """Return the ca
+00022390: 6c6c 6162 6c65 2069 6d70 6c65 6d65 6e74  llable implement
+000223a0: 696e 6720 7468 6520 6175 746f 6361 7374  ing the autocast
+000223b0: 2072 756c 6520 666f 7220 7468 6520 7379   rule for the sy
+000223c0: 6d62 6f6c 2e0a 0a20 2020 2041 7267 733a  mbol...    Args:
+000223d0: 0a20 2020 2020 2020 2062 6f75 6e64 5f73  .        bound_s
+000223e0: 796d 626f 6c3a 204d 6170 7065 6420 746f  ymbol: Mapped to
+000223f0: 2069 7473 2061 7574 6f63 6173 7420 7275   its autocast ru
+00022400: 6c65 2e0a 0a20 2020 2052 6574 7572 6e73  le...    Returns
+00022410: 3a0a 2020 2020 2020 2020 4361 6c6c 6162  :.        Callab
+00022420: 6c65 3a20 5468 6520 6361 6c6c 6162 6c65  le: The callable
+00022430: 2069 6d70 6c65 6d65 6e74 696e 6720 7468   implementing th
+00022440: 6520 6175 746f 6361 7374 2072 756c 6520  e autocast rule 
+00022450: 666f 7220 7468 6520 7379 6d62 6f6c 2e0a  for the symbol..
+00022460: 2020 2020 2222 220a 2020 2020 6175 746f      """.    auto
+00022470: 6361 7374 5f69 6d70 6c3a 2043 616c 6c61  cast_impl: Calla
+00022480: 626c 6520 7c20 4e6f 6e65 203d 2061 7574  ble | None = aut
+00022490: 6f63 6173 745f 696d 706c 732e 6765 7428  ocast_impls.get(
+000224a0: 626f 756e 645f 7379 6d62 6f6c 2e73 796d  bound_symbol.sym
+000224b0: 2e69 6429 0a20 2020 2072 6574 7572 6e20  .id).    return 
+000224c0: 626f 756e 645f 7379 6d62 6f6c 2e73 796d  bound_symbol.sym
+000224d0: 2069 6620 6175 746f 6361 7374 5f69 6d70   if autocast_imp
+000224e0: 6c20 6973 204e 6f6e 6520 656c 7365 2070  l is None else p
+000224f0: 6172 7469 616c 2861 7574 6f63 6173 745f  artial(autocast_
+00022500: 696d 706c 2c20 6474 7970 653d 6474 7970  impl, dtype=dtyp
+00022510: 6529 0a0a 0a64 6566 2061 7574 6f63 6173  e)...def autocas
+00022520: 7428 6675 6e63 3a20 4361 6c6c 6162 6c65  t(func: Callable
+00022530: 2c20 6474 7970 653a 2064 7479 7065 732e  , dtype: dtypes.
+00022540: 6474 7970 6529 3a0a 2020 2020 2222 2254  dtype):.    """T
+00022550: 7261 6e73 666f 726d 7320 6120 6675 6e63  ransforms a func
+00022560: 7469 6f6e 2074 6f20 6175 746f 6361 7374  tion to autocast
+00022570: 2063 6572 7461 696e 206f 7065 7261 7469   certain operati
+00022580: 6f6e 732e 0a0a 2020 2020 4172 6773 3a0a  ons...    Args:.
+00022590: 2020 2020 2020 2020 6675 6e63 3a20 5468          func: Th
+000225a0: 6520 6675 6e63 7469 6f6e 2074 6f20 6265  e function to be
+000225b0: 2074 7261 6e73 666f 726d 6564 2e0a 2020   transformed..  
+000225c0: 2020 2020 2020 6474 7970 653a 2054 6865        dtype: The
+000225d0: 2064 6174 6120 7479 7065 2074 6f20 7768   data type to wh
+000225e0: 6963 6820 6172 6775 6d65 6e74 7320 6f66  ich arguments of
+000225f0: 2074 6865 2066 756e 6374 696f 6e20 6f72   the function or
+00022600: 2073 7562 2066 756e 6374 696f 6e73 2063   sub functions c
+00022610: 6f75 6c64 2067 6574 2063 6173 7420 6966  ould get cast if
+00022620: 0a20 2020 2020 2020 2020 2020 2074 6865  .            the
+00022630: 7920 6172 6520 6064 7479 7065 732e 666c  y are `dtypes.fl
+00022640: 6f61 7433 3260 2e0a 0a20 2020 2052 6574  oat32`...    Ret
+00022650: 7572 6e73 3a0a 2020 2020 2020 2020 4361  urns:.        Ca
+00022660: 6c6c 6162 6c65 3a20 5468 6520 7472 616e  llable: The tran
+00022670: 7366 6f72 6d65 6420 6675 6e63 7469 6f6e  sformed function
+00022680: 0a20 2020 2022 2222 0a0a 2020 2020 6966  .    """..    if
+00022690: 206e 6f74 2069 7369 6e73 7461 6e63 6528   not isinstance(
+000226a0: 6474 7970 652c 2064 7479 7065 732e 6474  dtype, dtypes.dt
+000226b0: 7970 6529 3a0a 2020 2020 2020 2020 7261  ype):.        ra
+000226c0: 6973 6520 5661 6c75 6545 7272 6f72 2866  ise ValueError(f
+000226d0: 2260 6474 7970 6560 2069 7320 6578 7065  "`dtype` is expe
+000226e0: 6374 6564 2074 6f20 6265 2060 7468 756e  cted to be `thun
+000226f0: 6465 722e 6474 7970 652e 6474 7970 6560  der.dtype.dtype`
+00022700: 2062 7574 207b 7479 7065 2864 7479 7065   but {type(dtype
+00022710: 297d 2229 0a20 2020 2069 6620 6474 7970  )}").    if dtyp
+00022720: 6520 6e6f 7420 696e 207b 6474 7970 6573  e not in {dtypes
+00022730: 2e66 6c6f 6174 3136 2c20 6474 7970 6573  .float16, dtypes
+00022740: 2e62 666c 6f61 7431 367d 3a0a 2020 2020  .bfloat16}:.    
+00022750: 2020 2020 7261 6973 6520 5661 6c75 6545      raise ValueE
+00022760: 7272 6f72 2866 2260 6474 7970 6560 2069  rror(f"`dtype` i
+00022770: 7320 6578 7065 6374 6564 2074 6f20 6265  s expected to be
+00022780: 2065 6974 6865 7220 6074 6875 6e64 6572   either `thunder
+00022790: 2e66 6c6f 6174 3136 6020 6f72 2060 7468  .float16` or `th
+000227a0: 756e 6465 722e 6266 6c6f 6174 3136 602c  under.bfloat16`,
+000227b0: 2062 7574 207b 6474 7970 657d 2229 0a0a   but {dtype}")..
+000227c0: 2020 2020 4077 7261 7073 2866 756e 6329      @wraps(func)
+000227d0: 0a20 2020 2064 6566 2077 7261 7070 6572  .    def wrapper
+000227e0: 282a 6172 6773 2c20 2a2a 6b77 6172 6773  (*args, **kwargs
+000227f0: 293a 0a20 2020 2020 2020 2074 7261 6365  ):.        trace
+00022800: 203d 2063 6f6e 7374 7275 6374 5f74 7261   = construct_tra
+00022810: 6365 2829 2866 756e 632c 202a 6172 6773  ce()(func, *args
+00022820: 2c20 2a2a 6b77 6172 6773 290a 2020 2020  , **kwargs).    
+00022830: 2020 2020 7265 7475 726e 2065 7661 6c5f      return eval_
+00022840: 7472 6163 6528 7472 6163 652c 202a 6172  trace(trace, *ar
+00022850: 6773 2c20 2a2a 6b77 6172 6773 2c20 7379  gs, **kwargs, sy
+00022860: 6d62 6f6c 5f6d 6170 7065 723d 7061 7274  mbol_mapper=part
+00022870: 6961 6c28 6175 746f 6361 7374 5f73 796d  ial(autocast_sym
+00022880: 626f 6c5f 6d61 7070 6572 2c20 6474 7970  bol_mapper, dtyp
+00022890: 653d 6474 7970 6529 290a 0a20 2020 2072  e=dtype))..    r
+000228a0: 6574 7572 6e20 7772 6170 7065 720a       eturn wrapper.
```

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/core/utils.py` & `lightning_thunder-0.2.0.dev20240519/thunder/core/utils.py`

 * *Files 2% similar despite different names*

```diff
@@ -203,15 +203,15 @@
 
     if len(args) == 0:
         return None, None
 
     numbertype = None
     dtype = None
     for a in args:
-        if isinstance(a, Number):
+        if isinstance(a, (Number, NumberProxy)):
             typ = to_dtype(a)
             if numbertype is None:
                 numbertype = typ
 
             check(
                 typ is numbertype,
                 lambda: f"Expected numbertype {numbertype} but found {typ}!",
@@ -392,14 +392,15 @@
 class ELEMENTWISE_TYPE_PROMOTION_KIND(Enum):
     DEFAULT = (0,)
     PRESERVE = (1,)
     INT_TO_FLOAT = (2,)
     ALWAYS_BOOL = (3,)
     COMPLEX_TO_FLOAT = (4,)
     BOOL_TO_LONG = (5,)
+    NUMBER_TO_INT = (6,)
 
 
 # TODO: allow dtypes as arguments, too
 def elementwise_type_promotion(*args, type_promotion_kind: ELEMENTWISE_TYPE_PROMOTION_KIND):
     """Computes the computation and result types for elementwise type promotion on the given arguments and with the
     given elementwise type promotion kind.
 
@@ -443,20 +444,24 @@
 
       DEFAULT                 : add
       PRESERVE                : where, nextafter, cat
       INT_TO_FLOAT            : sin
       COMPLEX_TO_FLOAT        : abs
       BOOL_TO_LONG            : pow
       ALWAYS_BOOL             : eq
+      NUMBER_TO_INT           : ceil, floor
     """
 
     # Type checks inputs
     check(len(args) > 0, lambda: f"Execpted one or more arguments for type promotion, but got {args=}")
+    all_number_type = True
     for a in args:
-        check_type(a, (TensorProxy, Number))
+        check_type(a, (TensorProxy, Number, NumberProxy))
+        if not isinstance(a, (Number, NumberProxy)):
+            all_number_type = False
 
     # Computes the promotion type
     extracted = tuple(to_dtype(x, true_dtype=True) for x in args)
     promotiontype = reduce(_elementwise_type_promotion, extracted, bool)
 
     # Applies the different kinds of type promotion
     if type_promotion_kind is ELEMENTWISE_TYPE_PROMOTION_KIND.PRESERVE:
@@ -472,14 +477,21 @@
         if is_low_precision_dtype(promotiontype):
             return get_computation_dtype(promotiontype), dtypes.corresponding_real_dtype(promotiontype)
         return promotiontype, dtypes.corresponding_real_dtype(promotiontype)
 
     if type_promotion_kind is ELEMENTWISE_TYPE_PROMOTION_KIND.BOOL_TO_LONG and is_boolean_dtype(promotiontype):
         return int, int
 
+    if (
+        type_promotion_kind is ELEMENTWISE_TYPE_PROMOTION_KIND.NUMBER_TO_INT
+        and is_float_dtype(promotiontype)
+        and all_number_type
+    ):
+        return int, int
+
     # Falls through to DEFAULT
     if is_low_precision_dtype(promotiontype):
         return get_computation_dtype(promotiontype), promotiontype
     return promotiontype, promotiontype
 
 
 def const_as(number, dtype):
@@ -609,15 +621,15 @@
 def validate_idx(rank: int, idx: int):
     """Validates that idx is a valid index for the given shape.
 
     Assumes the index is already canonicalized.
     """
 
     check(
-        isinstance(idx, int) and idx >= 0 and (idx < rank or idx == 0),
+        isinstance(idx, (int, NumberProxy)) and idx >= 0 and (idx < rank or idx == 0),
         lambda: f"Found invalid index {idx} for rank {rank}!",
     )
 
 
 def check_no_duplicates(dims: Sequence):
     def _reify(x):
         if isinstance(x, NumberProxy):
@@ -1044,14 +1056,15 @@
         >>> x_proxy = trace.args[0]
         >>> y_proxy = trace.args[1]
         >>> intermediate = trace.bound_symbols[-3].output
         >>> utils.find_producer_symbols(trace, [intermediate], [x_proxy, y_proxy])
         (__b = ltorch.sub(x, y)
         # __b = prims.sub(x, y),)
     """
+    stop_proxies = tuple(filter(lambda x: isinstance(x, Proxy), stop_proxies))
     trace_producers = producers(trace)
     result = set()
     queue = list(proxies)
     seen = set()
     while queue:
         proxy = queue.pop()
         p = trace_producers.get(proxy, None)
```

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/core/vjp_utils.py` & `lightning_thunder-0.2.0.dev20240519/thunder/core/vjp_utils.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/cudagraphs/__init__.py` & `lightning_thunder-0.2.0.dev20240519/thunder/cudagraphs/__init__.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/distributed/__init__.py` & `lightning_thunder-0.2.0.dev20240519/thunder/distributed/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,12 +1,11 @@
 from __future__ import annotations
 import os
 
 from itertools import chain
-import collections
 from contextlib import contextmanager
 from contextvars import ContextVar, Token
 import copy
 from enum import auto, Enum
 from typing import TYPE_CHECKING, Any
 from collections.abc import Generator
 from functools import partial
@@ -16,15 +15,15 @@
 import torch.distributed as tdist
 
 import thunder.core.utils as utils
 from thunder.core.proxies import DDPType
 
 if TYPE_CHECKING:
     from torch.distributed import ProcessGroup
-    import thunder
+    from thunder.core.module import ThunderModule
 
 
 __all__ = [
     "ddp",
     "fsdp",
     "FSDPBucketingStrategy",
     "FSDPType",
@@ -364,114 +363,46 @@
 #
 # Note that for doing so, there are a few constraints / caveats:
 # - We do not have prologues/compute traces when we transform the module.
 # - We need to record the info from the module transformations because a later transform might modify the module further.
 
 
 def fsdp_transform_module(
-    thunder_model: thunder.ThunderModule,
+    thunder_model: ThunderModule,
     *,
     device: torch.device | None = None,
     broadcast_from: int | None = None,
     sharding_strategy: FSDPType = FSDPType.ZERO2,
     bucketing_strategy: FSDPBucketingStrategy = FSDPBucketingStrategy.NONE,
-) -> thunder.ThunderModule:
-    import thunder
-
-    cd = thunder.compile_data(thunder_model)
-    # TODO: promote use_fsdp and use_ddp to public members of CompileData
-    cd.use_fsdp = True
+) -> ThunderModule:
+    from thunder import compile_data as get_compile_data
+    from thunder.core.transforms import add_transform
+    from thunder.core.module import ThunderModule
+    from thunder.distributed.transforms.fsdp_v2 import FSDPTraceTransform
 
     process_group = tdist.distributed_c10d._get_default_group()
     utils.check(process_group is not None, lambda: "The default process group is None")
     global_rank = tdist.get_rank(group=process_group)
     world_size = tdist.get_world_size(group=process_group)
     if device is None:
         local_rank = int(os.environ["LOCAL_RANK"])
         device = torch.device("cuda", local_rank)
 
-    def prologue_and_compute_transform(prologue_trace, computation_trace, epilogue_trace, **kwargs):
-        import thunder
-
-        prologue_producers, prologue_consumers = thunder.core.utils.producers_and_consumers(prologue_trace)
-        computation_producers, computation_consumers = thunder.core.utils.producers_and_consumers(computation_trace)
-
-        modules_and_thunder_modules = [
-            (bsym.args[0], bsym.output)
-            for bsym in prologue_trace.bound_symbols
-            if bsym.sym is thunder.prims.unpack_thunder_module
-        ]
-
-        if len(modules_and_thunder_modules) != 1:
-            raise NotImplementedError("cannot deal with modules other than the compiled module")
-
-        ((orig_module_proxy, thunder_module_proxy),) = modules_and_thunder_modules
-        if prologue_producers[orig_module_proxy].sym is not thunder.prims.unpack_function_obj:
-            raise NotImplementedError("original module does not match the compiled module")
-
-        computation_trace.push_scope([])
-
-        synchronized_parameters = []
-        # todo: deal with epilogue output
-        for pro_out_p, comp_inp_p in zip(prologue_trace.output, computation_trace.args):
-            bsym = prologue_producers[pro_out_p]
-            if bsym.sym == thunder.prims.unpack_parameter:
-                param_thunder_module, param_name = bsym.args
-                assert param_thunder_module is thunder_module_proxy
-                if param_name in sharded_params:
-                    old_shape, new_shape, new_torch_device = sharded_params[param_name]
-                    thunder_device = thunder.core.devices.to_device(new_torch_device)
-                    thunder_device_str = str(thunder_device)
-
-                    pro_out_p._ddp_type = thunder.core.proxies.DDPType.FULLY_SHARDED
-                    pro_out_p._shape = tuple(new_shape)
-                    pro_out_p._device = thunder_device
-                    if comp_inp_p is not pro_out_p:
-                        comp_inp_p._ddp_type = thunder.core.proxies.DDPType.FULLY_SHARDED
-                        comp_inp_p._shape = tuple(new_shape)
-                        comp_inp_p._device = thunder_device
-                    with thunder.core.trace.tracectx(computation_trace):
-                        synchronized_parameters.append(thunder.distributed.prims.synchronize(comp_inp_p, process_group))
-
-                    for c in prologue_consumers[pro_out_p]:
-                        if c.sym is thunder.core.prims.check_tensor_shape_and_metadata:
-                            # TODO have a more principled way to update this?
-                            a0, _, _, *a2pp = c.args
-                            c.args = (a0, tuple(new_shape), thunder_device_str, *a2pp)
-
-        new_scope = computation_trace.pop_scope()
-
-        for bsym in prologue_trace.bound_symbols:
-            if bsym.sym is thunder.core.prims.check_tensor_shape_and_metadata and prologue_producers[
-                bsym.args[0]
-            ].sym in (thunder.core.prims.unpack_parameter, thunder.core.prims.unpack_buffer):
-                param_thunder_module, name = prologue_producers[bsym.args[0]].args
-                assert param_thunder_module is thunder_module_proxy
-                if name not in sharded_params and name in device_adjutments:
-                    a0, shape, _, *a2pp = bsym.args
-                    bsym.args = (a0, shape, thunder_device_str, *a2pp)
-
-        proxies_to_replace = {id(bsym.args[0]): bsym.output for bsym in new_scope}
-
-        new_computation_trace = thunder.core.trace.from_trace(computation_trace)
-        for idx, bsym in enumerate(computation_trace.bound_symbols):
-            if bsym.sym != thunder.core.prims.unpack_trivial:
-                break
-            new_computation_trace.bound_symbols.append(bsym.from_bsym())
-        new_computation_trace.bound_symbols += new_scope
-        for bsym in computation_trace.bound_symbols[idx:]:
-            new_args = tuple(proxies_to_replace.get(id(a), a) for a in bsym.args)
-            new_computation_trace.bound_symbols.append(bsym.from_bsym(args=new_args))
-
-        new_computation_trace.set_provenance(thunder.core.trace.TraceProvenance("fsdp pass"))
-
-        return prologue_trace, new_computation_trace, epilogue_trace
-
-    # add prologue + compute transform
-    thunder_model = thunder.core.transforms.add_transform(thunder_model, early_transform=prologue_and_compute_transform)
+    cd = get_compile_data(thunder_model)
+    # TODO: promote use_fsdp and use_ddp to public members of CompileData
+    cd.use_fsdp = True
+    orig_module: torch.nn.Module = cd.fn
+    utils.check(
+        isinstance(orig_module, torch.nn.Module) and not isinstance(orig_module, ThunderModule),
+        lambda: f"CompileData.fn expected to be `nn.Module` but {type(orig_module)}",
+    )
+    orig_module.use_fsdp = True
+    orig_module.process_group_for_ddp = process_group
+    orig_module.bucketing_strategy = bucketing_strategy
+    orig_module.sharding_strategy = sharding_strategy
 
     # modify module
     sharded_params = {}
     device_adjustments = {}
     for module_name, _ in thunder_model._model.named_modules():
         submodule = thunder_model.get_submodule(module_name)
 
@@ -481,15 +412,15 @@
 
         # Materialize meta-parameters on-device if necessary.
         # This is done before sharding in case the materialization logic depends on the tensor shape.
         # The tradeoff is that all of a module's direct parameters need to fit in device.
         # Each module only initializes its own parameters and not those of its children (recurse=False)
         if any(t.is_meta for t in chain(module_copy.parameters(recurse=False), module_copy.buffers(recurse=False))):
             # TODO: we could also support calling a "param_init_fn" argument like PyTorch
-            thunder.distributed._materialize(module_copy, device)
+            _materialize(module_copy, device)
             for n, p in module_copy.named_parameters(recurse=False, prefix=module_name):
                 thunder_model._overrides[n] = p
                 device_adjustments[n] = device
             for n, b in module_copy.named_buffers(recurse=False, prefix=module_name):
                 thunder_model._overrides[n] = b
                 device_adjustments[n] = device
         else:
@@ -514,18 +445,25 @@
                 tdist.broadcast(thunder_model.get_buffer(pn), src=broadcast_from, group=process_group, async_op=False)
 
         for pn, p in submodule.named_parameters(recurse=False, prefix=module_name):
             if pn not in thunder_model._overrides:
                 thunder_model._overrides[pn] = copy.copy(p)
             # we collect shapes and devices because we do not know if other transforms also change it...
             old_shape = thunder_model._overrides[pn].shape
-            thunder.distributed._shard_param(thunder_model._overrides[pn], global_rank, world_size, pn)
+            _shard_param(thunder_model._overrides[pn], global_rank, world_size, pn, allow_padding_for_fsdp=True)
             new_shape = thunder_model._overrides[pn].shape
             sharded_params[pn] = (old_shape, new_shape, thunder_model._overrides[pn].device)
 
+    early_transform_from_trace_to_fsdp_trace = FSDPTraceTransform(
+        sharded_params=sharded_params,
+        process_group=process_group,
+    )
+    # add prologue + compute transform
+    thunder_model = add_transform(thunder_model, early_transform=early_transform_from_trace_to_fsdp_trace)
+
     return thunder_model
 
 
 def fsdp(
     model: torch.nn.Module,
     *,
     device: torch.device | None = None,
@@ -545,15 +483,17 @@
     To apply bucketing of collective communications, specify either
     :obj:`~thunder.distributed.FSDPBucketingStrategy.LAYER` or :obj:`BucketingStrategy.BLOCK` as
     ``bucketing_strategy``.
     The latter uses one collective communication, be it AllGather to unshard parameters or
     ReduceScatter to shard gradients, for one Transformer block. The former users one per layer such as
     :class:`torch.nn.Linear` and :class:`torch.nn.LayerNorm`.
 
-     Args:
+    See :doc:`/notebooks/dev_tutorials/fsdp_tutorial` to see how parameters are sharded across devices and how communications calls are inserted.
+
+    Args:
         model: The model to convert.
 
     Keyword Args:
         device: The corresponding model shard will be moved to this device. We recommend setting this to ``torch.cuda.current_device()``.
         broadcast_from: The rank of the device hosting the parameters to broadcast. If None is passed,
             broadcasting will be skipped (default). Enabling can be useful for models whose weights have been loaded
             from a checkpoint in a single rank.
@@ -585,15 +525,15 @@
     utils.check(process_group is not None, lambda: "The default process group is None")
     model.use_fsdp = True
     model.process_group_for_ddp = process_group
     model.sharding_strategy = sharding_strategy
     model.bucketing_strategy = bucketing_strategy
 
     # Shard the parameters
-    _shard_params(model, process_group, device, broadcast_from)
+    _shard_params(model, process_group, device, broadcast_from, allow_padding_for_fsdp=True)
 
     # See Note [DistributedDataParallel and ddp_type]
     # If model was wrapped with thunder.distributed.fsdp it would have a
     # .use_fsdp attribute set to True and all parameters would be already
     # sharded across all other processes. So that our tracing is aware of
     # this we need to mark the ddp_type of model's parameters as
     # thunder.proxies.DDPType.FULLY_SHARDED
@@ -601,15 +541,19 @@
         p.ddp_type = DDPType.FULLY_SHARDED
 
     return model
 
 
 @torch.no_grad()
 def _shard_params(
-    module: torch.nn.Module, process_group: ProcessGroup, device: torch.device | None, broadcast_from: int | None
+    module: torch.nn.Module,
+    process_group: ProcessGroup,
+    device: torch.device | None,
+    broadcast_from: int | None,
+    allow_padding_for_fsdp: bool = False,
 ) -> None:
     """Shards the parameters on the first dimension."""
     global_rank = tdist.get_rank(group=process_group)
     world_size = tdist.get_world_size(group=process_group)
     if device is None:
         local_rank = int(os.environ["LOCAL_RANK"])
         device = torch.device("cuda", local_rank)
@@ -632,30 +576,49 @@
         if broadcast_from is not None:
             for tensor in chain(submodule.parameters(recurse=False), submodule.buffers(recurse=False)):
                 tdist.broadcast(tensor, src=broadcast_from, group=process_group, async_op=False)
 
         # Note [FSDP Sharding]
         # All internal code will assume that the parameters are sharded on the first dimension
         for param_name, param in submodule.named_parameters(recurse=False, prefix=module_name):
-            _shard_param(param, global_rank, world_size, param_name)
+            _shard_param(param, global_rank, world_size, param_name, allow_padding_for_fsdp=allow_padding_for_fsdp)
 
 
-def _shard_param(param: torch.Tensor, rank: int, world_size: int, name: str) -> None:
-    utils.check(
-        param.shape[0] % world_size == 0,
-        lambda: (
-            f"Current sharding requires the first dimension of the parameter {name!r} ({param.shape[0]})"
-            f" to be divisible by the world size ({world_size})"
-        ),
-    )
-    chunk_size = param.shape[0] // world_size
-    # NOTE This could be a ShardTensor to indicate other parts of the code
-    # that it's sharded and should be treated differently
-    shard = param.data.narrow(0, chunk_size * rank, chunk_size).clone()
-    param.data = shard
+def _shard_param(
+    param: torch.Tensor,
+    rank: int,
+    world_size: int,
+    name: str,
+    allow_padding_for_fsdp: bool = False,
+) -> None:
+
+    if not allow_padding_for_fsdp or (param.size(0) % world_size == 0):
+        if not allow_padding_for_fsdp:
+            utils.check(
+                param.shape[0] % world_size == 0,
+                lambda: (
+                    f"Current sharding requires the first dimension of the parameter {name!r} ({param.shape[0]})"
+                    f" to be divisible by the world size ({world_size})"
+                ),
+            )
+        chunk_size = param.shape[0] // world_size
+        # NOTE This could be a ShardTensor to indicate other parts of the code
+        # that it's sharded and should be treated differently
+        shard = param.data.narrow(0, chunk_size * rank, chunk_size).clone()
+        param.data = shard
+    else:
+        padded_param_shape = list(param.shape)
+        orig_0dim_size = param.size(0)
+        chunk_size = (padded_param_shape[0] + world_size - 1) // world_size
+        padded_param_shape[0] = chunk_size * world_size
+        _thunder_fsdp_padding_size = padded_param_shape[0] - param.size(0)
+        padded_param = torch.empty(padded_param_shape, device=param.device, dtype=param.dtype)
+        padded_param[:orig_0dim_size].copy_(param)
+        param.data = padded_param.data.narrow(0, chunk_size * rank, chunk_size).clone()
+        param._thunder_fsdp_padding_size = _thunder_fsdp_padding_size
 
 
 @torch.no_grad()
 def _unshard_params(module: torch.nn.Module, process_group: ProcessGroup, cpu_offload: bool = False) -> None:
     """Unshard a module's parameters.
 
     This supports CPU offloading of parameters.
```

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/distributed/bucketing.py` & `lightning_thunder-0.2.0.dev20240519/thunder/distributed/bucketing.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/distributed/checkpoint.py` & `lightning_thunder-0.2.0.dev20240519/thunder/distributed/checkpoint.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/distributed/prims.py` & `lightning_thunder-0.2.0.dev20240519/thunder/distributed/prims.py`

 * *Files 1% similar despite different names*

```diff
@@ -144,15 +144,19 @@
 def wait_meta(a: FutureTensorProxy, /) -> TensorProxy:
     check_if_distributed_available()
     utils.check_type(a, FutureTensorProxy)
 
     return TensorProxy(like=a)
 
 
-def synchronize_meta(a: TensorProxy, /, group: torch.distributed.ProcessGroup) -> TensorProxy:
+def synchronize_meta(
+    a: TensorProxy,
+    /,
+    group: torch.distributed.ProcessGroup,
+) -> TensorProxy:
     utils.check_type(a, TensorProxy)
     utils.check_type(group, torch.distributed.ProcessGroup)
 
     match a.ddp_type:
         case DDPType.REPLICATED:
             return TensorProxy(like=a)
         case DDPType.FULLY_SHARDED:
@@ -282,15 +286,16 @@
     "stash_grad_for_fsdp",
     meta=stash_grad_for_fsdp_meta,
 )
 
 
 @register_augmented_forward(PrimIDs.SYNCHRONIZE)
 def synchronize_augmented_forward_rule(
-    a: TensorProxy, group: torch.distributed.ProcessGroup
+    a: TensorProxy,
+    group: torch.distributed.ProcessGroup,
 ) -> tuple[TensorProxy, tuple]:
     match a.ddp_type:
         case DDPType.REPLICATED:
             # Assuming that the input is a replicated tensor, so no need to do anything
             # in the forward pass
             return a, (
                 a.ddp_type,
@@ -298,25 +303,27 @@
             )
         case DDPType.FULLY_SHARDED:
             # Assuming that the sharding is done on the first dimension.
             # We do the communication on the side CUDA stream and wait is
             # immediately called on the result with the hope that the execution
             # passes would reorder the wait operation to be closer to the actual
             # usage of the tensor.
-            return all_gather(a, group, do_async=True).wait(), (
+            return all_gather(a, group, True).wait(), (
                 a.ddp_type,
                 group,
             )
         case _:
             utils.check(False, lambda: f"Proxy {a} has unexpected {a.ddp_type=}")
 
 
 @register_backward(PrimIDs.SYNCHRONIZE)
 def synchronize_backward_rule(
-    ddp_type: DDPType, group: torch.distributed.ProcessGroup, grad: TensorProxy
+    ddp_type: DDPType,
+    group: torch.distributed.ProcessGroup,
+    grad: TensorProxy,
 ) -> tuple[TensorProxy, None]:
     preaverage_grad = grad / group.size()
     match ddp_type:
         case DDPType.REPLICATED:
             synced_grad = all_reduce(preaverage_grad, DistributedReduceOps.SUM, group, do_async=True).wait()
         case DDPType.FULLY_SHARDED:
             synced_grad = reduce_scatter(preaverage_grad, DistributedReduceOps.SUM, group, do_async=True).wait()
```

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/distributed/transforms/ddp.py` & `lightning_thunder-0.2.0.dev20240519/thunder/distributed/transforms/ddp.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/distributed/transforms/fsdp.py` & `lightning_thunder-0.2.0.dev20240519/thunder/distributed/transforms/fsdp.py`

 * *Files 0% similar despite different names*

```diff
@@ -500,15 +500,15 @@
                         index_to_fqn[index] = rev_fqn_to_proxy_name[tmp_name]
             self.index_to_fqn = index_to_fqn
 
     def _collect_sharded_parameters(self, fwd_trace: TraceCtx) -> list[TensorProxy]:
         fwd_trace_flat_args, _ = tree_flatten((fwd_trace.args, fwd_trace.kwargs))
         return fwd_trace_flat_args
 
-    def apply_bucketing_to_forward_trace(self, fwd_trace: TraceCtx, bwd_trace_names: set[str]) -> TraceCtx:
+    def apply_bucketing_to_forward_trace(self, fwd_trace: TraceCtx) -> TraceCtx:
         """Optimize collective comms in fsdp with bucketing.
 
         This function is no-op if you pass :obj:`BucketingStrategy.NONE` as kwarg of ``sharding_strategy`` to :func:`thunder.distributed.fsdp`.
         With :obj:`BucketingStrategy.LAYER`, buckets will be created per :class:`torch.nn.Module` such as
         :class:`torch.nn.Linear`, and :class:`torch.nn.LayerNorm`.
         Use :obj:`BucketingStrategy.BLOCK` to assign a bucket to one :class:`torch.nn.Transformer`.
```

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/distributed/utils.py` & `lightning_thunder-0.2.0.dev20240519/thunder/distributed/utils.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/examine/__init__.py` & `lightning_thunder-0.2.0.dev20240519/thunder/examine/__init__.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/examine/memory_caculation.py` & `lightning_thunder-0.2.0.dev20240519/thunder/examine/memory_caculation.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/executors/__init__.py` & `lightning_thunder-0.2.0.dev20240519/thunder/executors/__init__.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/executors/apex_entropyex.py` & `lightning_thunder-0.2.0.dev20240519/thunder/executors/apex_entropyex.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/executors/cudnn_layernormex.py` & `lightning_thunder-0.2.0.dev20240519/thunder/executors/cudnn_layernormex.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/executors/cudnnex.py` & `lightning_thunder-0.2.0.dev20240519/thunder/executors/cudnnex.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/executors/data_dependent_partition.py` & `lightning_thunder-0.2.0.dev20240519/thunder/executors/data_dependent_partition.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/executors/nvfuserex.py` & `lightning_thunder-0.2.0.dev20240519/thunder/executors/nvfuserex.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/executors/nvfuserex_impl.py` & `lightning_thunder-0.2.0.dev20240519/thunder/executors/nvfuserex_impl.py`

 * *Files 0% similar despite different names*

```diff
@@ -153,15 +153,15 @@
             return False
 
     rank_supported = a.ndim <= 8
     return devicetype_supported and dtype_supported and rank_supported
 
 
 def is_supported_tensor_or_number(a: TensorProxy | Number) -> bool:
-    if isinstance(a, Number):
+    if isinstance(a, (Number, NumberProxy)):
         return True
 
     return is_supported_tensor(a)
 
 
 # Returns True when all arguments given are supported tensors
 #   Throws an error if any arguments are not tensors
```

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/executors/passes.py` & `lightning_thunder-0.2.0.dev20240519/thunder/executors/passes.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,15 @@
 from thunder.core.symbol import BoundSymbol
 from thunder.core.pytree import tree_flatten, tree_unflatten, tree_map
 import thunder.core.prims as prims
 from thunder.core.proxies import Proxy, variableify, unvariableify, Variable, CollectionProxy
 import thunder.core.transforms as transforms
 from thunder.core.transform_common import dce
 from thunder.core.trace import get_tracectx
-from thunder.executors.pythonex import clear_collection
+from thunder.executors.pythonex import clear_mutable_collection
 
 from thunder.extend import Executor, get_always_executors, OperatorExecutor, FusionExecutor
 
 comment_symbols = {prims.PrimIDs.COMMENT, prims.PrimIDs.UNPACK_TRIVIAL}
 
 
 # Transforms a trace by determining which execution transforms to call given the list of executors in priority order
@@ -225,21 +225,21 @@
     elapsed_time_ns = end_time_ns - start_time_ns
     elapsed_time_millis = elapsed_time_ns // 1000000
     new_trace.set_provenance(TraceProvenance(f"Update Call Context (took {elapsed_time_millis} milliseconds)"))
     return new_trace
 
 
 # TODO Review deleting non-proxies
-def del_last_used(trace: TraceCtx, *, clear_collections=False) -> TraceCtx:
+def del_last_used(trace: TraceCtx, *, clear_mutable_collections=False) -> TraceCtx:
     """Mark last used intermediates to be deleted. This lets the Python garbage collector free
         unused tensor memory.
 
     Args:
         trace: trace to be transformed
-        clear_collections: whether to clear collections
+        clear_mutable_collections: whether to clear collections
     Returns:
         list: transformed trace
     """
     start_time_ns = time.time_ns()
 
     del_trace = from_trace(trace)
     bsyms = deque()
@@ -264,26 +264,26 @@
             if x in handled:
                 continue
 
             handled[x] = None
             to_del.append(x)
 
         to_clear_collections = []
-        if clear_collections:
+        if clear_mutable_collections:
             for x in to_del:
                 if isinstance(x, CollectionProxy):
                     to_clear_collections.append(x)
 
         # NOTE The check for return avoids putting dels after the return statement
         if to_del and bsym.sym.id is not prims.PrimIDs.RETURN:
             del_sym: BoundSymbol = prims.python_del.bind(*to_del, output=None)
             bsyms.appendleft(del_sym)
 
             for x in to_clear_collections:
-                bsyms.appendleft(clear_collection.bind(x, output=None))
+                bsyms.appendleft(clear_mutable_collection.bind(x, output=None))
 
         bsyms.appendleft(bsym)
 
     del_trace.bound_symbols = list(bsyms)
 
     end_time_ns = time.time_ns()
     elapsed_time_ns = end_time_ns - start_time_ns
```

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/executors/pythonex.py` & `lightning_thunder-0.2.0.dev20240519/thunder/executors/pythonex.py`

 * *Files 2% similar despite different names*

```diff
@@ -10,15 +10,15 @@
 from types import ModuleType
 import platform
 
 import torch
 
 import thunder.core.prims as prims
 from thunder.core.prims import PrimIDs
-from thunder.core.proxies import TensorProxy, CollectionProxy
+from thunder.core.proxies import NumberProxy, TensorProxy, CollectionProxy
 from thunder.core.symbol import Symbol, BoundSymbol
 from thunder.core import baseutils
 import thunder.core.dtypes as dtypes
 import thunder.core.devices as devices
 import thunder.core.utils as utils
 
 from thunder.extend import OperatorExecutor, register_executor, add_always_executor
@@ -215,21 +215,21 @@
     return a.real
 
 
 def _signbit_prim_impl(a: Number) -> bool:
     return a < 0
 
 
-def _clear_collection_meta(coll: CollectionProxy) -> None:
+def _clear_mutable_collection_meta(coll: CollectionProxy) -> None:
     baseutils.check_type(coll, CollectionProxy)
     baseutils.check_type(coll.coll, Sequence)
     return None
 
 
-def _clear_collection_prim_impl(a: Collection) -> None:
+def _clear_mutable_collection_prim_impl(a: Collection) -> None:
     if isinstance(a, (MutableSequence, MutableMapping, MutableSet)):
         a.clear()
 
 
 acos = ex.register_operator("acos", like=prims.acos, module=math)
 acosh = ex.register_operator("acosh", like=prims.acosh, module=math)
 asin = ex.register_operator("asin", like=prims.asin, module=math)
@@ -237,15 +237,17 @@
 atan = ex.register_operator("atan", like=prims.atan, module=math)
 atanh = ex.register_operator("atanh", like=prims.atanh, module=math)
 py_abs = ex.register_operator("abs", like=prims.py_abs, module=builtins)
 tensor_abs = ex.register_operator("tensor_abs", like=prims.abs, fn=_tensor_abs_prim_impl)
 neg = ex.register_operator("neg", like=prims.neg, module=operator)
 real = ex.register_operator("real", like=prims.real, fn=_real_prim_impl)
 signbit = ex.register_operator("signbit", like=prims.signbit, fn=_signbit_prim_impl)
-clear_collection = ex.register_operator("clear_collection", meta=_clear_collection_meta, fn=_clear_collection_prim_impl)
+clear_mutable_collection = ex.register_operator(
+    "clear_mutable_collection", meta=_clear_mutable_collection_meta, fn=_clear_mutable_collection_prim_impl
+)
 
 ex.register_implementation(prims.acos, acos, checker=_elementwise_unary_checker)
 ex.register_implementation(prims.acosh, acosh, checker=_elementwise_unary_checker)
 ex.register_implementation(prims.asin, asin, checker=_elementwise_unary_checker)
 ex.register_implementation(prims.asinh, asinh, checker=_elementwise_unary_checker)
 ex.register_implementation(prims.atan, atan, checker=_elementwise_unary_checker)
 ex.register_implementation(prims.atanh, atanh, checker=_elementwise_unary_checker)
@@ -289,15 +291,15 @@
 
 #
 # Elementwise binary primitives
 #
 
 
 def _elementwise_binary_checker(a: Number | TensorProxy, b: Number | TensorProxy) -> bool:
-    return isinstance(a, Number) and isinstance(b, Number)
+    return isinstance(a, (Number, NumberProxy)) and isinstance(b, (Number, NumberProxy))
 
 
 add = ex.register_operator("add", like=prims.add, module=operator)
 atan2 = ex.register_operator("atan2", like=prims.atan2, module=operator)
 bitwise_and = ex.register_operator("bitwise_and", like=prims.bitwise_and, module=operator)
 bitwise_or = ex.register_operator("bitwise_or", like=prims.bitwise_or, module=operator)
 bitwise_xor = ex.register_operator("bitwise_xor", like=prims.bitwise_xor, module=operator)
```

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/executors/sdpaex.py` & `lightning_thunder-0.2.0.dev20240519/thunder/executors/sdpaex.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/executors/torch_autograd.py` & `lightning_thunder-0.2.0.dev20240519/thunder/executors/torch_autograd.py`

 * *Files 0% similar despite different names*

```diff
@@ -154,15 +154,15 @@
 
     # autograd.Function.backward expects a flat tuple of gradients
     bw_trace.bound_symbols[-1] = replace(bw_trace.bound_symbols[-1], args=(filtered_grads,))
 
     _fsdp_comm_bucketing: FSDPCommBucketing | None = None
     if getattr(compile_data.fn, "use_fsdp", False):
         _fsdp_comm_bucketing = FSDPCommBucketing(compile_data, computation_trc)
-        fw_trace = _fsdp_comm_bucketing.apply_bucketing_to_forward_trace(fw_trace, bw_trace.names)
+        fw_trace = _fsdp_comm_bucketing.apply_bucketing_to_forward_trace(fw_trace)
 
     # Now we can run the optimization passes on the forward trace
     # TODO Restore request for no rematerialization
     fw_extrace = transform_for_execution(
         fw_trace,
         executors_list=compile_data.executors_list,
     )
@@ -247,15 +247,15 @@
     if transformer_engine_ex in compile_data.executors_list:
         # NOTE: `_transformer_engine_bwd_fp8_meta_sync` may mutate `fw_extrace` or `bw_extrace`.
         _transformer_engine_bwd_fp8_meta_sync(fw_extrace, bw_extrace)
 
     fw_extrace = del_last_used(fw_extrace)
     fw_traces.append(fw_extrace)
 
-    bw_extrace = del_last_used(bw_extrace, clear_collections=True)
+    bw_extrace = del_last_used(bw_extrace, clear_mutable_collections=True)
     bw_traces.append(bw_extrace)
 
     bw_trace = rename_bwd_trace_outputs(bw_extrace, fw_extrace)
 
     if compile_stats is not None:
         compile_stats.last_traces += fw_traces
         compile_stats.last_backward_traces += bw_traces
```

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/executors/torch_compile.py` & `lightning_thunder-0.2.0.dev20240519/thunder/executors/torch_compile.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/executors/torchex.py` & `lightning_thunder-0.2.0.dev20240519/thunder/executors/torchex.py`

 * *Files 1% similar despite different names*

```diff
@@ -22,15 +22,15 @@
 import thunder.core.dtypes as dtypes
 from thunder.core.dtypes import to_torch_dtype, to_dtype
 import thunder.core.devices as devices
 from thunder.core.devices import to_torch_device, to_device
 import thunder.core.prims as prims
 from thunder.core.prims import PrimIDs
 from thunder.core.trace import TraceCtx, set_tracectx, reset_tracectx, from_trace
-from thunder.core.proxies import TensorProxy, FutureTensorProxy, variableify, pytype
+from thunder.core.proxies import NumberProxy, TensorProxy, FutureTensorProxy, variableify, pytype
 from thunder.core.pytree import tree_flatten, tree_unflatten
 from thunder.core.symbol import Symbol, BoundSymbol
 from thunder.distributed.prims import DistributedReduceOps
 import thunder.distributed.prims as dist_prims
 import thunder.core.utils as utils
 
 import thunder.torch as ltorch
@@ -163,14 +163,15 @@
 full_like = _register_torch_operation("full_like")
 ones = _register_torch_operation("ones")
 ones_like = _register_torch_operation("ones_like")
 tensor_from_sequence = _register_torch_operation("tensor")
 zeros = _register_torch_operation("zeros")
 zeros_like = _register_torch_operation("zeros_like")
 randn = _register_torch_operation("randn")
+empty = _register_torch_operation("empty")
 einsum = _register_torch_operation("einsum")
 
 
 def _uniform_philox_like(
     shape: Sequence[int],
     *,
     stride: None = None,
@@ -413,14 +414,25 @@
     dtype: dtypes.dtype,
 ) -> TensorLike:
     torch_device: torch.device = to_torch_device(device)
     torch_dtype: torch.dtype = to_torch_dtype(dtype)
     return randn(shape, device=torch_device, dtype=torch_dtype)
 
 
+def _empty_prims_transform(
+    shape: tuple[int, ...],
+    *,
+    device: devices.Device,
+    dtype: dtypes.dtype,
+) -> TensorLike:
+    torch_device: torch.device = to_torch_device(device)
+    torch_dtype: torch.dtype = to_torch_dtype(dtype)
+    return empty(shape, device=torch_device, dtype=torch_dtype)
+
+
 def _tensor_from_sequence_prims_transform(
     seq_or_number, *, device: devices.Device, dtype: None | dtypes.dtype
 ) -> TensorLike:
     torch_device: torch.device = to_torch_device(device)
     torch_dtype: torch.dtype = to_torch_dtype(dtype)
     return tensor_from_sequence(seq_or_number, device=torch_device, dtype=torch_dtype)
 
@@ -428,14 +440,15 @@
 _register_implementation(prims.full, checker=_always_executable, execution_transform=_full_transform)
 _register_implementation(prims.iota, checker=_always_executable, execution_transform=_iota_transform)
 _register_implementation(prims.uniform, checker=_always_executable, execution_transform=_uniform_transform)
 _register_implementation(
     prims.uniform_philox, checker=_uniform_philox_prim_checker, execution_transform=_uniform_philox_prim_transform
 )
 _register_implementation(prims.randn, checker=_always_executable, execution_transform=_randn_prims_transform)
+_register_implementation(prims.empty, checker=_always_executable, execution_transform=_empty_prims_transform)
 _register_implementation(
     prims.tensor_from_sequence, checker=_always_executable, execution_transform=_tensor_from_sequence_prims_transform
 )
 
 _register_implementation(ltorch.arange, checker=_always_executable, execution_transform=_arange_transform)
 _register_implementation(ltorch.full, checker=_always_executable, execution_transform=_full_transform)
 _register_implementation(ltorch.full_like, checker=_always_executable, execution_transform=_full_like_transform)
@@ -470,14 +483,16 @@
 tensor_split = _register_torch_operation("tensor_split")
 transpose = _register_torch_operation("transpose")
 unbind = _register_torch_operation("unbind")
 unfold = _register_torch_operation("unfold", module=torch.Tensor)
 unsqueeze = _register_torch_operation("unsqueeze")
 view = _register_torch_operation("view", module=torch.Tensor)
 view_as = _register_torch_operation("view_as", module=torch.Tensor)
+all_tensor = _register_torch_operation("all", like=ltorch.all_tensor)
+any_tensor = _register_torch_operation("any", like=ltorch.any_tensor)
 
 
 def _broadcast_in_dim_prim_transform(
     a: TensorProxy, /, shape: Sequence[int], broadcast_dimensions: Sequence[int]
 ) -> TensorProxy:
     s = list(shape)
 
@@ -528,14 +543,38 @@
 # NOTE PyTorch has a bug where it doesn't interpret calls like squeeze(a, None) correctly
 def _squeeze_transform(a: TensorLike, /, dim: None | int | Sequence[int] = None) -> TensorLike:
     if dim is None:
         return squeeze(a)
     return squeeze(a, dim)
 
 
+def _empty_transform(
+    shape: Sequence[int],
+    device: None | DeviceLike = None,
+    dtype: None | dtypeLike = None,
+    out: None | TensorLike = None,
+    layout: torch.layout = torch.strided,
+    requires_grad: bool = False,
+    pin_memory: bool = False,
+    memory_format: torch.memory_format = torch.contiguous_format,
+):
+    torch_device: None | torch.device = to_torch_device(device)
+    torch_dtype: None | torch.dtype = to_torch_dtype(dtype)
+    return empty(
+        shape,
+        device=torch_device,
+        dtype=torch_dtype,
+        out=out,
+        layout=layout,
+        requires_grad=requires_grad,
+        pin_memory=pin_memory,
+        memory_format=memory_format,
+    )
+
+
 _register_implementation(
     prims.broadcast_in_dim, checker=_always_executable, execution_transform=_broadcast_in_dim_prim_transform
 )
 _register_implementation(prims.cat, cat, checker=_always_executable)
 _register_implementation(prims.flip, flip, checker=_always_executable)
 _register_implementation(prims.reshape, reshape, checker=_always_executable)
 slice_prim_impl = ex.register_operator("torch_slice_prim_impl", meta=prims.slice_prim.meta, fn=_slice_prim_impl)
@@ -563,14 +602,17 @@
 _register_implementation(ltorch.tensor_split, tensor_split, checker=_always_executable)
 _register_implementation(ltorch.transpose, transpose, checker=_always_executable)
 _register_implementation(ltorch.unbind, unbind, checker=_always_executable)
 _register_implementation(ltorch.unfold, unfold, checker=_always_executable)
 _register_implementation(ltorch.unsqueeze, unsqueeze, checker=_always_executable)
 _register_implementation(ltorch.view, view, checker=_always_executable)
 _register_implementation(ltorch.view_as, view_as, checker=_always_executable)
+_register_implementation(ltorch.empty, empty, checker=_always_executable, execution_transform=_empty_transform)
+_register_implementation(ltorch.all_tensor, all_tensor, checker=_always_executable)
+_register_implementation(ltorch.any_tensor, any_tensor, checker=_always_executable)
 
 #
 # Memory format operations
 #
 contiguous = _register_torch_operation("contiguous", module=torch.Tensor)
 
 
@@ -976,15 +1018,15 @@
 # NOTE PyTorch's checking of whether a number can be safely cast to a different type is based on the number's value, not
 #   the type of the number as is done here
 def _masked_fill_checker(a: TensorLike, /, mask: TensorLike, value: Number | TensorLike) -> bool:
     if not dtypes.is_boolean_dtype(mask.dtype):
         return False
 
     value_dtype: type | dtypes.dtype
-    if isinstance(value, Number):
+    if isinstance(value, (Number, NumberProxy)):
         value_dtype = pytype(value)
     else:
         if len(value.shape) != 0:
             return False
         value_dtype = value.dtype
 
     return utils.can_safe_cast_to(cast_from=value_dtype, cast_to=a.dtype)
```

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/executors/transformer_engineex.py` & `lightning_thunder-0.2.0.dev20240519/thunder/executors/transformer_engineex.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/executors/triton_crossentropy_impl.py` & `lightning_thunder-0.2.0.dev20240519/thunder/executors/triton_crossentropy_impl.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/executors/utils.py` & `lightning_thunder-0.2.0.dev20240519/thunder/executors/utils.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/extend/__init__.py` & `lightning_thunder-0.2.0.dev20240519/thunder/extend/__init__.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/functional.py` & `lightning_thunder-0.2.0.dev20240519/thunder/functional.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/numpy/__init__.py` & `lightning_thunder-0.2.0.dev20240519/thunder/numpy/__init__.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/numpy/langctx.py` & `lightning_thunder-0.2.0.dev20240519/thunder/numpy/langctx.py`

 * *Files identical despite different names*

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/torch/__init__.py` & `lightning_thunder-0.2.0.dev20240519/thunder/torch/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -20,15 +20,15 @@
 from thunder.core.devices import to_device, device_from_string
 import thunder.core.dtypes as dtypes
 from thunder.core.dtypes import to_torch_dtype, to_dtype, _thunder_to_torch_dtype_map, _torch_to_thunder_dtype_map
 import thunder.core.prims as prims
 import thunder.core.utils as utils
 import thunder.distributed.prims as dist_prims
 from thunder.core.langctxs import langctx, Languages
-from thunder.core.proxies import TensorProxy, FutureTensorProxy
+from thunder.core.proxies import FloatProxy, IntegerProxy, NumberProxy, TensorProxy, FutureTensorProxy, pyval
 from thunder.core.pytree import tree_map
 from thunder.core.symbol import Symbol
 from thunder.core.transforms import register_grad, put_grads
 from thunder.core.prims import get_grad, put_grad
 from thunder.core.baseutils import run_once
 
 __all__ = [
@@ -38,14 +38,15 @@
 # NOTE torch is a requirement
 import torch
 import torch.distributed as tdist
 
 import warnings
 
 # Type annotation helpers
+NumberLike = Number | NumberProxy
 TensorLike = TensorProxy
 FutureTensorLike = FutureTensorProxy
 DeviceLike = str | devices.Device | torch.device
 dtypeLike = dtypes.dtype | torch.dtype
 
 
 # TODO RC1 Remove this map
@@ -110,16 +111,14 @@
             else:
                 utils.check(
                     False,
                     lambda: f"The torchsymbol decorator failed to infer an id for {name}, specify one explicitly (with id=<your id>)",
                     exception_type=AssertionError,
                 )
         else:
-            if not self.id.startswith("torch"):
-                warnings.warn(f"{self.id=} does not start with the namespace of `torch`")
             id = self.id
 
         if self.is_prim:
             sym = Symbol(
                 name=fn.__name__, meta=langctx(Languages.PRIMS)(_fn), id=id, is_prim=self.is_prim, tags=self.tags
             )
         else:
@@ -169,15 +168,15 @@
 @torchsymbol(torch.is_floating_point, is_method=True)
 def is_floating_point(a: TensorLike, /) -> bool:
     return dtypes.is_float_dtype(a.dtype)
 
 
 # Handles the size method
 def size(a: TensorLike, /, dim: None | int = None) -> int | Sequence[int]:
-    if dim:
+    if dim is not None:
         return a.shape[dim]
     return a.shape
 
 
 register_method("size", size)
 
 
@@ -190,14 +189,21 @@
 
 
 @torchsymbol(torch.Tensor.is_cuda, is_property=True, id="torch.is_cuda")
 def is_cuda(a: TensorLike, /) -> bool:
     return a.device.devicetype is devices.DeviceType.CUDA
 
 
+# is nested always returns False for now:
+# https://github.com/Lightning-AI/lightning-thunder/issues/93#issuecomment-2030416883
+@torchsymbol(torch.Tensor.is_nested, is_property=True, id="torch.is_nested")
+def is_nested(a: TensorLike, /) -> bool:
+    return False
+
+
 _torch_dtype_to_old_torch_typestring_map = {
     torch.float32: "FloatTensor",
     torch.float64: "DoubleTensor",
     torch.float16: "HalfTensor",
     torch.bfloat16: "BFloat16Tensor",
     torch.uint8: "ByteTensor",
     torch.int8: "CharTensor",
@@ -285,15 +291,15 @@
 # Data movement and transformation operations
 #
 
 
 # NOTE This handles a.float()
 #   It avoids using the name "float" to not collide with the builtin
 #   "float"
-def to_float(a: Number | TensorLike) -> Number | TensorLike:
+def to_float(a: NumberLike | TensorLike) -> Number | TensorLike:
     return clang.maybe_convert_to_dtype(a, dtypes.float32)
 
 
 register_method("float", to_float)
 
 
 # NOTE to's parsing is a little whacky
@@ -431,24 +437,29 @@
     # TODO Create a generic Tensor annotation, and support both PyTorch
     #   tensors and TensorProxies being passed to this operation
     utils.check_type(b, TensorProxy)
 
     return to(a, b.true_dtype)
 
 
+@torchsymbol(torch.Tensor.long, is_method=True)
+def long(a: TensorLike, /, memory_format: torch.memory_format = torch.preserve_format) -> TensorLike:
+    return to(a, dtype=dtypes.int64, memory_format=memory_format)
+
+
 #
 # Tensor creation operations
 #
 
 
 @torchsymbol(torch.arange)
 def arange(
-    start: Number,
+    start: NumberLike,
     end: None | Number = None,
-    step: Number = 1,
+    step: NumberLike = 1,
     *,
     device: None | DeviceLike = None,
     dtype: None | dtypeLike = None,
 ) -> TensorLike:
     if device is None:
         device = "cpu"
 
@@ -459,28 +470,28 @@
         end = start
         start = 0
     return clang.arange(start=start, step=step, stop=end, device=device, dtype=dtype)
 
 
 @torchsymbol(torch.full)
 def full(
-    shape: Sequence[int], fill_value: Number, *, device: None | DeviceLike = None, dtype: None | dtypeLike = None
+    shape: Sequence[int], fill_value: NumberLike, *, device: None | DeviceLike = None, dtype: None | dtypeLike = None
 ) -> TensorLike:
     if device is None:
         device = "cpu"
 
     device = to_device(device)
     dtype = to_dtype(dtype)
 
     return clang.full(shape, fill_value, device=device, dtype=dtype)
 
 
 @torchsymbol(torch.full_like)
 def full_like(
-    a: TensorLike, /, fill_value: Number, *, device: None | DeviceLike = None, dtype: None | dtypeLike = None
+    a: TensorLike, /, fill_value: NumberLike, *, device: None | DeviceLike = None, dtype: None | dtypeLike = None
 ) -> TensorLike:
     device = to_device(device)
     dtype = to_dtype(dtype)
     return clang.full_like(a, fill_value, device=device, dtype=dtype)
 
 
 # NOTE ones, unlike full, can accept an integer shape
@@ -511,44 +522,44 @@
         exception_type=NotImplementedError,
     )
     utils.check(
         not requires_grad, lambda: "requires_grad=True is not yet supported within thunder.compile", NotImplementedError
     )
     utils.check(not pin_memory, lambda: "pin_memory=True is not supported within thunder.compile", NotImplementedError)
 
-    if isinstance(seq_or_number, Number):
+    if isinstance(seq_or_number, (Number, NumberProxy)):
         return full((), seq_or_number, dtype=dtype, device=device)
 
     return clang.tensor_from_sequence(seq_or_number, dtype=dtype, device=device)
 
 
 # TODO based on uniform_, check if Torch now has a functional uniform
 # NOTE the uniform_ documentation suggests the interval is specified using "from" and "to",
 #   but from is a reserved keyword in Python
 @torchsymbol(is_method=False, id="torch.uniform")
 def uniform(
     shape: Sequence[int],
-    minval: Number = 0.0,
-    maxval: Number = 1.0,
+    minval: NumberLike = 0.0,
+    maxval: NumberLike = 1.0,
     *,
     device: DeviceLike,
     dtype: dtypeLike,
 ) -> TensorLike:
     device = to_device(device)
     dtype = to_dtype(dtype)
 
     return clang.uniform(shape, minval, maxval, device=device, dtype=dtype)
 
 
 @torchsymbol(is_method=False, id="torch.uniform_like")
 def uniform_like(
     a: TensorLike,
     /,
-    minval: Number = 0.0,
-    maxval: Number = 1.0,
+    minval: NumberLike = 0.0,
+    maxval: NumberLike = 1.0,
     *,
     device: None | DeviceLike = None,
     dtype: None | dtypeLike = None,
 ) -> TensorLike:
     device = to_device(device)
     dtype = to_dtype(dtype)
 
@@ -578,16 +589,16 @@
 
 
 # TODO Maybe update this to return an offset of how far to advance the seed to acquire new values
 # See issue "Maybe return offset from thunder.torch.uniform_philox"
 @torchsymbol(is_method=False, id="torch.uniform_philox")
 def uniform_philox(
     shape: Sequence[int],
-    minval: Number = 0.0,
-    maxval: Number = 1.0,
+    minval: NumberLike = 0.0,
+    maxval: NumberLike = 1.0,
     *,
     device: DeviceLike,
     dtype: dtypeLike,
     seed: int | TensorProxy,
     offset: int | TensorProxy,
 ) -> TensorLike:
     device = to_device(device)
@@ -681,14 +692,54 @@
 
 
 @torchsymbol(torch.zeros_like)
 def zeros_like(a: TensorLike, /, *, device: DeviceLike | None = None, dtype: dtypeLike | None = None) -> TensorLike:
     return full_like(a, 0, device=device, dtype=dtype)
 
 
+@torchsymbol(torch.empty)
+def empty(
+    *size: int,
+    device: None | DeviceLike = None,
+    dtype: None | dtypeLike = None,
+    out: None | TensorLike = None,
+    layout: torch.layout = torch.strided,
+    requires_grad: bool = False,
+    pin_memory: bool = False,
+    memory_format: torch.memory_format = torch.contiguous_format,
+) -> TensorLike:
+    size = utils.extract_shape_from_varargs(size)
+
+    utils.check(out is None, lambda: "empty(): out is not None which is currently unsupported", NotImplementedError)
+    utils.check(layout == torch.strided, lambda: "Only torch.strided layout is supported", NotImplementedError)
+    utils.check(
+        not requires_grad, lambda: "requires_grad=True is not yet supported within thunder.compile", NotImplementedError
+    )
+    utils.check(not pin_memory, lambda: "pin_memory=True is not supported within thunder.compile", NotImplementedError)
+    utils.check(
+        memory_format == torch.contiguous_format,
+        lambda: "Only torch.contiguous_format is supported",
+        NotImplementedError,
+    )
+
+    # For now we default to `float32`,
+    # however, we should add a default dtype or rely on `torch.get_default_dtype`.
+    if dtype is None:
+        dtype = torch.float
+    dtype = to_dtype(dtype)
+
+    # For now we default to "cpu",
+    # however, we should add a default device or rely on `torch.get_default_device`.
+    if device is None:
+        device = "cpu"
+    device = to_device(device)
+
+    return clang.empty(size, device=device, dtype=dtype)
+
+
 #
 # Shape operations
 #
 
 
 # TODO Update this to take a *args series of tensors or a sequence of tensors
 @torchsymbol(torch.cat)
@@ -784,15 +835,19 @@
 @torchsymbol(torch.flip, is_method=True)
 def flip(a: TensorLike, /, *dims: int) -> TensorLike:
     dims = utils.extract_shape_from_varargs(dims)
 
     # PyTorch supports 0-dim inputs with len(dims) <= 1
     if a.ndim == 0 and isinstance(dims, Sequence) and len(dims) > 0:
         utils.check(
-            len(dims) == 1 and isinstance(dims[0], int) and dims[0] in (0, -1),
+            len(dims) == 1
+            and (
+                (isinstance(dims[0], (int, IntegerProxy)) and dims[0] in (0, -1))
+                or (isinstance(dims[0], NumberProxy) and pyval(dims[0]) in (0, -1))
+            ),
             lambda: f"Expected {dims=} to be a sequence of integers in range [-1, 0], and of length 1",
         )
         return clang.flip(a, ())
 
     return clang.flip(a, dims)
 
 
@@ -829,15 +884,15 @@
 
 @torchsymbol(torch.movedim, is_method=True)
 def movedim(a: TensorLike, /, source: int | Sequence[int], destination: int | Sequence[int]) -> TensorLike:
     return clang.movedim(a, source, destination)
 
 
 @torchsymbol(torch.nn.functional.pad)
-def pad(a: TensorProxy, /, pad: tuple[int, ...], mode: str | None = "constant", value: Number | None = None):
+def pad(a: TensorProxy, /, pad: tuple[int, ...], mode: str | None = "constant", value: NumberLike | None = None):
     utils.check(mode == "constant", lambda: f"Mode arguments other than constant are not supported")
     utils.check(len(pad) % 2 == 0, lambda: f"Padding length must be divisible by 2")
     utils.check(
         len(pad) <= a.ndim * 2,
         lambda: f"Padding length should be less than or equal to two times the input dimension.",
     )
 
@@ -978,19 +1033,19 @@
     if isinstance(size_or_sections, TensorProxy):
         raise NotImplementedError
 
     dim = utils.canonicalize_dim(a.ndim, dim)
 
     utils.check_type(
         size_or_sections,
-        (int, Sequence),
+        (int, IntegerProxy, Sequence),
     )
 
     # TODO: consider revising this to just call _split_indices
-    if isinstance(size_or_sections, int):
+    if isinstance(size_or_sections, (int, IntegerProxy)):
         target_length = size_or_sections
 
         # Short-circuits special-case of zero
         if target_length == 0:
             utils.check(
                 a.shape[dim] == 0,
                 lambda: f"When size_or_sections={size_or_sections} is zero then the length of the split dimension ({a.shape[dim]}) must also be zero",
@@ -1043,15 +1098,15 @@
     # Converts dim to a tuple of numbers
     dims = dim
     if dim is None:
         dims = []
         for idx, l in enumerate(a.shape):
             if l == 1:
                 dims.append(idx)
-    elif isinstance(dim, int):
+    elif isinstance(dim, (int, NumberProxy)):
         dims = (dim,)
 
     # a.shape is being indexed below.
     # We want to make sure that dims is valid.
     dims = utils.canonicalize_dims(a.ndim, dims)
 
     # Make sure that squeezing a non-1 dim is a no-op
@@ -1100,15 +1155,15 @@
     utils.check(
         indices_or_sections,
         (Number, Sequence),
         lambda: f"indices_or_sections={indices_or_sections} should be a Number or a Sequence!",
     )
 
     # TODO: maybe revise _split_n to a call to _split_indices
-    if isinstance(indices_or_sections, Number):
+    if isinstance(indices_or_sections, (Number, NumberProxy)):
         return _split_n(a, indices_or_sections, dim)
 
     # NOTE: isinstance(indices_or_sections, Sequence)
     return _split_indices(a, indices_or_sections, dim)
 
 
 @torchsymbol(torch.transpose, is_method=True)
@@ -1156,20 +1211,20 @@
 #
 # Elementwise unary operaitons
 #
 # TODO Add type annotations
 
 
 @torchsymbol(torch.abs, is_method=True)
-def abs(a: Number | TensorLike, /) -> Number | TensorLike:
+def abs(a: NumberLike | TensorLike, /) -> Number | TensorLike:
     return clang.abs(a)
 
 
 @torchsymbol(torch.acos, is_method=True)
-def acos(a: Number | TensorLike, /) -> Number | TensorLike:
+def acos(a: NumberLike | TensorLike, /) -> Number | TensorLike:
     return clang.acos(a)
 
 
 @torchsymbol(torch.acosh, is_method=True)
 def acosh(a):
     return clang.acosh(a)
 
@@ -1424,15 +1479,15 @@
 #
 # Elementwise binary operations
 #
 
 
 @torchsymbol(torch.add, is_method=True)
 def add(
-    a: Number | TensorLike, b: Number | TensorLike, /, *, alpha: None | Number | TensorLike = None
+    a: NumberLike | TensorLike, b: NumberLike | TensorLike, /, *, alpha: None | Number | TensorLike = None
 ) -> Number | TensorLike:
     if alpha is not None:
         b = b * alpha
 
     return clang.add(a, b)
 
 
@@ -1540,15 +1595,17 @@
 def nextafter(a, b, /):
     return clang.nextafter(a, b)
 
 
 # TODO Extend to tensor x tensor
 @torchsymbol(torch.polygamma, torch.special.polygamma, is_method=True)
 def polygamma(n: int, a: TensorLike, /) -> TensorLike:
-    utils.check(isinstance(n, int), lambda: f"polygamma(n, a) expects the first argument to be an integer.")
+    utils.check(
+        isinstance(n, (int, NumberProxy)), lambda: f"polygamma(n, a) expects the first argument to be an integer."
+    )
     utils.check(n >= 0, lambda: f"polygamma(n, a) does not support negative {n=}.")
 
     # NOTE Use digamma for n == 0 case; otherwise zeta(1, a) returns math.inf
     if n == 0:
         return digamma(a)
 
     sign = 1 if (n % 2) == 1 else -1
@@ -1572,15 +1629,15 @@
     if alpha is not None:
         b = b * alpha
 
     return clang.sub(a, b)
 
 
 @torchsymbol(torch.true_divide, is_method=True)
-def true_divide(a: Number | TensorLike, b: Number | TensorLike, /) -> Number | TensorLike:
+def true_divide(a: NumberLike | TensorLike, b: NumberLike | TensorLike, /) -> Number | TensorLike:
     return clang.true_divide(a, b)
 
 
 @torchsymbol(torch.special.zeta)
 def zeta(a, b, /):
     return clang.zeta(a, b)
 
@@ -1673,15 +1730,15 @@
 # NOTE masked_fill is a strange wrapper around where, it probably exists only because of PyTorch's inplace pattern
 # NOTE PyTorch's masked fill requires value be a number or number tensor
 # NOTE PyTorch's masked fill is only defined as a tensor method that implicitly takes a as the first argument
 # NOTE PyTorch's masked_fill_ requires the dtype of a not change, so it checks that
 #   value can be safely cast to a (for numbers, it checks that the actual number value can safely be cast)
 # NOTE We have chosen not to emulate PyTorch's odd type promotion behavior for this operation
 @torchsymbol(torch.masked_fill, is_method=True)
-def masked_fill(a: TensorLike, /, mask: TensorLike, value: Number | TensorLike) -> TensorLike:
+def masked_fill(a: TensorLike, /, mask: TensorLike, value: NumberLike | TensorLike) -> TensorLike:
     result = where(mask, value, a)
     return result
 
 
 # NOTE The key to understanding tril is that it generates a mask
 #   which (by default) masks elements of a matrix (or batch of matrices)
 #   s.t. elements whose row number is greater than or equal to its column number
@@ -1705,15 +1762,15 @@
 
 
 @torchsymbol(torch.where, is_method=True)
 def where(
     pred: TensorLike, a: None | Number | TensorLike = None, b: None | Number | TensorLike = None, /
 ) -> TensorLike:
     utils.check(
-        isinstance(a, (Number, TensorProxy)) and isinstance(b, (Number, TensorProxy)),
+        isinstance(a, (Number, NumberProxy, TensorProxy)) and isinstance(b, (Number, NumberProxy, TensorProxy)),
         lambda: f"torch.where() does not support only specifying a condition",
         exception_type=NotImplementedError,
     )
     return clang.where(pred, a, b)
 
 
 @torchsymbol(torch.nan_to_num, is_method=True)
@@ -1815,15 +1872,15 @@
         result_dtype = None
     else:  # ALWAYS_BOOL
         result_dtype = torch.bool
     return computation_dtype, result_dtype
 
 
 def _reduction_dims(shape, dims: Sequence | None) -> tuple[int, ...]:
-    if isinstance(dims, int):
+    if isinstance(dims, (int, NumberProxy)):
         dims = (dims,)
     if dims is None or len(dims) == 0:
         return tuple(range(len(shape)))
 
     dims = tuple(utils.canonicalize_dim(len(shape), idx) for idx in dims)
     utils.check_no_duplicates(dims)
 
@@ -1843,26 +1900,26 @@
     output_dtype_kind: REDUCTION_OUTPUT_TYPE_KIND,
 ) -> TensorProxy:
     # TODO: check that a is the correct type?
 
     # reduces over all dimensions if dim=() is passed
     if dims == () or dims == []:
         dims = None
-    if isinstance(dims, int):
+    if isinstance(dims, (int, IntegerProxy)):
         dims = (dims,)
 
     utils.check(
         a.ndim <= 64,
         lambda: f"Received a tensor with {a.ndim} dimensions, but only tensors with up to 64 dims are supported!",
     )
 
     if not accepts_dim_tuple:
-        assert dims is None or isinstance(dims, int)
+        assert dims is None or isinstance(dims, (int, IntegerProxy))
 
-    if isinstance(dims, int):
+    if isinstance(dims, (int, IntegerProxy)):
         dims = (dims,)
 
     dims = _reduction_dims(a.shape, dims)
 
     if not has_identity:
         valid_shape = (a.ndim == 0) or all(a.shape[i] for i in dims)
         utils.check(
@@ -1882,14 +1939,46 @@
 
     if result_dtype is not None:
         result = tree_map(lambda x: to(x, result_dtype), result)
 
     return result
 
 
+@torchsymbol(torch.all, is_method=True, id="torch.all")
+def all_tensor(
+    a: TensorLike, /, dim: None | int | Sequence[int] = None, keepdim: bool = False, *, out: None | TensorLike = None
+) -> TensorLike:
+    # named as all_tensor to avoid confusion with python's built-in all function
+    utils.check(out is None, lambda: "out is not None which is currently unsupported", NotImplementedError)
+    result = logical_not(any_tensor(logical_not(a), dim=dim, keepdim=keepdim))
+
+    # Pytorch's torch.all matches the behavior of NumPy in returning output of dtype bool for all supported dtypes except uint8.
+    # For uint8 the dtype of output is uint8 iteself (https://pytorch.org/docs/stable/generated/torch.all.html)
+    if a.dtype is dtypes.uint8:
+        result = to(result, dtype=dtypes.uint8)
+    return result
+
+
+@torchsymbol(torch.any, is_method=True, id="torch.any")
+def any_tensor(a: TensorLike, /, dim: None | int | Sequence[int] = None, keepdim: bool = False) -> TensorLike:
+    # named as any_tensor to avoid confusion with python's built-in any function
+    a_ = clang.maybe_convert_to_dtype(a, dtypes.bool8)
+    if isinstance(dim, Sequence) and len(dim) == 0:
+        # PyTorch returns a_.clone()
+        result = a_ | a_
+    else:
+        result = ne(sum(a_, dim=dim, keepdim=keepdim), False)
+
+    # Pytorch's torch.any matches the behavior of NumPy in returning output of dtype bool for all supported dtypes except uint8.
+    # For uint8 the dtype of output is uint8 iteself (https://pytorch.org/docs/stable/generated/torch.any.html)
+    if a.dtype is dtypes.uint8:
+        return prims.convert_element_type(result, dtypes.uint8)
+    return result
+
+
 @torchsymbol(torch.amax, is_method=True)
 def amax(a, /, dim=None, keepdim: bool = False):
     return _reduction(
         a,
         prims.amax,
         dims=dim,
         keepdims=keepdim,
@@ -2020,15 +2109,15 @@
 @torchsymbol(torch.var, is_method=True)
 def var(
     a: TensorProxy,
     /,
     dim=None,
     *,
     keepdim: bool = False,
-    correction: Number = 1,
+    correction: NumberLike = 1,
 ) -> TensorProxy:
     result = _reduction(
         a,
         partial(prims.var, correction=correction),
         dims=dim,
         keepdims=keepdim,
         dtype=None,
@@ -2041,15 +2130,15 @@
 @torchsymbol(torch.var_mean, tags=(prims.OpTags.REDUCTION_OP,))
 def var_mean(
     a: TensorProxy,
     /,
     dim=None,
     *,
     keepdim: bool = False,
-    correction: Number = 1,
+    correction: NumberLike = 1,
 ) -> tuple[TensorProxy, TensorProxy]:
     result = _reduction(
         a,
         partial(prims.var_mean, correction=correction),
         dims=dim,
         keepdims=keepdim,
         dtype=None,
@@ -2740,15 +2829,15 @@
 @torchsymbol(torch.nn.functional.layer_norm)
 def layer_norm(
     a: TensorLike,
     /,
     normalized_shape: Sequence[int],
     weight: None | TensorLike = None,
     bias: None | TensorLike = None,
-    eps: Number = 1e-5,
+    eps: NumberLike = 1e-5,
 ) -> TensorLike:
     # Note [LayerNorm with parameter sharding]
     # Sharding messes up the normalized_shape argument, so we need to get the
     # unsharded normalized shape from the weight
     if weight is not None:
         normalized_ndim = len(weight.shape)
         normalized_shape = a.shape[-normalized_ndim:]
@@ -2822,16 +2911,16 @@
 def batch_norm(
     a: TensorLike,
     running_mean: None | TensorLike = None,
     running_var: None | TensorLike = None,
     weight: None | TensorLike = None,
     bias: None | TensorLike = None,
     training: bool = False,
-    momentum: Number = 0.1,
-    eps: Number = 1e-5,
+    momentum: NumberLike = 0.1,
+    eps: NumberLike = 1e-5,
 ) -> TensorLike:
     # Validates inputs
     input_shape = tuple(a.shape)
     utils.check(len(input_shape) >= 2, lambda: f"Expected input_shape={input_shape} to have length >= 2!")
 
     # NOTE Containers are canonicalized in the following checks since
     #   (1, 2, 3) != [1, 2, 3]
@@ -2950,15 +3039,15 @@
 
     return batch_handler
 
 
 # A helper function to converts an interger to 1-len tuple.
 # It is used to handle arguments like stride/dilation/padding and similar.
 def int_to_seq(param):
-    if isinstance(param, int):
+    if isinstance(param, (int, NumberProxy)):
         return (param,)
     else:
         return param
 
 
 # Transforms (x,) -> (x,) * rank.
 # It is used to map arguments like stride/dilation/padding to a rank-len
@@ -2976,15 +3065,16 @@
 
 # Pad input with `pad_value`. Pool-like padding has some restrictions,
 # see the checks below.
 def apply_padding_for_pool_ops(dim, a, padding, kernel_size, pad_value):
     padding = maybe_to_rank_len_sequence(padding, dim)
     kernel_size = maybe_to_rank_len_sequence(kernel_size, dim)
     utils.check(
-        len(padding) == dim and all(isinstance(p, int) and 0 <= p <= k // 2 for p, k in zip(padding, kernel_size)),
+        len(padding) == dim
+        and all(isinstance(p, (int, IntegerProxy)) and 0 <= p <= k // 2 for p, k in zip(padding, kernel_size)),
         lambda: f"Implied {padding=} (with dimensionality {dim}) should contain integers "
         f"between 0 and `kernel_size / 2` (with the implied {kernel_size=})",
     )
 
     # No need to pad batch and channels dims, only spatial dims.
     new_padding = [(0, 0, 0), (0, 0, 0)]
     for p in padding:
@@ -3022,15 +3112,15 @@
                 utils.check(
                     all(s == 1 for s in stride), lambda: f"{padding=} requires all `strides` to be 1, but got {stride=}"
                 )
                 utils.check(
                     len(dilation) == 1 or len(dilation) == dim, lambda: f"{len(dilation)=} has to be either 1 or {dim}"
                 )
                 utils.check(
-                    all(isinstance(d, int) and d >= 1 for d in dilation),
+                    all(isinstance(d, (int, IntegerProxy)) and d >= 1 for d in dilation),
                     lambda: f"{dilation=} has to be a Sequences of integers >= 1",
                 )
 
                 # Need to pad a because "low" padding might not be equal to "high" padding,
                 # and clang.convolution assumes this equality.
                 # Expand to len == dim for easier processing of the pad arguments.
                 if len(dilation) == 1:
@@ -3094,15 +3184,15 @@
     )
 
     if stride is None:
         stride = kernel_size
 
     kernel_size = maybe_to_rank_len_sequence(kernel_size, dim)
     utils.check(
-        len(kernel_size) == dim and all(isinstance(k, int) and k > 0 for k in kernel_size),
+        len(kernel_size) == dim and all(isinstance(k, (int, IntegerProxy)) and k > 0 for k in kernel_size),
         lambda: f"Implied {kernel_size=} (with dimensionality {dim}) should either be a non-negative integer "
         f"or a sequence of non-negative integers of length {dim}",
     )
 
     # Check channels > 0 {
     n_channels = a.shape[1]
     utils.check(n_channels > 0, lambda: f"in_channels={n_channels} should be greater than zero")
@@ -3147,15 +3237,15 @@
     dim: int,
     a: TensorProxy,
     kernel_size: int | Sequence[int],
     stride: int | Sequence[int] | None = None,
     padding: int | Sequence[int] = 0,
     ceil_mode: bool = False,
     count_include_pad: bool = True,
-    divisor_override: Number | None = None,
+    divisor_override: NumberLike | None = None,
 ) -> TensorProxy:
     utils.check(
         not ceil_mode,
         lambda: "{ceil_mode=} is not supported",
         NotImplementedError,
     )
 
@@ -3166,15 +3256,15 @@
     )
 
     if stride is None:
         stride = kernel_size
 
     kernel_size = maybe_to_rank_len_sequence(kernel_size, dim)
     utils.check(
-        len(kernel_size) == dim and all(isinstance(k, int) and k > 0 for k in kernel_size),
+        len(kernel_size) == dim and all(isinstance(k, (int, IntegerProxy)) and k > 0 for k in kernel_size),
         lambda: f"Implied {kernel_size=} (with dimensionality {dim}) should either be a non-negative integer "
         f"or a sequence of non-negative integers of length {dim}",
     )
 
     # Check channels > 0 {
     n_channels = a.shape[1]
     utils.check(n_channels > 0, lambda: f"in_channels={n_channels} should be greater than zero")
@@ -3192,15 +3282,15 @@
     # 1D case is niche.
     # If needed, handle it with checks and transforms. For now unconditionally
     # override value with kernel_numel.
     if divisor_override is None or dim == 1:
         divisor_override = kernel_numel
 
     utils.check(
-        isinstance(divisor_override, Number) and divisor_override > 0,
+        isinstance(divisor_override, (Number, NumberProxy)) and divisor_override > 0,
         lambda: f"{divisor_override=} should be a greater than 0 scalar",
     )
 
     kernel = ones(*kernel_size, device=a.device, dtype=a.dtype) / divisor_override
     kernel = reshape(kernel, (1, 1, *kernel_size))
     kernel = expand(kernel, (n_channels, 1, *kernel_size))
 
@@ -3214,43 +3304,43 @@
     a: TensorProxy,
     /,
     kernel_size: int | Sequence[int],
     stride: int | Sequence[int] | None = None,
     padding: int | Sequence[int] = 0,
     ceil_mode: bool = False,
     count_include_pad: bool = True,
-    divisor_override: Number | None = None,
+    divisor_override: NumberLike | None = None,
 ) -> TensorProxy:
     return _avg_pool_helper(1, a, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override)
 
 
 @torchsymbol(torch.nn.functional.avg_pool2d, id="torch.nn.functional.avg_pool2d", is_method=False)
 def avg_pool2d(
     a: TensorProxy,
     /,
     kernel_size: int | Sequence[int],
     stride: int | Sequence[int] | None = None,
     padding: int | Sequence[int] = 0,
     ceil_mode: bool = False,
     count_include_pad: bool = True,
-    divisor_override: Number | None = None,
+    divisor_override: NumberLike | None = None,
 ) -> TensorProxy:
     return _avg_pool_helper(2, a, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override)
 
 
 @torchsymbol(torch.nn.functional.avg_pool3d, id="torch.nn.functional.avg_pool3d", is_method=False)
 def avg_pool3d(
     a: TensorProxy,
     /,
     kernel_size: int | Sequence[int],
     stride: int | Sequence[int] | None = None,
     padding: int | Sequence[int] = 0,
     ceil_mode: bool = False,
     count_include_pad: bool = True,
-    divisor_override: Number | None = None,
+    divisor_override: NumberLike | None = None,
 ) -> TensorProxy:
     return _avg_pool_helper(3, a, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override)
 
 
 @torchsymbol(torch.max_pool1d, torch.nn.functional.max_pool1d, id="torch.nn.functional.max_pool1d", is_method=False)
 def max_pool1d(
     a: TensorProxy,
@@ -3629,15 +3719,15 @@
 
 
 # TODO Is this a method?
 # TODO Move this to nn.functional
 # NOTE The id must be explicitly specified so as not to resolve to torch.dropout
 #   (Using torch.nn.functional.dropout is just for readability as it's the documented operator)
 @torchsymbol(torch.nn.functional.dropout, id="torch.nn.functional.dropout")
-def dropout(a: TensorProxy, /, p: Number = 0.5, training: bool = True, inplace: bool = False) -> TensorProxy:
+def dropout(a: TensorProxy, /, p: NumberLike = 0.5, training: bool = True, inplace: bool = False) -> TensorProxy:
     if inplace:
         raise NotImplementedError("Only inplace=False is currently supported in dropout")
 
     if not training:
         return a
 
     utils.check(
@@ -3772,23 +3862,23 @@
 ) -> TensorLike:
     assert mode == "nearest"
 
     # a is assumed to be at least 3D.
     batch, channels, *spatial_dims = a.shape
     dim = len(spatial_dims)
 
-    if isinstance(scale_factor, float):
+    if isinstance(scale_factor, (float, FloatProxy)):
         utils.check(scale_factor > 0, lambda: f"{scale_factor=} is expected to be strictly positive")
         scale_factor = (scale_factor,) * dim
     else:
         utils.check(
             (
                 isinstance(scale_factor, Sequence)
                 and len(scale_factor) == dim
-                and all(isinstance(s, float) and s > 0 for s in scale_factor)
+                and all(isinstance(s, (float, FloatProxy)) and s > 0 for s in scale_factor)
             ),
             lambda: f"{scale_factor=} is expected to be a strictly positive floating point number or "
             f"a sequence of strictly positive floating point numbers of length {dim}",
         )
 
     # perform nearest up/down-sampling
     def nearest_sampler(t, input_dim, output_dim, *, scale, dim):
@@ -3846,20 +3936,24 @@
     a: TensorLike,
     size: Sequence[int] | int,
     mode: str = "nearest",
 ) -> TensorLike:
     batch, channels, *spatial_dims = a.shape
     dim = len(spatial_dims)
 
-    if isinstance(size, int):
+    if isinstance(size, (int, IntegerProxy)):
         utils.check(size > 0, lambda: f"{size=} is expected to be greater than zero")
         size = (size,) * dim
     else:
         utils.check(
-            (isinstance(size, Sequence) and len(size) == dim and all(isinstance(s, int) and s > 0 for s in size)),
+            (
+                isinstance(size, Sequence)
+                and len(size) == dim
+                and all(isinstance(s, (int, IntegerProxy)) and s > 0 for s in size)
+            ),
             lambda: f"{size=} is expected to be a greater than zero integer "
             f"or a sequence of strictly positive integers of length {dim}",
         )
 
     scale_factor = tuple(output_size / input_size for output_size, input_size in zip(size, spatial_dims))
 
     return _interpolate_scale_factor_helper(a, scale_factor)
```

### Comparing `lightning_thunder-0.2.0.dev20240513/thunder/torch/langctx.py` & `lightning_thunder-0.2.0.dev20240519/thunder/torch/langctx.py`

 * *Files 2% similar despite different names*

```diff
@@ -42,17 +42,17 @@
                 raise AttributeError(f"The {self.name} language context has no method or attribute {id}")
             if method:
                 return method
             else:
                 return prop(inps[0])
 
         # has_tensor_input is False
-        # Defers to the primitive language context when there are no tensor inputs=
-        #   (the primitive language context handles operations on numbers)
-        primsctx: LanguageContext = resolve_language(Languages.PRIMS)
+        # Defers to the CLANG language context when there are no tensor inputs=
+        #   (the clang language context handles operations on NumberProxies and Numbers)
+        primsctx: LanguageContext = resolve_language(Languages.CLANG)
         if not primsctx.has_method(id):
             raise AttributeError(
                 f"Attempting to call method {id} in the torch language context, but it has no tensor inputs and the primitive language context (which handles numbers) doesn't have the method"
             )
         prim_method: Callable = primsctx.get_method(id, *args, **kwargs)
         return prim_method
```

