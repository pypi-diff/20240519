# Comparing `tmp/oc_ocdm-8.0.2.tar.gz` & `tmp/oc_ocdm-8.1.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "oc_ocdm-8.0.2.tar", max compression
+gzip compressed data, was "oc_ocdm-8.1.0.tar", max compression
```

## Comparing `oc_ocdm-8.0.2.tar` & `oc_ocdm-8.1.0.tar`

### file list

```diff
@@ -1,98 +1,98 @@
--rw-r--r--   0        0        0      795 2022-12-20 14:08:57.539390 oc_ocdm-8.0.2/LICENSE.md
--rw-r--r--   0        0        0      932 2022-12-20 14:08:57.555020 oc_ocdm-8.0.2/oc_ocdm/__init__.py
--rw-r--r--   0        0        0     8012 2023-01-31 16:12:47.420934 oc_ocdm-8.0.2/oc_ocdm/abstract_entity.py
--rw-r--r--   0        0        0     2890 2022-12-20 14:08:57.570646 oc_ocdm-8.0.2/oc_ocdm/abstract_set.py
--rw-r--r--   0        0        0     1082 2022-12-20 14:08:57.570646 oc_ocdm-8.0.2/oc_ocdm/counter_handler/__init__.py
--rw-r--r--   0        0        0     6500 2024-04-04 20:59:41.203116 oc_ocdm-8.0.2/oc_ocdm/counter_handler/counter_handler.py
--rw-r--r--   0        0        0    16948 2024-04-04 20:59:41.204114 oc_ocdm-8.0.2/oc_ocdm/counter_handler/filesystem_counter_handler.py
--rw-r--r--   0        0        0    12624 2024-04-04 20:59:41.205118 oc_ocdm-8.0.2/oc_ocdm/counter_handler/in_memory_counter_handler.py
--rw-r--r--   0        0        0     3676 2023-06-08 09:32:26.643046 oc_ocdm-8.0.2/oc_ocdm/counter_handler/sqlite_counter_handler.py
--rw-r--r--   0        0        0     2647 2022-12-20 14:08:57.570646 oc_ocdm-8.0.2/oc_ocdm/decorators.py
--rw-r--r--   0        0        0      937 2022-12-20 14:08:57.570646 oc_ocdm-8.0.2/oc_ocdm/graph/__init__.py
--rw-r--r--   0        0        0      974 2022-12-20 14:08:57.570646 oc_ocdm-8.0.2/oc_ocdm/graph/entities/__init__.py
--rw-r--r--   0        0        0     1680 2022-12-20 14:08:57.570646 oc_ocdm-8.0.2/oc_ocdm/graph/entities/bibliographic/__init__.py
--rw-r--r--   0        0        0     8436 2022-12-20 14:08:57.570646 oc_ocdm-8.0.2/oc_ocdm/graph/entities/bibliographic/agent_role.py
--rw-r--r--   0        0        0     9064 2022-12-20 14:08:57.570646 oc_ocdm-8.0.2/oc_ocdm/graph/entities/bibliographic/bibliographic_reference.py
--rw-r--r--   0        0        0    49262 2023-06-15 09:24:33.053664 oc_ocdm-8.0.2/oc_ocdm/graph/entities/bibliographic/bibliographic_resource.py
--rw-r--r--   0        0        0    16277 2023-03-08 10:55:02.484160 oc_ocdm-8.0.2/oc_ocdm/graph/entities/bibliographic/citation.py
--rw-r--r--   0        0        0    21579 2022-12-20 14:08:57.570646 oc_ocdm-8.0.2/oc_ocdm/graph/entities/bibliographic/discourse_element.py
--rw-r--r--   0        0        0     6313 2022-12-20 14:08:57.570646 oc_ocdm-8.0.2/oc_ocdm/graph/entities/bibliographic/pointer_list.py
--rw-r--r--   0        0        0     4907 2022-12-20 14:08:57.570646 oc_ocdm-8.0.2/oc_ocdm/graph/entities/bibliographic/reference_annotation.py
--rw-r--r--   0        0        0    10131 2022-12-20 14:08:57.570646 oc_ocdm-8.0.2/oc_ocdm/graph/entities/bibliographic/reference_pointer.py
--rw-r--r--   0        0        0    10359 2022-12-20 14:08:57.570646 oc_ocdm-8.0.2/oc_ocdm/graph/entities/bibliographic/resource_embodiment.py
--rw-r--r--   0        0        0     8831 2022-12-20 14:08:57.570646 oc_ocdm-8.0.2/oc_ocdm/graph/entities/bibliographic/responsible_agent.py
--rw-r--r--   0        0        0     6582 2022-12-20 14:08:57.570646 oc_ocdm-8.0.2/oc_ocdm/graph/entities/bibliographic_entity.py
--rw-r--r--   0        0        0    20380 2023-09-15 20:24:11.894595 oc_ocdm-8.0.2/oc_ocdm/graph/entities/identifier.py
--rw-r--r--   0        0        0    15630 2023-09-15 20:22:31.451351 oc_ocdm-8.0.2/oc_ocdm/graph/graph_entity.py
--rw-r--r--   0        0        0    20240 2024-04-04 20:59:41.206113 oc_ocdm-8.0.2/oc_ocdm/graph/graph_set.py
--rw-r--r--   0        0        0      955 2022-12-20 14:08:57.570646 oc_ocdm-8.0.2/oc_ocdm/metadata/__init__.py
--rw-r--r--   0        0        0      959 2022-12-20 14:08:57.570646 oc_ocdm-8.0.2/oc_ocdm/metadata/entities/__init__.py
--rw-r--r--   0        0        0    19262 2022-12-20 14:08:57.570646 oc_ocdm-8.0.2/oc_ocdm/metadata/entities/dataset.py
--rw-r--r--   0        0        0    12483 2022-12-20 14:08:57.570646 oc_ocdm-8.0.2/oc_ocdm/metadata/entities/distribution.py
--rw-r--r--   0        0        0     7586 2022-12-20 14:08:57.570646 oc_ocdm-8.0.2/oc_ocdm/metadata/metadata_entity.py
--rw-r--r--   0        0        0     6549 2022-12-20 14:08:57.570646 oc_ocdm-8.0.2/oc_ocdm/metadata/metadata_set.py
--rw-r--r--   0        0        0      931 2022-12-20 14:08:57.570646 oc_ocdm-8.0.2/oc_ocdm/prov/__init__.py
--rw-r--r--   0        0        0      905 2022-12-20 14:08:57.570646 oc_ocdm-8.0.2/oc_ocdm/prov/entities/__init__.py
--rw-r--r--   0        0        0    13642 2023-01-31 14:34:56.084004 oc_ocdm-8.0.2/oc_ocdm/prov/entities/snapshot_entity.py
--rw-r--r--   0        0        0     3759 2023-03-08 15:28:49.049031 oc_ocdm-8.0.2/oc_ocdm/prov/prov_entity.py
--rw-r--r--   0        0        0    16895 2024-04-04 20:59:41.207114 oc_ocdm-8.0.2/oc_ocdm/prov/prov_set.py
--rw-r--r--   0        0        0    12063 2024-04-04 21:05:53.727582 oc_ocdm-8.0.2/oc_ocdm/reader.py
--rw-r--r--   0        0        0      837 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/resources/__init__.py
--rw-r--r--   0        0        0     1361 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/resources/querymap.txt
--rw-r--r--   0        0        0    22001 2023-03-01 17:12:50.977316 oc_ocdm-8.0.2/oc_ocdm/resources/shacle.ttl
--rw-r--r--   0        0        0    12513 2023-09-12 19:18:40.048091 oc_ocdm-8.0.2/oc_ocdm/resources/shexc.txt
--rw-r--r--   0        0        0    12611 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/resources/shexc_closed.txt
--rw-r--r--   0        0        0    16796 2024-04-04 21:06:10.721806 oc_ocdm-8.0.2/oc_ocdm/storer.py
--rw-r--r--   0        0        0     1354 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/support/__init__.py
--rw-r--r--   0        0        0     3539 2023-03-05 18:46:51.846163 oc_ocdm-8.0.2/oc_ocdm/support/query_utils.py
--rw-r--r--   0        0        0     2615 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/support/reporter.py
--rw-r--r--   0        0        0    15792 2024-04-04 20:59:41.210113 oc_ocdm-8.0.2/oc_ocdm/support/support.py
--rw-r--r--   0        0        0      837 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/test/__init__.py
--rw-r--r--   0        0        0      837 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/test/counter_handler/__init__.py
--rw-r--r--   0        0        0     8681 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/test/counter_handler/test_filesystem_counter_handler.py
--rw-r--r--   0        0        0    11192 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/test/counter_handler/test_in_memory_counter_handler.py
--rw-r--r--   0        0        0    69632 2024-04-04 20:59:41.211113 oc_ocdm-8.0.2/oc_ocdm/test/coverage/.coverage
--rw-r--r--   0        0        0      109 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/test/coverage/.coveragerc
--rw-r--r--   0        0        0      925 2024-04-04 20:59:41.212113 oc_ocdm-8.0.2/oc_ocdm/test/coverage/coverage.svg
--rw-r--r--   0        0        0      837 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/test/graph/__init__.py
--rw-r--r--   0        0        0      837 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/__init__.py
--rw-r--r--   0        0        0      837 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/bibliographic/__init__.py
--rw-r--r--   0        0        0     2679 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/bibliographic/test_agent_role.py
--rw-r--r--   0        0        0     2209 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/bibliographic/test_bibliographic_reference.py
--rw-r--r--   0        0        0    12671 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/bibliographic/test_bibliographic_resource.py
--rw-r--r--   0        0        0     6887 2023-03-08 14:23:54.735495 oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/bibliographic/test_citation.py
--rw-r--r--   0        0        0     4915 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/bibliographic/test_discourse_element.py
--rw-r--r--   0        0        0     1908 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/bibliographic/test_pointer_list.py
--rw-r--r--   0        0        0     1740 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/bibliographic/test_reference_annotation.py
--rw-r--r--   0        0        0     2501 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/bibliographic/test_reference_pointer.py
--rw-r--r--   0        0        0     2990 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/bibliographic/test_resource_embodiment.py
--rw-r--r--   0        0        0     2535 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/bibliographic/test_responsible_agent.py
--rw-r--r--   0        0        0     2980 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/test_bibliographic_entity.py
--rw-r--r--   0        0        0     8109 2023-03-08 11:33:47.672369 oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/test_identifier.py
--rw-r--r--   0        0        0      964 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/test/graph/test_graph_entity.py
--rw-r--r--   0        0        0     6675 2023-01-31 16:12:47.427934 oc_ocdm-8.0.2/oc_ocdm/test/graph/test_graph_set.py
--rw-r--r--   0        0        0      837 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/test/metadata/__init__.py
--rw-r--r--   0        0        0      837 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/test/metadata/entities/__init__.py
--rw-r--r--   0        0        0     4691 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/test/metadata/entities/test_dataset.py
--rw-r--r--   0        0        0     3601 2022-12-20 14:08:57.586271 oc_ocdm-8.0.2/oc_ocdm/test/metadata/entities/test_distribution.py
--rw-r--r--   0        0        0     2738 2022-12-20 14:08:57.601896 oc_ocdm-8.0.2/oc_ocdm/test/metadata/test_metadata_set.py
--rw-r--r--   0        0        0      837 2022-12-20 14:08:57.601896 oc_ocdm-8.0.2/oc_ocdm/test/prov/__init__.py
--rw-r--r--   0        0        0      837 2022-12-20 14:08:57.601896 oc_ocdm-8.0.2/oc_ocdm/test/prov/entities/__init__.py
--rw-r--r--   0        0        0     4248 2022-12-20 14:08:57.601896 oc_ocdm-8.0.2/oc_ocdm/test/prov/entities/test_snapshot_entity.py
--rw-r--r--   0        0        0    12288 2023-03-08 15:11:17.576967 oc_ocdm-8.0.2/oc_ocdm/test/prov/prov_counter.db
--rw-r--r--   0        0        0    13047 2024-04-04 20:59:41.213112 oc_ocdm-8.0.2/oc_ocdm/test/prov/test_prov_set.py
--rw-r--r--   0        0        0        0 2023-03-05 14:27:05.796485 oc_ocdm-8.0.2/oc_ocdm/test/reader/__init__.py
--rw-r--r--   0        0        0     2542 2023-03-05 17:46:14.507023 oc_ocdm-8.0.2/oc_ocdm/test/reader/br.nt
--rw-r--r--   0        0        0     1902 2024-04-04 20:59:41.214113 oc_ocdm-8.0.2/oc_ocdm/test/reader/test_reader.py
--rw-r--r--   0        0        0      837 2022-12-20 14:08:57.601896 oc_ocdm-8.0.2/oc_ocdm/test/resources/__init__.py
--rw-r--r--   0        0        0     6627 2023-03-01 17:12:20.402368 oc_ocdm-8.0.2/oc_ocdm/test/resources/data.json
--rw-r--r--   0        0        0     6627 2023-03-01 17:12:20.402368 oc_ocdm-8.0.2/oc_ocdm/test/resources/data_reader.json
--rw-r--r--   0        0        0     6628 2023-03-03 13:05:35.809618 oc_ocdm-8.0.2/oc_ocdm/test/resources/data_reader_invalid.json
--rw-r--r--   0        0        0     3677 2024-04-04 20:59:41.214113 oc_ocdm-8.0.2/oc_ocdm/test/resources/test_shacle.py
--rw-r--r--   0        0        0      841 2022-12-20 14:08:57.601896 oc_ocdm-8.0.2/oc_ocdm/test/storer/__init__.py
--rw-r--r--   0        0        0    14942 2024-04-04 20:59:41.215113 oc_ocdm-8.0.2/oc_ocdm/test/storer/test_storer.py
--rw-r--r--   0        0        0      837 2022-12-20 14:08:57.601896 oc_ocdm-8.0.2/oc_ocdm/test/support/__init__.py
--rw-r--r--   0        0        0     5485 2023-01-31 16:12:50.030419 oc_ocdm-8.0.2/oc_ocdm/test/support/test_support.py
--rw-r--r--   0        0        0     1611 2024-04-04 21:07:10.961409 oc_ocdm-8.0.2/pyproject.toml
--rw-r--r--   0        0        0     5058 2024-04-04 20:59:41.202119 oc_ocdm-8.0.2/README.md
--rw-r--r--   0        0        0     6391 1970-01-01 00:00:00.000000 oc_ocdm-8.0.2/PKG-INFO
+-rw-r--r--   0        0        0      782 2024-05-19 11:18:15.261698 oc_ocdm-8.1.0/LICENSE.md
+-rw-r--r--   0        0        0     4932 2024-05-19 11:18:15.261698 oc_ocdm-8.1.0/README.md
+-rw-r--r--   0        0        0      913 2024-05-19 11:18:15.261698 oc_ocdm-8.1.0/oc_ocdm/__init__.py
+-rw-r--r--   0        0        0     7810 2024-05-19 11:18:15.261698 oc_ocdm-8.1.0/oc_ocdm/abstract_entity.py
+-rw-r--r--   0        0        0     2811 2024-05-19 11:18:15.261698 oc_ocdm-8.1.0/oc_ocdm/abstract_set.py
+-rw-r--r--   0        0        0     1063 2024-05-19 11:18:15.261698 oc_ocdm-8.1.0/oc_ocdm/counter_handler/__init__.py
+-rw-r--r--   0        0        0     6370 2024-05-19 11:18:15.261698 oc_ocdm-8.1.0/oc_ocdm/counter_handler/counter_handler.py
+-rw-r--r--   0        0        0    18162 2024-05-19 12:11:08.241109 oc_ocdm-8.1.0/oc_ocdm/counter_handler/filesystem_counter_handler.py
+-rw-r--r--   0        0        0    12389 2024-05-19 11:18:15.261698 oc_ocdm-8.1.0/oc_ocdm/counter_handler/in_memory_counter_handler.py
+-rw-r--r--   0        0        0     3581 2024-05-19 11:18:15.261698 oc_ocdm-8.1.0/oc_ocdm/counter_handler/sqlite_counter_handler.py
+-rw-r--r--   0        0        0     2588 2024-05-19 11:18:15.261698 oc_ocdm-8.1.0/oc_ocdm/decorators.py
+-rw-r--r--   0        0        0      919 2024-05-19 11:18:15.261698 oc_ocdm-8.1.0/oc_ocdm/graph/__init__.py
+-rw-r--r--   0        0        0      956 2024-05-19 11:18:15.261698 oc_ocdm-8.1.0/oc_ocdm/graph/entities/__init__.py
+-rw-r--r--   0        0        0     1654 2024-05-19 11:18:15.261698 oc_ocdm-8.1.0/oc_ocdm/graph/entities/bibliographic/__init__.py
+-rw-r--r--   0        0        0     8233 2024-05-19 11:18:15.261698 oc_ocdm-8.1.0/oc_ocdm/graph/entities/bibliographic/agent_role.py
+-rw-r--r--   0        0        0     8869 2024-05-19 11:18:15.261698 oc_ocdm-8.1.0/oc_ocdm/graph/entities/bibliographic/bibliographic_reference.py
+-rw-r--r--   0        0        0    48004 2024-05-19 11:18:15.261698 oc_ocdm-8.1.0/oc_ocdm/graph/entities/bibliographic/bibliographic_resource.py
+-rw-r--r--   0        0        0    15906 2024-05-19 11:18:15.261698 oc_ocdm-8.1.0/oc_ocdm/graph/entities/bibliographic/citation.py
+-rw-r--r--   0        0        0    21065 2024-05-19 11:18:15.261698 oc_ocdm-8.1.0/oc_ocdm/graph/entities/bibliographic/discourse_element.py
+-rw-r--r--   0        0        0     6171 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/graph/entities/bibliographic/pointer_list.py
+-rw-r--r--   0        0        0     4807 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/graph/entities/bibliographic/reference_annotation.py
+-rw-r--r--   0        0        0     9901 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/graph/entities/bibliographic/reference_pointer.py
+-rw-r--r--   0        0        0    10104 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/graph/entities/bibliographic/resource_embodiment.py
+-rw-r--r--   0        0        0     8614 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/graph/entities/bibliographic/responsible_agent.py
+-rw-r--r--   0        0        0     6443 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/graph/entities/bibliographic_entity.py
+-rw-r--r--   0        0        0    19946 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/graph/entities/identifier.py
+-rw-r--r--   0        0        0    15326 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/graph/graph_entity.py
+-rw-r--r--   0        0        0    19833 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/graph/graph_set.py
+-rw-r--r--   0        0        0      937 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/metadata/__init__.py
+-rw-r--r--   0        0        0      941 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/metadata/entities/__init__.py
+-rw-r--r--   0        0        0    18784 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/metadata/entities/dataset.py
+-rw-r--r--   0        0        0    12161 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/metadata/entities/distribution.py
+-rw-r--r--   0        0        0     7405 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/metadata/metadata_entity.py
+-rw-r--r--   0        0        0     6411 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/metadata/metadata_set.py
+-rw-r--r--   0        0        0      913 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/prov/__init__.py
+-rw-r--r--   0        0        0      888 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/prov/entities/__init__.py
+-rw-r--r--   0        0        0    13309 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/prov/entities/snapshot_entity.py
+-rw-r--r--   0        0        0     3673 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/prov/prov_entity.py
+-rw-r--r--   0        0        0    16593 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/prov/prov_set.py
+-rw-r--r--   0        0        0    11825 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/reader.py
+-rw-r--r--   0        0        0      822 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/resources/__init__.py
+-rw-r--r--   0        0        0     1361 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/resources/querymap.txt
+-rw-r--r--   0        0        0    20997 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/resources/shacle.ttl
+-rw-r--r--   0        0        0    12150 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/resources/shexc.txt
+-rw-r--r--   0        0        0    12248 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/resources/shexc_closed.txt
+-rw-r--r--   0        0        0    16455 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/storer.py
+-rw-r--r--   0        0        0     1332 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/support/__init__.py
+-rw-r--r--   0        0        0     3460 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/support/query_utils.py
+-rw-r--r--   0        0        0     2550 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/support/reporter.py
+-rw-r--r--   0        0        0    15410 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/support/support.py
+-rw-r--r--   0        0        0      822 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/__init__.py
+-rw-r--r--   0        0        0      837 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/counter_handler/__init__.py
+-rw-r--r--   0        0        0     8502 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/counter_handler/test_filesystem_counter_handler.py
+-rw-r--r--   0        0        0    10970 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/counter_handler/test_in_memory_counter_handler.py
+-rw-r--r--   0        0        0    69632 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/coverage/.coverage
+-rw-r--r--   0        0        0      107 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/coverage/.coveragerc
+-rw-r--r--   0        0        0      904 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/coverage/coverage.svg
+-rw-r--r--   0        0        0      837 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/graph/__init__.py
+-rw-r--r--   0        0        0      837 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/__init__.py
+-rw-r--r--   0        0        0      837 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/bibliographic/__init__.py
+-rw-r--r--   0        0        0     2608 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/bibliographic/test_agent_role.py
+-rw-r--r--   0        0        0     2149 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/bibliographic/test_bibliographic_reference.py
+-rw-r--r--   0        0        0    12323 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/bibliographic/test_bibliographic_resource.py
+-rw-r--r--   0        0        0     6730 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/bibliographic/test_citation.py
+-rw-r--r--   0        0        0     4776 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/bibliographic/test_discourse_element.py
+-rw-r--r--   0        0        0     1856 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/bibliographic/test_pointer_list.py
+-rw-r--r--   0        0        0     1696 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/bibliographic/test_reference_annotation.py
+-rw-r--r--   0        0        0     2433 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/bibliographic/test_reference_pointer.py
+-rw-r--r--   0        0        0     2908 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/bibliographic/test_resource_embodiment.py
+-rw-r--r--   0        0        0     2466 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/bibliographic/test_responsible_agent.py
+-rw-r--r--   0        0        0     2903 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/test_bibliographic_entity.py
+-rw-r--r--   0        0        0     7908 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/test_identifier.py
+-rw-r--r--   0        0        0      940 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/graph/test_graph_entity.py
+-rw-r--r--   0        0        0     6500 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/graph/test_graph_set.py
+-rw-r--r--   0        0        0      837 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/metadata/__init__.py
+-rw-r--r--   0        0        0      837 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/metadata/entities/__init__.py
+-rw-r--r--   0        0        0     4573 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/metadata/entities/test_dataset.py
+-rw-r--r--   0        0        0     3507 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/metadata/entities/test_distribution.py
+-rw-r--r--   0        0        0     2665 2024-05-19 11:18:15.265698 oc_ocdm-8.1.0/oc_ocdm/test/metadata/test_metadata_set.py
+-rw-r--r--   0        0        0      837 2024-05-19 11:18:15.269698 oc_ocdm-8.1.0/oc_ocdm/test/prov/__init__.py
+-rw-r--r--   0        0        0      837 2024-05-19 11:18:15.269698 oc_ocdm-8.1.0/oc_ocdm/test/prov/entities/__init__.py
+-rw-r--r--   0        0        0     4141 2024-05-19 11:18:15.269698 oc_ocdm-8.1.0/oc_ocdm/test/prov/entities/test_snapshot_entity.py
+-rw-r--r--   0        0        0    12288 2024-05-19 11:18:15.269698 oc_ocdm-8.1.0/oc_ocdm/test/prov/prov_counter.db
+-rw-r--r--   0        0        0    12789 2024-05-19 11:18:15.269698 oc_ocdm-8.1.0/oc_ocdm/test/prov/test_prov_set.py
+-rw-r--r--   0        0        0        0 2024-05-19 11:18:15.269698 oc_ocdm-8.1.0/oc_ocdm/test/reader/__init__.py
+-rw-r--r--   0        0        0     2523 2024-05-19 11:18:15.269698 oc_ocdm-8.1.0/oc_ocdm/test/reader/br.nt
+-rw-r--r--   0        0        0     1862 2024-05-19 11:18:15.269698 oc_ocdm-8.1.0/oc_ocdm/test/reader/test_reader.py
+-rw-r--r--   0        0        0      822 2024-05-19 11:18:15.269698 oc_ocdm-8.1.0/oc_ocdm/test/resources/__init__.py
+-rw-r--r--   0        0        0     6448 2024-05-19 11:18:15.269698 oc_ocdm-8.1.0/oc_ocdm/test/resources/data.json
+-rw-r--r--   0        0        0     6448 2024-05-19 11:18:15.269698 oc_ocdm-8.1.0/oc_ocdm/test/resources/data_reader.json
+-rw-r--r--   0        0        0     6449 2024-05-19 11:18:15.269698 oc_ocdm-8.1.0/oc_ocdm/test/resources/data_reader_invalid.json
+-rw-r--r--   0        0        0     3602 2024-05-19 11:18:15.269698 oc_ocdm-8.1.0/oc_ocdm/test/resources/test_shacle.py
+-rw-r--r--   0        0        0      826 2024-05-19 11:18:15.269698 oc_ocdm-8.1.0/oc_ocdm/test/storer/__init__.py
+-rw-r--r--   0        0        0    14739 2024-05-19 11:18:15.269698 oc_ocdm-8.1.0/oc_ocdm/test/storer/test_storer.py
+-rw-r--r--   0        0        0      837 2024-05-19 11:18:15.269698 oc_ocdm-8.1.0/oc_ocdm/test/support/__init__.py
+-rw-r--r--   0        0        0     5356 2024-05-19 11:18:15.269698 oc_ocdm-8.1.0/oc_ocdm/test/support/test_support.py
+-rw-r--r--   0        0        0     1558 2024-05-19 12:11:24.741184 oc_ocdm-8.1.0/pyproject.toml
+-rw-r--r--   0        0        0     6442 1970-01-01 00:00:00.000000 oc_ocdm-8.1.0/PKG-INFO
```

### Comparing `oc_ocdm-8.0.2/LICENSE.md` & `oc_ocdm-8.1.0/LICENSE.md`

 * *Ordering differences only*

 * *Files 6% similar despite different names*

```diff
@@ -1,13 +1,13 @@
-ISC License (ISC)
-==================================
-_Copyright 2020 OpenCitations_
-
-Permission to use, copy, modify, and/or distribute this software for any purpose with or
-without fee is hereby granted, provided that the above copyright notice and this permission
-notice appear in all copies.
-
-THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
-SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
-THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
-OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ISC License (ISC)
+==================================
+_Copyright 2020 OpenCitations_
+
+Permission to use, copy, modify, and/or distribute this software for any purpose with or
+without fee is hereby granted, provided that the above copyright notice and this permission
+notice appear in all copies.
+
+THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
+SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
+THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
+OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/__init__.py` & `oc_ocdm-8.1.0/oc_ocdm/__init__.py`

 * *Ordering differences only*

 * *Files 7% similar despite different names*

```diff
@@ -1,19 +1,19 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-__version__ = '7.0.1'
-
-from oc_ocdm.storer import Storer
-from oc_ocdm.reader import Reader
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+__version__ = '7.0.1'
+
+from oc_ocdm.storer import Storer
+from oc_ocdm.reader import Reader
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/abstract_entity.py` & `oc_ocdm-8.1.0/oc_ocdm/abstract_entity.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,202 +1,202 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-from abc import ABC
-from typing import TYPE_CHECKING
-
-from oc_ocdm.support.support import create_type, create_literal, get_short_name, is_dataset, is_string_empty
-from rdflib import URIRef, RDFS, RDF, Literal, Graph
-
-if TYPE_CHECKING:
-    from typing import Optional, List, ClassVar, Dict, Tuple, Iterable
-    from rdflib import term
-
-
-class AbstractEntity(ABC):
-    """
-    Abstract class which represents a generic entity from the OCDM. It sits
-    at the top of the entity class hierarchy.
-    """
-
-    short_name_to_type_iri: ClassVar[Dict[str, URIRef]] = {}
-
-    def __init__(self) -> None:
-        """
-        Constructor of the ``AbstractEntity`` class.
-        """
-        self.g: Graph = Graph()
-        self.res: URIRef = URIRef("")
-        self.short_name: str = ""
-
-    def remove_every_triple(self) -> None:
-        """
-        Remover method that removes every triple from the current entity.
-
-        **WARNING: the OCDM specification requires that every entity has at least
-        one triple that defines its type (through the** ``rdf:type`` **RDF predicate). If
-        such triple is not subsequently restored by the user, the entity will be considered
-        as to be deleted since it wouldn't be valid anymore.**
-
-        :return: None
-        """
-        self.g.remove((None, None, None))
-
-    # LABEL
-    def get_label(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``rdfs:label`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(RDFS.label)
-
-    def create_label(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``rdfs:label`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :return: None
-        """
-        self.remove_label()
-        self._create_literal(RDFS.label, string)
-
-    def remove_label(self) -> None:
-        """
-        Remover method corresponding to the ``rdfs:label`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, RDFS.label, None))
-
-    def _create_literal(self, p: URIRef, s: str, dt: URIRef = None, nor: bool = True) -> None:
-        """
-        Adds an RDF triple with a literal object inside the graph of the entity
-
-        :param p: The predicate
-        :type p: URIRef
-        :param s: The string to add as a literal value
-        :type s: str
-        :param dt: The object's datatype, if present
-        :type dt: URIRef, optional
-        :param nor: Whether to normalize the graph or not
-        :type nor: bool, optional
-        :return: None
-        """
-        create_literal(self.g, self.res, p, s, dt, nor)
-
-    # TYPE
-    def get_types(self) -> List[URIRef]:
-        """
-        Getter method corresponding to the ``rdf:type`` RDF predicate.
-
-        :return: A list containing the requested values if found, None otherwise
-        """
-        uri_list: List[URIRef] = self._get_multiple_uri_references(RDF.type)
-        return uri_list
-
-    def _create_type(self, res_type: URIRef) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        :param res_type: The value that will be set as the object of the property related to this method
-        :type res_type: URIRef
-        :return: None
-        """
-        self.remove_type()  # <-- It doesn't remove the main type!
-        create_type(self.g, self.res, res_type)
-
-    def remove_type(self) -> None:
-        """
-        Remover method corresponding to the ``rdf:type`` RDF predicate.
-
-        **WARNING: the OCDM specification requires at least one type for an entity.
-        This method removes any existing secondary type, without removing the main type.**
-
-        :return: None
-        """
-        self.g.remove((self.res, RDF.type, None))
-        # Restore the main type IRI
-        iri_main_type: URIRef = self.short_name_to_type_iri[self.short_name]
-        create_type(self.g, self.res, iri_main_type)
-
-    # Overrides __str__ method
-    def __str__(self) -> str:
-        return str(self.res)
-
-    def add_triples(self, iterable_of_triples: Iterable[Tuple[term]]) -> None:
-        """
-        A utility method that allows to add a batch of triples into the graph of the entity.
-
-        **WARNING: Only triples that have this entity as their subject will be imported!**
-
-        :param iterable_of_triples: A collection of triples to be added to the entity
-        :type iterable_of_triples: Iterable[Tuple[term]]
-        :return: None
-        """
-        for s, p, o in iterable_of_triples:
-            if s == self.res:  # This guarantees that only triples belonging to the resource will be added
-                self.g.add((s, p, o))
-
-    def _get_literal(self, predicate: URIRef) -> Optional[str]:
-        result: Optional[str] = None
-        for o in self.g.objects(self.res, predicate):
-            if type(o) == Literal:
-                result = str(o)
-                break
-        return result
-
-    def _get_multiple_literals(self, predicate: URIRef) -> List[str]:
-        result: List[str] = []
-        for o in self.g.objects(self.res, predicate):
-            if type(o) == Literal:
-                result.append(str(o))
-        return result
-
-    def _get_uri_reference(self, predicate: URIRef, short_name: str = None) -> Optional[URIRef]:
-        result: Optional[URIRef] = None
-        for o in self.g.objects(self.res, predicate):
-            if type(o) == URIRef:
-                if not is_string_empty(short_name):
-                    # If a particular short_name is explicitly requested,
-                    # then the following additional check must be performed:
-                    if (short_name == '_dataset_' and is_dataset(o)) or get_short_name(o) == short_name:
-                        result = o
-                        break
-                else:
-                    result = o
-                    break
-        return result
-
-    def _get_multiple_uri_references(self, predicate: URIRef, short_name: str = None) -> List[URIRef]:
-        result: List[URIRef] = []
-        for o in self.g.objects(self.res, predicate):
-            if type(o) == URIRef:
-                if not is_string_empty(short_name):
-                    # If a particular short_name is explicitly requested,
-                    # then the following additional check must be performed:
-                    if (short_name == '_dataset_' and is_dataset(o)) or get_short_name(o) == short_name:
-                        result.append(o)
-                else:
-                    result.append(o)
-        return result
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+from abc import ABC
+from typing import TYPE_CHECKING
+
+from oc_ocdm.support.support import create_type, create_literal, get_short_name, is_dataset, is_string_empty
+from rdflib import URIRef, RDFS, RDF, Literal, Graph
+
+if TYPE_CHECKING:
+    from typing import Optional, List, ClassVar, Dict, Tuple, Iterable
+    from rdflib import term
+
+
+class AbstractEntity(ABC):
+    """
+    Abstract class which represents a generic entity from the OCDM. It sits
+    at the top of the entity class hierarchy.
+    """
+
+    short_name_to_type_iri: ClassVar[Dict[str, URIRef]] = {}
+
+    def __init__(self) -> None:
+        """
+        Constructor of the ``AbstractEntity`` class.
+        """
+        self.g: Graph = Graph()
+        self.res: URIRef = URIRef("")
+        self.short_name: str = ""
+
+    def remove_every_triple(self) -> None:
+        """
+        Remover method that removes every triple from the current entity.
+
+        **WARNING: the OCDM specification requires that every entity has at least
+        one triple that defines its type (through the** ``rdf:type`` **RDF predicate). If
+        such triple is not subsequently restored by the user, the entity will be considered
+        as to be deleted since it wouldn't be valid anymore.**
+
+        :return: None
+        """
+        self.g.remove((None, None, None))
+
+    # LABEL
+    def get_label(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``rdfs:label`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(RDFS.label)
+
+    def create_label(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``rdfs:label`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :return: None
+        """
+        self.remove_label()
+        self._create_literal(RDFS.label, string)
+
+    def remove_label(self) -> None:
+        """
+        Remover method corresponding to the ``rdfs:label`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, RDFS.label, None))
+
+    def _create_literal(self, p: URIRef, s: str, dt: URIRef = None, nor: bool = True) -> None:
+        """
+        Adds an RDF triple with a literal object inside the graph of the entity
+
+        :param p: The predicate
+        :type p: URIRef
+        :param s: The string to add as a literal value
+        :type s: str
+        :param dt: The object's datatype, if present
+        :type dt: URIRef, optional
+        :param nor: Whether to normalize the graph or not
+        :type nor: bool, optional
+        :return: None
+        """
+        create_literal(self.g, self.res, p, s, dt, nor)
+
+    # TYPE
+    def get_types(self) -> List[URIRef]:
+        """
+        Getter method corresponding to the ``rdf:type`` RDF predicate.
+
+        :return: A list containing the requested values if found, None otherwise
+        """
+        uri_list: List[URIRef] = self._get_multiple_uri_references(RDF.type)
+        return uri_list
+
+    def _create_type(self, res_type: URIRef) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        :param res_type: The value that will be set as the object of the property related to this method
+        :type res_type: URIRef
+        :return: None
+        """
+        self.remove_type()  # <-- It doesn't remove the main type!
+        create_type(self.g, self.res, res_type)
+
+    def remove_type(self) -> None:
+        """
+        Remover method corresponding to the ``rdf:type`` RDF predicate.
+
+        **WARNING: the OCDM specification requires at least one type for an entity.
+        This method removes any existing secondary type, without removing the main type.**
+
+        :return: None
+        """
+        self.g.remove((self.res, RDF.type, None))
+        # Restore the main type IRI
+        iri_main_type: URIRef = self.short_name_to_type_iri[self.short_name]
+        create_type(self.g, self.res, iri_main_type)
+
+    # Overrides __str__ method
+    def __str__(self) -> str:
+        return str(self.res)
+
+    def add_triples(self, iterable_of_triples: Iterable[Tuple[term]]) -> None:
+        """
+        A utility method that allows to add a batch of triples into the graph of the entity.
+
+        **WARNING: Only triples that have this entity as their subject will be imported!**
+
+        :param iterable_of_triples: A collection of triples to be added to the entity
+        :type iterable_of_triples: Iterable[Tuple[term]]
+        :return: None
+        """
+        for s, p, o in iterable_of_triples:
+            if s == self.res:  # This guarantees that only triples belonging to the resource will be added
+                self.g.add((s, p, o))
+
+    def _get_literal(self, predicate: URIRef) -> Optional[str]:
+        result: Optional[str] = None
+        for o in self.g.objects(self.res, predicate):
+            if type(o) == Literal:
+                result = str(o)
+                break
+        return result
+
+    def _get_multiple_literals(self, predicate: URIRef) -> List[str]:
+        result: List[str] = []
+        for o in self.g.objects(self.res, predicate):
+            if type(o) == Literal:
+                result.append(str(o))
+        return result
+
+    def _get_uri_reference(self, predicate: URIRef, short_name: str = None) -> Optional[URIRef]:
+        result: Optional[URIRef] = None
+        for o in self.g.objects(self.res, predicate):
+            if type(o) == URIRef:
+                if not is_string_empty(short_name):
+                    # If a particular short_name is explicitly requested,
+                    # then the following additional check must be performed:
+                    if (short_name == '_dataset_' and is_dataset(o)) or get_short_name(o) == short_name:
+                        result = o
+                        break
+                else:
+                    result = o
+                    break
+        return result
+
+    def _get_multiple_uri_references(self, predicate: URIRef, short_name: str = None) -> List[URIRef]:
+        result: List[URIRef] = []
+        for o in self.g.objects(self.res, predicate):
+            if type(o) == URIRef:
+                if not is_string_empty(short_name):
+                    # If a particular short_name is explicitly requested,
+                    # then the following additional check must be performed:
+                    if (short_name == '_dataset_' and is_dataset(o)) or get_short_name(o) == short_name:
+                        result.append(o)
+                else:
+                    result.append(o)
+        return result
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/abstract_set.py` & `oc_ocdm-8.1.0/oc_ocdm/abstract_set.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,79 +1,79 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-from abc import ABC, abstractmethod
-from typing import TYPE_CHECKING
-
-from oc_ocdm.abstract_entity import AbstractEntity
-
-if TYPE_CHECKING:
-    from typing import List, ClassVar, Dict, Optional
-    from rdflib import URIRef, Graph
-
-
-class AbstractSet(ABC):
-    """
-    Abstract class which represents a generic set of entities.
-    It is the base class for each concrete set of entities.
-    """
-
-    short_name_to_type_iri: ClassVar[Dict[str, URIRef]] = {}
-
-    def __init__(self) -> None:
-        """
-        Constructor of the ``AbstractSet`` class.
-        """
-        self.res_to_entity: Dict[URIRef, AbstractEntity] = {}
-
-    def graphs(self) -> List[Graph]:
-        """
-        A utility method that allows to retrieve the list of ``rdflib.Graph``
-        instances corresponding to each entity contained in the set.
-
-        :return: The requested list of graphs
-        """
-        result: List[Graph] = []
-        for entity in self.res_to_entity.values():
-            if len(entity.g) > 0:
-                result.append(entity.g)
-        return result
-
-    @abstractmethod
-    def get_entity(self, res: URIRef) -> Optional[AbstractEntity]:
-        """
-        Method signature for concrete implementations that allow
-        to retrieve a contained entity identified by its URI.
-
-        :param res: The URI that identifies the requested entity
-        :type res: URIRef
-        :return: The requested entity if found, None otherwise
-        """
-        raise NotImplementedError
-
-    @staticmethod
-    def get_graph_iri(g: Graph) -> str:
-        """
-        A utility method that allows to retrieve the IRI which represents
-        the name of a given named graph.
-
-        **NOTE: this is a static function!**
-
-        :param g: The named graph whose name will be returned
-        :type g: Graph
-        :return: The requested string whose content is the IRI associated to the given named graph
-        """
-        return str(g.identifier)
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+from abc import ABC, abstractmethod
+from typing import TYPE_CHECKING
+
+from oc_ocdm.abstract_entity import AbstractEntity
+
+if TYPE_CHECKING:
+    from typing import List, ClassVar, Dict, Optional
+    from rdflib import URIRef, Graph
+
+
+class AbstractSet(ABC):
+    """
+    Abstract class which represents a generic set of entities.
+    It is the base class for each concrete set of entities.
+    """
+
+    short_name_to_type_iri: ClassVar[Dict[str, URIRef]] = {}
+
+    def __init__(self) -> None:
+        """
+        Constructor of the ``AbstractSet`` class.
+        """
+        self.res_to_entity: Dict[URIRef, AbstractEntity] = {}
+
+    def graphs(self) -> List[Graph]:
+        """
+        A utility method that allows to retrieve the list of ``rdflib.Graph``
+        instances corresponding to each entity contained in the set.
+
+        :return: The requested list of graphs
+        """
+        result: List[Graph] = []
+        for entity in self.res_to_entity.values():
+            if len(entity.g) > 0:
+                result.append(entity.g)
+        return result
+
+    @abstractmethod
+    def get_entity(self, res: URIRef) -> Optional[AbstractEntity]:
+        """
+        Method signature for concrete implementations that allow
+        to retrieve a contained entity identified by its URI.
+
+        :param res: The URI that identifies the requested entity
+        :type res: URIRef
+        :return: The requested entity if found, None otherwise
+        """
+        raise NotImplementedError
+
+    @staticmethod
+    def get_graph_iri(g: Graph) -> str:
+        """
+        A utility method that allows to retrieve the IRI which represents
+        the name of a given named graph.
+
+        **NOTE: this is a static function!**
+
+        :param g: The named graph whose name will be returned
+        :type g: Graph
+        :return: The requested string whose content is the IRI associated to the given named graph
+        """
+        return str(g.identifier)
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/counter_handler/__init__.py` & `oc_ocdm-8.1.0/oc_ocdm/counter_handler/__init__.py`

 * *Ordering differences only*

 * *Files 6% similar despite different names*

```diff
@@ -1,19 +1,19 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-
-from oc_ocdm.counter_handler.counter_handler import CounterHandler
-from oc_ocdm.counter_handler.filesystem_counter_handler import FilesystemCounterHandler
-from oc_ocdm.counter_handler.in_memory_counter_handler import InMemoryCounterHandler
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+
+from oc_ocdm.counter_handler.counter_handler import CounterHandler
+from oc_ocdm.counter_handler.filesystem_counter_handler import FilesystemCounterHandler
+from oc_ocdm.counter_handler.in_memory_counter_handler import InMemoryCounterHandler
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/counter_handler/counter_handler.py` & `oc_ocdm-8.1.0/oc_ocdm/counter_handler/counter_handler.py`

 * *Ordering differences only*

 * *Files 8% similar despite different names*

```diff
@@ -1,130 +1,130 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from abc import ABC, abstractmethod
-
-
-class CounterHandler(ABC):
-    """Abstract class representing the interface for every concrete counter handler."""
-
-    @abstractmethod
-    def set_counter(self, new_value: int, entity_short_name: str, prov_short_name: str = "",
-                    identifier: int = 1, supplier_prefix: str = "") -> None:
-        """
-        Method signature for concrete implementations that allow setting the counter value
-        of graph and provenance entities.
-
-        :param new_value: The new counter value to be set
-        :type new_value: int
-        :param entity_short_name: The short name associated either to the type of the entity itself
-         or, in case of a provenance entity, to the type of the relative graph entity.
-        :type entity_short_name: str
-        :param prov_short_name: In case of a provenance entity, the short name associated to the type
-         of the entity itself. An empty string otherwise.
-        :type prov_short_name: str
-        :param identifier: In case of a provenance entity, the counter value that identifies the relative
-          graph entity. The integer value '1' otherwise.
-        :type identifier: int
-        :raises NotImplementedError: always
-        :return: None
-        """
-        raise NotImplementedError
-
-    @abstractmethod
-    def read_counter(self, entity_short_name: str, prov_short_name: str = "", identifier: int = 1, supplier_prefix: str = "") -> int:
-        """
-        Method signature for concrete implementations that allow reading the counter value
-        of graph and provenance entities.
-
-        :param entity_short_name: The short name associated either to the type of the entity itself
-         or, in case of a provenance entity, to the type of the relative graph entity.
-        :type entity_short_name: str
-        :param prov_short_name: In case of a provenance entity, the short name associated to the type
-         of the entity itself. An empty string otherwise.
-        :type prov_short_name: str
-        :param identifier: In case of a provenance entity, the counter value that identifies the relative
-          graph entity. The integer value '1' otherwise.
-        :type identifier: int
-        :raises NotImplementedError: always
-        :return: The requested counter value.
-        """
-        raise NotImplementedError
-
-    @abstractmethod
-    def increment_counter(self, entity_short_name: str, prov_short_name: str = "", identifier: int = 1, supplier_prefix: str = "") -> int:
-        """
-        Method signature for concrete implementations that allow incrementing by one unit
-        the counter value of graph and provenance entities.
-
-        :param entity_short_name: The short name associated either to the type of the entity itself
-         or, in case of a provenance entity, to the type of the relative graph entity.
-        :type entity_short_name: str
-        :param prov_short_name: In case of a provenance entity, the short name associated to the type
-         of the entity itself. An empty string otherwise.
-        :type prov_short_name: str
-        :param identifier: In case of a provenance entity, the counter value that identifies the relative
-          graph entity. The integer value '1' otherwise.
-        :type identifier: int
-        :raises NotImplementedError: always
-        :return: The newly-updated (already incremented) counter value.
-        """
-        raise NotImplementedError
-
-    @abstractmethod
-    def set_metadata_counter(self, new_value: int, entity_short_name: str, dataset_name: str) -> None:
-        """
-        Method signature for concrete implementations that allow setting the counter value
-        of metadata entities.
-
-        :param new_value: The new counter value to be set
-        :type new_value: int
-        :param entity_short_name: The short name associated either to the type of the entity itself.
-        :type entity_short_name: str
-        :param dataset_name: In case of a ``Dataset``, its name. Otherwise, the name of the relative dataset.
-        :type dataset_name: str
-        :raises NotImplementedError: always
-        :return: None
-        """
-        raise NotImplementedError
-
-    @abstractmethod
-    def read_metadata_counter(self, entity_short_name: str, dataset_name: str) -> int:
-        """
-        Method signature for concrete implementations that allow reading the counter value
-        of metadata entities.
-
-        :param entity_short_name: The short name associated either to the type of the entity itself.
-        :type entity_short_name: str
-        :param dataset_name: In case of a ``Dataset``, its name. Otherwise, the name of the relative dataset.
-        :type dataset_name: str
-        :raises NotImplementedError: always
-        :return: The requested counter value.
-        """
-        raise NotImplementedError
-
-    @abstractmethod
-    def increment_metadata_counter(self, entity_short_name: str, dataset_name: str) -> int:
-        """
-        Method signature for concrete implementations that allow incrementing by one unit
-        the counter value of metadata entities.
-
-        :param entity_short_name: The short name associated either to the type of the entity itself.
-        :type entity_short_name: str
-        :param dataset_name: In case of a ``Dataset``, its name. Otherwise, the name of the relative dataset.
-        :type dataset_name: str
-        :raises NotImplementedError: always
-        :return: The newly-updated (already incremented) counter value.
-        """
-        raise NotImplementedError
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from abc import ABC, abstractmethod
+
+
+class CounterHandler(ABC):
+    """Abstract class representing the interface for every concrete counter handler."""
+
+    @abstractmethod
+    def set_counter(self, new_value: int, entity_short_name: str, prov_short_name: str = "",
+                    identifier: int = 1, supplier_prefix: str = "") -> None:
+        """
+        Method signature for concrete implementations that allow setting the counter value
+        of graph and provenance entities.
+
+        :param new_value: The new counter value to be set
+        :type new_value: int
+        :param entity_short_name: The short name associated either to the type of the entity itself
+         or, in case of a provenance entity, to the type of the relative graph entity.
+        :type entity_short_name: str
+        :param prov_short_name: In case of a provenance entity, the short name associated to the type
+         of the entity itself. An empty string otherwise.
+        :type prov_short_name: str
+        :param identifier: In case of a provenance entity, the counter value that identifies the relative
+          graph entity. The integer value '1' otherwise.
+        :type identifier: int
+        :raises NotImplementedError: always
+        :return: None
+        """
+        raise NotImplementedError
+
+    @abstractmethod
+    def read_counter(self, entity_short_name: str, prov_short_name: str = "", identifier: int = 1, supplier_prefix: str = "") -> int:
+        """
+        Method signature for concrete implementations that allow reading the counter value
+        of graph and provenance entities.
+
+        :param entity_short_name: The short name associated either to the type of the entity itself
+         or, in case of a provenance entity, to the type of the relative graph entity.
+        :type entity_short_name: str
+        :param prov_short_name: In case of a provenance entity, the short name associated to the type
+         of the entity itself. An empty string otherwise.
+        :type prov_short_name: str
+        :param identifier: In case of a provenance entity, the counter value that identifies the relative
+          graph entity. The integer value '1' otherwise.
+        :type identifier: int
+        :raises NotImplementedError: always
+        :return: The requested counter value.
+        """
+        raise NotImplementedError
+
+    @abstractmethod
+    def increment_counter(self, entity_short_name: str, prov_short_name: str = "", identifier: int = 1, supplier_prefix: str = "") -> int:
+        """
+        Method signature for concrete implementations that allow incrementing by one unit
+        the counter value of graph and provenance entities.
+
+        :param entity_short_name: The short name associated either to the type of the entity itself
+         or, in case of a provenance entity, to the type of the relative graph entity.
+        :type entity_short_name: str
+        :param prov_short_name: In case of a provenance entity, the short name associated to the type
+         of the entity itself. An empty string otherwise.
+        :type prov_short_name: str
+        :param identifier: In case of a provenance entity, the counter value that identifies the relative
+          graph entity. The integer value '1' otherwise.
+        :type identifier: int
+        :raises NotImplementedError: always
+        :return: The newly-updated (already incremented) counter value.
+        """
+        raise NotImplementedError
+
+    @abstractmethod
+    def set_metadata_counter(self, new_value: int, entity_short_name: str, dataset_name: str) -> None:
+        """
+        Method signature for concrete implementations that allow setting the counter value
+        of metadata entities.
+
+        :param new_value: The new counter value to be set
+        :type new_value: int
+        :param entity_short_name: The short name associated either to the type of the entity itself.
+        :type entity_short_name: str
+        :param dataset_name: In case of a ``Dataset``, its name. Otherwise, the name of the relative dataset.
+        :type dataset_name: str
+        :raises NotImplementedError: always
+        :return: None
+        """
+        raise NotImplementedError
+
+    @abstractmethod
+    def read_metadata_counter(self, entity_short_name: str, dataset_name: str) -> int:
+        """
+        Method signature for concrete implementations that allow reading the counter value
+        of metadata entities.
+
+        :param entity_short_name: The short name associated either to the type of the entity itself.
+        :type entity_short_name: str
+        :param dataset_name: In case of a ``Dataset``, its name. Otherwise, the name of the relative dataset.
+        :type dataset_name: str
+        :raises NotImplementedError: always
+        :return: The requested counter value.
+        """
+        raise NotImplementedError
+
+    @abstractmethod
+    def increment_metadata_counter(self, entity_short_name: str, dataset_name: str) -> int:
+        """
+        Method signature for concrete implementations that allow incrementing by one unit
+        the counter value of metadata entities.
+
+        :param entity_short_name: The short name associated either to the type of the entity itself.
+        :type entity_short_name: str
+        :param dataset_name: In case of a ``Dataset``, its name. Otherwise, the name of the relative dataset.
+        :type dataset_name: str
+        :raises NotImplementedError: always
+        :return: The newly-updated (already incremented) counter value.
+        """
+        raise NotImplementedError
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/counter_handler/filesystem_counter_handler.py` & `oc_ocdm-8.1.0/oc_ocdm/counter_handler/filesystem_counter_handler.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,351 +1,384 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-import os
-from shutil import copymode, move
-from tempfile import mkstemp
-from typing import TYPE_CHECKING
-
-if TYPE_CHECKING:
-    from typing import BinaryIO, Tuple, List, Dict
-
-from oc_ocdm.counter_handler.counter_handler import CounterHandler
-from oc_ocdm.support.support import is_string_empty
-
-
-class FilesystemCounterHandler(CounterHandler):
-    """A concrete implementation of the ``CounterHandler`` interface that persistently stores
-    the counter values within the filesystem."""
-
-    _initial_line_len: int = 3
-    _trailing_char: str = " "
-
-    def __init__(self, info_dir: str, supplier_prefix: str = "") -> None:
-        """
-        Constructor of the ``FilesystemCounterHandler`` class.
-
-        :param info_dir: The path to the folder that does/will contain the counter values.
-        :type info_dir: str
-        :raises ValueError: if ``info_dir`` is None or an empty string.
-        """
-        if info_dir is None or is_string_empty(info_dir):
-            raise ValueError("info_dir parameter is required!")
-
-        if info_dir[-1] != os.sep:
-            info_dir += os.sep
-
-        self.info_dir: str = info_dir
-        self.supplier_prefix: str = supplier_prefix
-        self.datasets_dir: str = info_dir + 'datasets' + os.sep
-        self.short_names: List[str] = ["an", "ar", "be", "br", "ci", "de", "id", "pl", "ra", "re", "rp"]
-        self.metadata_short_names: List[str] = ["di"]
-        self.info_files: Dict[str, str] = {key: ("info_file_" + key + ".txt")
-                                           for key in self.short_names}
-        self.prov_files: Dict[str, str] = {key: ("prov_file_" + key + ".txt")
-                                           for key in self.short_names}
-
-    def set_counter(self, new_value: int, entity_short_name: str, prov_short_name: str = "",
-                    identifier: int = 1, supplier_prefix: str = "") -> None:
-        """
-        It allows to set the counter value of graph and provenance entities.
-
-        :param new_value: The new counter value to be set
-        :type new_value: int
-        :param entity_short_name: The short name associated either to the type of the entity itself
-         or, in case of a provenance entity, to the type of the relative graph entity.
-        :type entity_short_name: str
-        :param prov_short_name: In case of a provenance entity, the short name associated to the type
-         of the entity itself. An empty string otherwise.
-        :type prov_short_name: str
-        :param identifier: In case of a provenance entity, the counter value that identifies the relative
-          graph entity. The integer value '1' otherwise.
-        :type identifier: int
-        :raises ValueError: if ``new_value`` is a negative integer or ``identifier`` is less than or equal to zero.
-        :return: None
-        """
-        if new_value < 0:
-            raise ValueError("new_value must be a non negative integer!")
-
-        if prov_short_name == "se":
-            file_path: str = self._get_prov_path(entity_short_name, supplier_prefix)
-        else:
-            file_path: str = self._get_info_path(entity_short_name, supplier_prefix)
-        self._set_number(new_value, file_path, identifier)
-
-    def read_counter(self, entity_short_name: str, prov_short_name: str = "", identifier: int = 1, supplier_prefix: str = "") -> int:
-        """
-        It allows to read the counter value of graph and provenance entities.
-
-        :param entity_short_name: The short name associated either to the type of the entity itself
-         or, in case of a provenance entity, to the type of the relative graph entity.
-        :type entity_short_name: str
-        :param prov_short_name: In case of a provenance entity, the short name associated to the type
-         of the entity itself. An empty string otherwise.
-        :type prov_short_name: str
-        :param identifier: In case of a provenance entity, the counter value that identifies the relative
-          graph entity. The integer value '1' otherwise.
-        :type identifier: int
-        :raises ValueError: if ``identifier`` is less than or equal to zero.
-        :return: The requested counter value.
-        """
-        if prov_short_name == "se":
-            file_path: str = self._get_prov_path(entity_short_name, supplier_prefix)
-        else:
-            file_path: str = self._get_info_path(entity_short_name, supplier_prefix)
-        return self._read_number(file_path, identifier)[0]
-
-    def increment_counter(self, entity_short_name: str, prov_short_name: str = "", identifier: int = 1, supplier_prefix: str = "") -> int:
-        """
-        It allows to increment the counter value of graph and provenance entities by one unit.
-
-        :param entity_short_name: The short name associated either to the type of the entity itself
-         or, in case of a provenance entity, to the type of the relative graph entity.
-        :type entity_short_name: str
-        :param prov_short_name: In case of a provenance entity, the short name associated to the type
-         of the entity itself. An empty string otherwise.
-        :type prov_short_name: str
-        :param identifier: In case of a provenance entity, the counter value that identifies the relative
-          graph entity. The integer value '1' otherwise.
-        :type identifier: int
-        :raises ValueError: if ``identifier`` is less than or equal to zero.
-        :return: The newly-updated (already incremented) counter value.
-        """
-        if prov_short_name == "se":
-            file_path: str = self._get_prov_path(entity_short_name, supplier_prefix)
-        else:
-            file_path: str = self._get_info_path(entity_short_name, supplier_prefix)
-        return self._add_number(file_path, identifier)
-
-    def _get_info_path(self, short_name: str, supplier_prefix: str) -> str:
-        supplier_prefix = "" if supplier_prefix is None else supplier_prefix
-        directory = self.info_dir if supplier_prefix == self.supplier_prefix or not self.supplier_prefix else self.info_dir.replace(self.supplier_prefix, supplier_prefix, 1)
-        return directory + self.info_files[short_name]
-
-    def _get_prov_path(self, short_name: str, supplier_prefix: str) -> str:
-        supplier_prefix = "" if supplier_prefix is None else supplier_prefix
-        directory = self.info_dir if supplier_prefix == self.supplier_prefix or not self.supplier_prefix else self.info_dir.replace(self.supplier_prefix, supplier_prefix, 1)
-        return directory + self.prov_files[short_name]
-
-    def _get_metadata_path(self, short_name: str, dataset_name: str) -> str:
-        return self.datasets_dir + dataset_name + os.sep + 'metadata_' + short_name + '.txt'
-
-    def __initialize_file_if_not_existing(self, file_path: str):
-        if not os.path.exists(os.path.dirname(file_path)):
-            os.makedirs(os.path.dirname(file_path))
-
-        if not os.path.isfile(file_path):
-            with open(file_path, 'wb') as file:
-                first_line: str = self._trailing_char * (self._initial_line_len - 1) + '\n'
-                file.write(first_line.encode('ascii'))
-
-    def _read_number(self, file_path: str, line_number: int) -> Tuple[int, int]:
-        if line_number <= 0:
-            raise ValueError("line_number must be a positive non-zero integer number!")
-
-        self.__initialize_file_if_not_existing(file_path)
-
-        cur_number: int = 0
-        cur_line_len: int = 0
-        try:
-            with open(file_path, 'rb') as file:
-                cur_line_len = self._get_line_len(file)
-                line_offset = (line_number - 1) * cur_line_len
-                file.seek(line_offset)
-                line = file.readline(cur_line_len).decode('ascii')
-                cur_number = int(line.rstrip(self._trailing_char + '\n'))
-        except ValueError:
-            cur_number = 0
-        except Exception as e:
-            print(e)
-
-        return cur_number, cur_line_len
-
-    def _add_number(self, file_path: str, line_number: int = 1) -> int:
-        if line_number <= 0:
-            raise ValueError("line_number must be a positive non-zero integer number!")
-
-        self.__initialize_file_if_not_existing(file_path)
-
-        cur_number, cur_line_len = self._read_number(file_path, line_number)
-        cur_number += 1
-
-        cur_number_len: int = len(str(cur_number)) + 1
-        if cur_number_len > cur_line_len:
-            self._increase_line_len(file_path, new_length=cur_number_len)
-            cur_line_len = cur_number_len
-
-        with open(file_path, 'r+b') as file:
-            line_offset: int = (line_number - 1) * cur_line_len
-            file.seek(line_offset)
-            line: str = str(cur_number).ljust(cur_line_len - 1, self._trailing_char) + '\n'
-            file.write(line.encode('ascii'))
-            file.seek(-cur_line_len, os.SEEK_CUR)
-            self._fix_previous_lines(file, cur_line_len)
-        return cur_number
-
-    def _set_number(self, new_value: int, file_path: str, line_number: int = 1) -> None:
-        if new_value < 0:
-            raise ValueError("new_value must be a non negative integer!")
-
-        if line_number <= 0:
-            raise ValueError("line_number must be a positive non-zero integer number!")
-
-        self.__initialize_file_if_not_existing(file_path)
-
-        cur_line_len = self._read_number(file_path, line_number)[1]
-
-        cur_number_len: int = len(str(new_value)) + 1
-        if cur_number_len > cur_line_len:
-            self._increase_line_len(file_path, new_length=cur_number_len)
-            cur_line_len = cur_number_len
-
-        with open(file_path, 'r+b') as file:
-            line_offset: int = (line_number - 1) * cur_line_len
-            file.seek(line_offset)
-            line: str = str(new_value).ljust(cur_line_len - 1, self._trailing_char) + '\n'
-            file.write(line.encode('ascii'))
-            file.seek(-cur_line_len, os.SEEK_CUR)
-            self._fix_previous_lines(file, cur_line_len)
-
-    @staticmethod
-    def _get_line_len(file: BinaryIO) -> int:
-        cur_char: str = file.read(1).decode("ascii")
-        count: int = 1
-        while cur_char is not None and len(cur_char) == 1 and cur_char != "\0":
-            cur_char = file.read(1).decode("ascii")
-            count += 1
-            if cur_char == "\n":
-                break
-
-        # Undo I/O pointer updates
-        file.seek(0)
-
-        if cur_char is None:
-            raise EOFError("Reached end-of-file without encountering a line separator!")
-        elif cur_char == "\0":
-            raise ValueError("Encountered a NULL byte!")
-        else:
-            return count
-
-    def _increase_line_len(self, file_path: str, new_length: int = 0) -> None:
-        if new_length <= 0:
-            raise ValueError("new_length must be a positive non-zero integer number!")
-
-        with open(file_path, 'rb') as cur_file:
-            if self._get_line_len(cur_file) >= new_length:
-                raise ValueError("Current line length is greater than new_length!")
-
-        fh, abs_path = mkstemp()
-        with os.fdopen(fh, 'wb') as new_file:
-            with open(file_path, 'rt', encoding='ascii') as old_file:
-                for line in old_file:
-                    number: str = line.rstrip(self._trailing_char + '\n')
-                    new_line: str = str(number).ljust(new_length - 1, self._trailing_char) + '\n'
-                    new_file.write(new_line.encode('ascii'))
-
-        # Copy the file permissions from the old file to the new file
-        copymode(file_path, abs_path)
-
-        # Replace original file
-        os.remove(file_path)
-        move(abs_path, file_path)
-
-    @staticmethod
-    def _is_a_valid_line(buf: bytes) -> bool:
-        string: str = buf.decode("ascii")
-        return (string[-1] == "\n") and ("\0" not in string[:-1])
-
-    def _fix_previous_lines(self, file: BinaryIO, line_len: int) -> None:
-        if line_len < self._initial_line_len:
-            raise ValueError("line_len should be at least %d!" % self._initial_line_len)
-
-        while file.tell() >= line_len:
-            file.seek(-line_len, os.SEEK_CUR)
-            buf: bytes = file.read(line_len)
-            if self._is_a_valid_line(buf) or len(buf) < line_len:
-                break
-            else:
-                file.seek(-line_len, os.SEEK_CUR)
-                fixed_line: str = (self._trailing_char * (line_len - 1)) + "\n"
-                file.write(fixed_line.encode("ascii"))
-                file.seek(-line_len, os.SEEK_CUR)
-
-    def set_metadata_counter(self, new_value: int, entity_short_name: str, dataset_name: str) -> None:
-        """
-        It allows to set the counter value of metadata entities.
-
-        :param new_value: The new counter value to be set
-        :type new_value: int
-        :param entity_short_name: The short name associated either to the type of the entity itself.
-        :type entity_short_name: str
-        :param dataset_name: In case of a ``Dataset``, its name. Otherwise, the name of the relative dataset.
-        :type dataset_name: str
-        :raises ValueError: if ``new_value`` is a negative integer, ``dataset_name`` is None or
-          ``entity_short_name`` is not a known metadata short name.
-        :return: None
-        """
-        if new_value < 0:
-            raise ValueError("new_value must be a non negative integer!")
-
-        if dataset_name is None:
-            raise ValueError("dataset_name must be provided!")
-
-        if entity_short_name not in self.metadata_short_names:
-            raise ValueError("entity_short_name is not a known metadata short name!")
-
-        file_path: str = self._get_metadata_path(entity_short_name, dataset_name)
-        return self._set_number(new_value, file_path, 1)
-
-    def read_metadata_counter(self, entity_short_name: str, dataset_name: str) -> int:
-        """
-        It allows to read the counter value of metadata entities.
-
-        :param entity_short_name: The short name associated either to the type of the entity itself.
-        :type entity_short_name: str
-        :param dataset_name: In case of a ``Dataset``, its name. Otherwise, the name of the relative dataset.
-        :type dataset_name: str
-        :raises ValueError: if ``dataset_name`` is None or ``entity_short_name`` is not a known metadata short name.
-        :return: The requested counter value.
-        """
-        if dataset_name is None:
-            raise ValueError("dataset_name must be provided!")
-
-        if entity_short_name not in self.metadata_short_names:
-            raise ValueError("entity_short_name is not a known metadata short name!")
-
-        file_path: str = self._get_metadata_path(entity_short_name, dataset_name)
-        return self._read_number(file_path, 1)[0]
-
-    def increment_metadata_counter(self, entity_short_name: str, dataset_name: str) -> int:
-        """
-        It allows to increment the counter value of metadata entities by one unit.
-
-        :param entity_short_name: The short name associated either to the type of the entity itself.
-        :type entity_short_name: str
-        :param dataset_name: In case of a ``Dataset``, its name. Otherwise, the name of the relative dataset.
-        :type dataset_name: str
-        :raises ValueError: if ``dataset_name`` is None or ``entity_short_name`` is not a known metadata short name.
-        :return: The newly-updated (already incremented) counter value.
-        """
-        if dataset_name is None:
-            raise ValueError("dataset_name must be provided!")
-
-        if entity_short_name not in self.metadata_short_names:
-            raise ValueError("entity_short_name is not a known metadata short name!")
-
-        file_path: str = self._get_metadata_path(entity_short_name, dataset_name)
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+import os
+from shutil import copymode, move
+from tempfile import mkstemp
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from typing import BinaryIO, Tuple, List, Dict
+
+from oc_ocdm.counter_handler.counter_handler import CounterHandler
+from oc_ocdm.support.support import is_string_empty
+
+
+class FilesystemCounterHandler(CounterHandler):
+    """A concrete implementation of the ``CounterHandler`` interface that persistently stores
+    the counter values within the filesystem."""
+
+    _initial_line_len: int = 3
+    _trailing_char: str = " "
+
+    def __init__(self, info_dir: str, supplier_prefix: str = "") -> None:
+        """
+        Constructor of the ``FilesystemCounterHandler`` class.
+
+        :param info_dir: The path to the folder that does/will contain the counter values.
+        :type info_dir: str
+        :raises ValueError: if ``info_dir`` is None or an empty string.
+        """
+        if info_dir is None or is_string_empty(info_dir):
+            raise ValueError("info_dir parameter is required!")
+
+        if info_dir[-1] != os.sep:
+            info_dir += os.sep
+
+        self.info_dir: str = info_dir
+        self.supplier_prefix: str = supplier_prefix
+        self.datasets_dir: str = info_dir + 'datasets' + os.sep
+        self.short_names: List[str] = ["an", "ar", "be", "br", "ci", "de", "id", "pl", "ra", "re", "rp"]
+        self.metadata_short_names: List[str] = ["di"]
+        self.info_files: Dict[str, str] = {key: ("info_file_" + key + ".txt")
+                                           for key in self.short_names}
+        self.prov_files: Dict[str, str] = {key: ("prov_file_" + key + ".txt")
+                                           for key in self.short_names}
+
+    def set_counter(self, new_value: int, entity_short_name: str, prov_short_name: str = "",
+                    identifier: int = 1, supplier_prefix: str = "") -> None:
+        """
+        It allows to set the counter value of graph and provenance entities.
+
+        :param new_value: The new counter value to be set
+        :type new_value: int
+        :param entity_short_name: The short name associated either to the type of the entity itself
+         or, in case of a provenance entity, to the type of the relative graph entity.
+        :type entity_short_name: str
+        :param prov_short_name: In case of a provenance entity, the short name associated to the type
+         of the entity itself. An empty string otherwise.
+        :type prov_short_name: str
+        :param identifier: In case of a provenance entity, the counter value that identifies the relative
+          graph entity. The integer value '1' otherwise.
+        :type identifier: int
+        :raises ValueError: if ``new_value`` is a negative integer or ``identifier`` is less than or equal to zero.
+        :return: None
+        """
+        if new_value < 0:
+            raise ValueError("new_value must be a non negative integer!")
+
+        if prov_short_name == "se":
+            file_path: str = self._get_prov_path(entity_short_name, supplier_prefix)
+        else:
+            file_path: str = self._get_info_path(entity_short_name, supplier_prefix)
+        self._set_number(new_value, file_path, identifier)
+
+    def set_counters_batch(self, updates: Dict[Tuple[str, str], Dict[int, int]], supplier_prefix: str) -> None:
+        """
+        Updates counters in batch for multiple files.
+        `updates` is a dictionary where the key is a tuple (entity_short_name, prov_short_name)
+        and the value is a dictionary of line numbers to new counter values.
+        """
+        for (entity_short_name, prov_short_name), file_updates in updates.items():
+            file_path = self._get_prov_path(entity_short_name, supplier_prefix) if prov_short_name == "se" else self._get_info_path(entity_short_name, supplier_prefix)
+            self._set_numbers(file_path, file_updates)
+
+    def _set_numbers(self, file_path: str, updates: Dict[int, int]) -> None:
+        """
+        Apply multiple counter updates to a single file.
+        `updates` is a dictionary where the key is the line number (identifier)
+        and the value is the new counter value.
+        """
+        self.__initialize_file_if_not_existing(file_path)
+        with open(file_path, 'r') as file:
+            lines = file.readlines()
+        max_line_number = max(updates.keys())
+
+        # Ensure the lines list is long enough
+        while len(lines) < max_line_number + 1:
+            lines.append("  \n")  # Default counter value
+
+        # Apply updates
+        for line_number, new_value in updates.items():
+            lines[line_number-1] = str(new_value).rstrip() + " \n"
+
+        # Write updated lines back to file
+        with open(file_path, 'w') as file:
+            file.writelines(lines)
+
+    def read_counter(self, entity_short_name: str, prov_short_name: str = "", identifier: int = 1, supplier_prefix: str = "") -> int:
+        """
+        It allows to read the counter value of graph and provenance entities.
+
+        :param entity_short_name: The short name associated either to the type of the entity itself
+         or, in case of a provenance entity, to the type of the relative graph entity.
+        :type entity_short_name: str
+        :param prov_short_name: In case of a provenance entity, the short name associated to the type
+         of the entity itself. An empty string otherwise.
+        :type prov_short_name: str
+        :param identifier: In case of a provenance entity, the counter value that identifies the relative
+          graph entity. The integer value '1' otherwise.
+        :type identifier: int
+        :raises ValueError: if ``identifier`` is less than or equal to zero.
+        :return: The requested counter value.
+        """
+        if prov_short_name == "se":
+            file_path: str = self._get_prov_path(entity_short_name, supplier_prefix)
+        else:
+            file_path: str = self._get_info_path(entity_short_name, supplier_prefix)
+        return self._read_number(file_path, identifier)[0]
+
+    def increment_counter(self, entity_short_name: str, prov_short_name: str = "", identifier: int = 1, supplier_prefix: str = "") -> int:
+        """
+        It allows to increment the counter value of graph and provenance entities by one unit.
+
+        :param entity_short_name: The short name associated either to the type of the entity itself
+         or, in case of a provenance entity, to the type of the relative graph entity.
+        :type entity_short_name: str
+        :param prov_short_name: In case of a provenance entity, the short name associated to the type
+         of the entity itself. An empty string otherwise.
+        :type prov_short_name: str
+        :param identifier: In case of a provenance entity, the counter value that identifies the relative
+          graph entity. The integer value '1' otherwise.
+        :type identifier: int
+        :raises ValueError: if ``identifier`` is less than or equal to zero.
+        :return: The newly-updated (already incremented) counter value.
+        """
+        if prov_short_name == "se":
+            file_path: str = self._get_prov_path(entity_short_name, supplier_prefix)
+        else:
+            file_path: str = self._get_info_path(entity_short_name, supplier_prefix)
+        return self._add_number(file_path, identifier)
+
+    def _get_info_path(self, short_name: str, supplier_prefix: str) -> str:
+        supplier_prefix = "" if supplier_prefix is None else supplier_prefix
+        directory = self.info_dir if supplier_prefix == self.supplier_prefix or not self.supplier_prefix else self.info_dir.replace(self.supplier_prefix, supplier_prefix, 1)
+        return directory + self.info_files[short_name]
+
+    def _get_prov_path(self, short_name: str, supplier_prefix: str) -> str:
+        supplier_prefix = "" if supplier_prefix is None else supplier_prefix
+        directory = self.info_dir if supplier_prefix == self.supplier_prefix or not self.supplier_prefix else self.info_dir.replace(self.supplier_prefix, supplier_prefix, 1)
+        return directory + self.prov_files[short_name]
+
+    def _get_metadata_path(self, short_name: str, dataset_name: str) -> str:
+        return self.datasets_dir + dataset_name + os.sep + 'metadata_' + short_name + '.txt'
+
+    def __initialize_file_if_not_existing(self, file_path: str):
+        if not os.path.exists(os.path.dirname(file_path)):
+            os.makedirs(os.path.dirname(file_path))
+
+        if not os.path.isfile(file_path):
+            with open(file_path, 'wb') as file:
+                first_line: str = self._trailing_char * (self._initial_line_len - 1) + '\n'
+                file.write(first_line.encode('ascii'))
+
+    def _read_number(self, file_path: str, line_number: int) -> Tuple[int, int]:
+        if line_number <= 0:
+            raise ValueError("line_number must be a positive non-zero integer number!")
+
+        self.__initialize_file_if_not_existing(file_path)
+
+        cur_number: int = 0
+        cur_line_len: int = 0
+        try:
+            with open(file_path, 'rb') as file:
+                cur_line_len = self._get_line_len(file)
+                line_offset = (line_number - 1) * cur_line_len
+                file.seek(line_offset)
+                line = file.readline(cur_line_len).decode('ascii')
+                cur_number = int(line.rstrip(self._trailing_char + '\n'))
+        except ValueError:
+            cur_number = 0
+        except Exception as e:
+            print(e)
+
+        return cur_number, cur_line_len
+
+    def _add_number(self, file_path: str, line_number: int = 1) -> int:
+        if line_number <= 0:
+            raise ValueError("line_number must be a positive non-zero integer number!")
+
+        self.__initialize_file_if_not_existing(file_path)
+
+        cur_number, cur_line_len = self._read_number(file_path, line_number)
+        cur_number += 1
+
+        cur_number_len: int = len(str(cur_number)) + 1
+        if cur_number_len > cur_line_len:
+            self._increase_line_len(file_path, new_length=cur_number_len)
+            cur_line_len = cur_number_len
+
+        with open(file_path, 'r+b') as file:
+            line_offset: int = (line_number - 1) * cur_line_len
+            file.seek(line_offset)
+            line: str = str(cur_number).ljust(cur_line_len - 1, self._trailing_char) + '\n'
+            file.write(line.encode('ascii'))
+            file.seek(-cur_line_len, os.SEEK_CUR)
+            self._fix_previous_lines(file, cur_line_len)
+        return cur_number
+
+    def _set_number(self, new_value: int, file_path: str, line_number: int = 1) -> None:
+        if new_value < 0:
+            raise ValueError("new_value must be a non negative integer!")
+
+        if line_number <= 0:
+            raise ValueError("line_number must be a positive non-zero integer number!")
+
+        self.__initialize_file_if_not_existing(file_path)
+
+        cur_line_len = self._read_number(file_path, line_number)[1]
+
+        cur_number_len: int = len(str(new_value)) + 1
+        if cur_number_len > cur_line_len:
+            self._increase_line_len(file_path, new_length=cur_number_len)
+            cur_line_len = cur_number_len
+
+        with open(file_path, 'r+b') as file:
+            line_offset: int = (line_number - 1) * cur_line_len
+            file.seek(line_offset)
+            line: str = str(new_value).ljust(cur_line_len - 1, self._trailing_char) + '\n'
+            file.write(line.encode('ascii'))
+            file.seek(-cur_line_len, os.SEEK_CUR)
+            self._fix_previous_lines(file, cur_line_len)
+
+    @staticmethod
+    def _get_line_len(file: BinaryIO) -> int:
+        cur_char: str = file.read(1).decode("ascii")
+        count: int = 1
+        while cur_char is not None and len(cur_char) == 1 and cur_char != "\0":
+            cur_char = file.read(1).decode("ascii")
+            count += 1
+            if cur_char == "\n":
+                break
+
+        # Undo I/O pointer updates
+        file.seek(0)
+
+        if cur_char is None:
+            raise EOFError("Reached end-of-file without encountering a line separator!")
+        elif cur_char == "\0":
+            raise ValueError("Encountered a NULL byte!")
+        else:
+            return count
+
+    def _increase_line_len(self, file_path: str, new_length: int = 0) -> None:
+        if new_length <= 0:
+            raise ValueError("new_length must be a positive non-zero integer number!")
+
+        with open(file_path, 'rb') as cur_file:
+            if self._get_line_len(cur_file) >= new_length:
+                raise ValueError("Current line length is greater than new_length!")
+
+        fh, abs_path = mkstemp()
+        with os.fdopen(fh, 'wb') as new_file:
+            with open(file_path, 'rt', encoding='ascii') as old_file:
+                for line in old_file:
+                    number: str = line.rstrip(self._trailing_char + '\n')
+                    new_line: str = str(number).ljust(new_length - 1, self._trailing_char) + '\n'
+                    new_file.write(new_line.encode('ascii'))
+
+        # Copy the file permissions from the old file to the new file
+        copymode(file_path, abs_path)
+
+        # Replace original file
+        os.remove(file_path)
+        move(abs_path, file_path)
+
+    @staticmethod
+    def _is_a_valid_line(buf: bytes) -> bool:
+        string: str = buf.decode("ascii")
+        return (string[-1] == "\n") and ("\0" not in string[:-1])
+
+    def _fix_previous_lines(self, file: BinaryIO, line_len: int) -> None:
+        if line_len < self._initial_line_len:
+            raise ValueError("line_len should be at least %d!" % self._initial_line_len)
+
+        while file.tell() >= line_len:
+            file.seek(-line_len, os.SEEK_CUR)
+            buf: bytes = file.read(line_len)
+            if self._is_a_valid_line(buf) or len(buf) < line_len:
+                break
+            else:
+                file.seek(-line_len, os.SEEK_CUR)
+                fixed_line: str = (self._trailing_char * (line_len - 1)) + "\n"
+                file.write(fixed_line.encode("ascii"))
+                file.seek(-line_len, os.SEEK_CUR)
+
+    def set_metadata_counter(self, new_value: int, entity_short_name: str, dataset_name: str) -> None:
+        """
+        It allows to set the counter value of metadata entities.
+
+        :param new_value: The new counter value to be set
+        :type new_value: int
+        :param entity_short_name: The short name associated either to the type of the entity itself.
+        :type entity_short_name: str
+        :param dataset_name: In case of a ``Dataset``, its name. Otherwise, the name of the relative dataset.
+        :type dataset_name: str
+        :raises ValueError: if ``new_value`` is a negative integer, ``dataset_name`` is None or
+          ``entity_short_name`` is not a known metadata short name.
+        :return: None
+        """
+        if new_value < 0:
+            raise ValueError("new_value must be a non negative integer!")
+
+        if dataset_name is None:
+            raise ValueError("dataset_name must be provided!")
+
+        if entity_short_name not in self.metadata_short_names:
+            raise ValueError("entity_short_name is not a known metadata short name!")
+
+        file_path: str = self._get_metadata_path(entity_short_name, dataset_name)
+        return self._set_number(new_value, file_path, 1)
+
+    def read_metadata_counter(self, entity_short_name: str, dataset_name: str) -> int:
+        """
+        It allows to read the counter value of metadata entities.
+
+        :param entity_short_name: The short name associated either to the type of the entity itself.
+        :type entity_short_name: str
+        :param dataset_name: In case of a ``Dataset``, its name. Otherwise, the name of the relative dataset.
+        :type dataset_name: str
+        :raises ValueError: if ``dataset_name`` is None or ``entity_short_name`` is not a known metadata short name.
+        :return: The requested counter value.
+        """
+        if dataset_name is None:
+            raise ValueError("dataset_name must be provided!")
+
+        if entity_short_name not in self.metadata_short_names:
+            raise ValueError("entity_short_name is not a known metadata short name!")
+
+        file_path: str = self._get_metadata_path(entity_short_name, dataset_name)
+        return self._read_number(file_path, 1)[0]
+
+    def increment_metadata_counter(self, entity_short_name: str, dataset_name: str) -> int:
+        """
+        It allows to increment the counter value of metadata entities by one unit.
+
+        :param entity_short_name: The short name associated either to the type of the entity itself.
+        :type entity_short_name: str
+        :param dataset_name: In case of a ``Dataset``, its name. Otherwise, the name of the relative dataset.
+        :type dataset_name: str
+        :raises ValueError: if ``dataset_name`` is None or ``entity_short_name`` is not a known metadata short name.
+        :return: The newly-updated (already incremented) counter value.
+        """
+        if dataset_name is None:
+            raise ValueError("dataset_name must be provided!")
+
+        if entity_short_name not in self.metadata_short_names:
+            raise ValueError("entity_short_name is not a known metadata short name!")
+
+        file_path: str = self._get_metadata_path(entity_short_name, dataset_name)
         return self._add_number(file_path, 1)
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/counter_handler/sqlite_counter_handler.py` & `oc_ocdm-8.1.0/oc_ocdm/counter_handler/sqlite_counter_handler.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,96 +1,96 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2023, Arcangelo Massari <arcangelo.massari@unibo.it>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-
-import sqlite3
-
-from oc_ocdm.counter_handler.counter_handler import CounterHandler
-
-
-class SqliteCounterHandler(CounterHandler):
-    """A concrete implementation of the ``CounterHandler`` interface that persistently stores
-    the counter values within a SQLite database."""
-
-    def __init__(self, database: str) -> None:
-        """
-        Constructor of the ``SqliteCounterHandler`` class.
-
-        :param database: The name of the database
-        :type info_dir: str
-        """
-        sqlite3.threadsafety = 3
-        self.con = sqlite3.connect(database)
-        self.cur = self.con.cursor()
-        self.cur.execute("""CREATE TABLE IF NOT EXISTS info(
-            entity TEXT PRIMARY KEY, 
-            count INTEGER)""")
-
-    def set_counter(self, new_value: int, entity_name: str) -> None:
-        """
-        It allows to set the counter value of provenance entities.
-
-        :param new_value: The new counter value to be set
-        :type new_value: int
-        :param entity_name: The entity name
-        :type entity_name: str
-        :raises ValueError: if ``new_value`` is a negative integer.
-        :return: None
-        """
-        entity_name = str(entity_name)
-        if new_value < 0:
-            raise ValueError("new_value must be a non negative integer!")
-        self.cur.execute(f"INSERT OR REPLACE INTO info (entity, count) VALUES ('{entity_name}', {new_value})")
-        self.con.commit()
-
-    def read_counter(self, entity_name: str) -> int:
-        """
-        It allows to read the counter value of provenance entities.
-
-        :param entity_name: The entity name
-        :type entity_name: str
-        :return: The requested counter value.
-        """
-        entity_name = str(entity_name)
-        result = self.cur.execute(f"SELECT count FROM info WHERE entity='{entity_name}'")
-        rows = result.fetchall()
-        if len(rows) == 1:
-            return rows[0][0]
-        elif len(rows) == 0:
-            return 0
-        else:
-            raise(Exception("There is more than one counter for this entity. The databse id broken"))
-
-    def increment_counter(self, entity_name: str) -> int:
-        """
-        It allows to increment the counter value of graph and provenance entities by one unit.
-
-        :param entity_name: The entity name
-        :type entity_name: str
-        :return: The newly-updated (already incremented) counter value.
-        """
-        entity_name = str(entity_name)
-        cur_count = self.read_counter(entity_name)
-        count = cur_count + 1
-        self.set_counter(count, entity_name)
-        return count
-
-    def increment_metadata_counter(self):
-        pass
-    
-    def read_metadata_counter(self):
-        pass
-    
-    def set_metadata_counter(self):
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2023, Arcangelo Massari <arcangelo.massari@unibo.it>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+
+import sqlite3
+
+from oc_ocdm.counter_handler.counter_handler import CounterHandler
+
+
+class SqliteCounterHandler(CounterHandler):
+    """A concrete implementation of the ``CounterHandler`` interface that persistently stores
+    the counter values within a SQLite database."""
+
+    def __init__(self, database: str) -> None:
+        """
+        Constructor of the ``SqliteCounterHandler`` class.
+
+        :param database: The name of the database
+        :type info_dir: str
+        """
+        sqlite3.threadsafety = 3
+        self.con = sqlite3.connect(database)
+        self.cur = self.con.cursor()
+        self.cur.execute("""CREATE TABLE IF NOT EXISTS info(
+            entity TEXT PRIMARY KEY, 
+            count INTEGER)""")
+
+    def set_counter(self, new_value: int, entity_name: str) -> None:
+        """
+        It allows to set the counter value of provenance entities.
+
+        :param new_value: The new counter value to be set
+        :type new_value: int
+        :param entity_name: The entity name
+        :type entity_name: str
+        :raises ValueError: if ``new_value`` is a negative integer.
+        :return: None
+        """
+        entity_name = str(entity_name)
+        if new_value < 0:
+            raise ValueError("new_value must be a non negative integer!")
+        self.cur.execute(f"INSERT OR REPLACE INTO info (entity, count) VALUES ('{entity_name}', {new_value})")
+        self.con.commit()
+
+    def read_counter(self, entity_name: str) -> int:
+        """
+        It allows to read the counter value of provenance entities.
+
+        :param entity_name: The entity name
+        :type entity_name: str
+        :return: The requested counter value.
+        """
+        entity_name = str(entity_name)
+        result = self.cur.execute(f"SELECT count FROM info WHERE entity='{entity_name}'")
+        rows = result.fetchall()
+        if len(rows) == 1:
+            return rows[0][0]
+        elif len(rows) == 0:
+            return 0
+        else:
+            raise(Exception("There is more than one counter for this entity. The databse id broken"))
+
+    def increment_counter(self, entity_name: str) -> int:
+        """
+        It allows to increment the counter value of graph and provenance entities by one unit.
+
+        :param entity_name: The entity name
+        :type entity_name: str
+        :return: The newly-updated (already incremented) counter value.
+        """
+        entity_name = str(entity_name)
+        cur_count = self.read_counter(entity_name)
+        count = cur_count + 1
+        self.set_counter(count, entity_name)
+        return count
+
+    def increment_metadata_counter(self):
+        pass
+    
+    def read_metadata_counter(self):
+        pass
+    
+    def set_metadata_counter(self):
         pass
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/decorators.py` & `oc_ocdm-8.1.0/oc_ocdm/decorators.py`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,59 +1,59 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-from functools import wraps
-from typing import TYPE_CHECKING
-
-from oc_ocdm.abstract_entity import AbstractEntity
-
-if TYPE_CHECKING:
-    from typing import Callable, Any
-from rdflib import URIRef
-
-
-def accepts_only(param_type: str):
-    """
-    A decorator that can be applied to the entity methods such as setters and removers
-    when they accept a parameter. It enforces the right parameter type by raising a
-    ``TypeError`` when the parameter is not None but its type is not the expected one.
-
-    The expected type can be expressed through a short string:
-
-      * 'literal' for the ``str`` type;
-      * 'thing' for the ``URIRef`` type (from ``rdflib``);
-      * '_dataset_' for the ``Dataset`` entities;
-      * the OCDM short name in case of any other entity (e.g. 'br' for ``BibliographicResource``).
-
-    :param param_type: A short string representing the expected type
-    :type param_type: str
-    """
-    def accepts_only_decorator(function: Callable):
-
-        @wraps(function)
-        def accepts_only_wrapper(self, param: Any = None):
-            lowercase_type = param_type.lower()
-            if param is None or \
-                    (lowercase_type == 'literal' and type(param) == str) or \
-                    (lowercase_type == 'thing' and type(param) == URIRef) or \
-                    (isinstance(param, AbstractEntity) and param.short_name == lowercase_type):
-                function(self, param)
-            else:
-                raise TypeError('[%s.%s] Expected argument type: %s. Provided argument type: %s.' %
-                                (self.__class__.__name__, function.__name__, lowercase_type, type(param).__name__))
-
-        return accepts_only_wrapper
-    return accepts_only_decorator
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+from functools import wraps
+from typing import TYPE_CHECKING
+
+from oc_ocdm.abstract_entity import AbstractEntity
+
+if TYPE_CHECKING:
+    from typing import Callable, Any
+from rdflib import URIRef
+
+
+def accepts_only(param_type: str):
+    """
+    A decorator that can be applied to the entity methods such as setters and removers
+    when they accept a parameter. It enforces the right parameter type by raising a
+    ``TypeError`` when the parameter is not None but its type is not the expected one.
+
+    The expected type can be expressed through a short string:
+
+      * 'literal' for the ``str`` type;
+      * 'thing' for the ``URIRef`` type (from ``rdflib``);
+      * '_dataset_' for the ``Dataset`` entities;
+      * the OCDM short name in case of any other entity (e.g. 'br' for ``BibliographicResource``).
+
+    :param param_type: A short string representing the expected type
+    :type param_type: str
+    """
+    def accepts_only_decorator(function: Callable):
+
+        @wraps(function)
+        def accepts_only_wrapper(self, param: Any = None):
+            lowercase_type = param_type.lower()
+            if param is None or \
+                    (lowercase_type == 'literal' and type(param) == str) or \
+                    (lowercase_type == 'thing' and type(param) == URIRef) or \
+                    (isinstance(param, AbstractEntity) and param.short_name == lowercase_type):
+                function(self, param)
+            else:
+                raise TypeError('[%s.%s] Expected argument type: %s. Provided argument type: %s.' %
+                                (self.__class__.__name__, function.__name__, lowercase_type, type(param).__name__))
+
+        return accepts_only_wrapper
+    return accepts_only_decorator
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/graph/__init__.py` & `oc_ocdm-8.1.0/oc_ocdm/prov/entities/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,18 +1,17 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.graph.graph_set import GraphSet
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+
+from oc_ocdm.prov.entities.snapshot_entity import SnapshotEntity
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/graph/entities/__init__.py` & `oc_ocdm-8.1.0/oc_ocdm/graph/entities/__init__.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,18 +1,18 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-
-from oc_ocdm.graph.entities.bibliographic_entity import BibliographicEntity
-from oc_ocdm.graph.entities.identifier import Identifier
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+
+from oc_ocdm.graph.entities.bibliographic_entity import BibliographicEntity
+from oc_ocdm.graph.entities.identifier import Identifier
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/graph/entities/bibliographic/__init__.py` & `oc_ocdm-8.1.0/oc_ocdm/graph/entities/bibliographic/__init__.py`

 * *Ordering differences only*

 * *Files 7% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-
-from oc_ocdm.graph.entities.bibliographic.agent_role import AgentRole
-from oc_ocdm.graph.entities.bibliographic.bibliographic_reference import BibliographicReference
-from oc_ocdm.graph.entities.bibliographic.bibliographic_resource import BibliographicResource
-from oc_ocdm.graph.entities.bibliographic.citation import Citation
-from oc_ocdm.graph.entities.bibliographic.discourse_element import DiscourseElement
-from oc_ocdm.graph.entities.bibliographic.pointer_list import PointerList
-from oc_ocdm.graph.entities.bibliographic.reference_annotation import ReferenceAnnotation
-from oc_ocdm.graph.entities.bibliographic.reference_pointer import ReferencePointer
-from oc_ocdm.graph.entities.bibliographic.resource_embodiment import ResourceEmbodiment
-from oc_ocdm.graph.entities.bibliographic.responsible_agent import ResponsibleAgent
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+
+from oc_ocdm.graph.entities.bibliographic.agent_role import AgentRole
+from oc_ocdm.graph.entities.bibliographic.bibliographic_reference import BibliographicReference
+from oc_ocdm.graph.entities.bibliographic.bibliographic_resource import BibliographicResource
+from oc_ocdm.graph.entities.bibliographic.citation import Citation
+from oc_ocdm.graph.entities.bibliographic.discourse_element import DiscourseElement
+from oc_ocdm.graph.entities.bibliographic.pointer_list import PointerList
+from oc_ocdm.graph.entities.bibliographic.reference_annotation import ReferenceAnnotation
+from oc_ocdm.graph.entities.bibliographic.reference_pointer import ReferencePointer
+from oc_ocdm.graph.entities.bibliographic.resource_embodiment import ResourceEmbodiment
+from oc_ocdm.graph.entities.bibliographic.responsible_agent import ResponsibleAgent
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/graph/entities/bibliographic/agent_role.py` & `oc_ocdm-8.1.0/oc_ocdm/graph/entities/bibliographic/agent_role.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,203 +1,203 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-from oc_ocdm.decorators import accepts_only
-
-if TYPE_CHECKING:
-    from typing import Optional
-    from rdflib import URIRef
-    from oc_ocdm.graph.entities.bibliographic.responsible_agent import ResponsibleAgent
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.graph.entities.bibliographic_entity import BibliographicEntity
-
-
-class AgentRole(BibliographicEntity):
-    """Agent role (short: ar): a particular role held by an agent with respect to a bibliographic resource."""
-
-    @accepts_only('ar')
-    def merge(self, other: AgentRole) -> None:
-        """
-        The merge operation allows combining two ``AgentRole`` entities into a single one,
-        by marking the second entity as to be deleted while also copying its data into the current
-        ``AgentRole``. Moreover, every triple from the containing ``GraphSet`` referring to the second
-        entity gets "redirected" to the current entity: **every other reference contained inside a
-        different source (e.g. a triplestore) must be manually handled by the user!**
-
-        In case of functional properties, values from the current entity get overwritten
-        by those coming from the second entity while, in all other cases, values from the
-        second entity are simply appended to those of the current entity. In this context,
-        ``rdfs:label`` is considered as a functional property, while ``rdf:type`` is not.
-
-        :param other: The entity which will be marked as to be deleted and whose properties will
-         be merged into the current entity.
-        :type other: AgentRole
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        super(AgentRole, self).merge(other)
-
-        next_ar: Optional[AgentRole] = other.get_next()
-        if next_ar is not None:
-            self.has_next(next_ar)
-
-        resp_agent: Optional[ResponsibleAgent] = other.get_is_held_by()
-        if resp_agent is not None:
-            self.is_held_by(resp_agent)
-
-        role_type: Optional[URIRef] = other.get_role_type()
-        if role_type is not None:
-            if role_type == GraphEntity.iri_publisher:
-                self.create_publisher()
-            elif role_type == GraphEntity.iri_author:
-                self.create_author()
-            elif role_type == GraphEntity.iri_editor:
-                self.create_editor()
-
-    # HAS NEXT (AgentRole)
-    def get_next(self) -> Optional[AgentRole]:
-        """
-        Getter method corresponding to the ``oco:hasNext`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_has_next, 'ar')
-        if uri is not None:
-            return self.g_set.add_ar(self.resp_agent, self.source, uri)
-
-    @accepts_only('ar')
-    def has_next(self, ar_res: AgentRole) -> None:
-        """
-        Setter method corresponding to the ``oco:hasNext`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The previous role in a sequence of agent roles of the same type associated with the
-        same bibliographic resource (so as to define, for instance, an ordered list of authors).`
-
-        :param ar_res: The value that will be set as the object of the property related to this method
-        :type ar_res: AgentRole
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_next()
-        self.g.add((self.res, GraphEntity.iri_has_next, ar_res.res))
-
-    def remove_next(self) -> None:
-        """
-        Remover method corresponding to the ``oco:hasNext`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_has_next, None))
-
-    # IS HELD BY (ResponsibleAgent)
-    def get_is_held_by(self) -> Optional[ResponsibleAgent]:
-        """
-        Getter method corresponding to the ``pro:isHeldBy`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_is_held_by, 'ra')
-        if uri is not None:
-            return self.g_set.add_ra(self.resp_agent, self.source, uri)
-
-    @accepts_only('ra')
-    def is_held_by(self, ra_res: ResponsibleAgent):
-        """
-        Setter method corresponding to the ``pro:isHeldBy`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The agent holding this role with respect to a particular bibliographic resource.`
-
-        :param ra_res: The value that will be set as the object of the property related to this method
-        :type ra_res: ResponsibleAgent
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_is_held_by()
-        self.g.add((self.res, GraphEntity.iri_is_held_by, ra_res.res))
-
-    def remove_is_held_by(self) -> None:
-        """
-        Remover method corresponding to the ``pro:isHeldBy`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_is_held_by, None))
-
-    # HAS ROLE TYPE
-    def get_role_type(self) -> Optional[URIRef]:
-        """
-        Getter method corresponding to the ``pro:withRole`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_with_role)
-        return uri
-
-    def create_publisher(self) -> None:
-        """
-        Setter method corresponding to the ``pro:withRole`` RDF predicate.
-        It implicitly sets the object value ``pro:publisher``.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The specific type of role under consideration (e.g. author, editor or publisher).`
-
-        :return: None
-        """
-        self.remove_role_type()
-        self.g.add((self.res, GraphEntity.iri_with_role, GraphEntity.iri_publisher))
-
-    def create_author(self) -> None:
-        """
-        Setter method corresponding to the ``pro:withRole`` RDF predicate.
-        It implicitly sets the object value ``pro:author``.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The specific type of role under consideration (e.g. author, editor or publisher).`
-
-        :return: None
-        """
-        self.remove_role_type()
-        self.g.add((self.res, GraphEntity.iri_with_role, GraphEntity.iri_author))
-
-    def create_editor(self) -> None:
-        """
-        Setter method corresponding to the ``pro:withRole`` RDF predicate.
-        It implicitly sets the object value ``pro:editor``.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The specific type of role under consideration (e.g. author, editor or publisher).`
-
-        :return: None
-        """
-        self.remove_role_type()
-        self.g.add((self.res, GraphEntity.iri_with_role, GraphEntity.iri_editor))
-
-    def remove_role_type(self) -> None:
-        """
-        Remover method corresponding to the ``pro:withRole`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_with_role, None))
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+from oc_ocdm.decorators import accepts_only
+
+if TYPE_CHECKING:
+    from typing import Optional
+    from rdflib import URIRef
+    from oc_ocdm.graph.entities.bibliographic.responsible_agent import ResponsibleAgent
+from oc_ocdm.graph.graph_entity import GraphEntity
+from oc_ocdm.graph.entities.bibliographic_entity import BibliographicEntity
+
+
+class AgentRole(BibliographicEntity):
+    """Agent role (short: ar): a particular role held by an agent with respect to a bibliographic resource."""
+
+    @accepts_only('ar')
+    def merge(self, other: AgentRole) -> None:
+        """
+        The merge operation allows combining two ``AgentRole`` entities into a single one,
+        by marking the second entity as to be deleted while also copying its data into the current
+        ``AgentRole``. Moreover, every triple from the containing ``GraphSet`` referring to the second
+        entity gets "redirected" to the current entity: **every other reference contained inside a
+        different source (e.g. a triplestore) must be manually handled by the user!**
+
+        In case of functional properties, values from the current entity get overwritten
+        by those coming from the second entity while, in all other cases, values from the
+        second entity are simply appended to those of the current entity. In this context,
+        ``rdfs:label`` is considered as a functional property, while ``rdf:type`` is not.
+
+        :param other: The entity which will be marked as to be deleted and whose properties will
+         be merged into the current entity.
+        :type other: AgentRole
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        super(AgentRole, self).merge(other)
+
+        next_ar: Optional[AgentRole] = other.get_next()
+        if next_ar is not None:
+            self.has_next(next_ar)
+
+        resp_agent: Optional[ResponsibleAgent] = other.get_is_held_by()
+        if resp_agent is not None:
+            self.is_held_by(resp_agent)
+
+        role_type: Optional[URIRef] = other.get_role_type()
+        if role_type is not None:
+            if role_type == GraphEntity.iri_publisher:
+                self.create_publisher()
+            elif role_type == GraphEntity.iri_author:
+                self.create_author()
+            elif role_type == GraphEntity.iri_editor:
+                self.create_editor()
+
+    # HAS NEXT (AgentRole)
+    def get_next(self) -> Optional[AgentRole]:
+        """
+        Getter method corresponding to the ``oco:hasNext`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_has_next, 'ar')
+        if uri is not None:
+            return self.g_set.add_ar(self.resp_agent, self.source, uri)
+
+    @accepts_only('ar')
+    def has_next(self, ar_res: AgentRole) -> None:
+        """
+        Setter method corresponding to the ``oco:hasNext`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The previous role in a sequence of agent roles of the same type associated with the
+        same bibliographic resource (so as to define, for instance, an ordered list of authors).`
+
+        :param ar_res: The value that will be set as the object of the property related to this method
+        :type ar_res: AgentRole
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_next()
+        self.g.add((self.res, GraphEntity.iri_has_next, ar_res.res))
+
+    def remove_next(self) -> None:
+        """
+        Remover method corresponding to the ``oco:hasNext`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_has_next, None))
+
+    # IS HELD BY (ResponsibleAgent)
+    def get_is_held_by(self) -> Optional[ResponsibleAgent]:
+        """
+        Getter method corresponding to the ``pro:isHeldBy`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_is_held_by, 'ra')
+        if uri is not None:
+            return self.g_set.add_ra(self.resp_agent, self.source, uri)
+
+    @accepts_only('ra')
+    def is_held_by(self, ra_res: ResponsibleAgent):
+        """
+        Setter method corresponding to the ``pro:isHeldBy`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The agent holding this role with respect to a particular bibliographic resource.`
+
+        :param ra_res: The value that will be set as the object of the property related to this method
+        :type ra_res: ResponsibleAgent
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_is_held_by()
+        self.g.add((self.res, GraphEntity.iri_is_held_by, ra_res.res))
+
+    def remove_is_held_by(self) -> None:
+        """
+        Remover method corresponding to the ``pro:isHeldBy`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_is_held_by, None))
+
+    # HAS ROLE TYPE
+    def get_role_type(self) -> Optional[URIRef]:
+        """
+        Getter method corresponding to the ``pro:withRole`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_with_role)
+        return uri
+
+    def create_publisher(self) -> None:
+        """
+        Setter method corresponding to the ``pro:withRole`` RDF predicate.
+        It implicitly sets the object value ``pro:publisher``.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The specific type of role under consideration (e.g. author, editor or publisher).`
+
+        :return: None
+        """
+        self.remove_role_type()
+        self.g.add((self.res, GraphEntity.iri_with_role, GraphEntity.iri_publisher))
+
+    def create_author(self) -> None:
+        """
+        Setter method corresponding to the ``pro:withRole`` RDF predicate.
+        It implicitly sets the object value ``pro:author``.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The specific type of role under consideration (e.g. author, editor or publisher).`
+
+        :return: None
+        """
+        self.remove_role_type()
+        self.g.add((self.res, GraphEntity.iri_with_role, GraphEntity.iri_author))
+
+    def create_editor(self) -> None:
+        """
+        Setter method corresponding to the ``pro:withRole`` RDF predicate.
+        It implicitly sets the object value ``pro:editor``.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The specific type of role under consideration (e.g. author, editor or publisher).`
+
+        :return: None
+        """
+        self.remove_role_type()
+        self.g.add((self.res, GraphEntity.iri_with_role, GraphEntity.iri_editor))
+
+    def remove_role_type(self) -> None:
+        """
+        Remover method corresponding to the ``pro:withRole`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_with_role, None))
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/graph/entities/bibliographic/bibliographic_reference.py` & `oc_ocdm-8.1.0/oc_ocdm/graph/entities/bibliographic/bibliographic_reference.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,195 +1,195 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-from oc_ocdm.decorators import accepts_only
-
-if TYPE_CHECKING:
-    from typing import Optional, List
-    from rdflib import URIRef
-    from oc_ocdm.graph.entities.bibliographic.reference_annotation import ReferenceAnnotation
-    from oc_ocdm.graph.entities.bibliographic.bibliographic_resource import BibliographicResource
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.graph.entities.bibliographic_entity import BibliographicEntity
-
-
-class BibliographicReference(BibliographicEntity):
-    """Bibliographic reference (short: be): the particular textual bibliographic reference,
-    usually occurring in the reference list (and denoted by one or more in-text reference
-    pointers within the text of a citing bibliographic resource), that references another
-    bibliographic resource.
-    """
-
-    @accepts_only('be')
-    def merge(self, other: BibliographicReference) -> None:
-        """
-        The merge operation allows combining two ``BibliographicReference`` entities into a single one,
-        by marking the second entity as to be deleted while also copying its data into the current
-        ``BibliographicReference``. Moreover, every triple from the containing ``GraphSet`` referring to the second
-        entity gets "redirected" to the current entity: **every other reference contained inside a
-        different source (e.g. a triplestore) must be manually handled by the user!**
-
-        In case of functional properties, values from the current entity get overwritten
-        by those coming from the second entity while, in all other cases, values from the
-        second entity are simply appended to those of the current entity. In this context,
-        ``rdfs:label`` is considered as a functional property, while ``rdf:type`` is not.
-
-        :param other: The entity which will be marked as to be deleted and whose properties will
-         be merged into the current entity.
-        :type other: BibliographicReference
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        super(BibliographicReference, self).merge(other)
-
-        content: Optional[str] = other.get_content()
-        if content is not None:
-            self.has_content(content)
-
-        annotations_list: List[ReferenceAnnotation] = other.get_annotations()
-        for cur_annotation in annotations_list:
-            self.has_annotation(cur_annotation)
-
-        referenced_br: Optional[BibliographicResource] = other.get_referenced_br()
-        if referenced_br is not None:
-            self.references_br(referenced_br)
-
-    # HAS BIBLIOGRAPHIC REFERENCE TEXT
-    def get_content(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``c4o:hasContent`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(GraphEntity.iri_has_content)
-
-    @accepts_only('literal')
-    def has_content(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``c4o:hasContent`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The literal text of a bibliographic reference occurring in the reference list (or
-        elsewhere) within a bibliographic resource, that references another bibliographic
-        resource. The reference text should be recorded “as given” in the citing bibliographic
-        resource, including any errors (e.g. mis-spellings of authors’ names, or changes from
-        “β” in the original published title to “beta” in the reference text) or omissions (e.g.
-        omission of the title of the referenced bibliographic resource, or omission of sixth and
-        subsequent authors’ names, as required by certain publishers), and in whatever format
-        it has been made available. For instance, the reference text can be either as plain text
-        or as a block of XML.`
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_content()
-        self._create_literal(GraphEntity.iri_has_content, string)
-
-    def remove_content(self) -> None:
-        """
-        Remover method corresponding to the ``c4o:hasContent`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_has_content, None))
-
-    # HAS ANNOTATION (ReferenceAnnotation)
-    def get_annotations(self) -> List[ReferenceAnnotation]:
-        """
-        Getter method corresponding to the ``oco:hasAnnotation`` RDF predicate.
-
-        :return: A list containing the requested values if found, None otherwise
-        """
-        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_has_annotation, 'an')
-        result: List[ReferenceAnnotation] = []
-        for uri in uri_list:
-            result.append(self.g_set.add_an(self.resp_agent, self.source, uri))
-        return result
-
-    @accepts_only('an')
-    def has_annotation(self, an_res: ReferenceAnnotation) -> None:
-        """
-        Setter method corresponding to the ``oco:hasAnnotation`` RDF predicate.
-
-        `An annotation characterizing the related citation, in terms of its citation function (the
-        reason for that citation).`
-
-        :param an_res: The value that will be set as the object of the property related to this method
-        :type an_res: ReferenceAnnotation
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.g.add((self.res, GraphEntity.iri_has_annotation, an_res.res))
-
-    @accepts_only('an')
-    def remove_annotation(self, an_res: ReferenceAnnotation = None) -> None:
-        """
-        Remover method corresponding to the ``oco:hasAnnotation`` RDF predicate.
-
-        **WARNING: this is a non-functional property, hence, if the parameter
-        is None, any existing value will be removed!**
-
-        :param an_res: If not None, the specific object value that will be removed from the property
-         related to this method (defaults to None)
-        :type an_res: ReferenceAnnotation
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        if an_res is not None:
-            self.g.remove((self.res, GraphEntity.iri_has_annotation, an_res.res))
-        else:
-            self.g.remove((self.res, GraphEntity.iri_has_annotation, None))
-
-    # REFERENCES (BibliographicResource)
-    def get_referenced_br(self) -> Optional[BibliographicResource]:
-        """
-        Getter method corresponding to the ``biro:references`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_references, 'br')
-        if uri is not None:
-            return self.g_set.add_br(self.resp_agent, self.source, uri)
-
-    @accepts_only('br')
-    def references_br(self, br_res: BibliographicResource) -> None:
-        """
-        Setter method corresponding to the ``biro:references`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The bibliographic reference that cites this bibliographic resource.`
-
-        :param br_res: The value that will be set as the object of the property related to this method
-        :type br_res: BibliographicResource
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_referenced_br()
-        self.g.add((self.res, GraphEntity.iri_references, br_res.res))
-
-    def remove_referenced_br(self) -> None:
-        """
-        Remover method corresponding to the ``biro:references`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_references, None))
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+from oc_ocdm.decorators import accepts_only
+
+if TYPE_CHECKING:
+    from typing import Optional, List
+    from rdflib import URIRef
+    from oc_ocdm.graph.entities.bibliographic.reference_annotation import ReferenceAnnotation
+    from oc_ocdm.graph.entities.bibliographic.bibliographic_resource import BibliographicResource
+from oc_ocdm.graph.graph_entity import GraphEntity
+from oc_ocdm.graph.entities.bibliographic_entity import BibliographicEntity
+
+
+class BibliographicReference(BibliographicEntity):
+    """Bibliographic reference (short: be): the particular textual bibliographic reference,
+    usually occurring in the reference list (and denoted by one or more in-text reference
+    pointers within the text of a citing bibliographic resource), that references another
+    bibliographic resource.
+    """
+
+    @accepts_only('be')
+    def merge(self, other: BibliographicReference) -> None:
+        """
+        The merge operation allows combining two ``BibliographicReference`` entities into a single one,
+        by marking the second entity as to be deleted while also copying its data into the current
+        ``BibliographicReference``. Moreover, every triple from the containing ``GraphSet`` referring to the second
+        entity gets "redirected" to the current entity: **every other reference contained inside a
+        different source (e.g. a triplestore) must be manually handled by the user!**
+
+        In case of functional properties, values from the current entity get overwritten
+        by those coming from the second entity while, in all other cases, values from the
+        second entity are simply appended to those of the current entity. In this context,
+        ``rdfs:label`` is considered as a functional property, while ``rdf:type`` is not.
+
+        :param other: The entity which will be marked as to be deleted and whose properties will
+         be merged into the current entity.
+        :type other: BibliographicReference
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        super(BibliographicReference, self).merge(other)
+
+        content: Optional[str] = other.get_content()
+        if content is not None:
+            self.has_content(content)
+
+        annotations_list: List[ReferenceAnnotation] = other.get_annotations()
+        for cur_annotation in annotations_list:
+            self.has_annotation(cur_annotation)
+
+        referenced_br: Optional[BibliographicResource] = other.get_referenced_br()
+        if referenced_br is not None:
+            self.references_br(referenced_br)
+
+    # HAS BIBLIOGRAPHIC REFERENCE TEXT
+    def get_content(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``c4o:hasContent`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(GraphEntity.iri_has_content)
+
+    @accepts_only('literal')
+    def has_content(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``c4o:hasContent`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The literal text of a bibliographic reference occurring in the reference list (or
+        elsewhere) within a bibliographic resource, that references another bibliographic
+        resource. The reference text should be recorded “as given” in the citing bibliographic
+        resource, including any errors (e.g. mis-spellings of authors’ names, or changes from
+        “β” in the original published title to “beta” in the reference text) or omissions (e.g.
+        omission of the title of the referenced bibliographic resource, or omission of sixth and
+        subsequent authors’ names, as required by certain publishers), and in whatever format
+        it has been made available. For instance, the reference text can be either as plain text
+        or as a block of XML.`
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_content()
+        self._create_literal(GraphEntity.iri_has_content, string)
+
+    def remove_content(self) -> None:
+        """
+        Remover method corresponding to the ``c4o:hasContent`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_has_content, None))
+
+    # HAS ANNOTATION (ReferenceAnnotation)
+    def get_annotations(self) -> List[ReferenceAnnotation]:
+        """
+        Getter method corresponding to the ``oco:hasAnnotation`` RDF predicate.
+
+        :return: A list containing the requested values if found, None otherwise
+        """
+        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_has_annotation, 'an')
+        result: List[ReferenceAnnotation] = []
+        for uri in uri_list:
+            result.append(self.g_set.add_an(self.resp_agent, self.source, uri))
+        return result
+
+    @accepts_only('an')
+    def has_annotation(self, an_res: ReferenceAnnotation) -> None:
+        """
+        Setter method corresponding to the ``oco:hasAnnotation`` RDF predicate.
+
+        `An annotation characterizing the related citation, in terms of its citation function (the
+        reason for that citation).`
+
+        :param an_res: The value that will be set as the object of the property related to this method
+        :type an_res: ReferenceAnnotation
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.g.add((self.res, GraphEntity.iri_has_annotation, an_res.res))
+
+    @accepts_only('an')
+    def remove_annotation(self, an_res: ReferenceAnnotation = None) -> None:
+        """
+        Remover method corresponding to the ``oco:hasAnnotation`` RDF predicate.
+
+        **WARNING: this is a non-functional property, hence, if the parameter
+        is None, any existing value will be removed!**
+
+        :param an_res: If not None, the specific object value that will be removed from the property
+         related to this method (defaults to None)
+        :type an_res: ReferenceAnnotation
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        if an_res is not None:
+            self.g.remove((self.res, GraphEntity.iri_has_annotation, an_res.res))
+        else:
+            self.g.remove((self.res, GraphEntity.iri_has_annotation, None))
+
+    # REFERENCES (BibliographicResource)
+    def get_referenced_br(self) -> Optional[BibliographicResource]:
+        """
+        Getter method corresponding to the ``biro:references`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_references, 'br')
+        if uri is not None:
+            return self.g_set.add_br(self.resp_agent, self.source, uri)
+
+    @accepts_only('br')
+    def references_br(self, br_res: BibliographicResource) -> None:
+        """
+        Setter method corresponding to the ``biro:references`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The bibliographic reference that cites this bibliographic resource.`
+
+        :param br_res: The value that will be set as the object of the property related to this method
+        :type br_res: BibliographicResource
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_referenced_br()
+        self.g.add((self.res, GraphEntity.iri_references, br_res.res))
+
+    def remove_referenced_br(self) -> None:
+        """
+        Remover method corresponding to the ``biro:references`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_references, None))
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/graph/entities/bibliographic/bibliographic_resource.py` & `oc_ocdm-8.1.0/oc_ocdm/graph/entities/bibliographic/bibliographic_resource.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,1258 +1,1258 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-from oc_ocdm.decorators import accepts_only
-from oc_ocdm.support.support import get_datatype_from_iso_8601
-
-if TYPE_CHECKING:
-    from typing import Optional, List
-    from rdflib import URIRef
-    from oc_ocdm.graph.entities.bibliographic.bibliographic_reference import BibliographicReference
-    from oc_ocdm.graph.entities.bibliographic.agent_role import AgentRole
-    from oc_ocdm.graph.entities.bibliographic.discourse_element import DiscourseElement
-    from oc_ocdm.graph.entities.bibliographic.resource_embodiment import ResourceEmbodiment
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.graph.entities.bibliographic_entity import BibliographicEntity
-
-
-class BibliographicResource(BibliographicEntity):
-    """Bibliographic resource (short: br): a published bibliographic resource that cites/is
-       cited by another published bibliographic resource."""
-
-    @accepts_only('br')
-    def merge(self, other: BibliographicResource) -> None:
-        """
-        The merge operation allows combining two ``BibliographicResource`` entities into a single one,
-        by marking the second entity as to be deleted while also copying its data into the current
-        ``BibliographicResource``. Moreover, every triple from the containing ``GraphSet`` referring to the second
-        entity gets "redirected" to the current entity: **every other reference contained inside a
-        different source (e.g. a triplestore) must be manually handled by the user!**
-
-        In case of functional properties, values from the current entity get overwritten
-        by those coming from the second entity while, in all other cases, values from the
-        second entity are simply appended to those of the current entity. In this context,
-        ``rdfs:label`` is considered as a functional property, while ``rdf:type`` is not.
-
-        :param other: The entity which will be marked as to be deleted and whose properties will
-         be merged into the current entity.
-        :type other: BibliographicResource
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        super(BibliographicResource, self).merge(other)
-
-        title: Optional[str] = other.get_title()
-        if title is not None:
-            self.has_title(title)
-
-        subtitle: Optional[str] = other.get_subtitle()
-        if subtitle is not None:
-            self.has_subtitle(subtitle)
-
-        container: Optional[BibliographicResource] = other.get_is_part_of()
-        if container is not None:
-            self.is_part_of(container)
-
-        citations_list: List[BibliographicResource] = other.get_citations()
-        for cur_citation in citations_list:
-            self.has_citation(cur_citation)
-
-        pub_date: Optional[str] = other.get_pub_date()
-        if pub_date is not None:
-            self.has_pub_date(pub_date)
-
-        re_list: List[ResourceEmbodiment] = other.get_formats()
-        for cur_format in re_list:
-            self.has_format(cur_format)
-
-        number: Optional[str] = other.get_number()
-        if number is not None:
-            self.has_number(number)
-
-        edition: Optional[str] = other.get_edition()
-        if edition is not None:
-            self.has_edition(edition)
-
-        be_list: List[BibliographicReference] = other.get_contained_in_reference_lists()
-        for reference in be_list:
-            self.contains_in_reference_list(reference)
-
-        de_list: List[DiscourseElement] = other.get_contained_discourse_elements()
-        for discourse_element in de_list:
-            self.contains_discourse_element(discourse_element)
-
-        ar_list: List[AgentRole] = other.get_contributors()
-        for agent_role in ar_list:
-            self.has_contributor(agent_role)
-
-        related_doc_list: List[URIRef] = other.get_related_documents()
-        for doc in related_doc_list:
-            self.has_related_document(doc)
-
-    # HAS TITLE
-    def get_title(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``dcterms:title`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(GraphEntity.iri_title)
-
-    @accepts_only('literal')
-    def has_title(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``dcterms:title`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The title of the bibliographic resource.`
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_title()
-        self._create_literal(GraphEntity.iri_title, string)
-
-    def remove_title(self) -> None:
-        """
-        Remover method corresponding to the ``dcterms:title`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_title, None))
-
-    # HAS SUBTITLE
-    def get_subtitle(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``fabio:hasSubtitle`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(GraphEntity.iri_has_subtitle)
-
-    @accepts_only('literal')
-    def has_subtitle(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``fabio:hasSubtitle`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The subtitle of the bibliographic resource.`
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_subtitle()
-        self._create_literal(GraphEntity.iri_has_subtitle, string)
-
-    def remove_subtitle(self) -> None:
-        """
-        Remover method corresponding to the ``fabio:hasSubtitle`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_has_subtitle, None))
-
-    # IS PART OF (BibliographicResource)
-    def get_is_part_of(self) -> Optional[BibliographicResource]:
-        """
-        Getter method corresponding to the ``frbr:partOf`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_part_of, 'br')
-        if uri is not None:
-            return self.g_set.add_br(self.resp_agent, self.source, uri)
-
-    @accepts_only('br')
-    def is_part_of(self, br_res: BibliographicResource) -> None:
-        """
-        Setter method corresponding to the ``frbr:partOf`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The corpus identifier of the bibliographic resource (e.g. issue, volume, journal,
-        conference proceedings) that contains the subject bibliographic resource.`
-
-        :param br_res: The value that will be set as the object of the property related to this method
-        :type br_res: BibliographicResource
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_is_part_of()
-        self.g.add((self.res, GraphEntity.iri_part_of, br_res.res))
-
-    def remove_is_part_of(self) -> None:
-        """
-        Remover method corresponding to the ``frbr:partOf`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_part_of, None))
-
-    # CITES (BibliographicResource)
-    def get_citations(self) -> List[BibliographicResource]:
-        """
-        Getter method corresponding to the ``cito:cites`` RDF predicate.
-
-        :return: A list containing the requested values if found, None otherwise
-        """
-        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_cites, 'br')
-        result: List[BibliographicResource] = []
-        for uri in uri_list:
-            result.append(self.g_set.add_br(self.resp_agent, self.source, uri))
-        return result
-
-    @accepts_only('br')
-    def has_citation(self, br_res: BibliographicResource) -> None:
-        """
-        Setter method corresponding to the ``cito:cites`` RDF predicate.
-
-        `The corpus identifier of the bibliographic resource cited by the subject bibliographic
-        resource.`
-
-        :param br_res: The value that will be set as the object of the property related to this method
-        :type br_res: BibliographicResource
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.g.add((self.res, GraphEntity.iri_cites, br_res.res))
-
-    @accepts_only('br')
-    def remove_citation(self, br_res: BibliographicResource = None) -> None:
-        """
-        Remover method corresponding to the ``cito:cites`` RDF predicate.
-
-        **WARNING: this is a non-functional property, hence, if the parameter
-        is None, any existing value will be removed!**
-
-        :param br_res: If not None, the specific object value that will be removed from the property
-         related to this method (defaults to None)
-        :type br_res: BibliographicResource
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        if br_res is not None:
-            self.g.remove((self.res, GraphEntity.iri_cites, br_res.res))
-        else:
-            self.g.remove((self.res, GraphEntity.iri_cites, None))
-
-    # HAS PUBLICATION DATE
-    def get_pub_date(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``prism:publicationDate`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(GraphEntity.iri_has_publication_date)
-
-    @accepts_only('literal')
-    def has_pub_date(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``prism:publicationDate`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The date of publication of the bibliographic resource.`
-
-        :param string: The value that will be set as the object of the property related to this method. **It must
-          be a string compliant with the** ``ISO 8601`` **standard.**
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        cur_type, string = get_datatype_from_iso_8601(string)
-        if cur_type is not None and string is not None:
-            self.remove_pub_date()
-            self._create_literal(GraphEntity.iri_has_publication_date, string, cur_type, False)
-
-    def remove_pub_date(self) -> None:
-        """
-        Remover method corresponding to the ``prism:publicationDate`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_has_publication_date, None))
-
-    # IS EMBODIED AS (ResourceEmbodiment)
-    def get_formats(self) -> List[ResourceEmbodiment]:
-        """
-        Getter method corresponding to the ``frbr:embodiment`` RDF predicate.
-
-        :return: A list containing the requested values if found, None otherwise
-        """
-        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_embodiment, 're')
-        result: List[ResourceEmbodiment] = []
-        for uri in uri_list:
-            result.append(self.g_set.add_re(self.resp_agent, self.source, uri))
-        return result
-
-    @accepts_only('re')
-    def has_format(self, re_res: ResourceEmbodiment) -> None:
-        """
-        Setter method corresponding to the ``frbr:embodiment`` RDF predicate.
-
-        `The corpus identifier of the resource embodiment defining the format in which the
-        bibliographic resource has been embodied, which can be either print or digital.`
-
-        :param re_res: The value that will be set as the object of the property related to this method
-        :type re_res: ResourceEmbodiment
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.g.add((self.res, GraphEntity.iri_embodiment, re_res.res))
-
-    @accepts_only('re')
-    def remove_format(self, re_res: ResourceEmbodiment = None) -> None:
-        """
-        Remover method corresponding to the ``frbr:embodiment`` RDF predicate.
-
-        **WARNING: this is a non-functional property, hence, if the parameter
-        is None, any existing value will be removed!**
-
-        :param re_res: If not None, the specific object value that will be removed from the property
-         related to this method (defaults to None)
-        :type re_res: ResourceEmbodiment
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        if re_res is not None:
-            self.g.remove((self.res, GraphEntity.iri_embodiment, re_res.res))
-        else:
-            self.g.remove((self.res, GraphEntity.iri_embodiment, None))
-
-    # HAS NUMBER
-    def get_number(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``fabio:hasSequenceIdentifier`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(GraphEntity.iri_has_sequence_identifier)
-
-    @accepts_only('literal')
-    def has_number(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``fabio:hasSequenceIdentifier`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `A literal (for example a number or a letter) that identifies the sequence position of the
-        bibliographic resource as a particular item within a larger collection (e.g. an article
-        number within a journal issue, a volume number of a journal, a chapter number within
-        a book).`
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_number()
-        self._create_literal(GraphEntity.iri_has_sequence_identifier, string)
-
-    def remove_number(self) -> None:
-        """
-        Remover method corresponding to the ``fabio:hasSequenceIdentifier`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_has_sequence_identifier, None))
-
-    # HAS EDITION
-    def get_edition(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``prism:edition`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(GraphEntity.iri_has_edition)
-
-    @accepts_only('literal')
-    def has_edition(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``prism:edition`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `An identifier for one of several alternative editions of a particular bibliographic
-        resource.`
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_edition()
-        self._create_literal(GraphEntity.iri_has_edition, string)
-
-    def remove_edition(self) -> None:
-        """
-        Remover method corresponding to the ``prism:edition`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_has_edition, None))
-
-    # HAS PART (BibliographicReference)
-    def get_contained_in_reference_lists(self) -> List[BibliographicReference]:
-        """
-        Getter method corresponding to the ``frbr:part`` RDF predicate.
-
-        :return: A list containing the requested values if found, None otherwise
-        """
-        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_contains_reference, 'be')
-        result: List[BibliographicReference] = []
-        for uri in uri_list:
-            result.append(self.g_set.add_be(self.resp_agent, self.source, uri))
-        return result
-
-    @accepts_only('be')
-    def contains_in_reference_list(self, be_res: BibliographicReference) -> None:
-        """
-        Setter method corresponding to the ``frbr:part`` RDF predicate.
-
-        `A bibliographic reference within the bibliographic resource, or a discourse element
-        wherein the text of the bibliographic resources can be organized.`
-
-        :param be_res: The value that will be set as the object of the property related to this method
-        :type be_res: BibliographicReference
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.g.add((self.res, GraphEntity.iri_contains_reference, be_res.res))
-
-    @accepts_only('be')
-    def remove_contained_in_reference_list(self, be_res: BibliographicReference = None) -> None:
-        """
-        Remover method corresponding to the ``frbr:part`` RDF predicate.
-
-        **WARNING: this is a non-functional property, hence, if the parameter
-        is None, any existing value will be removed!**
-
-        :param be_res: If not None, the specific object value that will be removed from the property
-         related to this method (defaults to None)
-        :type be_res: BibliographicReference
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        if be_res is not None:
-            self.g.remove((self.res, GraphEntity.iri_contains_reference, be_res.res))
-        else:
-            self.g.remove((self.res, GraphEntity.iri_contains_reference, None))
-
-    # HAS PART (DiscourseElement)
-    def get_contained_discourse_elements(self) -> List[DiscourseElement]:
-        """
-        Getter method corresponding to the ``frbr:part`` RDF predicate.
-
-        :return: A list containing the requested values if found, None otherwise
-        """
-        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_contains_de, 'de')
-        result: List[DiscourseElement] = []
-        for uri in uri_list:
-            result.append(self.g_set.add_de(self.resp_agent, self.source, uri))
-        return result
-
-    @accepts_only('de')
-    def contains_discourse_element(self, de_res: DiscourseElement) -> None:
-        """
-        Setter method corresponding to the ``frbr:part`` RDF predicate.
-
-        `A bibliographic reference within the bibliographic resource, or a discourse element
-        wherein the text of the bibliographic resources can be organized.`
-
-        :param de_res: The value that will be set as the object of the property related to this method
-        :type de_res: DiscourseElement
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.g.add((self.res, GraphEntity.iri_contains_de, de_res.res))
-
-    @accepts_only('de')
-    def remove_contained_discourse_element(self, de_res: DiscourseElement = None) -> None:
-        """
-        Remover method corresponding to the ``frbr:part`` RDF predicate.
-
-        **WARNING: this is a non-functional property, hence, if the parameter
-        is None, any existing value will be removed!**
-
-        :param de_res: If not None, the specific object value that will be removed from the property
-         related to this method (defaults to None)
-        :type de_res: DiscourseElement
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        if de_res is not None:
-            self.g.remove((self.res, GraphEntity.iri_contains_de, de_res.res))
-        else:
-            self.g.remove((self.res, GraphEntity.iri_contains_de, None))
-
-    # HAS CONTRIBUTOR (AgentRole)
-    def get_contributors(self) -> List[AgentRole]:
-        """
-        Getter method corresponding to the ``pro:isDocumentContextFor`` RDF predicate.
-
-        :return: A list containing the requested values if found, None otherwise
-        """
-        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_is_document_context_for, 'ar')
-        result: List[AgentRole] = []
-        for uri in uri_list:
-            result.append(self.g_set.add_ar(self.resp_agent, self.source, uri))
-        return result
-
-    @accepts_only('ar')
-    def has_contributor(self, ar_res: AgentRole):
-        """
-        Setter method corresponding to the ``pro:isDocumentContextFor`` RDF predicate.
-
-        :param ar_res: The value that will be set as the object of the property related to this method
-        :type ar_res: AgentRole
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.g.add((self.res, GraphEntity.iri_is_document_context_for, ar_res.res))
-
-    @accepts_only('ar')
-    def remove_contributor(self, ar_res: AgentRole = None):
-        """
-        Remover method corresponding to the ``frbr:part`` RDF predicate.
-
-        **WARNING: this is a non-functional property, hence, if the parameter
-        is None, any existing value will be removed!**
-
-        :param ar_res: If not None, the specific object value that will be removed from the property
-         related to this method (defaults to None)
-        :type ar_res: AgentRole
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        if ar_res is not None:
-            self.g.remove((self.res, GraphEntity.iri_is_document_context_for, ar_res.res))
-        else:
-            self.g.remove((self.res, GraphEntity.iri_is_document_context_for, None))
-
-    # HAS RELATED DOCUMENT
-    def get_related_documents(self) -> List[URIRef]:
-        """
-        Getter method corresponding to the ``dcterms:relation`` RDF predicate.
-
-        :return: A list containing the requested values if found, None otherwise
-        """
-        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_relation)
-        return uri_list
-
-    @accepts_only('thing')
-    def has_related_document(self, thing_res: URIRef) -> None:
-        """
-        Setter method corresponding to the ``dcterms:relation`` RDF predicate.
-
-        `A document external to the Corpus, that is related to the bibliographic resource (such
-        as a version of the bibliographic resource – for example a preprint – recorded in an
-        external database).`
-
-        :param thing_res: The value that will be set as the object of the property related to this method
-        :type thing_res: URIRef
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.g.add((self.res, GraphEntity.iri_relation, thing_res))
-
-    @accepts_only('thing')
-    def remove_related_document(self, thing_res: URIRef = None) -> None:
-        """
-        Remover method corresponding to the ``dcterms:relation`` RDF predicate.
-
-        **WARNING: this is a non-functional property, hence, if the parameter
-        is None, any existing value will be removed!**
-
-        :param thing_res: If not None, the specific object value that will be removed from the property
-         related to this method (defaults to None)
-        :type thing_res: URIRef
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        if thing_res is not None:
-            self.g.remove((self.res, GraphEntity.iri_relation, thing_res))
-        else:
-            self.g.remove((self.res, GraphEntity.iri_relation, None))
-    
-    def create_abstract(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``doco:Abstract``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_abstract)
-
-    # HAS TYPE
-    def create_archival_document(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:ArchivalDocument``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_archival_document)
-
-    def create_audio_document(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:AudioDocument``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_audio_document)
-
-    def create_book(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:Book``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_book)
-
-    def create_book_chapter(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:BookChapter``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_book_chapter)
-
-    def create_book_part(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``doco:Part``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_part)
-
-    def create_book_section(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:ExpressionCollection``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_expression_collection)
-
-    def create_book_series(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:BookSeries``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_book_series)
-
-    def create_book_set(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:BookSet``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_book_set)
-
-    def create_book_track(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:Expression``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_expression)
-
-    def create_component(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:Expression``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_expression)
-
-    def create_computer_program(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:ComputerProgram``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_computer_program)
-
-    def create_data_management_plan(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:DataManagementPlan``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_data_management_plan)
-
-    def create_dataset(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:DataFile``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_data_file)
-
-    def create_dissertation(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:Thesis``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_thesis)
-
-    def create_edited_book(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:Book``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_book)
-
-    def create_editorial(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:Editorial``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_editorial)
-
-    def create_journal_article(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:JournalArticle``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_journal_article)
-
-    def create_journal_editorial(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:JournalEditorial``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_journal_editorial)
-
-    def create_issue(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:JournalIssue``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_journal_issue)
-
-    def create_volume(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:JournalVolume``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_journal_volume)
-
-    def create_journal(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:Journal``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_journal)
-
-    def create_monograph(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:Book``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_book)
-
-    def create_newspaper(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:Newspaper``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_newspaper)
-
-    def create_newspaper_article(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:NewspaperArticle``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_newspaper_article)
-
-    def create_newspaper_editorial(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:NewspaperEditorial``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_newspaper_editorial)
-    
-    def create_newspaper_issue(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:NewspaperIssue``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_newspaper_issue)
-
-    def create_peer_review(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fr:ReviewVersion``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_peer_review)
-
-    def create_preprint(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:Preprint``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_preprint)
-
-    def create_presentation(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:Presentation``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_presentation)
-
-    def create_proceedings_article(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:ProceedingsPaper``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_proceedings_paper)
-
-    def create_proceedings(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:AcademicProceedings``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_academic_proceedings)
-
-    def create_proceedings_series(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:Series``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_proceedings_series)
-
-    def create_reference_book(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:ReferenceBook``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_reference_book)
-
-    def create_reference_entry(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:ReferenceEntry``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_reference_entry)
-
-    def create_report_series(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:Series``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_series)
-
-    def create_report(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:ReportDocument``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_report_document)
-
-    def create_retraction_notice(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:RetractionNotice``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_retraction_notice)
-
-    def create_standard_series(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:Series``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_series)
-
-    def create_standard(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:SpecificationDocument``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_specification_document)
-
-    def create_series(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:Series``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_series)
-
-    def create_expression_collection(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:ExpressionCollection``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_expression_collection)
-
-    def create_web_content(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:WebContent``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_web_content)
-
-    def create_other(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:Expression``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of the bibliographic resource`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_expression)
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+from oc_ocdm.decorators import accepts_only
+from oc_ocdm.support.support import get_datatype_from_iso_8601
+
+if TYPE_CHECKING:
+    from typing import Optional, List
+    from rdflib import URIRef
+    from oc_ocdm.graph.entities.bibliographic.bibliographic_reference import BibliographicReference
+    from oc_ocdm.graph.entities.bibliographic.agent_role import AgentRole
+    from oc_ocdm.graph.entities.bibliographic.discourse_element import DiscourseElement
+    from oc_ocdm.graph.entities.bibliographic.resource_embodiment import ResourceEmbodiment
+from oc_ocdm.graph.graph_entity import GraphEntity
+from oc_ocdm.graph.entities.bibliographic_entity import BibliographicEntity
+
+
+class BibliographicResource(BibliographicEntity):
+    """Bibliographic resource (short: br): a published bibliographic resource that cites/is
+       cited by another published bibliographic resource."""
+
+    @accepts_only('br')
+    def merge(self, other: BibliographicResource) -> None:
+        """
+        The merge operation allows combining two ``BibliographicResource`` entities into a single one,
+        by marking the second entity as to be deleted while also copying its data into the current
+        ``BibliographicResource``. Moreover, every triple from the containing ``GraphSet`` referring to the second
+        entity gets "redirected" to the current entity: **every other reference contained inside a
+        different source (e.g. a triplestore) must be manually handled by the user!**
+
+        In case of functional properties, values from the current entity get overwritten
+        by those coming from the second entity while, in all other cases, values from the
+        second entity are simply appended to those of the current entity. In this context,
+        ``rdfs:label`` is considered as a functional property, while ``rdf:type`` is not.
+
+        :param other: The entity which will be marked as to be deleted and whose properties will
+         be merged into the current entity.
+        :type other: BibliographicResource
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        super(BibliographicResource, self).merge(other)
+
+        title: Optional[str] = other.get_title()
+        if title is not None:
+            self.has_title(title)
+
+        subtitle: Optional[str] = other.get_subtitle()
+        if subtitle is not None:
+            self.has_subtitle(subtitle)
+
+        container: Optional[BibliographicResource] = other.get_is_part_of()
+        if container is not None:
+            self.is_part_of(container)
+
+        citations_list: List[BibliographicResource] = other.get_citations()
+        for cur_citation in citations_list:
+            self.has_citation(cur_citation)
+
+        pub_date: Optional[str] = other.get_pub_date()
+        if pub_date is not None:
+            self.has_pub_date(pub_date)
+
+        re_list: List[ResourceEmbodiment] = other.get_formats()
+        for cur_format in re_list:
+            self.has_format(cur_format)
+
+        number: Optional[str] = other.get_number()
+        if number is not None:
+            self.has_number(number)
+
+        edition: Optional[str] = other.get_edition()
+        if edition is not None:
+            self.has_edition(edition)
+
+        be_list: List[BibliographicReference] = other.get_contained_in_reference_lists()
+        for reference in be_list:
+            self.contains_in_reference_list(reference)
+
+        de_list: List[DiscourseElement] = other.get_contained_discourse_elements()
+        for discourse_element in de_list:
+            self.contains_discourse_element(discourse_element)
+
+        ar_list: List[AgentRole] = other.get_contributors()
+        for agent_role in ar_list:
+            self.has_contributor(agent_role)
+
+        related_doc_list: List[URIRef] = other.get_related_documents()
+        for doc in related_doc_list:
+            self.has_related_document(doc)
+
+    # HAS TITLE
+    def get_title(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``dcterms:title`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(GraphEntity.iri_title)
+
+    @accepts_only('literal')
+    def has_title(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``dcterms:title`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The title of the bibliographic resource.`
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_title()
+        self._create_literal(GraphEntity.iri_title, string)
+
+    def remove_title(self) -> None:
+        """
+        Remover method corresponding to the ``dcterms:title`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_title, None))
+
+    # HAS SUBTITLE
+    def get_subtitle(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``fabio:hasSubtitle`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(GraphEntity.iri_has_subtitle)
+
+    @accepts_only('literal')
+    def has_subtitle(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``fabio:hasSubtitle`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The subtitle of the bibliographic resource.`
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_subtitle()
+        self._create_literal(GraphEntity.iri_has_subtitle, string)
+
+    def remove_subtitle(self) -> None:
+        """
+        Remover method corresponding to the ``fabio:hasSubtitle`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_has_subtitle, None))
+
+    # IS PART OF (BibliographicResource)
+    def get_is_part_of(self) -> Optional[BibliographicResource]:
+        """
+        Getter method corresponding to the ``frbr:partOf`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_part_of, 'br')
+        if uri is not None:
+            return self.g_set.add_br(self.resp_agent, self.source, uri)
+
+    @accepts_only('br')
+    def is_part_of(self, br_res: BibliographicResource) -> None:
+        """
+        Setter method corresponding to the ``frbr:partOf`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The corpus identifier of the bibliographic resource (e.g. issue, volume, journal,
+        conference proceedings) that contains the subject bibliographic resource.`
+
+        :param br_res: The value that will be set as the object of the property related to this method
+        :type br_res: BibliographicResource
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_is_part_of()
+        self.g.add((self.res, GraphEntity.iri_part_of, br_res.res))
+
+    def remove_is_part_of(self) -> None:
+        """
+        Remover method corresponding to the ``frbr:partOf`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_part_of, None))
+
+    # CITES (BibliographicResource)
+    def get_citations(self) -> List[BibliographicResource]:
+        """
+        Getter method corresponding to the ``cito:cites`` RDF predicate.
+
+        :return: A list containing the requested values if found, None otherwise
+        """
+        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_cites, 'br')
+        result: List[BibliographicResource] = []
+        for uri in uri_list:
+            result.append(self.g_set.add_br(self.resp_agent, self.source, uri))
+        return result
+
+    @accepts_only('br')
+    def has_citation(self, br_res: BibliographicResource) -> None:
+        """
+        Setter method corresponding to the ``cito:cites`` RDF predicate.
+
+        `The corpus identifier of the bibliographic resource cited by the subject bibliographic
+        resource.`
+
+        :param br_res: The value that will be set as the object of the property related to this method
+        :type br_res: BibliographicResource
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.g.add((self.res, GraphEntity.iri_cites, br_res.res))
+
+    @accepts_only('br')
+    def remove_citation(self, br_res: BibliographicResource = None) -> None:
+        """
+        Remover method corresponding to the ``cito:cites`` RDF predicate.
+
+        **WARNING: this is a non-functional property, hence, if the parameter
+        is None, any existing value will be removed!**
+
+        :param br_res: If not None, the specific object value that will be removed from the property
+         related to this method (defaults to None)
+        :type br_res: BibliographicResource
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        if br_res is not None:
+            self.g.remove((self.res, GraphEntity.iri_cites, br_res.res))
+        else:
+            self.g.remove((self.res, GraphEntity.iri_cites, None))
+
+    # HAS PUBLICATION DATE
+    def get_pub_date(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``prism:publicationDate`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(GraphEntity.iri_has_publication_date)
+
+    @accepts_only('literal')
+    def has_pub_date(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``prism:publicationDate`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The date of publication of the bibliographic resource.`
+
+        :param string: The value that will be set as the object of the property related to this method. **It must
+          be a string compliant with the** ``ISO 8601`` **standard.**
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        cur_type, string = get_datatype_from_iso_8601(string)
+        if cur_type is not None and string is not None:
+            self.remove_pub_date()
+            self._create_literal(GraphEntity.iri_has_publication_date, string, cur_type, False)
+
+    def remove_pub_date(self) -> None:
+        """
+        Remover method corresponding to the ``prism:publicationDate`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_has_publication_date, None))
+
+    # IS EMBODIED AS (ResourceEmbodiment)
+    def get_formats(self) -> List[ResourceEmbodiment]:
+        """
+        Getter method corresponding to the ``frbr:embodiment`` RDF predicate.
+
+        :return: A list containing the requested values if found, None otherwise
+        """
+        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_embodiment, 're')
+        result: List[ResourceEmbodiment] = []
+        for uri in uri_list:
+            result.append(self.g_set.add_re(self.resp_agent, self.source, uri))
+        return result
+
+    @accepts_only('re')
+    def has_format(self, re_res: ResourceEmbodiment) -> None:
+        """
+        Setter method corresponding to the ``frbr:embodiment`` RDF predicate.
+
+        `The corpus identifier of the resource embodiment defining the format in which the
+        bibliographic resource has been embodied, which can be either print or digital.`
+
+        :param re_res: The value that will be set as the object of the property related to this method
+        :type re_res: ResourceEmbodiment
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.g.add((self.res, GraphEntity.iri_embodiment, re_res.res))
+
+    @accepts_only('re')
+    def remove_format(self, re_res: ResourceEmbodiment = None) -> None:
+        """
+        Remover method corresponding to the ``frbr:embodiment`` RDF predicate.
+
+        **WARNING: this is a non-functional property, hence, if the parameter
+        is None, any existing value will be removed!**
+
+        :param re_res: If not None, the specific object value that will be removed from the property
+         related to this method (defaults to None)
+        :type re_res: ResourceEmbodiment
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        if re_res is not None:
+            self.g.remove((self.res, GraphEntity.iri_embodiment, re_res.res))
+        else:
+            self.g.remove((self.res, GraphEntity.iri_embodiment, None))
+
+    # HAS NUMBER
+    def get_number(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``fabio:hasSequenceIdentifier`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(GraphEntity.iri_has_sequence_identifier)
+
+    @accepts_only('literal')
+    def has_number(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``fabio:hasSequenceIdentifier`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `A literal (for example a number or a letter) that identifies the sequence position of the
+        bibliographic resource as a particular item within a larger collection (e.g. an article
+        number within a journal issue, a volume number of a journal, a chapter number within
+        a book).`
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_number()
+        self._create_literal(GraphEntity.iri_has_sequence_identifier, string)
+
+    def remove_number(self) -> None:
+        """
+        Remover method corresponding to the ``fabio:hasSequenceIdentifier`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_has_sequence_identifier, None))
+
+    # HAS EDITION
+    def get_edition(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``prism:edition`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(GraphEntity.iri_has_edition)
+
+    @accepts_only('literal')
+    def has_edition(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``prism:edition`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `An identifier for one of several alternative editions of a particular bibliographic
+        resource.`
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_edition()
+        self._create_literal(GraphEntity.iri_has_edition, string)
+
+    def remove_edition(self) -> None:
+        """
+        Remover method corresponding to the ``prism:edition`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_has_edition, None))
+
+    # HAS PART (BibliographicReference)
+    def get_contained_in_reference_lists(self) -> List[BibliographicReference]:
+        """
+        Getter method corresponding to the ``frbr:part`` RDF predicate.
+
+        :return: A list containing the requested values if found, None otherwise
+        """
+        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_contains_reference, 'be')
+        result: List[BibliographicReference] = []
+        for uri in uri_list:
+            result.append(self.g_set.add_be(self.resp_agent, self.source, uri))
+        return result
+
+    @accepts_only('be')
+    def contains_in_reference_list(self, be_res: BibliographicReference) -> None:
+        """
+        Setter method corresponding to the ``frbr:part`` RDF predicate.
+
+        `A bibliographic reference within the bibliographic resource, or a discourse element
+        wherein the text of the bibliographic resources can be organized.`
+
+        :param be_res: The value that will be set as the object of the property related to this method
+        :type be_res: BibliographicReference
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.g.add((self.res, GraphEntity.iri_contains_reference, be_res.res))
+
+    @accepts_only('be')
+    def remove_contained_in_reference_list(self, be_res: BibliographicReference = None) -> None:
+        """
+        Remover method corresponding to the ``frbr:part`` RDF predicate.
+
+        **WARNING: this is a non-functional property, hence, if the parameter
+        is None, any existing value will be removed!**
+
+        :param be_res: If not None, the specific object value that will be removed from the property
+         related to this method (defaults to None)
+        :type be_res: BibliographicReference
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        if be_res is not None:
+            self.g.remove((self.res, GraphEntity.iri_contains_reference, be_res.res))
+        else:
+            self.g.remove((self.res, GraphEntity.iri_contains_reference, None))
+
+    # HAS PART (DiscourseElement)
+    def get_contained_discourse_elements(self) -> List[DiscourseElement]:
+        """
+        Getter method corresponding to the ``frbr:part`` RDF predicate.
+
+        :return: A list containing the requested values if found, None otherwise
+        """
+        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_contains_de, 'de')
+        result: List[DiscourseElement] = []
+        for uri in uri_list:
+            result.append(self.g_set.add_de(self.resp_agent, self.source, uri))
+        return result
+
+    @accepts_only('de')
+    def contains_discourse_element(self, de_res: DiscourseElement) -> None:
+        """
+        Setter method corresponding to the ``frbr:part`` RDF predicate.
+
+        `A bibliographic reference within the bibliographic resource, or a discourse element
+        wherein the text of the bibliographic resources can be organized.`
+
+        :param de_res: The value that will be set as the object of the property related to this method
+        :type de_res: DiscourseElement
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.g.add((self.res, GraphEntity.iri_contains_de, de_res.res))
+
+    @accepts_only('de')
+    def remove_contained_discourse_element(self, de_res: DiscourseElement = None) -> None:
+        """
+        Remover method corresponding to the ``frbr:part`` RDF predicate.
+
+        **WARNING: this is a non-functional property, hence, if the parameter
+        is None, any existing value will be removed!**
+
+        :param de_res: If not None, the specific object value that will be removed from the property
+         related to this method (defaults to None)
+        :type de_res: DiscourseElement
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        if de_res is not None:
+            self.g.remove((self.res, GraphEntity.iri_contains_de, de_res.res))
+        else:
+            self.g.remove((self.res, GraphEntity.iri_contains_de, None))
+
+    # HAS CONTRIBUTOR (AgentRole)
+    def get_contributors(self) -> List[AgentRole]:
+        """
+        Getter method corresponding to the ``pro:isDocumentContextFor`` RDF predicate.
+
+        :return: A list containing the requested values if found, None otherwise
+        """
+        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_is_document_context_for, 'ar')
+        result: List[AgentRole] = []
+        for uri in uri_list:
+            result.append(self.g_set.add_ar(self.resp_agent, self.source, uri))
+        return result
+
+    @accepts_only('ar')
+    def has_contributor(self, ar_res: AgentRole):
+        """
+        Setter method corresponding to the ``pro:isDocumentContextFor`` RDF predicate.
+
+        :param ar_res: The value that will be set as the object of the property related to this method
+        :type ar_res: AgentRole
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.g.add((self.res, GraphEntity.iri_is_document_context_for, ar_res.res))
+
+    @accepts_only('ar')
+    def remove_contributor(self, ar_res: AgentRole = None):
+        """
+        Remover method corresponding to the ``frbr:part`` RDF predicate.
+
+        **WARNING: this is a non-functional property, hence, if the parameter
+        is None, any existing value will be removed!**
+
+        :param ar_res: If not None, the specific object value that will be removed from the property
+         related to this method (defaults to None)
+        :type ar_res: AgentRole
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        if ar_res is not None:
+            self.g.remove((self.res, GraphEntity.iri_is_document_context_for, ar_res.res))
+        else:
+            self.g.remove((self.res, GraphEntity.iri_is_document_context_for, None))
+
+    # HAS RELATED DOCUMENT
+    def get_related_documents(self) -> List[URIRef]:
+        """
+        Getter method corresponding to the ``dcterms:relation`` RDF predicate.
+
+        :return: A list containing the requested values if found, None otherwise
+        """
+        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_relation)
+        return uri_list
+
+    @accepts_only('thing')
+    def has_related_document(self, thing_res: URIRef) -> None:
+        """
+        Setter method corresponding to the ``dcterms:relation`` RDF predicate.
+
+        `A document external to the Corpus, that is related to the bibliographic resource (such
+        as a version of the bibliographic resource – for example a preprint – recorded in an
+        external database).`
+
+        :param thing_res: The value that will be set as the object of the property related to this method
+        :type thing_res: URIRef
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.g.add((self.res, GraphEntity.iri_relation, thing_res))
+
+    @accepts_only('thing')
+    def remove_related_document(self, thing_res: URIRef = None) -> None:
+        """
+        Remover method corresponding to the ``dcterms:relation`` RDF predicate.
+
+        **WARNING: this is a non-functional property, hence, if the parameter
+        is None, any existing value will be removed!**
+
+        :param thing_res: If not None, the specific object value that will be removed from the property
+         related to this method (defaults to None)
+        :type thing_res: URIRef
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        if thing_res is not None:
+            self.g.remove((self.res, GraphEntity.iri_relation, thing_res))
+        else:
+            self.g.remove((self.res, GraphEntity.iri_relation, None))
+    
+    def create_abstract(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``doco:Abstract``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_abstract)
+
+    # HAS TYPE
+    def create_archival_document(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:ArchivalDocument``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_archival_document)
+
+    def create_audio_document(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:AudioDocument``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_audio_document)
+
+    def create_book(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:Book``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_book)
+
+    def create_book_chapter(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:BookChapter``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_book_chapter)
+
+    def create_book_part(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``doco:Part``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_part)
+
+    def create_book_section(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:ExpressionCollection``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_expression_collection)
+
+    def create_book_series(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:BookSeries``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_book_series)
+
+    def create_book_set(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:BookSet``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_book_set)
+
+    def create_book_track(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:Expression``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_expression)
+
+    def create_component(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:Expression``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_expression)
+
+    def create_computer_program(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:ComputerProgram``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_computer_program)
+
+    def create_data_management_plan(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:DataManagementPlan``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_data_management_plan)
+
+    def create_dataset(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:DataFile``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_data_file)
+
+    def create_dissertation(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:Thesis``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_thesis)
+
+    def create_edited_book(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:Book``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_book)
+
+    def create_editorial(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:Editorial``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_editorial)
+
+    def create_journal_article(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:JournalArticle``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_journal_article)
+
+    def create_journal_editorial(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:JournalEditorial``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_journal_editorial)
+
+    def create_issue(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:JournalIssue``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_journal_issue)
+
+    def create_volume(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:JournalVolume``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_journal_volume)
+
+    def create_journal(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:Journal``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_journal)
+
+    def create_monograph(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:Book``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_book)
+
+    def create_newspaper(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:Newspaper``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_newspaper)
+
+    def create_newspaper_article(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:NewspaperArticle``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_newspaper_article)
+
+    def create_newspaper_editorial(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:NewspaperEditorial``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_newspaper_editorial)
+    
+    def create_newspaper_issue(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:NewspaperIssue``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_newspaper_issue)
+
+    def create_peer_review(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fr:ReviewVersion``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_peer_review)
+
+    def create_preprint(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:Preprint``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_preprint)
+
+    def create_presentation(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:Presentation``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_presentation)
+
+    def create_proceedings_article(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:ProceedingsPaper``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_proceedings_paper)
+
+    def create_proceedings(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:AcademicProceedings``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_academic_proceedings)
+
+    def create_proceedings_series(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:Series``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_proceedings_series)
+
+    def create_reference_book(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:ReferenceBook``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_reference_book)
+
+    def create_reference_entry(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:ReferenceEntry``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_reference_entry)
+
+    def create_report_series(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:Series``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_series)
+
+    def create_report(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:ReportDocument``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_report_document)
+
+    def create_retraction_notice(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:RetractionNotice``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_retraction_notice)
+
+    def create_standard_series(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:Series``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_series)
+
+    def create_standard(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:SpecificationDocument``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_specification_document)
+
+    def create_series(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:Series``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_series)
+
+    def create_expression_collection(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:ExpressionCollection``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_expression_collection)
+
+    def create_web_content(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:WebContent``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_web_content)
+
+    def create_other(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:Expression``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of the bibliographic resource`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_expression)
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/graph/entities/bibliographic/citation.py` & `oc_ocdm-8.1.0/oc_ocdm/graph/entities/bibliographic/citation.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,371 +1,371 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-from rdflib import XSD
-
-from oc_ocdm.decorators import accepts_only
-from oc_ocdm.support.support import get_datatype_from_iso_8601
-
-if TYPE_CHECKING:
-    from typing import Optional
-    from rdflib import URIRef
-    from oc_ocdm.graph.entities.bibliographic.bibliographic_resource import BibliographicResource
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.graph.entities.bibliographic_entity import BibliographicEntity
-
-
-class Citation(BibliographicEntity):
-    """Citation (short: ci): a permanent conceptual directional link from the citing
-       bibliographic resource to a cited bibliographic resource. A citation is created by the
-       performative act of an author citing a published work that is relevant to the current
-       work by using a particular textual device. Typically, citations are made by including a
-       bibliographic reference in the reference list of the citing work and by denoting such a
-       bibliographic reference using one or more in-text reference pointers (e.g. '[1]'), or by
-       the inclusion within the citing work of a link, in the form of an HTTP Uniform Resource
-       Locator (URL), to the cited bibliographic resource on the World Wide Web."""
-
-    @accepts_only('ci')
-    def merge(self, other: Citation) -> None:
-        """
-        The merge operation allows combining two ``Citation`` entities into a single one,
-        by marking the second entity as to be deleted while also copying its data into the current
-        ``Citation``. Moreover, every triple from the containing ``GraphSet`` referring to the second
-        entity gets "redirected" to the current entity: **every other reference contained inside a
-        different source (e.g. a triplestore) must be manually handled by the user!**
-
-        In case of functional properties, values from the current entity get overwritten
-        by those coming from the second entity while, in all other cases, values from the
-        second entity are simply appended to those of the current entity. In this context,
-        ``rdfs:label`` is considered as a functional property, while ``rdf:type`` is not.
-
-        :param other: The entity which will be marked as to be deleted and whose properties will
-         be merged into the current entity.
-        :type other: Citation
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        super(Citation, self).merge(other)
-
-        citing_br: Optional[BibliographicResource] = other.get_citing_entity()
-        if citing_br is not None:
-            self.has_citing_entity(citing_br)
-
-        cited_br: Optional[BibliographicResource] = other.get_cited_entity()
-        if cited_br is not None:
-            self.has_cited_entity(cited_br)
-
-        creation_date: Optional[str] = other.get_citation_creation_date()
-        if creation_date is not None:
-            self.has_citation_creation_date(creation_date)
-
-        time_span: Optional[str] = other.get_citation_time_span()
-        if time_span is not None:
-            self.has_citation_time_span(time_span)
-
-        characterization: Optional[URIRef] = other.get_citation_characterization()
-        if characterization is not None:
-            self.has_citation_characterization(characterization)
-
-    # HAS CITING DOCUMENT (BibliographicResource)
-    def get_citing_entity(self) -> Optional[BibliographicResource]:
-        """
-        Getter method corresponding to the ``cito:hasCitingEntity`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_has_citing_entity, 'br')
-        if uri is not None:
-            return self.g_set.add_br(self.resp_agent, self.source, uri)
-
-    @accepts_only('br')
-    def has_citing_entity(self, citing_res: BibliographicResource) -> None:
-        """
-        Setter method corresponding to the ``cito:hasCitingEntity`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The bibliographic resource which acts as the source for the citation.`
-
-        :param citing_res: The value that will be set as the object of the property related to this method
-        :type citing_res: BibliographicResource
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_citing_entity()
-        self.g.add((self.res, GraphEntity.iri_has_citing_entity, citing_res.res))
-
-    def remove_citing_entity(self) -> None:
-        """
-        Remover method corresponding to the ``cito:hasCitingEntity`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_has_citing_entity, None))
-
-    # HAS CITED DOCUMENT (BibliographicResource)
-    def get_cited_entity(self) -> Optional[BibliographicResource]:
-        """
-        Getter method corresponding to the ``cito:hasCitedEntity`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_has_cited_entity, 'br')
-        if uri is not None:
-            return self.g_set.add_br(self.resp_agent, self.source, uri)
-
-    @accepts_only('br')
-    def has_cited_entity(self, cited_res: BibliographicResource) -> None:
-        """
-        Setter method corresponding to the ``cito:hasCitedEntity`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The bibliographic resource which acts as the target for the citation.`
-
-        :param cited_res: The value that will be set as the object of the property related to this method
-        :type cited_res: BibliographicResource
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_cited_entity()
-        self.g.add((self.res, GraphEntity.iri_has_cited_entity, cited_res.res))
-
-    def remove_cited_entity(self) -> None:
-        """
-        Remover method corresponding to the ``c4o:hasCitedEntity`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_has_cited_entity, None))
-
-    # HAS CITATION CREATION DATE
-    def get_citation_creation_date(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``cito:hasCitationCreationDate`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(GraphEntity.iri_has_citation_creation_date)
-
-    @accepts_only('literal')
-    def has_citation_creation_date(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``cito:hasCitationCreationDate`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The date on which the citation was created. This has the same numerical value
-        as the publication date of the citing bibliographic resource, but is a property
-        of the citation itself. When combined with the citation time span, it permits
-        that citation to be located in history.`
-
-        :param string: The value that will be set as the object of the property related to this method. **It must
-          be a string compliant with the** ``ISO 8601`` **standard.**
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        cur_type, string = get_datatype_from_iso_8601(string)
-        if cur_type is not None and string is not None:
-            self.remove_citation_creation_date()
-            self._create_literal(GraphEntity.iri_has_citation_creation_date, string, cur_type, False)
-
-    def remove_citation_creation_date(self) -> None:
-        """
-        Remover method corresponding to the ``c4o:hasCitationCreationDate`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_has_citation_creation_date, None))
-
-    # HAS CITATION TIME SPAN
-    def get_citation_time_span(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``cito:hasCitationTimeSpan`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(GraphEntity.iri_has_citation_time_span)
-
-    @accepts_only('literal')
-    def has_citation_time_span(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``cito:hasCitationTimeSpan`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The date interval between the publication date of the cited bibliographic resource and
-        the publication date of the citing bibliographic resource.`
-
-        :param string: The value that will be set as the object of the property related to this method. **It must
-          be a string compliant with the** ``xsd:duration`` **datatype.**
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_citation_time_span()
-        self._create_literal(GraphEntity.iri_has_citation_time_span, string, XSD.duration, False)
-
-    def remove_citation_time_span(self) -> None:
-        """
-        Remover method corresponding to the ``c4o:hasCitationTimeSpan`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_has_citation_time_span, None))
-
-    # HAS CITATION CHARACTERIZATION
-    def get_citation_characterization(self) -> Optional[URIRef]:
-        """
-        Getter method corresponding to the ``cito:hasCitationCharacterisation`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_citation_characterisation)
-        return uri
-
-    @accepts_only('thing')
-    def has_citation_characterization(self, thing_res: URIRef) -> None:
-        """
-        Setter method corresponding to the ``cito:hasCitationCharacterisation`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The citation function characterizing the purpose of the citation.`
-
-        :param thing_res: The value that will be set as the object of the property related to this method
-        :type thing_res: URIRef
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_citation_characterization()
-        self.g.add((self.res, GraphEntity.iri_citation_characterisation, thing_res))
-
-    def remove_citation_characterization(self) -> None:
-        """
-        Remover method corresponding to the ``c4o:hasCitationCharacterisation`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_citation_characterisation, None))
-
-    # HAS TYPE
-    def create_self_citation(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``cito:SelfCitation``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_self_citation)
-
-    def create_affiliation_self_citation(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``cito:AffiliationSelfCitation``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_affiliation_self_citation)
-
-    def create_author_network_self_citation(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``cito:AuthorNetworkSelfCitation``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_author_network_self_citation)
-
-    def create_author_self_citation(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``cito:AuthorSelfCitation``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_author_self_citation)
-
-    def create_funder_self_citation(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``cito:FunderSelfCitation``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_funder_self_citation)
-
-    def create_journal_self_citation(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``cito:JournalSelfCitation``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_journal_self_citation)
-
-    def create_journal_cartel_citation(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``cito:JournalCartelCitation``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_journal_cartel_citation)
-
-    def create_distant_citation(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``cito:DistantCitation``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_distant_citation)
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+from rdflib import XSD
+
+from oc_ocdm.decorators import accepts_only
+from oc_ocdm.support.support import get_datatype_from_iso_8601
+
+if TYPE_CHECKING:
+    from typing import Optional
+    from rdflib import URIRef
+    from oc_ocdm.graph.entities.bibliographic.bibliographic_resource import BibliographicResource
+from oc_ocdm.graph.graph_entity import GraphEntity
+from oc_ocdm.graph.entities.bibliographic_entity import BibliographicEntity
+
+
+class Citation(BibliographicEntity):
+    """Citation (short: ci): a permanent conceptual directional link from the citing
+       bibliographic resource to a cited bibliographic resource. A citation is created by the
+       performative act of an author citing a published work that is relevant to the current
+       work by using a particular textual device. Typically, citations are made by including a
+       bibliographic reference in the reference list of the citing work and by denoting such a
+       bibliographic reference using one or more in-text reference pointers (e.g. '[1]'), or by
+       the inclusion within the citing work of a link, in the form of an HTTP Uniform Resource
+       Locator (URL), to the cited bibliographic resource on the World Wide Web."""
+
+    @accepts_only('ci')
+    def merge(self, other: Citation) -> None:
+        """
+        The merge operation allows combining two ``Citation`` entities into a single one,
+        by marking the second entity as to be deleted while also copying its data into the current
+        ``Citation``. Moreover, every triple from the containing ``GraphSet`` referring to the second
+        entity gets "redirected" to the current entity: **every other reference contained inside a
+        different source (e.g. a triplestore) must be manually handled by the user!**
+
+        In case of functional properties, values from the current entity get overwritten
+        by those coming from the second entity while, in all other cases, values from the
+        second entity are simply appended to those of the current entity. In this context,
+        ``rdfs:label`` is considered as a functional property, while ``rdf:type`` is not.
+
+        :param other: The entity which will be marked as to be deleted and whose properties will
+         be merged into the current entity.
+        :type other: Citation
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        super(Citation, self).merge(other)
+
+        citing_br: Optional[BibliographicResource] = other.get_citing_entity()
+        if citing_br is not None:
+            self.has_citing_entity(citing_br)
+
+        cited_br: Optional[BibliographicResource] = other.get_cited_entity()
+        if cited_br is not None:
+            self.has_cited_entity(cited_br)
+
+        creation_date: Optional[str] = other.get_citation_creation_date()
+        if creation_date is not None:
+            self.has_citation_creation_date(creation_date)
+
+        time_span: Optional[str] = other.get_citation_time_span()
+        if time_span is not None:
+            self.has_citation_time_span(time_span)
+
+        characterization: Optional[URIRef] = other.get_citation_characterization()
+        if characterization is not None:
+            self.has_citation_characterization(characterization)
+
+    # HAS CITING DOCUMENT (BibliographicResource)
+    def get_citing_entity(self) -> Optional[BibliographicResource]:
+        """
+        Getter method corresponding to the ``cito:hasCitingEntity`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_has_citing_entity, 'br')
+        if uri is not None:
+            return self.g_set.add_br(self.resp_agent, self.source, uri)
+
+    @accepts_only('br')
+    def has_citing_entity(self, citing_res: BibliographicResource) -> None:
+        """
+        Setter method corresponding to the ``cito:hasCitingEntity`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The bibliographic resource which acts as the source for the citation.`
+
+        :param citing_res: The value that will be set as the object of the property related to this method
+        :type citing_res: BibliographicResource
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_citing_entity()
+        self.g.add((self.res, GraphEntity.iri_has_citing_entity, citing_res.res))
+
+    def remove_citing_entity(self) -> None:
+        """
+        Remover method corresponding to the ``cito:hasCitingEntity`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_has_citing_entity, None))
+
+    # HAS CITED DOCUMENT (BibliographicResource)
+    def get_cited_entity(self) -> Optional[BibliographicResource]:
+        """
+        Getter method corresponding to the ``cito:hasCitedEntity`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_has_cited_entity, 'br')
+        if uri is not None:
+            return self.g_set.add_br(self.resp_agent, self.source, uri)
+
+    @accepts_only('br')
+    def has_cited_entity(self, cited_res: BibliographicResource) -> None:
+        """
+        Setter method corresponding to the ``cito:hasCitedEntity`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The bibliographic resource which acts as the target for the citation.`
+
+        :param cited_res: The value that will be set as the object of the property related to this method
+        :type cited_res: BibliographicResource
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_cited_entity()
+        self.g.add((self.res, GraphEntity.iri_has_cited_entity, cited_res.res))
+
+    def remove_cited_entity(self) -> None:
+        """
+        Remover method corresponding to the ``c4o:hasCitedEntity`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_has_cited_entity, None))
+
+    # HAS CITATION CREATION DATE
+    def get_citation_creation_date(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``cito:hasCitationCreationDate`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(GraphEntity.iri_has_citation_creation_date)
+
+    @accepts_only('literal')
+    def has_citation_creation_date(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``cito:hasCitationCreationDate`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The date on which the citation was created. This has the same numerical value
+        as the publication date of the citing bibliographic resource, but is a property
+        of the citation itself. When combined with the citation time span, it permits
+        that citation to be located in history.`
+
+        :param string: The value that will be set as the object of the property related to this method. **It must
+          be a string compliant with the** ``ISO 8601`` **standard.**
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        cur_type, string = get_datatype_from_iso_8601(string)
+        if cur_type is not None and string is not None:
+            self.remove_citation_creation_date()
+            self._create_literal(GraphEntity.iri_has_citation_creation_date, string, cur_type, False)
+
+    def remove_citation_creation_date(self) -> None:
+        """
+        Remover method corresponding to the ``c4o:hasCitationCreationDate`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_has_citation_creation_date, None))
+
+    # HAS CITATION TIME SPAN
+    def get_citation_time_span(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``cito:hasCitationTimeSpan`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(GraphEntity.iri_has_citation_time_span)
+
+    @accepts_only('literal')
+    def has_citation_time_span(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``cito:hasCitationTimeSpan`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The date interval between the publication date of the cited bibliographic resource and
+        the publication date of the citing bibliographic resource.`
+
+        :param string: The value that will be set as the object of the property related to this method. **It must
+          be a string compliant with the** ``xsd:duration`` **datatype.**
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_citation_time_span()
+        self._create_literal(GraphEntity.iri_has_citation_time_span, string, XSD.duration, False)
+
+    def remove_citation_time_span(self) -> None:
+        """
+        Remover method corresponding to the ``c4o:hasCitationTimeSpan`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_has_citation_time_span, None))
+
+    # HAS CITATION CHARACTERIZATION
+    def get_citation_characterization(self) -> Optional[URIRef]:
+        """
+        Getter method corresponding to the ``cito:hasCitationCharacterisation`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_citation_characterisation)
+        return uri
+
+    @accepts_only('thing')
+    def has_citation_characterization(self, thing_res: URIRef) -> None:
+        """
+        Setter method corresponding to the ``cito:hasCitationCharacterisation`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The citation function characterizing the purpose of the citation.`
+
+        :param thing_res: The value that will be set as the object of the property related to this method
+        :type thing_res: URIRef
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_citation_characterization()
+        self.g.add((self.res, GraphEntity.iri_citation_characterisation, thing_res))
+
+    def remove_citation_characterization(self) -> None:
+        """
+        Remover method corresponding to the ``c4o:hasCitationCharacterisation`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_citation_characterisation, None))
+
+    # HAS TYPE
+    def create_self_citation(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``cito:SelfCitation``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_self_citation)
+
+    def create_affiliation_self_citation(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``cito:AffiliationSelfCitation``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_affiliation_self_citation)
+
+    def create_author_network_self_citation(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``cito:AuthorNetworkSelfCitation``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_author_network_self_citation)
+
+    def create_author_self_citation(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``cito:AuthorSelfCitation``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_author_self_citation)
+
+    def create_funder_self_citation(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``cito:FunderSelfCitation``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_funder_self_citation)
+
+    def create_journal_self_citation(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``cito:JournalSelfCitation``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_journal_self_citation)
+
+    def create_journal_cartel_citation(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``cito:JournalCartelCitation``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_journal_cartel_citation)
+
+    def create_distant_citation(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``cito:DistantCitation``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_distant_citation)
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/graph/entities/bibliographic/discourse_element.py` & `oc_ocdm-8.1.0/oc_ocdm/graph/entities/bibliographic/discourse_element.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,514 +1,514 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-from oc_ocdm.decorators import accepts_only
-
-if TYPE_CHECKING:
-    from typing import Optional, List
-    from rdflib import URIRef
-    from oc_ocdm.graph.entities.bibliographic.reference_pointer import ReferencePointer
-    from oc_ocdm.graph.entities.bibliographic.pointer_list import PointerList
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.graph.entities.bibliographic_entity import BibliographicEntity
-
-
-class DiscourseElement(BibliographicEntity):
-    """Discourse element (short: de): a document component, either structural (e.g.
-       paragraph, section, chapter, table, caption, footnote, title) or rhetorical (e.g.
-       introduction, discussion, acknowledgements, reference list, figure, appendix), in which
-       the content of a bibliographic resource can be organized."""
-
-    @accepts_only('de')
-    def merge(self, other: DiscourseElement) -> None:
-        """
-        The merge operation allows combining two ``DiscourseElement`` entities into a single one,
-        by marking the second entity as to be deleted while also copying its data into the current
-        ``DiscourseElement``. Moreover, every triple from the containing ``GraphSet`` referring to the second
-        entity gets "redirected" to the current entity: **every other reference contained inside a
-        different source (e.g. a triplestore) must be manually handled by the user!**
-
-        In case of functional properties, values from the current entity get overwritten
-        by those coming from the second entity while, in all other cases, values from the
-        second entity are simply appended to those of the current entity. In this context,
-        ``rdfs:label`` is considered as a functional property, while ``rdf:type`` is not.
-
-        :param other: The entity which will be marked as to be deleted and whose properties will
-         be merged into the current entity.
-        :type other: DiscourseElement
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        super(DiscourseElement, self).merge(other)
-
-        title: Optional[str] = other.get_title()
-        if title is not None:
-            self.has_title(title)
-
-        de_list: List[DiscourseElement] = other.get_contained_discourse_elements()
-        for cur_de in de_list:
-            self.contains_discourse_element(cur_de)
-
-        next_de: Optional[DiscourseElement] = other.get_next_de()
-        if next_de is not None:
-            self.has_next_de(next_de)
-
-        rp_list: List[ReferencePointer] = other.get_is_context_of_rp()
-        for cur_rp in rp_list:
-            self.is_context_of_rp(cur_rp)
-
-        pl_list: List[PointerList] = other.get_is_context_of_pl()
-        for cur_pl in pl_list:
-            self.is_context_of_pl(cur_pl)
-
-        content: Optional[str] = other.get_content()
-        if content is not None:
-            self.has_content(content)
-
-        number: Optional[str] = other.get_number()
-        if number is not None:
-            self.has_number(number)
-
-    # HAS TITLE
-    def get_title(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``dcterms:title`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(GraphEntity.iri_title)
-
-    @accepts_only('literal')
-    def has_title(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``dcterms:title`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The title of the discourse element, such as the title of a figure or a section in an article.`
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_title()
-        self._create_literal(GraphEntity.iri_title, string)
-
-    def remove_title(self) -> None:
-        """
-        Remover method corresponding to the ``dcterms:title`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_title, None))
-    
-    # HAS PART (DiscourseElement)
-    def get_contained_discourse_elements(self) -> List[DiscourseElement]:
-        """
-        Getter method corresponding to the ``frbr:part`` RDF predicate.
-
-        :return: A list containing the requested values if found, None otherwise
-        """
-        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_contains_de, 'de')
-        result: List[DiscourseElement] = []
-        for uri in uri_list:
-            result.append(self.g_set.add_de(self.resp_agent, self.source, uri))
-        return result
-
-    @accepts_only('de')
-    def contains_discourse_element(self, de_res: DiscourseElement) -> None:
-        """
-        Setter method corresponding to the ``frbr:part`` RDF predicate.
-
-        `The discourse element hierarchically nested within the parent element, such as a
-        sentence within a paragraph, or a paragraph within a section.`
-
-        :param de_res: The value that will be set as the object of the property related to this method
-        :type de_res: DiscourseElement
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.g.add((self.res, GraphEntity.iri_contains_de, de_res.res))
-
-    @accepts_only('de')
-    def remove_contained_discourse_element(self, de_res: DiscourseElement = None) -> None:
-        """
-        Remover method corresponding to the ``frbr:part`` RDF predicate.
-
-        **WARNING: this is a non-functional property, hence, if the parameter
-        is None, any existing value will be removed!**
-
-        :param de_res: If not None, the specific object value that will be removed from the property
-         related to this method (defaults to None)
-        :type de_res: DiscourseElement
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        if de_res is not None:
-            self.g.remove((self.res, GraphEntity.iri_contains_de, de_res.res))
-        else:
-            self.g.remove((self.res, GraphEntity.iri_contains_de, None))
-
-    # HAS NEXT (DiscourseElement)
-    def get_next_de(self) -> Optional[DiscourseElement]:
-        """
-        Getter method corresponding to the ``oco:hasNext`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_has_next, 'de')
-        if uri is not None:
-            return self.g_set.add_de(self.resp_agent, self.source, uri)
-
-    @accepts_only('de')
-    def has_next_de(self, de_res: DiscourseElement) -> None:
-        """
-        Setter method corresponding to the ``oco:hasNext`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The following discourse element that includes at least one in-text reference pointer.`
-
-        :param de_res: The value that will be set as the object of the property related to this method
-        :type de_res: DiscourseElement
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_next_de()
-        self.g.add((self.res, GraphEntity.iri_has_next, de_res.res))
-
-    def remove_next_de(self) -> None:
-        """
-        Remover method corresponding to the ``oco:hasNext`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_has_next, None))
-
-    # IS CONTEXT OF (ReferencePointer)
-    def get_is_context_of_rp(self) -> List[ReferencePointer]:
-        """
-        Getter method corresponding to the ``c4o:isContextOf`` RDF predicate.
-
-        :return: A list containing the requested values if found, None otherwise
-        """
-        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_is_context_of, 'rp')
-        result: List[ReferencePointer] = []
-        for uri in uri_list:
-            result.append(self.g_set.add_rp(self.resp_agent, self.source, uri))
-        return result
-
-    @accepts_only('rp')
-    def is_context_of_rp(self, rp_res: ReferencePointer) -> None:
-        """
-        Setter method corresponding to the ``c4o:isContextOf`` RDF predicate.
-
-        `Provides the textual and semantic context of the in-text reference pointer
-        that appears within the discourse element.`
-
-        :param rp_res: The value that will be set as the object of the property related to this method
-        :type rp_res: ReferencePointer
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.g.add((self.res, GraphEntity.iri_is_context_of, rp_res.res))
-
-    @accepts_only('rp')
-    def remove_is_context_of_rp(self, rp_res: ReferencePointer = None) -> None:
-        """
-        Remover method corresponding to the ``c4o:isContextOf`` RDF predicate.
-
-        **WARNING: this is a non-functional property, hence, if the parameter
-        is None, any existing value will be removed!**
-
-        :param rp_res: If not None, the specific object value that will be removed from the property
-         related to this method (defaults to None)
-        :type rp_res: ReferencePointer
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        if rp_res is not None:
-            self.g.remove((self.res, GraphEntity.iri_is_context_of, rp_res.res))
-        else:
-            self.g.remove((self.res, GraphEntity.iri_is_context_of, None))
-
-    # IS CONTEXT OF (PointerList)
-    def get_is_context_of_pl(self) -> List[PointerList]:
-        """
-        Getter method corresponding to the ``c4o:isContextOf`` RDF predicate.
-
-        :return: A list containing the requested values if found, None otherwise
-        """
-        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_is_context_of, 'pl')
-        result: List[PointerList] = []
-        for uri in uri_list:
-            result.append(self.g_set.add_pl(self.resp_agent, self.source, uri))
-        return result
-
-    @accepts_only('pl')
-    def is_context_of_pl(self, pl_res: PointerList) -> None:
-        """
-        Setter method corresponding to the ``c4o:isContextOf`` RDF predicate.
-
-        `Provides the textual and semantic context of the list of
-        in-text reference pointers that appears within the discourse element.`
-
-        :param pl_res: The value that will be set as the object of the property related to this method
-        :type pl_res: PointerList
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.g.add((self.res, GraphEntity.iri_is_context_of, pl_res.res))
-
-    @accepts_only('pl')
-    def remove_is_context_of_pl(self, pl_res: PointerList = None) -> None:
-        """
-        Remover method corresponding to the ``c4o:isContextOf`` RDF predicate.
-
-        **WARNING: this is a non-functional property, hence, if the parameter
-        is None, any existing value will be removed!**
-
-        :param pl_res: If not None, the specific object value that will be removed from the property
-         related to this method (defaults to None)
-        :type pl_res: PointerList
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        if pl_res is not None:
-            self.g.remove((self.res, GraphEntity.iri_is_context_of, pl_res.res))
-        else:
-            self.g.remove((self.res, GraphEntity.iri_is_context_of, None))
-
-    # HAS CONTENT
-    def get_content(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``c4o:hasContent`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(GraphEntity.iri_has_content)
-
-    @accepts_only('literal')
-    def has_content(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``c4o:hasContent`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The literal document text contained by the discourse element.`
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_content()
-        self._create_literal(GraphEntity.iri_has_content, string)
-
-    def remove_content(self) -> None:
-        """
-        Remover method corresponding to the ``c4o:hasContent`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_has_content, None))
-
-    # HAS NUMBER
-    def get_number(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``fabio:hasSequenceIdentifier`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(GraphEntity.iri_has_sequence_identifier)
-
-    @accepts_only('literal')
-    def has_number(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``fabio:hasSequenceIdentifier`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_number()
-        self._create_literal(GraphEntity.iri_has_sequence_identifier, string)
-
-    def remove_number(self) -> None:
-        """
-        Remover method corresponding to the ``fabio:hasSequenceIdentifier`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_has_sequence_identifier, None))
-
-    # HAS TYPE
-    @accepts_only('thing')
-    def create_discourse_element(self, de_class: URIRef = None) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        If parameter is None, it implicitly sets the object value ``deo:DiscourseElement``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of discourse element – such as “paragraph”, “section”, “sentence”,
-        “acknowledgements”, “reference list” or “figure”.`
-
-        :param de_class: The value that will be set as the object of the property related to this method
-        :type de_class: URIRef
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        if de_class is not None:
-            self._create_type(de_class)
-        else:
-            self._create_type(GraphEntity.iri_discourse_element)
-
-    def create_section(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``doco:Section``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of discourse element – such as “paragraph”, “section”, “sentence”,
-        “acknowledgements”, “reference list” or “figure”.`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_section)
-
-    def create_section_title(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``doco:SectionTitle``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of discourse element – such as “paragraph”, “section”, “sentence”,
-        “acknowledgements”, “reference list” or “figure”.`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_section_title)
-
-    def create_paragraph(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``doco:Paragraph``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of discourse element – such as “paragraph”, “section”, “sentence”,
-        “acknowledgements”, “reference list” or “figure”.`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_paragraph)
-
-    def create_sentence(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``doco:Sentence``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of discourse element – such as “paragraph”, “section”, “sentence”,
-        “acknowledgements”, “reference list” or “figure”.`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_sentence)
-
-    def create_text_chunk(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``doco:TextChunk``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of discourse element – such as “paragraph”, “section”, “sentence”,
-        “acknowledgements”, “reference list” or “figure”.`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_text_chunk)
-
-    def create_table(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``doco:Table``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of discourse element – such as “paragraph”, “section”, “sentence”,
-        “acknowledgements”, “reference list” or “figure”.`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_table)
-
-    def create_footnote(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``doco:Footnote``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of discourse element – such as “paragraph”, “section”, “sentence”,
-        “acknowledgements”, “reference list” or “figure”.`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_footnote)
-
-    def create_caption(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``deo:Caption``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `The type of discourse element – such as “paragraph”, “section”, “sentence”,
-        “acknowledgements”, “reference list” or “figure”.`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_caption)
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+from oc_ocdm.decorators import accepts_only
+
+if TYPE_CHECKING:
+    from typing import Optional, List
+    from rdflib import URIRef
+    from oc_ocdm.graph.entities.bibliographic.reference_pointer import ReferencePointer
+    from oc_ocdm.graph.entities.bibliographic.pointer_list import PointerList
+from oc_ocdm.graph.graph_entity import GraphEntity
+from oc_ocdm.graph.entities.bibliographic_entity import BibliographicEntity
+
+
+class DiscourseElement(BibliographicEntity):
+    """Discourse element (short: de): a document component, either structural (e.g.
+       paragraph, section, chapter, table, caption, footnote, title) or rhetorical (e.g.
+       introduction, discussion, acknowledgements, reference list, figure, appendix), in which
+       the content of a bibliographic resource can be organized."""
+
+    @accepts_only('de')
+    def merge(self, other: DiscourseElement) -> None:
+        """
+        The merge operation allows combining two ``DiscourseElement`` entities into a single one,
+        by marking the second entity as to be deleted while also copying its data into the current
+        ``DiscourseElement``. Moreover, every triple from the containing ``GraphSet`` referring to the second
+        entity gets "redirected" to the current entity: **every other reference contained inside a
+        different source (e.g. a triplestore) must be manually handled by the user!**
+
+        In case of functional properties, values from the current entity get overwritten
+        by those coming from the second entity while, in all other cases, values from the
+        second entity are simply appended to those of the current entity. In this context,
+        ``rdfs:label`` is considered as a functional property, while ``rdf:type`` is not.
+
+        :param other: The entity which will be marked as to be deleted and whose properties will
+         be merged into the current entity.
+        :type other: DiscourseElement
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        super(DiscourseElement, self).merge(other)
+
+        title: Optional[str] = other.get_title()
+        if title is not None:
+            self.has_title(title)
+
+        de_list: List[DiscourseElement] = other.get_contained_discourse_elements()
+        for cur_de in de_list:
+            self.contains_discourse_element(cur_de)
+
+        next_de: Optional[DiscourseElement] = other.get_next_de()
+        if next_de is not None:
+            self.has_next_de(next_de)
+
+        rp_list: List[ReferencePointer] = other.get_is_context_of_rp()
+        for cur_rp in rp_list:
+            self.is_context_of_rp(cur_rp)
+
+        pl_list: List[PointerList] = other.get_is_context_of_pl()
+        for cur_pl in pl_list:
+            self.is_context_of_pl(cur_pl)
+
+        content: Optional[str] = other.get_content()
+        if content is not None:
+            self.has_content(content)
+
+        number: Optional[str] = other.get_number()
+        if number is not None:
+            self.has_number(number)
+
+    # HAS TITLE
+    def get_title(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``dcterms:title`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(GraphEntity.iri_title)
+
+    @accepts_only('literal')
+    def has_title(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``dcterms:title`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The title of the discourse element, such as the title of a figure or a section in an article.`
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_title()
+        self._create_literal(GraphEntity.iri_title, string)
+
+    def remove_title(self) -> None:
+        """
+        Remover method corresponding to the ``dcterms:title`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_title, None))
+    
+    # HAS PART (DiscourseElement)
+    def get_contained_discourse_elements(self) -> List[DiscourseElement]:
+        """
+        Getter method corresponding to the ``frbr:part`` RDF predicate.
+
+        :return: A list containing the requested values if found, None otherwise
+        """
+        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_contains_de, 'de')
+        result: List[DiscourseElement] = []
+        for uri in uri_list:
+            result.append(self.g_set.add_de(self.resp_agent, self.source, uri))
+        return result
+
+    @accepts_only('de')
+    def contains_discourse_element(self, de_res: DiscourseElement) -> None:
+        """
+        Setter method corresponding to the ``frbr:part`` RDF predicate.
+
+        `The discourse element hierarchically nested within the parent element, such as a
+        sentence within a paragraph, or a paragraph within a section.`
+
+        :param de_res: The value that will be set as the object of the property related to this method
+        :type de_res: DiscourseElement
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.g.add((self.res, GraphEntity.iri_contains_de, de_res.res))
+
+    @accepts_only('de')
+    def remove_contained_discourse_element(self, de_res: DiscourseElement = None) -> None:
+        """
+        Remover method corresponding to the ``frbr:part`` RDF predicate.
+
+        **WARNING: this is a non-functional property, hence, if the parameter
+        is None, any existing value will be removed!**
+
+        :param de_res: If not None, the specific object value that will be removed from the property
+         related to this method (defaults to None)
+        :type de_res: DiscourseElement
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        if de_res is not None:
+            self.g.remove((self.res, GraphEntity.iri_contains_de, de_res.res))
+        else:
+            self.g.remove((self.res, GraphEntity.iri_contains_de, None))
+
+    # HAS NEXT (DiscourseElement)
+    def get_next_de(self) -> Optional[DiscourseElement]:
+        """
+        Getter method corresponding to the ``oco:hasNext`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_has_next, 'de')
+        if uri is not None:
+            return self.g_set.add_de(self.resp_agent, self.source, uri)
+
+    @accepts_only('de')
+    def has_next_de(self, de_res: DiscourseElement) -> None:
+        """
+        Setter method corresponding to the ``oco:hasNext`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The following discourse element that includes at least one in-text reference pointer.`
+
+        :param de_res: The value that will be set as the object of the property related to this method
+        :type de_res: DiscourseElement
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_next_de()
+        self.g.add((self.res, GraphEntity.iri_has_next, de_res.res))
+
+    def remove_next_de(self) -> None:
+        """
+        Remover method corresponding to the ``oco:hasNext`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_has_next, None))
+
+    # IS CONTEXT OF (ReferencePointer)
+    def get_is_context_of_rp(self) -> List[ReferencePointer]:
+        """
+        Getter method corresponding to the ``c4o:isContextOf`` RDF predicate.
+
+        :return: A list containing the requested values if found, None otherwise
+        """
+        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_is_context_of, 'rp')
+        result: List[ReferencePointer] = []
+        for uri in uri_list:
+            result.append(self.g_set.add_rp(self.resp_agent, self.source, uri))
+        return result
+
+    @accepts_only('rp')
+    def is_context_of_rp(self, rp_res: ReferencePointer) -> None:
+        """
+        Setter method corresponding to the ``c4o:isContextOf`` RDF predicate.
+
+        `Provides the textual and semantic context of the in-text reference pointer
+        that appears within the discourse element.`
+
+        :param rp_res: The value that will be set as the object of the property related to this method
+        :type rp_res: ReferencePointer
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.g.add((self.res, GraphEntity.iri_is_context_of, rp_res.res))
+
+    @accepts_only('rp')
+    def remove_is_context_of_rp(self, rp_res: ReferencePointer = None) -> None:
+        """
+        Remover method corresponding to the ``c4o:isContextOf`` RDF predicate.
+
+        **WARNING: this is a non-functional property, hence, if the parameter
+        is None, any existing value will be removed!**
+
+        :param rp_res: If not None, the specific object value that will be removed from the property
+         related to this method (defaults to None)
+        :type rp_res: ReferencePointer
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        if rp_res is not None:
+            self.g.remove((self.res, GraphEntity.iri_is_context_of, rp_res.res))
+        else:
+            self.g.remove((self.res, GraphEntity.iri_is_context_of, None))
+
+    # IS CONTEXT OF (PointerList)
+    def get_is_context_of_pl(self) -> List[PointerList]:
+        """
+        Getter method corresponding to the ``c4o:isContextOf`` RDF predicate.
+
+        :return: A list containing the requested values if found, None otherwise
+        """
+        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_is_context_of, 'pl')
+        result: List[PointerList] = []
+        for uri in uri_list:
+            result.append(self.g_set.add_pl(self.resp_agent, self.source, uri))
+        return result
+
+    @accepts_only('pl')
+    def is_context_of_pl(self, pl_res: PointerList) -> None:
+        """
+        Setter method corresponding to the ``c4o:isContextOf`` RDF predicate.
+
+        `Provides the textual and semantic context of the list of
+        in-text reference pointers that appears within the discourse element.`
+
+        :param pl_res: The value that will be set as the object of the property related to this method
+        :type pl_res: PointerList
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.g.add((self.res, GraphEntity.iri_is_context_of, pl_res.res))
+
+    @accepts_only('pl')
+    def remove_is_context_of_pl(self, pl_res: PointerList = None) -> None:
+        """
+        Remover method corresponding to the ``c4o:isContextOf`` RDF predicate.
+
+        **WARNING: this is a non-functional property, hence, if the parameter
+        is None, any existing value will be removed!**
+
+        :param pl_res: If not None, the specific object value that will be removed from the property
+         related to this method (defaults to None)
+        :type pl_res: PointerList
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        if pl_res is not None:
+            self.g.remove((self.res, GraphEntity.iri_is_context_of, pl_res.res))
+        else:
+            self.g.remove((self.res, GraphEntity.iri_is_context_of, None))
+
+    # HAS CONTENT
+    def get_content(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``c4o:hasContent`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(GraphEntity.iri_has_content)
+
+    @accepts_only('literal')
+    def has_content(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``c4o:hasContent`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The literal document text contained by the discourse element.`
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_content()
+        self._create_literal(GraphEntity.iri_has_content, string)
+
+    def remove_content(self) -> None:
+        """
+        Remover method corresponding to the ``c4o:hasContent`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_has_content, None))
+
+    # HAS NUMBER
+    def get_number(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``fabio:hasSequenceIdentifier`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(GraphEntity.iri_has_sequence_identifier)
+
+    @accepts_only('literal')
+    def has_number(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``fabio:hasSequenceIdentifier`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_number()
+        self._create_literal(GraphEntity.iri_has_sequence_identifier, string)
+
+    def remove_number(self) -> None:
+        """
+        Remover method corresponding to the ``fabio:hasSequenceIdentifier`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_has_sequence_identifier, None))
+
+    # HAS TYPE
+    @accepts_only('thing')
+    def create_discourse_element(self, de_class: URIRef = None) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        If parameter is None, it implicitly sets the object value ``deo:DiscourseElement``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of discourse element – such as “paragraph”, “section”, “sentence”,
+        “acknowledgements”, “reference list” or “figure”.`
+
+        :param de_class: The value that will be set as the object of the property related to this method
+        :type de_class: URIRef
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        if de_class is not None:
+            self._create_type(de_class)
+        else:
+            self._create_type(GraphEntity.iri_discourse_element)
+
+    def create_section(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``doco:Section``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of discourse element – such as “paragraph”, “section”, “sentence”,
+        “acknowledgements”, “reference list” or “figure”.`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_section)
+
+    def create_section_title(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``doco:SectionTitle``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of discourse element – such as “paragraph”, “section”, “sentence”,
+        “acknowledgements”, “reference list” or “figure”.`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_section_title)
+
+    def create_paragraph(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``doco:Paragraph``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of discourse element – such as “paragraph”, “section”, “sentence”,
+        “acknowledgements”, “reference list” or “figure”.`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_paragraph)
+
+    def create_sentence(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``doco:Sentence``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of discourse element – such as “paragraph”, “section”, “sentence”,
+        “acknowledgements”, “reference list” or “figure”.`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_sentence)
+
+    def create_text_chunk(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``doco:TextChunk``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of discourse element – such as “paragraph”, “section”, “sentence”,
+        “acknowledgements”, “reference list” or “figure”.`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_text_chunk)
+
+    def create_table(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``doco:Table``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of discourse element – such as “paragraph”, “section”, “sentence”,
+        “acknowledgements”, “reference list” or “figure”.`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_table)
+
+    def create_footnote(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``doco:Footnote``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of discourse element – such as “paragraph”, “section”, “sentence”,
+        “acknowledgements”, “reference list” or “figure”.`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_footnote)
+
+    def create_caption(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``deo:Caption``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `The type of discourse element – such as “paragraph”, “section”, “sentence”,
+        “acknowledgements”, “reference list” or “figure”.`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_caption)
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/graph/entities/bibliographic/pointer_list.py` & `oc_ocdm-8.1.0/oc_ocdm/graph/entities/bibliographic/pointer_list.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,142 +1,142 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-from oc_ocdm.decorators import accepts_only
-
-if TYPE_CHECKING:
-    from typing import Optional, List
-    from rdflib import URIRef
-    from oc_ocdm.graph.entities.bibliographic.reference_pointer import ReferencePointer
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.graph.entities.bibliographic_entity import BibliographicEntity
-
-
-class PointerList(BibliographicEntity):
-    """Pointer list (short: pl): a textual device (e.g. '[1, 2, 3]' or '[4-9]') which includes a
-       number of reference pointers denoting the specific bibliographic references to which
-       the list pertains."""
-
-    @accepts_only('pl')
-    def merge(self, other: PointerList) -> None:
-        """
-        The merge operation allows combining two ``PointerList`` entities into a single one,
-        by marking the second entity as to be deleted while also copying its data into the current
-        ``PointerList``. Moreover, every triple from the containing ``GraphSet`` referring to the second
-        entity gets "redirected" to the current entity: **every other reference contained inside a
-        different source (e.g. a triplestore) must be manually handled by the user!**
-
-        In case of functional properties, values from the current entity get overwritten
-        by those coming from the second entity while, in all other cases, values from the
-        second entity are simply appended to those of the current entity. In this context,
-        ``rdfs:label`` is considered as a functional property, while ``rdf:type`` is not.
-
-        :param other: The entity which will be marked as to be deleted and whose properties will
-         be merged into the current entity.
-        :type other: PointerList
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        super(PointerList, self).merge(other)
-
-        content: Optional[str] = self.get_content()
-        if content is not None:
-            self.has_content(content)
-
-        rp_list: List[ReferencePointer] = other.get_contained_elements()
-        for cur_rp in rp_list:
-            self.contains_element(cur_rp)
-
-    # HAS POINTER LIST TEXT
-    def get_content(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``c4o:hasContent`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(GraphEntity.iri_has_content)
-
-    @accepts_only('literal')
-    def has_content(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``c4o:hasContent`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_content()
-        self._create_literal(GraphEntity.iri_has_content, string)
-
-    def remove_content(self) -> None:
-        """
-        Remover method corresponding to the ``c4o:hasContent`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_has_content, None))
-
-    # HAS ELEMENT (ReferencePointer)
-    def get_contained_elements(self) -> List[ReferencePointer]:
-        """
-        Getter method corresponding to the ``co:element`` RDF predicate.
-
-        :return: A list containing the requested values if found, None otherwise
-        """
-        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_has_element, 'rp')
-        result: List[ReferencePointer] = []
-        for uri in uri_list:
-            result.append(self.g_set.add_rp(self.resp_agent, self.source, uri))
-        return result
-
-    @accepts_only('rp')
-    def contains_element(self, rp_res: ReferencePointer) -> None:
-        """
-        Setter method corresponding to the ``co:element`` RDF predicate.
-
-        `The in-text reference pointer that is part of the in-text reference pointer list present at
-        a particular location within the body of the citing work.`
-
-        :param rp_res: The value that will be set as the object of the property related to this method
-        :type rp_res: ReferencePointer
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.g.add((self.res, GraphEntity.iri_has_element, rp_res.res))
-
-    @accepts_only('rp')
-    def remove_contained_element(self, rp_res: ReferencePointer = None) -> None:
-        """
-        Remover method corresponding to the ``co:element`` RDF predicate.
-
-        **WARNING: this is a non-functional property, hence, if the parameter
-        is None, any existing value will be removed!**
-
-        :param rp_res: If not None, the specific object value that will be removed from the property
-         related to this method (defaults to None)
-        :type rp_res: ReferencePointer
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        if rp_res is not None:
-            self.g.remove((self.res, GraphEntity.iri_has_element, rp_res.res))
-        else:
-            self.g.remove((self.res, GraphEntity.iri_has_element, None))
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+from oc_ocdm.decorators import accepts_only
+
+if TYPE_CHECKING:
+    from typing import Optional, List
+    from rdflib import URIRef
+    from oc_ocdm.graph.entities.bibliographic.reference_pointer import ReferencePointer
+from oc_ocdm.graph.graph_entity import GraphEntity
+from oc_ocdm.graph.entities.bibliographic_entity import BibliographicEntity
+
+
+class PointerList(BibliographicEntity):
+    """Pointer list (short: pl): a textual device (e.g. '[1, 2, 3]' or '[4-9]') which includes a
+       number of reference pointers denoting the specific bibliographic references to which
+       the list pertains."""
+
+    @accepts_only('pl')
+    def merge(self, other: PointerList) -> None:
+        """
+        The merge operation allows combining two ``PointerList`` entities into a single one,
+        by marking the second entity as to be deleted while also copying its data into the current
+        ``PointerList``. Moreover, every triple from the containing ``GraphSet`` referring to the second
+        entity gets "redirected" to the current entity: **every other reference contained inside a
+        different source (e.g. a triplestore) must be manually handled by the user!**
+
+        In case of functional properties, values from the current entity get overwritten
+        by those coming from the second entity while, in all other cases, values from the
+        second entity are simply appended to those of the current entity. In this context,
+        ``rdfs:label`` is considered as a functional property, while ``rdf:type`` is not.
+
+        :param other: The entity which will be marked as to be deleted and whose properties will
+         be merged into the current entity.
+        :type other: PointerList
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        super(PointerList, self).merge(other)
+
+        content: Optional[str] = self.get_content()
+        if content is not None:
+            self.has_content(content)
+
+        rp_list: List[ReferencePointer] = other.get_contained_elements()
+        for cur_rp in rp_list:
+            self.contains_element(cur_rp)
+
+    # HAS POINTER LIST TEXT
+    def get_content(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``c4o:hasContent`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(GraphEntity.iri_has_content)
+
+    @accepts_only('literal')
+    def has_content(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``c4o:hasContent`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_content()
+        self._create_literal(GraphEntity.iri_has_content, string)
+
+    def remove_content(self) -> None:
+        """
+        Remover method corresponding to the ``c4o:hasContent`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_has_content, None))
+
+    # HAS ELEMENT (ReferencePointer)
+    def get_contained_elements(self) -> List[ReferencePointer]:
+        """
+        Getter method corresponding to the ``co:element`` RDF predicate.
+
+        :return: A list containing the requested values if found, None otherwise
+        """
+        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_has_element, 'rp')
+        result: List[ReferencePointer] = []
+        for uri in uri_list:
+            result.append(self.g_set.add_rp(self.resp_agent, self.source, uri))
+        return result
+
+    @accepts_only('rp')
+    def contains_element(self, rp_res: ReferencePointer) -> None:
+        """
+        Setter method corresponding to the ``co:element`` RDF predicate.
+
+        `The in-text reference pointer that is part of the in-text reference pointer list present at
+        a particular location within the body of the citing work.`
+
+        :param rp_res: The value that will be set as the object of the property related to this method
+        :type rp_res: ReferencePointer
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.g.add((self.res, GraphEntity.iri_has_element, rp_res.res))
+
+    @accepts_only('rp')
+    def remove_contained_element(self, rp_res: ReferencePointer = None) -> None:
+        """
+        Remover method corresponding to the ``co:element`` RDF predicate.
+
+        **WARNING: this is a non-functional property, hence, if the parameter
+        is None, any existing value will be removed!**
+
+        :param rp_res: If not None, the specific object value that will be removed from the property
+         related to this method (defaults to None)
+        :type rp_res: ReferencePointer
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        if rp_res is not None:
+            self.g.remove((self.res, GraphEntity.iri_has_element, rp_res.res))
+        else:
+            self.g.remove((self.res, GraphEntity.iri_has_element, None))
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/graph/entities/bibliographic/reference_annotation.py` & `oc_ocdm-8.1.0/oc_ocdm/graph/entities/bibliographic/reference_annotation.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,100 +1,100 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-from oc_ocdm.decorators import accepts_only
-
-if TYPE_CHECKING:
-    from typing import Optional
-    from rdflib import URIRef
-    from oc_ocdm.graph.entities.bibliographic.citation import Citation
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.graph.entities.bibliographic_entity import BibliographicEntity
-
-
-class ReferenceAnnotation(BibliographicEntity):
-    """Reference annotation (short: an): an annotation, attached either to an in-text
-       reference pointer or to a bibliographic reference, describing the related citation. If an
-       in-text reference pointer is annotated, the related citation may be characterized with a
-       citation function (the reason for that citation) specific to the textual location of that
-       in-text reference pointer within the citing entity. If a bibliographic reference is
-       annotated, the related citation may be similarly characterized in a more general way
-       with a citation function (the reason for that citation)."""
-
-    @accepts_only('an')
-    def merge(self, other: ReferenceAnnotation) -> None:
-        """
-        The merge operation allows combining two ``ReferenceAnnotation`` entities into a single one,
-        by marking the second entity as to be deleted while also copying its data into the current
-        ``ReferenceAnnotation``. Moreover, every triple from the containing ``GraphSet`` referring to the second
-        entity gets "redirected" to the current entity: **every other reference contained inside a
-        different source (e.g. a triplestore) must be manually handled by the user!**
-
-        In case of functional properties, values from the current entity get overwritten
-        by those coming from the second entity while, in all other cases, values from the
-        second entity are simply appended to those of the current entity. In this context,
-        ``rdfs:label`` is considered as a functional property, while ``rdf:type`` is not.
-
-        :param other: The entity which will be marked as to be deleted and whose properties will
-         be merged into the current entity.
-        :type other: ReferenceAnnotation
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        super(ReferenceAnnotation, self).merge(other)
-
-        citation: Optional[Citation] = other.get_body_annotation()
-        if citation is not None:
-            self.has_body_annotation(citation)
-
-    # HAS CITATION (Citation)
-    def get_body_annotation(self) -> Optional[Citation]:
-        """
-        Getter method corresponding to the ``oa:hasBody`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_has_body, 'ci')
-        if uri is not None:
-            return self.g_set.add_ci(self.resp_agent, self.source, uri)
-
-    @accepts_only('ci')
-    def has_body_annotation(self, ci_res: Citation) -> None:
-        """
-        Setter method corresponding to the ``oa:hasBody`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The citation to which the annotation relates, that is relevant either to a bibliographic
-        reference or to an in-text reference pointer that denotes such a bibliographic reference.`
-
-        :param ci_res: The value that will be set as the object of the property related to this method
-        :type ci_res: Citation
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_body_annotation()
-        self.g.add((self.res, GraphEntity.iri_has_body, ci_res.res))
-
-    def remove_body_annotation(self) -> None:
-        """
-        Remover method corresponding to the ``oa:hasBody`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_has_body, None))
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+from oc_ocdm.decorators import accepts_only
+
+if TYPE_CHECKING:
+    from typing import Optional
+    from rdflib import URIRef
+    from oc_ocdm.graph.entities.bibliographic.citation import Citation
+from oc_ocdm.graph.graph_entity import GraphEntity
+from oc_ocdm.graph.entities.bibliographic_entity import BibliographicEntity
+
+
+class ReferenceAnnotation(BibliographicEntity):
+    """Reference annotation (short: an): an annotation, attached either to an in-text
+       reference pointer or to a bibliographic reference, describing the related citation. If an
+       in-text reference pointer is annotated, the related citation may be characterized with a
+       citation function (the reason for that citation) specific to the textual location of that
+       in-text reference pointer within the citing entity. If a bibliographic reference is
+       annotated, the related citation may be similarly characterized in a more general way
+       with a citation function (the reason for that citation)."""
+
+    @accepts_only('an')
+    def merge(self, other: ReferenceAnnotation) -> None:
+        """
+        The merge operation allows combining two ``ReferenceAnnotation`` entities into a single one,
+        by marking the second entity as to be deleted while also copying its data into the current
+        ``ReferenceAnnotation``. Moreover, every triple from the containing ``GraphSet`` referring to the second
+        entity gets "redirected" to the current entity: **every other reference contained inside a
+        different source (e.g. a triplestore) must be manually handled by the user!**
+
+        In case of functional properties, values from the current entity get overwritten
+        by those coming from the second entity while, in all other cases, values from the
+        second entity are simply appended to those of the current entity. In this context,
+        ``rdfs:label`` is considered as a functional property, while ``rdf:type`` is not.
+
+        :param other: The entity which will be marked as to be deleted and whose properties will
+         be merged into the current entity.
+        :type other: ReferenceAnnotation
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        super(ReferenceAnnotation, self).merge(other)
+
+        citation: Optional[Citation] = other.get_body_annotation()
+        if citation is not None:
+            self.has_body_annotation(citation)
+
+    # HAS CITATION (Citation)
+    def get_body_annotation(self) -> Optional[Citation]:
+        """
+        Getter method corresponding to the ``oa:hasBody`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_has_body, 'ci')
+        if uri is not None:
+            return self.g_set.add_ci(self.resp_agent, self.source, uri)
+
+    @accepts_only('ci')
+    def has_body_annotation(self, ci_res: Citation) -> None:
+        """
+        Setter method corresponding to the ``oa:hasBody`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The citation to which the annotation relates, that is relevant either to a bibliographic
+        reference or to an in-text reference pointer that denotes such a bibliographic reference.`
+
+        :param ci_res: The value that will be set as the object of the property related to this method
+        :type ci_res: Citation
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_body_annotation()
+        self.g.add((self.res, GraphEntity.iri_has_body, ci_res.res))
+
+    def remove_body_annotation(self) -> None:
+        """
+        Remover method corresponding to the ``oa:hasBody`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_has_body, None))
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/graph/entities/bibliographic/reference_pointer.py` & `oc_ocdm-8.1.0/oc_ocdm/graph/entities/bibliographic/reference_pointer.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,230 +1,230 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-from oc_ocdm.decorators import accepts_only
-
-if TYPE_CHECKING:
-    from typing import Optional, List
-    from rdflib import URIRef
-    from oc_ocdm.graph.entities.bibliographic.bibliographic_reference import BibliographicReference
-    from oc_ocdm.graph.entities.bibliographic.reference_annotation import ReferenceAnnotation
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.graph.entities.bibliographic_entity import BibliographicEntity
-
-
-class ReferencePointer(BibliographicEntity):
-    """Reference pointer (long: in-text reference pointer; short: rp): a textual device (e.g.
-       '[1]'), denoting a single bibliographic reference, that is embedded in the text of a
-       document within the context of a particular sentence or text chunk. A bibliographic
-       reference can be denoted in the text by one or more in-text reference pointers."""
-
-    @accepts_only('rp')
-    def merge(self, other: ReferencePointer) -> None:
-        """
-        The merge operation allows combining two ``ReferencePointer`` entities into a single one,
-        by marking the second entity as to be deleted while also copying its data into the current
-        ``ReferencePointer``. Moreover, every triple from the containing ``GraphSet`` referring to the second
-        entity gets "redirected" to the current entity: **every other reference contained inside a
-        different source (e.g. a triplestore) must be manually handled by the user!**
-
-        In case of functional properties, values from the current entity get overwritten
-        by those coming from the second entity while, in all other cases, values from the
-        second entity are simply appended to those of the current entity. In this context,
-        ``rdfs:label`` is considered as a functional property, while ``rdf:type`` is not.
-
-        :param other: The entity which will be marked as to be deleted and whose properties will
-         be merged into the current entity.
-        :type other: ReferencePointer
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        super(ReferencePointer, self).merge(other)
-
-        content: Optional[str] = other.get_content()
-        if content is not None:
-            self.has_content(content)
-
-        next_rp: Optional[ReferencePointer] = other.get_next_rp()
-        if next_rp is not None:
-            self.has_next_rp(next_rp)
-
-        denoted_be: Optional[BibliographicReference] = other.get_denoted_be()
-        if denoted_be is not None:
-            self.denotes_be(denoted_be)
-
-        an_list: List[ReferenceAnnotation] = other.get_annotations()
-        for cur_an in an_list:
-            self.has_annotation(cur_an)
-
-    # HAS REFERENCE POINTER TEXT
-    def get_content(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``c4o:hasContent`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(GraphEntity.iri_has_content)
-
-    @accepts_only('literal')
-    def has_content(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``c4o:hasContent`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The literal text of the textual device forming an in-text reference pointer and denoting
-        a single bibliographic reference (e.g. “[1]”).`
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_content()
-        self._create_literal(GraphEntity.iri_has_content, string)
-
-    def remove_content(self) -> None:
-        """
-        Remover method corresponding to the ``c4o:hasContent`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_has_content, None))
-
-    # HAS NEXT (ReferencePointer)
-    def get_next_rp(self) -> Optional[ReferencePointer]:
-        """
-        Getter method corresponding to the ``oco:hasNext`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_has_next, 'rp')
-        if uri is not None:
-            return self.g_set.add_rp(self.resp_agent, self.source, uri)
-
-    @accepts_only('rp')
-    def has_next_rp(self, rp_res: ReferencePointer) -> None:
-        """
-        Setter method corresponding to the ``oco:hasNext`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The following in-text reference pointer, when included within a single in-text reference
-        pointer list.`
-
-        :param rp_res: The value that will be set as the object of the property related to this method
-        :type rp_res: ReferencePointer
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_next_rp()
-        self.g.add((self.res, GraphEntity.iri_has_next, rp_res.res))
-
-    def remove_next_rp(self) -> None:
-        """
-        Remover method corresponding to the ``oco:hasNext`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_has_next, None))
-
-    # DENOTES (BibliographicReference)
-    def get_denoted_be(self) -> Optional[BibliographicReference]:
-        """
-        Getter method corresponding to the ``c4o:denotes`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_denotes, 'be')
-        if uri is not None:
-            return self.g_set.add_be(self.resp_agent, self.source, uri)
-
-    @accepts_only('be')
-    def denotes_be(self, be_res: BibliographicReference) -> None:
-        """
-        Setter method corresponding to the ``c4o:denotes`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The bibliographic reference included in the list of bibliographic references, denoted by
-        the in-text reference pointer.`
-
-        :param be_res: The value that will be set as the object of the property related to this method
-        :type be_res: BibliographicReference
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_denoted_be()
-        self.g.add((self.res, GraphEntity.iri_denotes, be_res.res))
-
-    def remove_denoted_be(self) -> None:
-        """
-        Remover method corresponding to the ``c4o:denotes`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_denotes, None))
-
-    # HAS ANNOTATION (ReferenceAnnotation)
-    def get_annotations(self) -> List[ReferenceAnnotation]:
-        """
-        Getter method corresponding to the ``oco:hasAnnotation`` RDF predicate.
-
-        :return: A list containing the requested values if found, None otherwise
-        """
-        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_has_annotation, 'an')
-        result: List[ReferenceAnnotation] = []
-        for uri in uri_list:
-            result.append(self.g_set.add_an(self.resp_agent, self.source, uri))
-        return result
-
-    @accepts_only('an')
-    def has_annotation(self, an_res: ReferenceAnnotation) -> None:
-        """
-        Setter method corresponding to the ``oco:hasAnnotation`` RDF predicate.
-
-        `An annotation characterizing the citation to which the in-text reference pointer relates
-        in terms of its citation function (the reason for that citation) specific to the textual
-        location of that in-text reference pointer within the citing entity.`
-
-        :param an_res: The value that will be set as the object of the property related to this method
-        :type an_res: ReferenceAnnotation
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.g.add((self.res, GraphEntity.iri_has_annotation, an_res.res))
-
-    @accepts_only('an')
-    def remove_annotation(self, an_res: ReferenceAnnotation = None) -> None:
-        """
-        Remover method corresponding to the ``oco:hasAnnotation`` RDF predicate.
-
-        **WARNING: this is a non-functional property, hence, if the parameter
-        is None, any existing value will be removed!**
-
-        :param an_res: If not None, the specific object value that will be removed from the property
-         related to this method (defaults to None)
-        :type an_res: ReferenceAnnotation
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        if an_res is not None:
-            self.g.remove((self.res, GraphEntity.iri_has_annotation, an_res.res))
-        else:
-            self.g.remove((self.res, GraphEntity.iri_has_annotation, None))
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+from oc_ocdm.decorators import accepts_only
+
+if TYPE_CHECKING:
+    from typing import Optional, List
+    from rdflib import URIRef
+    from oc_ocdm.graph.entities.bibliographic.bibliographic_reference import BibliographicReference
+    from oc_ocdm.graph.entities.bibliographic.reference_annotation import ReferenceAnnotation
+from oc_ocdm.graph.graph_entity import GraphEntity
+from oc_ocdm.graph.entities.bibliographic_entity import BibliographicEntity
+
+
+class ReferencePointer(BibliographicEntity):
+    """Reference pointer (long: in-text reference pointer; short: rp): a textual device (e.g.
+       '[1]'), denoting a single bibliographic reference, that is embedded in the text of a
+       document within the context of a particular sentence or text chunk. A bibliographic
+       reference can be denoted in the text by one or more in-text reference pointers."""
+
+    @accepts_only('rp')
+    def merge(self, other: ReferencePointer) -> None:
+        """
+        The merge operation allows combining two ``ReferencePointer`` entities into a single one,
+        by marking the second entity as to be deleted while also copying its data into the current
+        ``ReferencePointer``. Moreover, every triple from the containing ``GraphSet`` referring to the second
+        entity gets "redirected" to the current entity: **every other reference contained inside a
+        different source (e.g. a triplestore) must be manually handled by the user!**
+
+        In case of functional properties, values from the current entity get overwritten
+        by those coming from the second entity while, in all other cases, values from the
+        second entity are simply appended to those of the current entity. In this context,
+        ``rdfs:label`` is considered as a functional property, while ``rdf:type`` is not.
+
+        :param other: The entity which will be marked as to be deleted and whose properties will
+         be merged into the current entity.
+        :type other: ReferencePointer
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        super(ReferencePointer, self).merge(other)
+
+        content: Optional[str] = other.get_content()
+        if content is not None:
+            self.has_content(content)
+
+        next_rp: Optional[ReferencePointer] = other.get_next_rp()
+        if next_rp is not None:
+            self.has_next_rp(next_rp)
+
+        denoted_be: Optional[BibliographicReference] = other.get_denoted_be()
+        if denoted_be is not None:
+            self.denotes_be(denoted_be)
+
+        an_list: List[ReferenceAnnotation] = other.get_annotations()
+        for cur_an in an_list:
+            self.has_annotation(cur_an)
+
+    # HAS REFERENCE POINTER TEXT
+    def get_content(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``c4o:hasContent`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(GraphEntity.iri_has_content)
+
+    @accepts_only('literal')
+    def has_content(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``c4o:hasContent`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The literal text of the textual device forming an in-text reference pointer and denoting
+        a single bibliographic reference (e.g. “[1]”).`
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_content()
+        self._create_literal(GraphEntity.iri_has_content, string)
+
+    def remove_content(self) -> None:
+        """
+        Remover method corresponding to the ``c4o:hasContent`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_has_content, None))
+
+    # HAS NEXT (ReferencePointer)
+    def get_next_rp(self) -> Optional[ReferencePointer]:
+        """
+        Getter method corresponding to the ``oco:hasNext`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_has_next, 'rp')
+        if uri is not None:
+            return self.g_set.add_rp(self.resp_agent, self.source, uri)
+
+    @accepts_only('rp')
+    def has_next_rp(self, rp_res: ReferencePointer) -> None:
+        """
+        Setter method corresponding to the ``oco:hasNext`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The following in-text reference pointer, when included within a single in-text reference
+        pointer list.`
+
+        :param rp_res: The value that will be set as the object of the property related to this method
+        :type rp_res: ReferencePointer
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_next_rp()
+        self.g.add((self.res, GraphEntity.iri_has_next, rp_res.res))
+
+    def remove_next_rp(self) -> None:
+        """
+        Remover method corresponding to the ``oco:hasNext`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_has_next, None))
+
+    # DENOTES (BibliographicReference)
+    def get_denoted_be(self) -> Optional[BibliographicReference]:
+        """
+        Getter method corresponding to the ``c4o:denotes`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_denotes, 'be')
+        if uri is not None:
+            return self.g_set.add_be(self.resp_agent, self.source, uri)
+
+    @accepts_only('be')
+    def denotes_be(self, be_res: BibliographicReference) -> None:
+        """
+        Setter method corresponding to the ``c4o:denotes`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The bibliographic reference included in the list of bibliographic references, denoted by
+        the in-text reference pointer.`
+
+        :param be_res: The value that will be set as the object of the property related to this method
+        :type be_res: BibliographicReference
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_denoted_be()
+        self.g.add((self.res, GraphEntity.iri_denotes, be_res.res))
+
+    def remove_denoted_be(self) -> None:
+        """
+        Remover method corresponding to the ``c4o:denotes`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_denotes, None))
+
+    # HAS ANNOTATION (ReferenceAnnotation)
+    def get_annotations(self) -> List[ReferenceAnnotation]:
+        """
+        Getter method corresponding to the ``oco:hasAnnotation`` RDF predicate.
+
+        :return: A list containing the requested values if found, None otherwise
+        """
+        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_has_annotation, 'an')
+        result: List[ReferenceAnnotation] = []
+        for uri in uri_list:
+            result.append(self.g_set.add_an(self.resp_agent, self.source, uri))
+        return result
+
+    @accepts_only('an')
+    def has_annotation(self, an_res: ReferenceAnnotation) -> None:
+        """
+        Setter method corresponding to the ``oco:hasAnnotation`` RDF predicate.
+
+        `An annotation characterizing the citation to which the in-text reference pointer relates
+        in terms of its citation function (the reason for that citation) specific to the textual
+        location of that in-text reference pointer within the citing entity.`
+
+        :param an_res: The value that will be set as the object of the property related to this method
+        :type an_res: ReferenceAnnotation
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.g.add((self.res, GraphEntity.iri_has_annotation, an_res.res))
+
+    @accepts_only('an')
+    def remove_annotation(self, an_res: ReferenceAnnotation = None) -> None:
+        """
+        Remover method corresponding to the ``oco:hasAnnotation`` RDF predicate.
+
+        **WARNING: this is a non-functional property, hence, if the parameter
+        is None, any existing value will be removed!**
+
+        :param an_res: If not None, the specific object value that will be removed from the property
+         related to this method (defaults to None)
+        :type an_res: ReferenceAnnotation
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        if an_res is not None:
+            self.g.remove((self.res, GraphEntity.iri_has_annotation, an_res.res))
+        else:
+            self.g.remove((self.res, GraphEntity.iri_has_annotation, None))
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/graph/entities/bibliographic/resource_embodiment.py` & `oc_ocdm-8.1.0/oc_ocdm/graph/entities/bibliographic/resource_embodiment.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,255 +1,255 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-import re
-from typing import TYPE_CHECKING
-
-if TYPE_CHECKING:
-    from typing import Optional
-    from rdflib import URIRef
-
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.decorators import accepts_only
-from oc_ocdm.graph.entities.bibliographic_entity import BibliographicEntity
-
-
-class ResourceEmbodiment(BibliographicEntity):
-    """Resource embodiment (short: re): the particular physical or digital format in which a
-       bibliographic resource was made available by its publisher."""
-
-    @accepts_only('re')
-    def merge(self, other: ResourceEmbodiment) -> None:
-        """
-        The merge operation allows combining two ``ResourceEmbodiment`` entities into a single one,
-        by marking the second entity as to be deleted while also copying its data into the current
-        ``ResourceEmbodiment``. Moreover, every triple from the containing ``GraphSet`` referring to the second
-        entity gets "redirected" to the current entity: **every other reference contained inside a
-        different source (e.g. a triplestore) must be manually handled by the user!**
-
-        In case of functional properties, values from the current entity get overwritten
-        by those coming from the second entity while, in all other cases, values from the
-        second entity are simply appended to those of the current entity. In this context,
-        ``rdfs:label`` is considered as a functional property, while ``rdf:type`` is not.
-
-        :param other: The entity which will be marked as to be deleted and whose properties will
-         be merged into the current entity.
-        :type other: ResourceEmbodiment
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        super(ResourceEmbodiment, self).merge(other)
-
-        media_type: Optional[URIRef] = other.get_media_type()
-        if media_type is not None:
-            self.has_media_type(media_type)
-
-        starting_page: Optional[str] = other.get_starting_page()
-        if starting_page is not None:
-            self.has_starting_page(starting_page)
-
-        ending_page: Optional[str] = other.get_ending_page()
-        if ending_page is not None:
-            self.has_ending_page(ending_page)
-
-        url: Optional[URIRef] = other.get_url()
-        if url is not None:
-            self.has_url(url)
-
-    # HAS FORMAT
-    def get_media_type(self) -> Optional[URIRef]:
-        """
-        Getter method corresponding to the ``dcterms:format`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_has_format)
-        return uri
-
-    @accepts_only('thing')
-    def has_media_type(self, thing_res: URIRef) -> None:
-        """
-        Setter method corresponding to the ``dcterms:format`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `It allows one to specify the IANA media type of the embodiment.`
-
-        :param thing_res: The value that will be set as the object of the property related to this method
-        :type thing_res: URIRef
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_media_type()
-        self.g.add((self.res, GraphEntity.iri_has_format, thing_res))
-
-    def remove_media_type(self) -> None:
-        """
-        Remover method corresponding to the ``dcterms:format`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_has_format, None))
-
-    # HAS FIRST PAGE
-    def get_starting_page(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``prism:startingPage`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(GraphEntity.iri_starting_page)
-
-    @accepts_only('literal')
-    def has_starting_page(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``prism:startingPage`` RDF predicate.
-
-        The string gets internally preprocessed by eventually removing dashes and everything
-        that follows them (e.g. '22-45' becomes '22').
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The first page of the bibliographic resource according to the current embodiment.`
-
-        :param string: The value that will be set as the object of the property related to this method. **It must
-          be a string that starts with an integer number.**
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_starting_page()
-        if re.search("[-–]+", string) is None:
-            page_number = string
-        else:
-            page_number = re.sub("[-–]+.*$", "", string)
-        self._create_literal(GraphEntity.iri_starting_page, page_number)
-
-    def remove_starting_page(self) -> None:
-        """
-        Remover method corresponding to the ``prism:startingPage`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_starting_page, None))
-
-    # HAS LAST PAGE
-    def get_ending_page(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``prism:endingPage`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(GraphEntity.iri_ending_page)
-
-    @accepts_only('literal')
-    def has_ending_page(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``prism:endingPage`` RDF predicate.
-
-        The string gets internally preprocessed by eventually removing dashes and everything
-        that comes before them (e.g. '22-45' becomes '45').
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The last page of the bibliographic resource according to the current embodiment.`
-
-        :param string: The value that will be set as the object of the property related to this method. **It must
-          be a string that ends with an integer number.**
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_ending_page()
-        if re.search("[-–]+", string) is None:
-            page_number = string
-        else:
-            page_number = re.sub("^.*[-–]+", "", string)
-        self._create_literal(GraphEntity.iri_ending_page, page_number)
-
-    def remove_ending_page(self) -> None:
-        """
-        Remover method corresponding to the ``prism:endingPage`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_ending_page, None))
-
-    # HAS URL
-    def get_url(self) -> Optional[URIRef]:
-        """
-        Getter method corresponding to the ``frbr:exemplar`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_has_url)
-        return uri
-
-    @accepts_only('thing')
-    def has_url(self, thing_res: URIRef) -> None:
-        """
-        Setter method corresponding to the ``frbr:exemplar`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The URL at which the embodiment of the bibliographic resource is available.`
-
-        :param thing_res: The value that will be set as the object of the property related to this method
-        :type thing_res: URIRef
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_url()
-        self.g.add((self.res, GraphEntity.iri_has_url, thing_res))
-
-    def remove_url(self) -> None:
-        """
-        Remover method corresponding to the ``frbr:exemplar`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_has_url, None))
-
-    # HAS TYPE
-    def create_digital_embodiment(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:DigitalManifestation``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `It identifies the particular type of the embodiment, either digital or print.`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_digital_manifestation)
-
-    def create_print_embodiment(self) -> None:
-        """
-        Setter method corresponding to the ``rdf:type`` RDF predicate.
-        It implicitly sets the object value ``fabio:PrintObject``.
-
-        **WARNING: the OCDM specification admits at most two types for an entity.
-        The main type cannot be edited or removed. Any existing secondary type
-        will be overwritten!**
-
-        `It identifies the particular type of the embodiment, either digital or print.`
-
-        :return: None
-        """
-        self._create_type(GraphEntity.iri_print_object)
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+import re
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from typing import Optional
+    from rdflib import URIRef
+
+from oc_ocdm.graph.graph_entity import GraphEntity
+from oc_ocdm.decorators import accepts_only
+from oc_ocdm.graph.entities.bibliographic_entity import BibliographicEntity
+
+
+class ResourceEmbodiment(BibliographicEntity):
+    """Resource embodiment (short: re): the particular physical or digital format in which a
+       bibliographic resource was made available by its publisher."""
+
+    @accepts_only('re')
+    def merge(self, other: ResourceEmbodiment) -> None:
+        """
+        The merge operation allows combining two ``ResourceEmbodiment`` entities into a single one,
+        by marking the second entity as to be deleted while also copying its data into the current
+        ``ResourceEmbodiment``. Moreover, every triple from the containing ``GraphSet`` referring to the second
+        entity gets "redirected" to the current entity: **every other reference contained inside a
+        different source (e.g. a triplestore) must be manually handled by the user!**
+
+        In case of functional properties, values from the current entity get overwritten
+        by those coming from the second entity while, in all other cases, values from the
+        second entity are simply appended to those of the current entity. In this context,
+        ``rdfs:label`` is considered as a functional property, while ``rdf:type`` is not.
+
+        :param other: The entity which will be marked as to be deleted and whose properties will
+         be merged into the current entity.
+        :type other: ResourceEmbodiment
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        super(ResourceEmbodiment, self).merge(other)
+
+        media_type: Optional[URIRef] = other.get_media_type()
+        if media_type is not None:
+            self.has_media_type(media_type)
+
+        starting_page: Optional[str] = other.get_starting_page()
+        if starting_page is not None:
+            self.has_starting_page(starting_page)
+
+        ending_page: Optional[str] = other.get_ending_page()
+        if ending_page is not None:
+            self.has_ending_page(ending_page)
+
+        url: Optional[URIRef] = other.get_url()
+        if url is not None:
+            self.has_url(url)
+
+    # HAS FORMAT
+    def get_media_type(self) -> Optional[URIRef]:
+        """
+        Getter method corresponding to the ``dcterms:format`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_has_format)
+        return uri
+
+    @accepts_only('thing')
+    def has_media_type(self, thing_res: URIRef) -> None:
+        """
+        Setter method corresponding to the ``dcterms:format`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `It allows one to specify the IANA media type of the embodiment.`
+
+        :param thing_res: The value that will be set as the object of the property related to this method
+        :type thing_res: URIRef
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_media_type()
+        self.g.add((self.res, GraphEntity.iri_has_format, thing_res))
+
+    def remove_media_type(self) -> None:
+        """
+        Remover method corresponding to the ``dcterms:format`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_has_format, None))
+
+    # HAS FIRST PAGE
+    def get_starting_page(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``prism:startingPage`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(GraphEntity.iri_starting_page)
+
+    @accepts_only('literal')
+    def has_starting_page(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``prism:startingPage`` RDF predicate.
+
+        The string gets internally preprocessed by eventually removing dashes and everything
+        that follows them (e.g. '22-45' becomes '22').
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The first page of the bibliographic resource according to the current embodiment.`
+
+        :param string: The value that will be set as the object of the property related to this method. **It must
+          be a string that starts with an integer number.**
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_starting_page()
+        if re.search("[-–]+", string) is None:
+            page_number = string
+        else:
+            page_number = re.sub("[-–]+.*$", "", string)
+        self._create_literal(GraphEntity.iri_starting_page, page_number)
+
+    def remove_starting_page(self) -> None:
+        """
+        Remover method corresponding to the ``prism:startingPage`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_starting_page, None))
+
+    # HAS LAST PAGE
+    def get_ending_page(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``prism:endingPage`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(GraphEntity.iri_ending_page)
+
+    @accepts_only('literal')
+    def has_ending_page(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``prism:endingPage`` RDF predicate.
+
+        The string gets internally preprocessed by eventually removing dashes and everything
+        that comes before them (e.g. '22-45' becomes '45').
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The last page of the bibliographic resource according to the current embodiment.`
+
+        :param string: The value that will be set as the object of the property related to this method. **It must
+          be a string that ends with an integer number.**
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_ending_page()
+        if re.search("[-–]+", string) is None:
+            page_number = string
+        else:
+            page_number = re.sub("^.*[-–]+", "", string)
+        self._create_literal(GraphEntity.iri_ending_page, page_number)
+
+    def remove_ending_page(self) -> None:
+        """
+        Remover method corresponding to the ``prism:endingPage`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_ending_page, None))
+
+    # HAS URL
+    def get_url(self) -> Optional[URIRef]:
+        """
+        Getter method corresponding to the ``frbr:exemplar`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_has_url)
+        return uri
+
+    @accepts_only('thing')
+    def has_url(self, thing_res: URIRef) -> None:
+        """
+        Setter method corresponding to the ``frbr:exemplar`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The URL at which the embodiment of the bibliographic resource is available.`
+
+        :param thing_res: The value that will be set as the object of the property related to this method
+        :type thing_res: URIRef
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_url()
+        self.g.add((self.res, GraphEntity.iri_has_url, thing_res))
+
+    def remove_url(self) -> None:
+        """
+        Remover method corresponding to the ``frbr:exemplar`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_has_url, None))
+
+    # HAS TYPE
+    def create_digital_embodiment(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:DigitalManifestation``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `It identifies the particular type of the embodiment, either digital or print.`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_digital_manifestation)
+
+    def create_print_embodiment(self) -> None:
+        """
+        Setter method corresponding to the ``rdf:type`` RDF predicate.
+        It implicitly sets the object value ``fabio:PrintObject``.
+
+        **WARNING: the OCDM specification admits at most two types for an entity.
+        The main type cannot be edited or removed. Any existing secondary type
+        will be overwritten!**
+
+        `It identifies the particular type of the embodiment, either digital or print.`
+
+        :return: None
+        """
+        self._create_type(GraphEntity.iri_print_object)
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/graph/entities/bibliographic/responsible_agent.py` & `oc_ocdm-8.1.0/oc_ocdm/graph/entities/bibliographic/responsible_agent.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,217 +1,217 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-from oc_ocdm.decorators import accepts_only
-
-if TYPE_CHECKING:
-    from typing import Optional, List
-    from rdflib import URIRef
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.graph.entities.bibliographic_entity import BibliographicEntity
-
-
-class ResponsibleAgent(BibliographicEntity):
-    """Responsible agent (short: ra): the agent (usually a person or an organisation) having
-       a certain role with respect to a bibliographic resource (e.g. an author of a paper or
-       book, or an editor of a journal)."""
-
-    @accepts_only('ra')
-    def merge(self, other: ResponsibleAgent) -> None:
-        """
-        The merge operation allows combining two ``ResponsibleAgent`` entities into a single one,
-        by marking the second entity as to be deleted while also copying its data into the current
-        ``ResponsibleAgent``. Moreover, every triple from the containing ``GraphSet`` referring to the second
-        entity gets "redirected" to the current entity: **every other reference contained inside a
-        different source (e.g. a triplestore) must be manually handled by the user!**
-
-        In case of functional properties, values from the current entity get overwritten
-        by those coming from the second entity while, in all other cases, values from the
-        second entity are simply appended to those of the current entity. In this context,
-        ``rdfs:label`` is considered as a functional property, while ``rdf:type`` is not.
-
-        :param other: The entity which will be marked as to be deleted and whose properties will
-         be merged into the current entity.
-        :type other: ResponsibleAgent
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        super(ResponsibleAgent, self).merge(other)
-
-        name: Optional[str] = other.get_name()
-        if name is not None:
-            self.has_name(name)
-
-        given_name: Optional[str] = other.get_given_name()
-        if given_name is not None:
-            self.has_given_name(given_name)
-
-        family_name: Optional[str] = other.get_family_name()
-        if family_name is not None:
-            self.has_family_name(family_name)
-
-        related_agents: List[URIRef] = other.get_related_agents()
-        for cur_agent in related_agents:
-            self.has_related_agent(cur_agent)
-
-    # HAS NAME
-    def get_name(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``foaf:name`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(GraphEntity.iri_name)
-
-    @accepts_only('literal')
-    def has_name(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``foaf:name`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The name of an agent (for people, usually in the format: given name followed by family
-        name, separated by a space).`
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_name()
-        self._create_literal(GraphEntity.iri_name, string)
-
-    def remove_name(self) -> None:
-        """
-        Remover method corresponding to the ``foaf:name`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_name, None))
-
-    # HAS GIVEN NAME
-    def get_given_name(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``foaf:givenName`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(GraphEntity.iri_given_name)
-
-    @accepts_only('literal')
-    def has_given_name(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``foaf:givenName`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The given name of an agent, if a person.`
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_given_name()
-        self._create_literal(GraphEntity.iri_given_name, string)
-
-    def remove_given_name(self) -> None:
-        """
-        Remover method corresponding to the ``foaf:givenName`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_given_name, None))
-
-    # HAS FAMILY NAME
-    def get_family_name(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``foaf:familyName`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(GraphEntity.iri_family_name)
-
-    @accepts_only('literal')
-    def has_family_name(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``foaf:familyName`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The family name of an agent, if a person.`
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_family_name()
-        self._create_literal(GraphEntity.iri_family_name, string)
-
-    def remove_family_name(self) -> None:
-        """
-        Remover method corresponding to the ``foaf:familyName`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_family_name, None))
-
-    # HAS RELATED AGENT
-    def get_related_agents(self) -> List[URIRef]:
-        """
-        Getter method corresponding to the ``dcterms:relation`` RDF predicate.
-
-        :return: A list containing the requested values if found, None otherwise
-        """
-        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_relation)
-        return uri_list
-
-    @accepts_only('thing')
-    def has_related_agent(self, thing_res: URIRef) -> None:
-        """
-        Setter method corresponding to the ``dcterms:relation`` RDF predicate.
-
-        `An external agent that/who is related in some relevant way with this responsible agent
-        (e.g. for inter-linking purposes).`
-
-        :param thing_res: The value that will be set as the object of the property related to this method
-        :type thing_res: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.g.add((self.res, GraphEntity.iri_relation, thing_res))
-
-    @accepts_only('thing')
-    def remove_related_agent(self, thing_res: URIRef = None) -> None:
-        """
-        Remover method corresponding to the ``dcterms:relation`` RDF predicate.
-
-        **WARNING: this is a non-functional property, hence, if the parameter
-        is None, any existing value will be removed!**
-
-        :param thing_res: If not None, the specific object value that will be removed from the property
-         related to this method (defaults to None)
-        :type thing_res: URIRef
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        if thing_res is not None:
-            self.g.remove((self.res, GraphEntity.iri_relation, thing_res))
-        else:
-            self.g.remove((self.res, GraphEntity.iri_relation, None))
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+from oc_ocdm.decorators import accepts_only
+
+if TYPE_CHECKING:
+    from typing import Optional, List
+    from rdflib import URIRef
+from oc_ocdm.graph.graph_entity import GraphEntity
+from oc_ocdm.graph.entities.bibliographic_entity import BibliographicEntity
+
+
+class ResponsibleAgent(BibliographicEntity):
+    """Responsible agent (short: ra): the agent (usually a person or an organisation) having
+       a certain role with respect to a bibliographic resource (e.g. an author of a paper or
+       book, or an editor of a journal)."""
+
+    @accepts_only('ra')
+    def merge(self, other: ResponsibleAgent) -> None:
+        """
+        The merge operation allows combining two ``ResponsibleAgent`` entities into a single one,
+        by marking the second entity as to be deleted while also copying its data into the current
+        ``ResponsibleAgent``. Moreover, every triple from the containing ``GraphSet`` referring to the second
+        entity gets "redirected" to the current entity: **every other reference contained inside a
+        different source (e.g. a triplestore) must be manually handled by the user!**
+
+        In case of functional properties, values from the current entity get overwritten
+        by those coming from the second entity while, in all other cases, values from the
+        second entity are simply appended to those of the current entity. In this context,
+        ``rdfs:label`` is considered as a functional property, while ``rdf:type`` is not.
+
+        :param other: The entity which will be marked as to be deleted and whose properties will
+         be merged into the current entity.
+        :type other: ResponsibleAgent
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        super(ResponsibleAgent, self).merge(other)
+
+        name: Optional[str] = other.get_name()
+        if name is not None:
+            self.has_name(name)
+
+        given_name: Optional[str] = other.get_given_name()
+        if given_name is not None:
+            self.has_given_name(given_name)
+
+        family_name: Optional[str] = other.get_family_name()
+        if family_name is not None:
+            self.has_family_name(family_name)
+
+        related_agents: List[URIRef] = other.get_related_agents()
+        for cur_agent in related_agents:
+            self.has_related_agent(cur_agent)
+
+    # HAS NAME
+    def get_name(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``foaf:name`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(GraphEntity.iri_name)
+
+    @accepts_only('literal')
+    def has_name(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``foaf:name`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The name of an agent (for people, usually in the format: given name followed by family
+        name, separated by a space).`
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_name()
+        self._create_literal(GraphEntity.iri_name, string)
+
+    def remove_name(self) -> None:
+        """
+        Remover method corresponding to the ``foaf:name`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_name, None))
+
+    # HAS GIVEN NAME
+    def get_given_name(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``foaf:givenName`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(GraphEntity.iri_given_name)
+
+    @accepts_only('literal')
+    def has_given_name(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``foaf:givenName`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The given name of an agent, if a person.`
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_given_name()
+        self._create_literal(GraphEntity.iri_given_name, string)
+
+    def remove_given_name(self) -> None:
+        """
+        Remover method corresponding to the ``foaf:givenName`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_given_name, None))
+
+    # HAS FAMILY NAME
+    def get_family_name(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``foaf:familyName`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(GraphEntity.iri_family_name)
+
+    @accepts_only('literal')
+    def has_family_name(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``foaf:familyName`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The family name of an agent, if a person.`
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_family_name()
+        self._create_literal(GraphEntity.iri_family_name, string)
+
+    def remove_family_name(self) -> None:
+        """
+        Remover method corresponding to the ``foaf:familyName`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_family_name, None))
+
+    # HAS RELATED AGENT
+    def get_related_agents(self) -> List[URIRef]:
+        """
+        Getter method corresponding to the ``dcterms:relation`` RDF predicate.
+
+        :return: A list containing the requested values if found, None otherwise
+        """
+        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_relation)
+        return uri_list
+
+    @accepts_only('thing')
+    def has_related_agent(self, thing_res: URIRef) -> None:
+        """
+        Setter method corresponding to the ``dcterms:relation`` RDF predicate.
+
+        `An external agent that/who is related in some relevant way with this responsible agent
+        (e.g. for inter-linking purposes).`
+
+        :param thing_res: The value that will be set as the object of the property related to this method
+        :type thing_res: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.g.add((self.res, GraphEntity.iri_relation, thing_res))
+
+    @accepts_only('thing')
+    def remove_related_agent(self, thing_res: URIRef = None) -> None:
+        """
+        Remover method corresponding to the ``dcterms:relation`` RDF predicate.
+
+        **WARNING: this is a non-functional property, hence, if the parameter
+        is None, any existing value will be removed!**
+
+        :param thing_res: If not None, the specific object value that will be removed from the property
+         related to this method (defaults to None)
+        :type thing_res: URIRef
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        if thing_res is not None:
+            self.g.remove((self.res, GraphEntity.iri_relation, thing_res))
+        else:
+            self.g.remove((self.res, GraphEntity.iri_relation, None))
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/graph/entities/bibliographic_entity.py` & `oc_ocdm-8.1.0/oc_ocdm/graph/entities/bibliographic_entity.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,139 +1,139 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-from oc_ocdm.decorators import accepts_only
-
-if TYPE_CHECKING:
-    from typing import List, Dict, Optional
-    from rdflib import URIRef
-    from oc_ocdm.graph.entities.identifier import Identifier
-from oc_ocdm.graph.graph_entity import GraphEntity
-
-
-class BibliographicEntity(GraphEntity):
-    """The base class for each bibliographic entity of the OpenCitations DataModel (OCDM)."""
-
-    def merge(self, other: BibliographicEntity) -> None:
-        """
-        **WARNING:** ``BibliographicEntity`` **is an abstract class that cannot be instantiated at runtime.
-        As such, it's only possible to execute this method on entities generated from**
-        ``BibliographicEntity``'s **subclasses. Please, refer to their documentation of the** `merge` **method.**
-
-        :param other: The entity which will be marked as to be deleted and whose properties will
-         be merged into the current entity.
-        :type other: BibliographicEntity
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        super(BibliographicEntity, self).merge(other)
-
-        id_list: List[Identifier] = other.get_identifiers()
-        for cur_id in id_list:
-            self.has_identifier(cur_id)
-
-        # The special semantics associated to the identifiers
-        # of a bibliographic entity requires them to be uniquely
-        # defined based on their scheme and literal value:
-        self.remove_duplicated_identifiers()
-
-    # HAS IDENTIFIER
-    def get_identifiers(self) -> List[Identifier]:
-        """
-        Getter method corresponding to the ``datacite:hasIdentifier`` RDF predicate.
-
-        :return: A list containing the requested values if found, None otherwise
-        """
-        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_has_identifier, 'id')
-        result: List[Identifier] = []
-        for uri in uri_list:
-            result.append(self.g_set.add_id(self.resp_agent, self.source, uri))
-        return result
-
-    @accepts_only('id')
-    def has_identifier(self, id_res: Identifier) -> None:
-        """
-        Setter method corresponding to the ``datacite:hasIdentifier`` RDF predicate.
-
-        `In addition to the internal dataset identifier assigned to the entity upon initial
-        curation (format: [entity short name]/[local identifier]), other external third-party
-        identifiers can be specified through this attribute (e.g. DOI, ORCID, PubMedID).`
-
-        :param id_res: The value that will be set as the object of the property related to this method
-        :type id_res: Identifier
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.g.add((self.res, GraphEntity.iri_has_identifier, id_res.res))
-
-    @accepts_only('id')
-    def remove_identifier(self, id_res: Identifier = None) -> None:
-        """
-        Remover method corresponding to the ``datacite:hasIdentifier`` RDF predicate.
-
-        **WARNING: this is a non-functional property, hence, if the parameter
-        is None, any existing value will be removed!**
-
-        :param id_res: If not None, the specific object value that will be removed from the property
-         related to this method (defaults to None)
-        :type id_res: Identifier
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        if id_res is not None:
-            self.g.remove((self.res, GraphEntity.iri_has_identifier, id_res.res))
-        else:
-            self.g.remove((self.res, GraphEntity.iri_has_identifier, None))
-
-    def remove_duplicated_identifiers(self) -> None:
-        """
-        Utility function that automatically scans the list of Identifier entities associated to the
-        current bibliographic entity (through the ``datacite:hasIdentifier`` RDF predicate) and it removes
-        duplicated entries.
-
-        Two distinct ``Identifier`` entities are considered the same if they share both
-        the scheme (``datacite:usesIdentifierScheme``) and the literal value (``literal:hasLiteralValue``).
-
-        :return: None
-        """
-
-        # Identifiers should be merged based on the
-        # correspondence between both their scheme and literal value!
-        id_list: List[Identifier] = self.get_identifiers()
-        # We remove every identifier from 'self': only unique ones
-        # will be re-associated with 'self'.
-        self.remove_identifier()
-
-        # We use a nested dictionary which associates the 'schema-literal_value'
-        # pair to the corresponding identifier object
-        # (ex. id_dict[ISSN][1234-5678] <- base_iri:id/34).
-        id_dict: Dict[URIRef, Dict[str, Identifier]] = {}
-        for identifier in id_list:
-            schema: Optional[URIRef] = identifier.get_scheme()
-            literal_value: Optional[str] = identifier.get_literal_value()
-            if schema is not None and literal_value is not None:
-                if schema not in id_dict:
-                    id_dict[schema] = {literal_value: identifier}
-                    self.has_identifier(identifier)  # the Identifier is kept!
-                else:
-                    if literal_value not in id_dict[schema]:
-                        id_dict[schema][literal_value] = identifier
-                        self.has_identifier(identifier)  # the Identifier is kept!
-                    else:
-                        id_to_be_kept: Identifier = id_dict[schema][literal_value]
-                        id_to_be_kept.merge(identifier)  # the Identifier is dropped!
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+from oc_ocdm.decorators import accepts_only
+
+if TYPE_CHECKING:
+    from typing import List, Dict, Optional
+    from rdflib import URIRef
+    from oc_ocdm.graph.entities.identifier import Identifier
+from oc_ocdm.graph.graph_entity import GraphEntity
+
+
+class BibliographicEntity(GraphEntity):
+    """The base class for each bibliographic entity of the OpenCitations DataModel (OCDM)."""
+
+    def merge(self, other: BibliographicEntity) -> None:
+        """
+        **WARNING:** ``BibliographicEntity`` **is an abstract class that cannot be instantiated at runtime.
+        As such, it's only possible to execute this method on entities generated from**
+        ``BibliographicEntity``'s **subclasses. Please, refer to their documentation of the** `merge` **method.**
+
+        :param other: The entity which will be marked as to be deleted and whose properties will
+         be merged into the current entity.
+        :type other: BibliographicEntity
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        super(BibliographicEntity, self).merge(other)
+
+        id_list: List[Identifier] = other.get_identifiers()
+        for cur_id in id_list:
+            self.has_identifier(cur_id)
+
+        # The special semantics associated to the identifiers
+        # of a bibliographic entity requires them to be uniquely
+        # defined based on their scheme and literal value:
+        self.remove_duplicated_identifiers()
+
+    # HAS IDENTIFIER
+    def get_identifiers(self) -> List[Identifier]:
+        """
+        Getter method corresponding to the ``datacite:hasIdentifier`` RDF predicate.
+
+        :return: A list containing the requested values if found, None otherwise
+        """
+        uri_list: List[URIRef] = self._get_multiple_uri_references(GraphEntity.iri_has_identifier, 'id')
+        result: List[Identifier] = []
+        for uri in uri_list:
+            result.append(self.g_set.add_id(self.resp_agent, self.source, uri))
+        return result
+
+    @accepts_only('id')
+    def has_identifier(self, id_res: Identifier) -> None:
+        """
+        Setter method corresponding to the ``datacite:hasIdentifier`` RDF predicate.
+
+        `In addition to the internal dataset identifier assigned to the entity upon initial
+        curation (format: [entity short name]/[local identifier]), other external third-party
+        identifiers can be specified through this attribute (e.g. DOI, ORCID, PubMedID).`
+
+        :param id_res: The value that will be set as the object of the property related to this method
+        :type id_res: Identifier
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.g.add((self.res, GraphEntity.iri_has_identifier, id_res.res))
+
+    @accepts_only('id')
+    def remove_identifier(self, id_res: Identifier = None) -> None:
+        """
+        Remover method corresponding to the ``datacite:hasIdentifier`` RDF predicate.
+
+        **WARNING: this is a non-functional property, hence, if the parameter
+        is None, any existing value will be removed!**
+
+        :param id_res: If not None, the specific object value that will be removed from the property
+         related to this method (defaults to None)
+        :type id_res: Identifier
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        if id_res is not None:
+            self.g.remove((self.res, GraphEntity.iri_has_identifier, id_res.res))
+        else:
+            self.g.remove((self.res, GraphEntity.iri_has_identifier, None))
+
+    def remove_duplicated_identifiers(self) -> None:
+        """
+        Utility function that automatically scans the list of Identifier entities associated to the
+        current bibliographic entity (through the ``datacite:hasIdentifier`` RDF predicate) and it removes
+        duplicated entries.
+
+        Two distinct ``Identifier`` entities are considered the same if they share both
+        the scheme (``datacite:usesIdentifierScheme``) and the literal value (``literal:hasLiteralValue``).
+
+        :return: None
+        """
+
+        # Identifiers should be merged based on the
+        # correspondence between both their scheme and literal value!
+        id_list: List[Identifier] = self.get_identifiers()
+        # We remove every identifier from 'self': only unique ones
+        # will be re-associated with 'self'.
+        self.remove_identifier()
+
+        # We use a nested dictionary which associates the 'schema-literal_value'
+        # pair to the corresponding identifier object
+        # (ex. id_dict[ISSN][1234-5678] <- base_iri:id/34).
+        id_dict: Dict[URIRef, Dict[str, Identifier]] = {}
+        for identifier in id_list:
+            schema: Optional[URIRef] = identifier.get_scheme()
+            literal_value: Optional[str] = identifier.get_literal_value()
+            if schema is not None and literal_value is not None:
+                if schema not in id_dict:
+                    id_dict[schema] = {literal_value: identifier}
+                    self.has_identifier(identifier)  # the Identifier is kept!
+                else:
+                    if literal_value not in id_dict[schema]:
+                        id_dict[schema][literal_value] = identifier
+                        self.has_identifier(identifier)  # the Identifier is kept!
+                    else:
+                        id_to_be_kept: Identifier = id_dict[schema][literal_value]
+                        id_to_be_kept.merge(identifier)  # the Identifier is dropped!
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/graph/entities/identifier.py` & `oc_ocdm-8.1.0/oc_ocdm/graph/entities/identifier.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,434 +1,434 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-import re
-from typing import TYPE_CHECKING
-
-if TYPE_CHECKING:
-    from typing import Optional
-    from rdflib import URIRef
-
-from oc_ocdm.decorators import accepts_only
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.support.support import encode_url, is_string_empty
-
-
-class Identifier(GraphEntity):
-    """Identifier (short: id): an external identifier (e.g. DOI, ORCID, PubMedID, Open
-       Citation Identifier) associated with the bibliographic entity. Members of this class of
-       metadata are themselves given unique corpus identifiers e.g. 'id/0420129'."""
-
-    @accepts_only('id')
-    def merge(self, other: Identifier):
-        """
-        The merge operation allows combining two ``Identifier`` entities into a single one,
-        by marking the second entity as to be deleted while also copying its data into the current
-        ``Identifier``. Moreover, every triple from the containing ``GraphSet`` referring to the second
-        entity gets "redirected" to the current entity: **every other reference contained inside a
-        different source (e.g. a triplestore) must be manually handled by the user!**
-
-        In case of functional properties, values from the current entity get overwritten
-        by those coming from the second entity while, in all other cases, values from the
-        second entity are simply appended to those of the current entity. In this context,
-        ``rdfs:label`` is considered as a functional property, while ``rdf:type`` is not.
-
-        :param other: The entity which will be marked as to be deleted and whose properties will
-         be merged into the current entity.
-        :type other: Identifier
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        super(Identifier, self).merge(other)
-
-        literal_value: Optional[str] = other.get_literal_value()
-        scheme: Optional[URIRef] = other.get_scheme()
-        if literal_value is not None and scheme is not None:
-            self._associate_identifier_with_scheme(literal_value, scheme)
-
-    # HAS LITERAL VALUE and HAS SCHEME
-    def get_literal_value(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``literal:hasLiteralValue`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(GraphEntity.iri_has_literal_value)
-
-    def get_scheme(self) -> Optional[URIRef]:
-        """
-        Getter method corresponding to the ``datacite:usesIdentifierScheme`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_uses_identifier_scheme)
-        return uri
-
-    @accepts_only('literal')
-    def create_oci(self, string: str) -> None:
-        """
-        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-        It implicitly sets the object value ``datacite:oci`` for the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self._associate_identifier_with_scheme(string, GraphEntity.iri_oci)
-
-    @accepts_only('literal')
-    def create_orcid(self, string: str) -> None:
-        """
-        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-        It implicitly sets the object value ``datacite:orcid`` for the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self._associate_identifier_with_scheme(string, GraphEntity.iri_orcid)
-
-    @accepts_only('literal')
-    def create_openalex(self, string: str) -> None:
-        """
-        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-        It implicitly sets the object value ``datacite:openalex`` for the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self._associate_identifier_with_scheme(string, GraphEntity.iri_openalex)
-
-    @accepts_only('literal')
-    def create_doi(self, string: str) -> None:
-        """
-        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-        It implicitly sets the object value ``datacite:doi`` for the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-
-        The string gets internally preprocessed by converting it to lowercase
-        (e.g. 'DOI:10.1111/HEX.12487' becomes 'doi:10.1111/hex.12487').
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self._associate_identifier_with_scheme(string.lower(), GraphEntity.iri_doi)
-
-    @accepts_only('literal')
-    def create_jid(self, string: str) -> None:
-        """
-        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-        It implicitly sets the object value ``datacite:jid`` for the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self._associate_identifier_with_scheme(string, GraphEntity.iri_jid)
-
-    @accepts_only('literal')
-    def create_pmid(self, string: str) -> None:
-        """
-        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-        It implicitly sets the object value ``datacite:pmid`` for the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self._associate_identifier_with_scheme(string, GraphEntity.iri_pmid)
-
-    @accepts_only('literal')
-    def create_pmcid(self, string: str) -> None:
-        """
-        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-        It implicitly sets the object value ``datacite:pmcid`` for the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self._associate_identifier_with_scheme(string, GraphEntity.iri_pmcid)
-
-    @accepts_only('literal')
-    def create_issn(self, string: str) -> None:
-        """
-        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-        It implicitly sets the object value ``datacite:issn`` for the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-
-        The string gets internally preprocessed by eventually replacing long dashes with short ones
-        (e.g. '1522–4501' becomes '1522-4501').
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        :param string: The value that will be set as the object of the property related to this method. **It
-          must be a string different from '0000-0000'.**
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        cur_string = re.sub("–", "-", string)
-        if cur_string != "0000-0000":
-            self._associate_identifier_with_scheme(string, GraphEntity.iri_issn)
-
-    @accepts_only('literal')
-    def create_isbn(self, string: str) -> None:
-        """
-        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-        It implicitly sets the object value ``datacite:isbn`` for the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-
-        The string gets internally preprocessed by eventually replacing long dashes with short ones
-        (e.g. '817525766–0' becomes '817525766-0').
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self._associate_identifier_with_scheme(re.sub("–", "-", string), GraphEntity.iri_isbn)
-
-    @accepts_only('literal')
-    def create_url(self, string: str) -> None:
-        """
-        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-        It implicitly sets the object value ``datacite:url`` for the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-
-        The string gets internally preprocessed both by converting it to lowercase
-        (e.g. 'https://OPENCITATIONS.NET/' becomes 'https://opencitations.net/') and by
-        applying `URL encoding` on it (e.g. 'https://opencitations.net/file name.txt'
-        becomes 'https://opencitations.net/file%20name.txt').
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self._associate_identifier_with_scheme(encode_url(string.lower()), GraphEntity.iri_url)
-
-    @accepts_only('literal')
-    def create_xpath(self, string: str) -> None:
-        """
-        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-        It implicitly sets the object value `datacite:local-resource-identifier-scheme` for the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self._associate_identifier_with_scheme(string, GraphEntity.iri_xpath)
-
-    @accepts_only('literal')
-    def create_intrepid(self, string: str) -> None:
-        """
-        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-        It implicitly sets the object value ``datacite:intrepid`` for the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self._associate_identifier_with_scheme(string, GraphEntity.iri_intrepid)
-
-    @accepts_only('literal')
-    def create_xmlid(self, string: str) -> None:
-        """
-        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-        It implicitly sets the object value `datacite:local-resource-identifier-scheme` for the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self._associate_identifier_with_scheme(string, GraphEntity.iri_xmlid)
-
-    @accepts_only('literal')
-    def create_wikidata(self, string: str) -> None:
-        """
-        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-        It implicitly sets the object value ``datacite:wikidata`` for the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self._associate_identifier_with_scheme(string, GraphEntity.iri_wikidata)
-
-    @accepts_only('literal')
-    def create_wikipedia(self, string: str) -> None:
-        """
-        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-        It implicitly sets the object value ``datacite:wikipedia`` for the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self._associate_identifier_with_scheme(string, GraphEntity.iri_wikipedia)
-
-    @accepts_only('literal')
-    def create_arxiv(self, string: str) -> None:
-        """
-        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-        It implicitly sets the object value ``datacite:crossref`` for the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self._associate_identifier_with_scheme(string, GraphEntity.iri_arxiv)
-
-    @accepts_only('literal')
-    def create_crossref(self, string: str) -> None:
-        """
-        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-        It implicitly sets the object value ``datacite:crossref`` for the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self._associate_identifier_with_scheme(string, GraphEntity.iri_crossref)
-
-    @accepts_only('literal')
-    def create_datacite(self, string: str) -> None:
-        """
-        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-        It implicitly sets the object value ``datacite:datacite`` for the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self._associate_identifier_with_scheme(string, GraphEntity.iri_datacite)
-
-    @accepts_only('literal')
-    def create_viaf(self, string: str) -> None:
-        """
-        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-        It implicitly sets the object value ``datacite:viaf`` for the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self._associate_identifier_with_scheme(string, GraphEntity.iri_viaf)
-
-    def _associate_identifier_with_scheme(self, string: str, id_type: URIRef) -> None:
-        if not is_string_empty(string):
-            self.remove_identifier_with_scheme()
-            self._create_literal(GraphEntity.iri_has_literal_value, string)
-            self.g.add((self.res, GraphEntity.iri_uses_identifier_scheme, id_type))
-
-    def remove_identifier_with_scheme(self) -> None:
-        """
-        Remover method corresponding to both the ``literal:hasLiteralValue`` and the
-        ``datacite:usesIdentifierScheme`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, GraphEntity.iri_has_literal_value, None))
-        self.g.remove((self.res, GraphEntity.iri_uses_identifier_scheme, None))
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+import re
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from typing import Optional
+    from rdflib import URIRef
+
+from oc_ocdm.decorators import accepts_only
+from oc_ocdm.graph.graph_entity import GraphEntity
+from oc_ocdm.support.support import encode_url, is_string_empty
+
+
+class Identifier(GraphEntity):
+    """Identifier (short: id): an external identifier (e.g. DOI, ORCID, PubMedID, Open
+       Citation Identifier) associated with the bibliographic entity. Members of this class of
+       metadata are themselves given unique corpus identifiers e.g. 'id/0420129'."""
+
+    @accepts_only('id')
+    def merge(self, other: Identifier):
+        """
+        The merge operation allows combining two ``Identifier`` entities into a single one,
+        by marking the second entity as to be deleted while also copying its data into the current
+        ``Identifier``. Moreover, every triple from the containing ``GraphSet`` referring to the second
+        entity gets "redirected" to the current entity: **every other reference contained inside a
+        different source (e.g. a triplestore) must be manually handled by the user!**
+
+        In case of functional properties, values from the current entity get overwritten
+        by those coming from the second entity while, in all other cases, values from the
+        second entity are simply appended to those of the current entity. In this context,
+        ``rdfs:label`` is considered as a functional property, while ``rdf:type`` is not.
+
+        :param other: The entity which will be marked as to be deleted and whose properties will
+         be merged into the current entity.
+        :type other: Identifier
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        super(Identifier, self).merge(other)
+
+        literal_value: Optional[str] = other.get_literal_value()
+        scheme: Optional[URIRef] = other.get_scheme()
+        if literal_value is not None and scheme is not None:
+            self._associate_identifier_with_scheme(literal_value, scheme)
+
+    # HAS LITERAL VALUE and HAS SCHEME
+    def get_literal_value(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``literal:hasLiteralValue`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(GraphEntity.iri_has_literal_value)
+
+    def get_scheme(self) -> Optional[URIRef]:
+        """
+        Getter method corresponding to the ``datacite:usesIdentifierScheme`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        uri: Optional[URIRef] = self._get_uri_reference(GraphEntity.iri_uses_identifier_scheme)
+        return uri
+
+    @accepts_only('literal')
+    def create_oci(self, string: str) -> None:
+        """
+        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+        It implicitly sets the object value ``datacite:oci`` for the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self._associate_identifier_with_scheme(string, GraphEntity.iri_oci)
+
+    @accepts_only('literal')
+    def create_orcid(self, string: str) -> None:
+        """
+        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+        It implicitly sets the object value ``datacite:orcid`` for the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self._associate_identifier_with_scheme(string, GraphEntity.iri_orcid)
+
+    @accepts_only('literal')
+    def create_openalex(self, string: str) -> None:
+        """
+        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+        It implicitly sets the object value ``datacite:openalex`` for the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self._associate_identifier_with_scheme(string, GraphEntity.iri_openalex)
+
+    @accepts_only('literal')
+    def create_doi(self, string: str) -> None:
+        """
+        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+        It implicitly sets the object value ``datacite:doi`` for the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+
+        The string gets internally preprocessed by converting it to lowercase
+        (e.g. 'DOI:10.1111/HEX.12487' becomes 'doi:10.1111/hex.12487').
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self._associate_identifier_with_scheme(string.lower(), GraphEntity.iri_doi)
+
+    @accepts_only('literal')
+    def create_jid(self, string: str) -> None:
+        """
+        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+        It implicitly sets the object value ``datacite:jid`` for the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self._associate_identifier_with_scheme(string, GraphEntity.iri_jid)
+
+    @accepts_only('literal')
+    def create_pmid(self, string: str) -> None:
+        """
+        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+        It implicitly sets the object value ``datacite:pmid`` for the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self._associate_identifier_with_scheme(string, GraphEntity.iri_pmid)
+
+    @accepts_only('literal')
+    def create_pmcid(self, string: str) -> None:
+        """
+        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+        It implicitly sets the object value ``datacite:pmcid`` for the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self._associate_identifier_with_scheme(string, GraphEntity.iri_pmcid)
+
+    @accepts_only('literal')
+    def create_issn(self, string: str) -> None:
+        """
+        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+        It implicitly sets the object value ``datacite:issn`` for the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+
+        The string gets internally preprocessed by eventually replacing long dashes with short ones
+        (e.g. '1522–4501' becomes '1522-4501').
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        :param string: The value that will be set as the object of the property related to this method. **It
+          must be a string different from '0000-0000'.**
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        cur_string = re.sub("–", "-", string)
+        if cur_string != "0000-0000":
+            self._associate_identifier_with_scheme(string, GraphEntity.iri_issn)
+
+    @accepts_only('literal')
+    def create_isbn(self, string: str) -> None:
+        """
+        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+        It implicitly sets the object value ``datacite:isbn`` for the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+
+        The string gets internally preprocessed by eventually replacing long dashes with short ones
+        (e.g. '817525766–0' becomes '817525766-0').
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self._associate_identifier_with_scheme(re.sub("–", "-", string), GraphEntity.iri_isbn)
+
+    @accepts_only('literal')
+    def create_url(self, string: str) -> None:
+        """
+        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+        It implicitly sets the object value ``datacite:url`` for the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+
+        The string gets internally preprocessed both by converting it to lowercase
+        (e.g. 'https://OPENCITATIONS.NET/' becomes 'https://opencitations.net/') and by
+        applying `URL encoding` on it (e.g. 'https://opencitations.net/file name.txt'
+        becomes 'https://opencitations.net/file%20name.txt').
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self._associate_identifier_with_scheme(encode_url(string.lower()), GraphEntity.iri_url)
+
+    @accepts_only('literal')
+    def create_xpath(self, string: str) -> None:
+        """
+        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+        It implicitly sets the object value `datacite:local-resource-identifier-scheme` for the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self._associate_identifier_with_scheme(string, GraphEntity.iri_xpath)
+
+    @accepts_only('literal')
+    def create_intrepid(self, string: str) -> None:
+        """
+        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+        It implicitly sets the object value ``datacite:intrepid`` for the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self._associate_identifier_with_scheme(string, GraphEntity.iri_intrepid)
+
+    @accepts_only('literal')
+    def create_xmlid(self, string: str) -> None:
+        """
+        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+        It implicitly sets the object value `datacite:local-resource-identifier-scheme` for the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self._associate_identifier_with_scheme(string, GraphEntity.iri_xmlid)
+
+    @accepts_only('literal')
+    def create_wikidata(self, string: str) -> None:
+        """
+        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+        It implicitly sets the object value ``datacite:wikidata`` for the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self._associate_identifier_with_scheme(string, GraphEntity.iri_wikidata)
+
+    @accepts_only('literal')
+    def create_wikipedia(self, string: str) -> None:
+        """
+        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+        It implicitly sets the object value ``datacite:wikipedia`` for the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self._associate_identifier_with_scheme(string, GraphEntity.iri_wikipedia)
+
+    @accepts_only('literal')
+    def create_arxiv(self, string: str) -> None:
+        """
+        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+        It implicitly sets the object value ``datacite:crossref`` for the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self._associate_identifier_with_scheme(string, GraphEntity.iri_arxiv)
+
+    @accepts_only('literal')
+    def create_crossref(self, string: str) -> None:
+        """
+        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+        It implicitly sets the object value ``datacite:crossref`` for the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self._associate_identifier_with_scheme(string, GraphEntity.iri_crossref)
+
+    @accepts_only('literal')
+    def create_datacite(self, string: str) -> None:
+        """
+        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+        It implicitly sets the object value ``datacite:datacite`` for the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self._associate_identifier_with_scheme(string, GraphEntity.iri_datacite)
+
+    @accepts_only('literal')
+    def create_viaf(self, string: str) -> None:
+        """
+        Setter method corresponding to both the ``literal:hasLiteralValue`` and the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+        It implicitly sets the object value ``datacite:viaf`` for the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self._associate_identifier_with_scheme(string, GraphEntity.iri_viaf)
+
+    def _associate_identifier_with_scheme(self, string: str, id_type: URIRef) -> None:
+        if not is_string_empty(string):
+            self.remove_identifier_with_scheme()
+            self._create_literal(GraphEntity.iri_has_literal_value, string)
+            self.g.add((self.res, GraphEntity.iri_uses_identifier_scheme, id_type))
+
+    def remove_identifier_with_scheme(self) -> None:
+        """
+        Remover method corresponding to both the ``literal:hasLiteralValue`` and the
+        ``datacite:usesIdentifierScheme`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, GraphEntity.iri_has_literal_value, None))
+        self.g.remove((self.res, GraphEntity.iri_uses_identifier_scheme, None))
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/graph/graph_entity.py` & `oc_ocdm-8.1.0/oc_ocdm/graph/graph_entity.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,304 +1,304 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-from rdflib import Graph, Namespace, URIRef
-
-from oc_ocdm.abstract_entity import AbstractEntity
-
-if TYPE_CHECKING:
-    from typing import ClassVar, Dict, List, Optional, Tuple
-
-    from oc_ocdm.graph.graph_set import GraphSet
-
-
-class GraphEntity(AbstractEntity):
-    BIRO: ClassVar[Namespace] = Namespace("http://purl.org/spar/biro/")
-    C4O: ClassVar[Namespace] = Namespace("http://purl.org/spar/c4o/")
-    CO: ClassVar[Namespace] = Namespace("http://purl.org/co/")
-    CITO: ClassVar[Namespace] = Namespace("http://purl.org/spar/cito/")
-    DATACITE: ClassVar[Namespace] = Namespace("http://purl.org/spar/datacite/")
-    DCTERMS: ClassVar[Namespace] = Namespace("http://purl.org/dc/terms/")
-    DEO: ClassVar[Namespace] = Namespace("http://purl.org/spar/deo/")
-    DOCO: ClassVar[Namespace] = Namespace("http://purl.org/spar/doco/")
-    FABIO: ClassVar[Namespace] = Namespace("http://purl.org/spar/fabio/")
-    FOAF: ClassVar[Namespace] = Namespace("http://xmlns.com/foaf/0.1/")
-    FR: ClassVar[Namespace] = Namespace("http://purl.org/spar/fr/")
-    FRBR: ClassVar[Namespace] = Namespace("http://purl.org/vocab/frbr/core#")
-    LITERAL: ClassVar[Namespace] = Namespace("http://www.essepuntato.it/2010/06/literalreification/")
-    OA: ClassVar[Namespace] = Namespace("http://www.w3.org/ns/oa#")
-    OCO: ClassVar[Namespace] = Namespace("https://w3id.org/oc/ontology/")
-    PRISM: ClassVar[Namespace] = Namespace("http://prismstandard.org/namespaces/basic/2.0/")
-    PRO: ClassVar[Namespace] = Namespace("http://purl.org/spar/pro/")
-
-    iri_has_subtitle: ClassVar[URIRef] = FABIO.hasSubtitle
-    iri_has_publication_date: ClassVar[URIRef] = PRISM.publicationDate
-    iri_bibliographic_reference: ClassVar[URIRef] = BIRO.BibliographicReference
-    iri_references: ClassVar[URIRef] = BIRO.references
-    iri_denotes: ClassVar[URIRef] = C4O.denotes
-    iri_has_content: ClassVar[URIRef] = C4O.hasContent
-    iri_intextref_pointer: ClassVar[URIRef] = C4O.InTextReferencePointer
-    iri_is_context_of: ClassVar[URIRef] = C4O.isContextOf
-    iri_singleloc_pointer_list: ClassVar[URIRef] = C4O.SingleLocationPointerList
-    iri_has_element: ClassVar[URIRef] = CO.element
-    iri_citation: ClassVar[URIRef] = CITO.Citation
-    iri_cites: ClassVar[URIRef] = CITO.cites
-    iri_citation_characterisation: ClassVar[URIRef] = CITO.hasCitationCharacterisation
-    iri_has_citing_entity: ClassVar[URIRef] = CITO.hasCitingEntity
-    iri_has_cited_entity: ClassVar[URIRef] = CITO.hasCitedEntity
-    iri_openalex: ClassVar[URIRef] = DATACITE.openalex
-    iri_arxiv: ClassVar[URIRef] = DATACITE.arxiv
-    iri_oci: ClassVar[URIRef] = DATACITE.oci
-    iri_doi: ClassVar[URIRef] = DATACITE.doi
-    iri_pmid: ClassVar[URIRef] = DATACITE.pmid
-    iri_pmcid: ClassVar[URIRef] = DATACITE.pmcid
-    iri_orcid: ClassVar[URIRef] = DATACITE.orcid
-    iri_xpath: ClassVar[URIRef] = DATACITE["local-resource-identifier-scheme"]
-    iri_intrepid: ClassVar[URIRef] = DATACITE.intrepid
-    iri_xmlid: ClassVar[URIRef] = DATACITE["local-resource-identifier-scheme"]
-    iri_has_identifier: ClassVar[URIRef] = DATACITE.hasIdentifier
-    iri_identifier: ClassVar[URIRef] = DATACITE.Identifier
-    iri_isbn: ClassVar[URIRef] = DATACITE.isbn
-    iri_issn: ClassVar[URIRef] = DATACITE.issn
-    iri_url: ClassVar[URIRef] = DATACITE.url
-    iri_uses_identifier_scheme: ClassVar[URIRef] = DATACITE.usesIdentifierScheme
-    iri_title: ClassVar[URIRef] = DCTERMS["title"]
-    iri_caption: ClassVar[URIRef] = DEO.Caption
-    iri_discourse_element: ClassVar[URIRef] = DEO.DiscourseElement
-    iri_footnote: ClassVar[URIRef] = DOCO.Footnote
-    iri_paragraph: ClassVar[URIRef] = DOCO.Paragraph
-    iri_part: ClassVar[URIRef] = DOCO.Part
-    iri_section: ClassVar[URIRef] = DOCO.Section
-    iri_section_title: ClassVar[URIRef] = DOCO.SectionTitle
-    iri_sentence: ClassVar[URIRef] = DOCO.Sentence
-    iri_table: ClassVar[URIRef] = DOCO.Table
-    iri_text_chunk: ClassVar[URIRef] = DOCO.TextChunk
-    iri_abstract: ClassVar[URIRef] = DOCO.Abstract
-    iri_academic_proceedings: ClassVar[URIRef] = FABIO.AcademicProceedings
-    iri_audio_document: ClassVar[URIRef] = FABIO.AudioDocument
-    iri_book: ClassVar[URIRef] = FABIO.Book
-    iri_book_chapter: ClassVar[URIRef] = FABIO.BookChapter
-    iri_book_series: ClassVar[URIRef] = FABIO.BookSeries
-    iri_book_set: ClassVar[URIRef] = FABIO.BookSet
-    iri_computer_program: ClassVar[URIRef] = FABIO.ComputerProgram
-    iri_data_file: ClassVar[URIRef] = FABIO.DataFile
-    iri_data_management_plan: ClassVar[URIRef] = FABIO.DataManagementPlan
-    iri_editorial: ClassVar[URIRef] = FABIO.Editorial
-    iri_expression: ClassVar[URIRef] = FABIO.Expression
-    iri_expression_collection: ClassVar[URIRef] = FABIO.ExpressionCollection
-    iri_has_sequence_identifier: ClassVar[URIRef] = FABIO.hasSequenceIdentifier
-    iri_journal: ClassVar[URIRef] = FABIO.Journal
-    iri_journal_article: ClassVar[URIRef] = FABIO.JournalArticle
-    iri_journal_editorial: ClassVar[URIRef] = FABIO.JournalEditorial
-    iri_journal_issue: ClassVar[URIRef] = FABIO.JournalIssue
-    iri_journal_volume: ClassVar[URIRef] = FABIO.JournalVolume
-    iri_manifestation: ClassVar[URIRef] = FABIO.Manifestation
-    iri_newspaper: ClassVar[URIRef] = FABIO.Newspaper
-    iri_newspaper_article: ClassVar[URIRef] = FABIO.NewspaperArticle
-    iri_newspaper_editorial: ClassVar[URIRef] = FABIO.NewspaperEditorial
-    iri_newspaper_issue: ClassVar[URIRef] = FABIO.NewspaperIssue
-    iri_peer_review: ClassVar[URIRef] = FR.ReviewVersion
-    iri_preprint: ClassVar[URIRef] = FABIO.Preprint
-    iri_presentation: ClassVar[URIRef] = FABIO.Presentation
-    iri_proceedings_paper: ClassVar[URIRef] = FABIO.ProceedingsPaper
-    iri_proceedings_series: ClassVar[URIRef] = FABIO.Series
-    iri_reference_book: ClassVar[URIRef] = FABIO.ReferenceBook
-    iri_reference_entry: ClassVar[URIRef] = FABIO.ReferenceEntry
-    iri_report_document: ClassVar[URIRef] = FABIO.ReportDocument
-    iri_retraction_notice: ClassVar[URIRef] = FABIO.RetractionNotice
-    iri_series: ClassVar[URIRef] = FABIO.Series
-    iri_specification_document: ClassVar[URIRef] = FABIO.SpecificationDocument
-    iri_thesis: ClassVar[URIRef] = FABIO.Thesis
-    iri_web_content: ClassVar[URIRef] = FABIO.WebContent
-    iri_agent: ClassVar[URIRef] = FOAF.Agent
-    iri_family_name: ClassVar[URIRef] = FOAF.familyName
-    iri_given_name: ClassVar[URIRef] = FOAF.givenName
-    iri_name: ClassVar[URIRef] = FOAF.name
-    iri_embodiment: ClassVar[URIRef] = FRBR.embodiment
-    iri_part_of: ClassVar[URIRef] = FRBR.partOf
-    iri_contains_reference: ClassVar[URIRef] = FRBR.part
-    iri_contains_de: ClassVar[URIRef] = FRBR.part
-    iri_has_literal_value: ClassVar[URIRef] = LITERAL.hasLiteralValue
-    iri_ending_page: ClassVar[URIRef] = PRISM.endingPage
-    iri_starting_page: ClassVar[URIRef] = PRISM.startingPage
-    iri_author: ClassVar[URIRef] = PRO.author
-    iri_editor: ClassVar[URIRef] = PRO.editor
-    iri_is_held_by: ClassVar[URIRef] = PRO.isHeldBy
-    iri_publisher: ClassVar[URIRef] = PRO.publisher
-    iri_is_document_context_for: ClassVar[URIRef] = PRO.isDocumentContextFor
-    iri_role_in_time: ClassVar[URIRef] = PRO.RoleInTime
-    iri_with_role: ClassVar[URIRef] = PRO.withRole
-    iri_note: ClassVar[URIRef] = OA.Annotation
-    iri_has_body: ClassVar[URIRef] = OA.hasBody
-    iri_has_annotation: ClassVar[URIRef] = OCO.hasAnnotation  # inverse of OA.hasTarget
-    iri_has_next: ClassVar[URIRef] = OCO.hasNext
-    iri_archival_document: ClassVar[URIRef] = FABIO.ArchivalDocument
-    iri_viaf: ClassVar[URIRef] = DATACITE.viaf
-    iri_crossref: ClassVar[URIRef] = DATACITE.crossref  # TODO: add to datacite!
-    iri_datacite: ClassVar[URIRef] = DATACITE.datacite  # TODO: add to datacite!
-    iri_jid: ClassVar[URIRef] = DATACITE.jid # TODO: add to datacite!
-    iri_wikidata: ClassVar[URIRef] = DATACITE.wikidata  # TODO: add to datacite!
-    iri_wikipedia: ClassVar[URIRef] = DATACITE.wikipedia  # TODO: add to datacite!
-    iri_has_edition: ClassVar[URIRef] = PRISM.edition
-    iri_relation: ClassVar[URIRef] = DCTERMS.relation
-    iri_has_citation_creation_date: ClassVar[URIRef] = CITO.hasCitationCreationDate
-    iri_has_citation_time_span: ClassVar[URIRef] = CITO.hasCitationTimeSpan
-    iri_digital_manifestation: ClassVar[URIRef] = FABIO.DigitalManifestation
-    iri_print_object: ClassVar[URIRef] = FABIO.PrintObject
-    iri_has_url: ClassVar[URIRef] = FRBR.exemplar
-    iri_self_citation: ClassVar[URIRef] = CITO.SelfCitation
-    iri_affiliation_self_citation: ClassVar[URIRef] = CITO.AffiliationSelfCitation
-    iri_author_network_self_citation: ClassVar[URIRef] = CITO.AuthorNetworkSelfCitation
-    iri_author_self_citation: ClassVar[URIRef] = CITO.AuthorSelfCitation
-    iri_funder_self_citation: ClassVar[URIRef] = CITO.FunderSelfCitation
-    iri_journal_self_citation: ClassVar[URIRef] = CITO.JournalSelfCitation
-    iri_journal_cartel_citation: ClassVar[URIRef] = CITO.JournalCartelCitation
-    iri_distant_citation: ClassVar[URIRef] = CITO.DistantCitation
-    iri_has_format: ClassVar[URIRef] = DCTERMS["format"]
-
-    short_name_to_type_iri: ClassVar[Dict[str, URIRef]] = {
-        'an': iri_note,
-        'ar': iri_role_in_time,
-        'be': iri_bibliographic_reference,
-        'br': iri_expression,
-        'ci': iri_citation,
-        'de': iri_discourse_element,
-        'id': iri_identifier,
-        'pl': iri_singleloc_pointer_list,
-        'ra': iri_agent,
-        're': iri_manifestation,
-        'rp': iri_intextref_pointer
-    }
-
-    def __init__(self, g: Graph, g_set: GraphSet, res: URIRef = None, res_type: URIRef = None,
-                 resp_agent: str = None, source: str = None, count: str = None, label: str = None,
-                 short_name: str = "", preexisting_graph: Graph = None) -> None:
-        super(GraphEntity, self).__init__()
-        self.g: Graph = g
-        self.resp_agent: str = resp_agent
-        self.source: str = source
-        self.short_name: str = short_name
-        self.g_set: GraphSet = g_set
-        self.preexisting_graph: Graph = Graph(identifier=g.identifier)
-        self._merge_list: Tuple[GraphEntity] = tuple()
-        # FLAGS
-        self._to_be_deleted: bool = False
-        self._was_merged: bool = False
-
-        # If res was not specified, create from scratch the URI reference for this entity,
-        # otherwise use the provided one
-        if res is None:
-            self.res = self._generate_new_res(g, count)
-        else:
-            self.res = res
-
-        if g_set is not None:
-            # If not already done, register this GraphEntity instance inside the GraphSet
-            if self.res not in g_set.res_to_entity:
-                g_set.res_to_entity[self.res] = self
-
-        if preexisting_graph is not None:
-            # Triples inside self.g are entirely replaced by triples from preexisting_graph.
-            # This has maximum priority with respect to every other self.g initializations.
-            # It's fundamental that the preexisting graph gets passed as an argument of the constructor:
-            # allowing the user to set this value later through a method would mean that the user could
-            # set the preexisting graph AFTER having modified self.g (which would not make sense).
-            self.remove_every_triple()
-            for p, o in preexisting_graph.predicate_objects(self.res):
-                self.g.add((self.res, p, o))
-                self.preexisting_graph.add((self.res, p, o))
-        else:
-            # Add mandatory information to the entity graph
-            self._create_type(res_type)
-            if label is not None:
-                self.create_label(label)
-
-    @staticmethod
-    def _generate_new_res(g: Graph, count: str) -> URIRef:
-        return URIRef(str(g.identifier) + count)
-
-    @property
-    def to_be_deleted(self) -> bool:
-        return self._to_be_deleted
-
-    @property
-    def was_merged(self) -> bool:
-        return self._was_merged
-
-    @property
-    def merge_list(self) -> Tuple[GraphEntity]:
-        return self._merge_list
-
-    def mark_as_to_be_deleted(self) -> None:
-        # Here we must REMOVE triples pointing
-        # to 'self' [THIS CANNOT BE UNDONE]:
-        for res, entity in self.g_set.res_to_entity.items():
-            triples_list: List[Tuple] = list(entity.g.triples((res, None, self.res)))
-            for triple in triples_list:
-                entity.g.remove(triple)
-
-        self._to_be_deleted = True
-
-    def merge(self, other: GraphEntity) -> None:
-        """
-        **WARNING:** ``GraphEntity`` **is an abstract class that cannot be instantiated at runtime.
-        As such, it's only possible to execute this method on entities generated from**
-        ``GraphEntity``'s **subclasses. Please, refer to their documentation of the** `merge` **method.**
-
-        :param other: The entity which will be marked as to be deleted and whose properties will
-         be merged into the current entity.
-        :type other: GraphEntity
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-
-        # Here we must REDIRECT triples pointing
-        # to 'other' to make them point to 'self':
-        for res, entity in self.g_set.res_to_entity.items():
-            triples_list: List[Tuple] = list(entity.g.triples((res, None, other.res)))
-            for triple in triples_list:
-                entity.g.remove(triple)
-                new_triple = (triple[0], triple[1], self.res)
-                entity.g.add(new_triple)
-
-        types: List[URIRef] = other.get_types()
-        for cur_type in types:
-            self._create_type(cur_type)
-
-        label: Optional[str] = other.get_label()
-        if label is not None:
-            self.create_label(label)
-
-        self._was_merged = True
-        self._merge_list = (*self._merge_list, other)
-
-        # 'other' must be deleted AFTER the redirection of
-        # triples pointing to it, since mark_as_to_be_deleted
-        # also removes every triple pointing to 'other'
-        other.mark_as_to_be_deleted()
-
-    def commit_changes(self):
-        self.preexisting_graph = Graph(identifier=self.g.identifier)
-        if self._to_be_deleted:
-            self.remove_every_triple()
-        else:
-            for triple in self.g.triples((self.res, None, None)):
-                self.preexisting_graph.add(triple)
-        self._to_be_deleted = False
-        self._was_merged = False
-        self._merge_list = tuple()
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+from rdflib import Graph, Namespace, URIRef
+
+from oc_ocdm.abstract_entity import AbstractEntity
+
+if TYPE_CHECKING:
+    from typing import ClassVar, Dict, List, Optional, Tuple
+
+    from oc_ocdm.graph.graph_set import GraphSet
+
+
+class GraphEntity(AbstractEntity):
+    BIRO: ClassVar[Namespace] = Namespace("http://purl.org/spar/biro/")
+    C4O: ClassVar[Namespace] = Namespace("http://purl.org/spar/c4o/")
+    CO: ClassVar[Namespace] = Namespace("http://purl.org/co/")
+    CITO: ClassVar[Namespace] = Namespace("http://purl.org/spar/cito/")
+    DATACITE: ClassVar[Namespace] = Namespace("http://purl.org/spar/datacite/")
+    DCTERMS: ClassVar[Namespace] = Namespace("http://purl.org/dc/terms/")
+    DEO: ClassVar[Namespace] = Namespace("http://purl.org/spar/deo/")
+    DOCO: ClassVar[Namespace] = Namespace("http://purl.org/spar/doco/")
+    FABIO: ClassVar[Namespace] = Namespace("http://purl.org/spar/fabio/")
+    FOAF: ClassVar[Namespace] = Namespace("http://xmlns.com/foaf/0.1/")
+    FR: ClassVar[Namespace] = Namespace("http://purl.org/spar/fr/")
+    FRBR: ClassVar[Namespace] = Namespace("http://purl.org/vocab/frbr/core#")
+    LITERAL: ClassVar[Namespace] = Namespace("http://www.essepuntato.it/2010/06/literalreification/")
+    OA: ClassVar[Namespace] = Namespace("http://www.w3.org/ns/oa#")
+    OCO: ClassVar[Namespace] = Namespace("https://w3id.org/oc/ontology/")
+    PRISM: ClassVar[Namespace] = Namespace("http://prismstandard.org/namespaces/basic/2.0/")
+    PRO: ClassVar[Namespace] = Namespace("http://purl.org/spar/pro/")
+
+    iri_has_subtitle: ClassVar[URIRef] = FABIO.hasSubtitle
+    iri_has_publication_date: ClassVar[URIRef] = PRISM.publicationDate
+    iri_bibliographic_reference: ClassVar[URIRef] = BIRO.BibliographicReference
+    iri_references: ClassVar[URIRef] = BIRO.references
+    iri_denotes: ClassVar[URIRef] = C4O.denotes
+    iri_has_content: ClassVar[URIRef] = C4O.hasContent
+    iri_intextref_pointer: ClassVar[URIRef] = C4O.InTextReferencePointer
+    iri_is_context_of: ClassVar[URIRef] = C4O.isContextOf
+    iri_singleloc_pointer_list: ClassVar[URIRef] = C4O.SingleLocationPointerList
+    iri_has_element: ClassVar[URIRef] = CO.element
+    iri_citation: ClassVar[URIRef] = CITO.Citation
+    iri_cites: ClassVar[URIRef] = CITO.cites
+    iri_citation_characterisation: ClassVar[URIRef] = CITO.hasCitationCharacterisation
+    iri_has_citing_entity: ClassVar[URIRef] = CITO.hasCitingEntity
+    iri_has_cited_entity: ClassVar[URIRef] = CITO.hasCitedEntity
+    iri_openalex: ClassVar[URIRef] = DATACITE.openalex
+    iri_arxiv: ClassVar[URIRef] = DATACITE.arxiv
+    iri_oci: ClassVar[URIRef] = DATACITE.oci
+    iri_doi: ClassVar[URIRef] = DATACITE.doi
+    iri_pmid: ClassVar[URIRef] = DATACITE.pmid
+    iri_pmcid: ClassVar[URIRef] = DATACITE.pmcid
+    iri_orcid: ClassVar[URIRef] = DATACITE.orcid
+    iri_xpath: ClassVar[URIRef] = DATACITE["local-resource-identifier-scheme"]
+    iri_intrepid: ClassVar[URIRef] = DATACITE.intrepid
+    iri_xmlid: ClassVar[URIRef] = DATACITE["local-resource-identifier-scheme"]
+    iri_has_identifier: ClassVar[URIRef] = DATACITE.hasIdentifier
+    iri_identifier: ClassVar[URIRef] = DATACITE.Identifier
+    iri_isbn: ClassVar[URIRef] = DATACITE.isbn
+    iri_issn: ClassVar[URIRef] = DATACITE.issn
+    iri_url: ClassVar[URIRef] = DATACITE.url
+    iri_uses_identifier_scheme: ClassVar[URIRef] = DATACITE.usesIdentifierScheme
+    iri_title: ClassVar[URIRef] = DCTERMS["title"]
+    iri_caption: ClassVar[URIRef] = DEO.Caption
+    iri_discourse_element: ClassVar[URIRef] = DEO.DiscourseElement
+    iri_footnote: ClassVar[URIRef] = DOCO.Footnote
+    iri_paragraph: ClassVar[URIRef] = DOCO.Paragraph
+    iri_part: ClassVar[URIRef] = DOCO.Part
+    iri_section: ClassVar[URIRef] = DOCO.Section
+    iri_section_title: ClassVar[URIRef] = DOCO.SectionTitle
+    iri_sentence: ClassVar[URIRef] = DOCO.Sentence
+    iri_table: ClassVar[URIRef] = DOCO.Table
+    iri_text_chunk: ClassVar[URIRef] = DOCO.TextChunk
+    iri_abstract: ClassVar[URIRef] = DOCO.Abstract
+    iri_academic_proceedings: ClassVar[URIRef] = FABIO.AcademicProceedings
+    iri_audio_document: ClassVar[URIRef] = FABIO.AudioDocument
+    iri_book: ClassVar[URIRef] = FABIO.Book
+    iri_book_chapter: ClassVar[URIRef] = FABIO.BookChapter
+    iri_book_series: ClassVar[URIRef] = FABIO.BookSeries
+    iri_book_set: ClassVar[URIRef] = FABIO.BookSet
+    iri_computer_program: ClassVar[URIRef] = FABIO.ComputerProgram
+    iri_data_file: ClassVar[URIRef] = FABIO.DataFile
+    iri_data_management_plan: ClassVar[URIRef] = FABIO.DataManagementPlan
+    iri_editorial: ClassVar[URIRef] = FABIO.Editorial
+    iri_expression: ClassVar[URIRef] = FABIO.Expression
+    iri_expression_collection: ClassVar[URIRef] = FABIO.ExpressionCollection
+    iri_has_sequence_identifier: ClassVar[URIRef] = FABIO.hasSequenceIdentifier
+    iri_journal: ClassVar[URIRef] = FABIO.Journal
+    iri_journal_article: ClassVar[URIRef] = FABIO.JournalArticle
+    iri_journal_editorial: ClassVar[URIRef] = FABIO.JournalEditorial
+    iri_journal_issue: ClassVar[URIRef] = FABIO.JournalIssue
+    iri_journal_volume: ClassVar[URIRef] = FABIO.JournalVolume
+    iri_manifestation: ClassVar[URIRef] = FABIO.Manifestation
+    iri_newspaper: ClassVar[URIRef] = FABIO.Newspaper
+    iri_newspaper_article: ClassVar[URIRef] = FABIO.NewspaperArticle
+    iri_newspaper_editorial: ClassVar[URIRef] = FABIO.NewspaperEditorial
+    iri_newspaper_issue: ClassVar[URIRef] = FABIO.NewspaperIssue
+    iri_peer_review: ClassVar[URIRef] = FR.ReviewVersion
+    iri_preprint: ClassVar[URIRef] = FABIO.Preprint
+    iri_presentation: ClassVar[URIRef] = FABIO.Presentation
+    iri_proceedings_paper: ClassVar[URIRef] = FABIO.ProceedingsPaper
+    iri_proceedings_series: ClassVar[URIRef] = FABIO.Series
+    iri_reference_book: ClassVar[URIRef] = FABIO.ReferenceBook
+    iri_reference_entry: ClassVar[URIRef] = FABIO.ReferenceEntry
+    iri_report_document: ClassVar[URIRef] = FABIO.ReportDocument
+    iri_retraction_notice: ClassVar[URIRef] = FABIO.RetractionNotice
+    iri_series: ClassVar[URIRef] = FABIO.Series
+    iri_specification_document: ClassVar[URIRef] = FABIO.SpecificationDocument
+    iri_thesis: ClassVar[URIRef] = FABIO.Thesis
+    iri_web_content: ClassVar[URIRef] = FABIO.WebContent
+    iri_agent: ClassVar[URIRef] = FOAF.Agent
+    iri_family_name: ClassVar[URIRef] = FOAF.familyName
+    iri_given_name: ClassVar[URIRef] = FOAF.givenName
+    iri_name: ClassVar[URIRef] = FOAF.name
+    iri_embodiment: ClassVar[URIRef] = FRBR.embodiment
+    iri_part_of: ClassVar[URIRef] = FRBR.partOf
+    iri_contains_reference: ClassVar[URIRef] = FRBR.part
+    iri_contains_de: ClassVar[URIRef] = FRBR.part
+    iri_has_literal_value: ClassVar[URIRef] = LITERAL.hasLiteralValue
+    iri_ending_page: ClassVar[URIRef] = PRISM.endingPage
+    iri_starting_page: ClassVar[URIRef] = PRISM.startingPage
+    iri_author: ClassVar[URIRef] = PRO.author
+    iri_editor: ClassVar[URIRef] = PRO.editor
+    iri_is_held_by: ClassVar[URIRef] = PRO.isHeldBy
+    iri_publisher: ClassVar[URIRef] = PRO.publisher
+    iri_is_document_context_for: ClassVar[URIRef] = PRO.isDocumentContextFor
+    iri_role_in_time: ClassVar[URIRef] = PRO.RoleInTime
+    iri_with_role: ClassVar[URIRef] = PRO.withRole
+    iri_note: ClassVar[URIRef] = OA.Annotation
+    iri_has_body: ClassVar[URIRef] = OA.hasBody
+    iri_has_annotation: ClassVar[URIRef] = OCO.hasAnnotation  # inverse of OA.hasTarget
+    iri_has_next: ClassVar[URIRef] = OCO.hasNext
+    iri_archival_document: ClassVar[URIRef] = FABIO.ArchivalDocument
+    iri_viaf: ClassVar[URIRef] = DATACITE.viaf
+    iri_crossref: ClassVar[URIRef] = DATACITE.crossref  # TODO: add to datacite!
+    iri_datacite: ClassVar[URIRef] = DATACITE.datacite  # TODO: add to datacite!
+    iri_jid: ClassVar[URIRef] = DATACITE.jid # TODO: add to datacite!
+    iri_wikidata: ClassVar[URIRef] = DATACITE.wikidata  # TODO: add to datacite!
+    iri_wikipedia: ClassVar[URIRef] = DATACITE.wikipedia  # TODO: add to datacite!
+    iri_has_edition: ClassVar[URIRef] = PRISM.edition
+    iri_relation: ClassVar[URIRef] = DCTERMS.relation
+    iri_has_citation_creation_date: ClassVar[URIRef] = CITO.hasCitationCreationDate
+    iri_has_citation_time_span: ClassVar[URIRef] = CITO.hasCitationTimeSpan
+    iri_digital_manifestation: ClassVar[URIRef] = FABIO.DigitalManifestation
+    iri_print_object: ClassVar[URIRef] = FABIO.PrintObject
+    iri_has_url: ClassVar[URIRef] = FRBR.exemplar
+    iri_self_citation: ClassVar[URIRef] = CITO.SelfCitation
+    iri_affiliation_self_citation: ClassVar[URIRef] = CITO.AffiliationSelfCitation
+    iri_author_network_self_citation: ClassVar[URIRef] = CITO.AuthorNetworkSelfCitation
+    iri_author_self_citation: ClassVar[URIRef] = CITO.AuthorSelfCitation
+    iri_funder_self_citation: ClassVar[URIRef] = CITO.FunderSelfCitation
+    iri_journal_self_citation: ClassVar[URIRef] = CITO.JournalSelfCitation
+    iri_journal_cartel_citation: ClassVar[URIRef] = CITO.JournalCartelCitation
+    iri_distant_citation: ClassVar[URIRef] = CITO.DistantCitation
+    iri_has_format: ClassVar[URIRef] = DCTERMS["format"]
+
+    short_name_to_type_iri: ClassVar[Dict[str, URIRef]] = {
+        'an': iri_note,
+        'ar': iri_role_in_time,
+        'be': iri_bibliographic_reference,
+        'br': iri_expression,
+        'ci': iri_citation,
+        'de': iri_discourse_element,
+        'id': iri_identifier,
+        'pl': iri_singleloc_pointer_list,
+        'ra': iri_agent,
+        're': iri_manifestation,
+        'rp': iri_intextref_pointer
+    }
+
+    def __init__(self, g: Graph, g_set: GraphSet, res: URIRef = None, res_type: URIRef = None,
+                 resp_agent: str = None, source: str = None, count: str = None, label: str = None,
+                 short_name: str = "", preexisting_graph: Graph = None) -> None:
+        super(GraphEntity, self).__init__()
+        self.g: Graph = g
+        self.resp_agent: str = resp_agent
+        self.source: str = source
+        self.short_name: str = short_name
+        self.g_set: GraphSet = g_set
+        self.preexisting_graph: Graph = Graph(identifier=g.identifier)
+        self._merge_list: Tuple[GraphEntity] = tuple()
+        # FLAGS
+        self._to_be_deleted: bool = False
+        self._was_merged: bool = False
+
+        # If res was not specified, create from scratch the URI reference for this entity,
+        # otherwise use the provided one
+        if res is None:
+            self.res = self._generate_new_res(g, count)
+        else:
+            self.res = res
+
+        if g_set is not None:
+            # If not already done, register this GraphEntity instance inside the GraphSet
+            if self.res not in g_set.res_to_entity:
+                g_set.res_to_entity[self.res] = self
+
+        if preexisting_graph is not None:
+            # Triples inside self.g are entirely replaced by triples from preexisting_graph.
+            # This has maximum priority with respect to every other self.g initializations.
+            # It's fundamental that the preexisting graph gets passed as an argument of the constructor:
+            # allowing the user to set this value later through a method would mean that the user could
+            # set the preexisting graph AFTER having modified self.g (which would not make sense).
+            self.remove_every_triple()
+            for p, o in preexisting_graph.predicate_objects(self.res):
+                self.g.add((self.res, p, o))
+                self.preexisting_graph.add((self.res, p, o))
+        else:
+            # Add mandatory information to the entity graph
+            self._create_type(res_type)
+            if label is not None:
+                self.create_label(label)
+
+    @staticmethod
+    def _generate_new_res(g: Graph, count: str) -> URIRef:
+        return URIRef(str(g.identifier) + count)
+
+    @property
+    def to_be_deleted(self) -> bool:
+        return self._to_be_deleted
+
+    @property
+    def was_merged(self) -> bool:
+        return self._was_merged
+
+    @property
+    def merge_list(self) -> Tuple[GraphEntity]:
+        return self._merge_list
+
+    def mark_as_to_be_deleted(self) -> None:
+        # Here we must REMOVE triples pointing
+        # to 'self' [THIS CANNOT BE UNDONE]:
+        for res, entity in self.g_set.res_to_entity.items():
+            triples_list: List[Tuple] = list(entity.g.triples((res, None, self.res)))
+            for triple in triples_list:
+                entity.g.remove(triple)
+
+        self._to_be_deleted = True
+
+    def merge(self, other: GraphEntity) -> None:
+        """
+        **WARNING:** ``GraphEntity`` **is an abstract class that cannot be instantiated at runtime.
+        As such, it's only possible to execute this method on entities generated from**
+        ``GraphEntity``'s **subclasses. Please, refer to their documentation of the** `merge` **method.**
+
+        :param other: The entity which will be marked as to be deleted and whose properties will
+         be merged into the current entity.
+        :type other: GraphEntity
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+
+        # Here we must REDIRECT triples pointing
+        # to 'other' to make them point to 'self':
+        for res, entity in self.g_set.res_to_entity.items():
+            triples_list: List[Tuple] = list(entity.g.triples((res, None, other.res)))
+            for triple in triples_list:
+                entity.g.remove(triple)
+                new_triple = (triple[0], triple[1], self.res)
+                entity.g.add(new_triple)
+
+        types: List[URIRef] = other.get_types()
+        for cur_type in types:
+            self._create_type(cur_type)
+
+        label: Optional[str] = other.get_label()
+        if label is not None:
+            self.create_label(label)
+
+        self._was_merged = True
+        self._merge_list = (*self._merge_list, other)
+
+        # 'other' must be deleted AFTER the redirection of
+        # triples pointing to it, since mark_as_to_be_deleted
+        # also removes every triple pointing to 'other'
+        other.mark_as_to_be_deleted()
+
+    def commit_changes(self):
+        self.preexisting_graph = Graph(identifier=self.g.identifier)
+        if self._to_be_deleted:
+            self.remove_every_triple()
+        else:
+            for triple in self.g.triples((self.res, None, None)):
+                self.preexisting_graph.add(triple)
+        self._to_be_deleted = False
+        self._was_merged = False
+        self._merge_list = tuple()
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/graph/graph_set.py` & `oc_ocdm-8.1.0/oc_ocdm/graph/graph_set.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,407 +1,407 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-from SPARQLWrapper import RDFXML, SPARQLWrapper
-
-from oc_ocdm.abstract_set import AbstractSet
-from oc_ocdm.reader import Reader
-from oc_ocdm.support.support import get_count, get_short_name, get_prefix
-
-if TYPE_CHECKING:
-    from typing import Dict, ClassVar, Tuple, Optional, List, Set
-    from rdflib import ConjunctiveGraph
-
-from rdflib import Graph, Namespace, URIRef
-
-from oc_ocdm.counter_handler.counter_handler import CounterHandler
-from oc_ocdm.counter_handler.filesystem_counter_handler import \
-    FilesystemCounterHandler
-from oc_ocdm.counter_handler.in_memory_counter_handler import \
-    InMemoryCounterHandler
-from oc_ocdm.graph.entities.bibliographic.agent_role import AgentRole
-from oc_ocdm.graph.entities.bibliographic.bibliographic_reference import \
-    BibliographicReference
-from oc_ocdm.graph.entities.bibliographic.bibliographic_resource import \
-    BibliographicResource
-from oc_ocdm.graph.entities.bibliographic.citation import Citation
-from oc_ocdm.graph.entities.bibliographic.discourse_element import \
-    DiscourseElement
-from oc_ocdm.graph.entities.bibliographic.pointer_list import PointerList
-from oc_ocdm.graph.entities.bibliographic.reference_annotation import \
-    ReferenceAnnotation
-from oc_ocdm.graph.entities.bibliographic.reference_pointer import \
-    ReferencePointer
-from oc_ocdm.graph.entities.bibliographic.resource_embodiment import \
-    ResourceEmbodiment
-from oc_ocdm.graph.entities.bibliographic.responsible_agent import \
-    ResponsibleAgent
-from oc_ocdm.graph.entities.identifier import Identifier
-from oc_ocdm.graph.graph_entity import GraphEntity
-
-
-class GraphSet(AbstractSet):
-    # Labels
-    labels: ClassVar[Dict[str, str]] = {
-        "an": "annotation",
-        "ar": "agent role",
-        "be": "bibliographic entry",
-        "br": "bibliographic resource",
-        "ci": "citation",
-        "de": "discourse element",
-        "id": "identifier",
-        "pl": "single location pointer list",
-        "ra": "responsible agent",
-        "re": "resource embodiment",
-        "rp": "in-text reference pointer"
-    }
-
-    def __init__(self, base_iri: str, info_dir: str = "", supplier_prefix: str = "",
-                 wanted_label: bool = True) -> None:
-        super(GraphSet, self).__init__()
-        # The following variable maps a URIRef with the related graph entity
-        self.res_to_entity: Dict[URIRef, GraphEntity] = {}
-        self.base_iri: str = base_iri
-        self.info_dir: str = info_dir
-        self.supplier_prefix: str = supplier_prefix
-        self.wanted_label: bool = wanted_label
-        # Graphs
-        # The following structure of URL is quite important for the other classes
-        # developed and should not be changed. The only part that can change is the
-        # value of the base_iri
-        self.g_an: str = base_iri + "an/"
-        self.g_ar: str = base_iri + "ar/"
-        self.g_be: str = base_iri + "be/"
-        self.g_br: str = base_iri + "br/"
-        self.g_ci: str = base_iri + "ci/"
-        self.g_de: str = base_iri + "de/"
-        self.g_id: str = base_iri + "id/"
-        self.g_pl: str = base_iri + "pl/"
-        self.g_ra: str = base_iri + "ra/"
-        self.g_re: str = base_iri + "re/"
-        self.g_rp: str = base_iri + "rp/"
-
-        if info_dir is not None and info_dir != "":
-            self.counter_handler: CounterHandler = FilesystemCounterHandler(info_dir, supplier_prefix)
-        else:
-            self.counter_handler: CounterHandler = InMemoryCounterHandler()
-
-    def get_entity(self, res: URIRef) -> Optional[GraphEntity]:
-        if res in self.res_to_entity:
-            return self.res_to_entity[res]
-
-    # Add resources related to bibliographic entities
-    def add_an(self, resp_agent: str, source: str = None, res: URIRef = None,
-               preexisting_graph: Graph = None) -> ReferenceAnnotation:
-        if res is not None and get_short_name(res) != "an":
-            raise ValueError(f"Given res: <{res}> is inappropriate for a ReferenceAnnotation entity.")
-        if res is not None and res in self.res_to_entity:
-            return self.res_to_entity[res]
-        cur_g, count, label = self._add(self.g_an, "an", res)
-        return ReferenceAnnotation(cur_g, self, res, GraphEntity.iri_note,
-                                   resp_agent, source, count, label, "an",
-                                   preexisting_graph)
-
-    def add_ar(self, resp_agent: str, source: str = None, res: URIRef = None,
-               preexisting_graph: Graph = None) -> AgentRole:
-        if res is not None and get_short_name(res) != "ar":
-            raise ValueError(f"Given res: <{res}> is inappropriate for an AgentRole entity.")
-        if res is not None and res in self.res_to_entity:
-            return self.res_to_entity[res]
-        cur_g, count, label = self._add(self.g_ar, "ar", res)
-        return AgentRole(cur_g, self, res, GraphEntity.iri_role_in_time,
-                         resp_agent, source, count, label, "ar",
-                         preexisting_graph)
-
-    def add_be(self, resp_agent: str, source: str = None, res: URIRef = None,
-               preexisting_graph: Graph = None) -> BibliographicReference:
-        if res is not None and get_short_name(res) != "be":
-            raise ValueError(f"Given res: <{res}> is inappropriate for a BibliographicReference entity.")
-        if res is not None and res in self.res_to_entity:
-            return self.res_to_entity[res]
-        cur_g, count, label = self._add(self.g_be, "be", res)
-        return BibliographicReference(cur_g, self, res, GraphEntity.iri_bibliographic_reference,
-                                      resp_agent, source, count, label, "be",
-                                      preexisting_graph)
-
-    def add_br(self, resp_agent: str, source: str = None, res: URIRef = None,
-               preexisting_graph: Graph = None) -> BibliographicResource:
-        if res is not None and get_short_name(res) != "br":
-            raise ValueError(f"Given res: <{res}> is inappropriate for a BibliographicResource entity.")
-        if res is not None and res in self.res_to_entity:
-            return self.res_to_entity[res]
-        cur_g, count, label = self._add(self.g_br, "br", res)
-        return BibliographicResource(cur_g, self, res, GraphEntity.iri_expression,
-                                     resp_agent, source, count, label, "br",
-                                     preexisting_graph)
-
-    def add_ci(self, resp_agent: str, source: str = None, res: URIRef = None,
-               preexisting_graph: Graph = None) -> Citation:
-        if res is not None and get_short_name(res) != "ci":
-            raise ValueError(f"Given res: <{res}> is inappropriate for a Citation entity.")
-        if res is not None and res in self.res_to_entity:
-            return self.res_to_entity[res]
-        cur_g, count, label = self._add(self.g_ci, "ci", res)
-        return Citation(cur_g, self, res, GraphEntity.iri_citation,
-                        resp_agent, source, count, label, "ci",
-                        preexisting_graph)
-
-    def add_de(self, resp_agent: str, source: str = None, res: URIRef = None,
-               preexisting_graph: Graph = None) -> DiscourseElement:
-        if res is not None and get_short_name(res) != "de":
-            raise ValueError(f"Given res: <{res}> is inappropriate for a DiscourseElement entity.")
-        if res is not None and res in self.res_to_entity:
-            return self.res_to_entity[res]
-        cur_g, count, label = self._add(self.g_de, "de", res)
-        return DiscourseElement(cur_g, self, res, GraphEntity.iri_discourse_element,
-                                resp_agent, source, count, label, "de",
-                                preexisting_graph)
-
-    def add_id(self, resp_agent: str, source: str = None, res: URIRef = None,
-               preexisting_graph: Graph = None) -> Identifier:
-        if res is not None and get_short_name(res) != "id":
-            raise ValueError(f"Given res: <{res}> is inappropriate for an Identifier entity.")
-        if res is not None and res in self.res_to_entity:
-            return self.res_to_entity[res]
-        cur_g, count, label = self._add(self.g_id, "id", res)
-        return Identifier(cur_g, self, res, GraphEntity.iri_identifier,
-                          resp_agent, source, count, label, "id",
-                          preexisting_graph)
-
-    def add_pl(self, resp_agent: str, source: str = None, res: URIRef = None,
-               preexisting_graph: Graph = None) -> PointerList:
-        if res is not None and get_short_name(res) != "pl":
-            raise ValueError(f"Given res: <{res}> is inappropriate for a PointerList entity.")
-        if res is not None and res in self.res_to_entity:
-            return self.res_to_entity[res]
-        cur_g, count, label = self._add(self.g_pl, "pl", res)
-        return PointerList(cur_g, self, res, GraphEntity.iri_singleloc_pointer_list,
-                           resp_agent, source, count, label, "pl",
-                           preexisting_graph)
-
-    def add_rp(self, resp_agent: str, source: str = None, res: URIRef = None,
-               preexisting_graph: Graph = None) -> ReferencePointer:
-        if res is not None and get_short_name(res) != "rp":
-            raise ValueError(f"Given res: <{res}> is inappropriate for a ReferencePointer entity.")
-        if res is not None and res in self.res_to_entity:
-            return self.res_to_entity[res]
-        cur_g, count, label = self._add(self.g_rp, "rp", res)
-        return ReferencePointer(cur_g, self, res, GraphEntity.iri_intextref_pointer,
-                                resp_agent, source, count, label, "rp",
-                                preexisting_graph)
-
-    def add_ra(self, resp_agent: str, source: str = None, res: URIRef = None,
-               preexisting_graph: Graph = None) -> ResponsibleAgent:
-        if res is not None and get_short_name(res) != "ra":
-            raise ValueError(f"Given res: <{res}> is inappropriate for a ResponsibleAgent entity.")
-        if res is not None and res in self.res_to_entity:
-            return self.res_to_entity[res]
-        cur_g, count, label = self._add(self.g_ra, "ra", res)
-        return ResponsibleAgent(cur_g, self, res, GraphEntity.iri_agent,
-                                resp_agent, source, count, label, "ra",
-                                preexisting_graph)
-
-    def add_re(self, resp_agent: str, source: str = None, res: URIRef = None,
-               preexisting_graph: Graph = None) -> ResourceEmbodiment:
-        if res is not None and get_short_name(res) != "re":
-            raise ValueError(f"Given res: <{res}> is inappropriate for a ResourceEmbodiment entity.")
-        if res is not None and res in self.res_to_entity:
-            return self.res_to_entity[res]
-        cur_g, count, label = self._add(self.g_re, "re", res)
-        return ResourceEmbodiment(cur_g, self, res, GraphEntity.iri_manifestation,
-                                  resp_agent, source, count, label, "re",
-                                  preexisting_graph)
-
-    def _add(self, graph_url: str, short_name: str, res: URIRef = None) -> Tuple[Graph, Optional[str], Optional[str]]:
-        cur_g: Graph = Graph(identifier=graph_url)
-        self._set_ns(cur_g)
-
-        count: Optional[str] = None
-        label: Optional[str] = None
-        supplier_prefix = get_prefix(res) if res is not None else self.supplier_prefix
-        if res is not None:
-            try:
-                res_count: int = int(get_count(res))
-            except ValueError:
-                res_count: int = -1
-            if res_count > self.counter_handler.read_counter(short_name, supplier_prefix=supplier_prefix):
-                self.counter_handler.set_counter(res_count, short_name, supplier_prefix=supplier_prefix)
-            return cur_g, count, label
-
-        count = supplier_prefix + str(self.counter_handler.increment_counter(short_name, supplier_prefix=supplier_prefix))
-
-        if self.wanted_label:
-            label = "%s %s [%s/%s]" % (self.labels[short_name], count, short_name, count)
-
-        return cur_g, count, label
-
-    def get_orphans(self) -> List[GraphEntity]:
-        full_set_of_entities: Set[URIRef] = set(self.res_to_entity.keys())
-        referenced_entities: Set[URIRef] = set()
-        for res, entity in self.res_to_entity.items():
-            for obj in entity.g.objects(subject=res, predicate=None):
-                if type(obj) == URIRef:
-                    referenced_entities.add(obj)
-        set_of_orphan_res: Set[URIRef] = full_set_of_entities - referenced_entities
-
-        result_list: List[GraphEntity] = []
-        for orphan_res in set_of_orphan_res:
-            entity: Optional[GraphEntity] = self.get_entity(orphan_res)
-            if entity is not None:
-                result_list.append(entity)
-
-        return result_list
-
-    def remove_orphans_from_triplestore(self, ts_url: str, resp_agent: str) -> None:
-        sparql: SPARQLWrapper = SPARQLWrapper(ts_url)
-
-        for entity_res, entity in self.res_to_entity.items():
-            if entity.to_be_deleted:
-                query: str = f"CONSTRUCT {{?s ?p ?o}} WHERE {{?s ?p ?o ; ?p_1 <{entity_res}>}}"
-                sparql.setQuery(query)
-                sparql.setMethod('GET')
-                sparql.setReturnFormat(RDFXML)
-
-                result: ConjunctiveGraph = sparql.query().convert()
-                if result is not None:
-                    imported_entities: List[GraphEntity] = Reader.import_entities_from_graph(self, result, resp_agent)
-                    for imported_entity in imported_entities:
-                        imported_entity.g.remove((imported_entity.res, None, entity_res))
-
-    def commit_changes(self):
-        for res, entity in self.res_to_entity.items():
-            entity.commit_changes()
-            if entity.to_be_deleted:
-                del self.res_to_entity[res]
-
-    def _set_ns(self, g: Graph) -> None:
-        g.namespace_manager.bind("an", Namespace(self.g_an))
-        g.namespace_manager.bind("ar", Namespace(self.g_ar))
-        g.namespace_manager.bind("be", Namespace(self.g_be))
-        g.namespace_manager.bind("ci", Namespace(self.g_ci))
-        g.namespace_manager.bind("de", Namespace(self.g_de))
-        g.namespace_manager.bind("br", Namespace(self.g_br))
-        g.namespace_manager.bind("id", Namespace(self.g_id))
-        g.namespace_manager.bind("pl", Namespace(self.g_pl))
-        g.namespace_manager.bind("ra", Namespace(self.g_ra))
-        g.namespace_manager.bind("re", Namespace(self.g_re))
-        g.namespace_manager.bind("rp", Namespace(self.g_rp))
-        g.namespace_manager.bind("biro", GraphEntity.BIRO)
-        g.namespace_manager.bind("co", GraphEntity.CO)
-        g.namespace_manager.bind("c4o", GraphEntity.C4O)
-        g.namespace_manager.bind("cito", GraphEntity.CITO)
-        g.namespace_manager.bind("datacite", GraphEntity.DATACITE)
-        g.namespace_manager.bind("dcterms", GraphEntity.DCTERMS)
-        g.namespace_manager.bind("deo", GraphEntity.DEO)
-        g.namespace_manager.bind("doco", GraphEntity.DOCO)
-        g.namespace_manager.bind("fabio", GraphEntity.FABIO)
-        g.namespace_manager.bind("foaf", GraphEntity.FOAF)
-        g.namespace_manager.bind("frbr", GraphEntity.FRBR)
-        g.namespace_manager.bind("literal", GraphEntity.LITERAL)
-        g.namespace_manager.bind("oa", GraphEntity.OA)
-        g.namespace_manager.bind("oco", GraphEntity.OCO)
-        g.namespace_manager.bind("prism", GraphEntity.PRISM)
-        g.namespace_manager.bind("pro", GraphEntity.PRO)
-
-    def get_an(self) -> Tuple[ReferenceAnnotation]:
-        result: Tuple[ReferenceAnnotation] = tuple()
-        for ref in self.res_to_entity:
-            entity: GraphEntity = self.res_to_entity[ref]
-            if isinstance(entity, ReferenceAnnotation):
-                result += (entity, )
-        return result
-
-    def get_ar(self) -> Tuple[AgentRole]:
-        result: Tuple[AgentRole] = tuple()
-        for ref in self.res_to_entity:
-            entity: GraphEntity = self.res_to_entity[ref]
-            if isinstance(entity, AgentRole):
-                result += (entity, )
-        return result
-
-    def get_be(self) -> Tuple[BibliographicReference]:
-        result: Tuple[BibliographicReference] = tuple()
-        for ref in self.res_to_entity:
-            entity: GraphEntity = self.res_to_entity[ref]
-            if isinstance(entity, BibliographicReference):
-                result += (entity, )
-        return result
-
-    def get_br(self) -> Tuple[BibliographicResource]:
-        result: Tuple[BibliographicResource] = tuple()
-        for ref in self.res_to_entity:
-            entity: GraphEntity = self.res_to_entity[ref]
-            if isinstance(entity, BibliographicResource):
-                result += (entity, )
-        return result
-
-    def get_ci(self) -> Tuple[Citation]:
-        result: Tuple[Citation] = tuple()
-        for ref in self.res_to_entity:
-            entity: GraphEntity = self.res_to_entity[ref]
-            if isinstance(entity, Citation):
-                result += (entity, )
-        return result
-
-    def get_de(self) -> Tuple[DiscourseElement]:
-        result: Tuple[DiscourseElement] = tuple()
-        for ref in self.res_to_entity:
-            entity: GraphEntity = self.res_to_entity[ref]
-            if isinstance(entity, DiscourseElement):
-                result += (entity, )
-        return result
-
-    def get_id(self) -> Tuple[Identifier]:
-        result: Tuple[Identifier] = tuple()
-        for ref in self.res_to_entity:
-            entity: GraphEntity = self.res_to_entity[ref]
-            if isinstance(entity, Identifier):
-                result += (entity, )
-        return result
-
-    def get_pl(self) -> Tuple[PointerList]:
-        result: Tuple[PointerList] = tuple()
-        for ref in self.res_to_entity:
-            entity: GraphEntity = self.res_to_entity[ref]
-            if isinstance(entity, PointerList):
-                result += (entity, )
-        return result
-
-    def get_rp(self) -> Tuple[ReferencePointer]:
-        result: Tuple[ReferencePointer] = tuple()
-        for ref in self.res_to_entity:
-            entity: GraphEntity = self.res_to_entity[ref]
-            if isinstance(entity, ReferencePointer):
-                result += (entity, )
-        return result
-
-    def get_ra(self) -> Tuple[ResponsibleAgent]:
-        result: Tuple[ResponsibleAgent] = tuple()
-        for ref in self.res_to_entity:
-            entity: GraphEntity = self.res_to_entity[ref]
-            if isinstance(entity, ResponsibleAgent):
-                result += (entity, )
-        return result
-
-    def get_re(self) -> Tuple[ResourceEmbodiment]:
-        result: Tuple[ResourceEmbodiment] = tuple()
-        for ref in self.res_to_entity:
-            entity: GraphEntity = self.res_to_entity[ref]
-            if isinstance(entity, ResourceEmbodiment):
-                result += (entity, )
-        return result
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+from SPARQLWrapper import RDFXML, SPARQLWrapper
+
+from oc_ocdm.abstract_set import AbstractSet
+from oc_ocdm.reader import Reader
+from oc_ocdm.support.support import get_count, get_short_name, get_prefix
+
+if TYPE_CHECKING:
+    from typing import Dict, ClassVar, Tuple, Optional, List, Set
+    from rdflib import ConjunctiveGraph
+
+from rdflib import Graph, Namespace, URIRef
+
+from oc_ocdm.counter_handler.counter_handler import CounterHandler
+from oc_ocdm.counter_handler.filesystem_counter_handler import \
+    FilesystemCounterHandler
+from oc_ocdm.counter_handler.in_memory_counter_handler import \
+    InMemoryCounterHandler
+from oc_ocdm.graph.entities.bibliographic.agent_role import AgentRole
+from oc_ocdm.graph.entities.bibliographic.bibliographic_reference import \
+    BibliographicReference
+from oc_ocdm.graph.entities.bibliographic.bibliographic_resource import \
+    BibliographicResource
+from oc_ocdm.graph.entities.bibliographic.citation import Citation
+from oc_ocdm.graph.entities.bibliographic.discourse_element import \
+    DiscourseElement
+from oc_ocdm.graph.entities.bibliographic.pointer_list import PointerList
+from oc_ocdm.graph.entities.bibliographic.reference_annotation import \
+    ReferenceAnnotation
+from oc_ocdm.graph.entities.bibliographic.reference_pointer import \
+    ReferencePointer
+from oc_ocdm.graph.entities.bibliographic.resource_embodiment import \
+    ResourceEmbodiment
+from oc_ocdm.graph.entities.bibliographic.responsible_agent import \
+    ResponsibleAgent
+from oc_ocdm.graph.entities.identifier import Identifier
+from oc_ocdm.graph.graph_entity import GraphEntity
+
+
+class GraphSet(AbstractSet):
+    # Labels
+    labels: ClassVar[Dict[str, str]] = {
+        "an": "annotation",
+        "ar": "agent role",
+        "be": "bibliographic entry",
+        "br": "bibliographic resource",
+        "ci": "citation",
+        "de": "discourse element",
+        "id": "identifier",
+        "pl": "single location pointer list",
+        "ra": "responsible agent",
+        "re": "resource embodiment",
+        "rp": "in-text reference pointer"
+    }
+
+    def __init__(self, base_iri: str, info_dir: str = "", supplier_prefix: str = "",
+                 wanted_label: bool = True) -> None:
+        super(GraphSet, self).__init__()
+        # The following variable maps a URIRef with the related graph entity
+        self.res_to_entity: Dict[URIRef, GraphEntity] = {}
+        self.base_iri: str = base_iri
+        self.info_dir: str = info_dir
+        self.supplier_prefix: str = supplier_prefix
+        self.wanted_label: bool = wanted_label
+        # Graphs
+        # The following structure of URL is quite important for the other classes
+        # developed and should not be changed. The only part that can change is the
+        # value of the base_iri
+        self.g_an: str = base_iri + "an/"
+        self.g_ar: str = base_iri + "ar/"
+        self.g_be: str = base_iri + "be/"
+        self.g_br: str = base_iri + "br/"
+        self.g_ci: str = base_iri + "ci/"
+        self.g_de: str = base_iri + "de/"
+        self.g_id: str = base_iri + "id/"
+        self.g_pl: str = base_iri + "pl/"
+        self.g_ra: str = base_iri + "ra/"
+        self.g_re: str = base_iri + "re/"
+        self.g_rp: str = base_iri + "rp/"
+
+        if info_dir is not None and info_dir != "":
+            self.counter_handler: CounterHandler = FilesystemCounterHandler(info_dir, supplier_prefix)
+        else:
+            self.counter_handler: CounterHandler = InMemoryCounterHandler()
+
+    def get_entity(self, res: URIRef) -> Optional[GraphEntity]:
+        if res in self.res_to_entity:
+            return self.res_to_entity[res]
+
+    # Add resources related to bibliographic entities
+    def add_an(self, resp_agent: str, source: str = None, res: URIRef = None,
+               preexisting_graph: Graph = None) -> ReferenceAnnotation:
+        if res is not None and get_short_name(res) != "an":
+            raise ValueError(f"Given res: <{res}> is inappropriate for a ReferenceAnnotation entity.")
+        if res is not None and res in self.res_to_entity:
+            return self.res_to_entity[res]
+        cur_g, count, label = self._add(self.g_an, "an", res)
+        return ReferenceAnnotation(cur_g, self, res, GraphEntity.iri_note,
+                                   resp_agent, source, count, label, "an",
+                                   preexisting_graph)
+
+    def add_ar(self, resp_agent: str, source: str = None, res: URIRef = None,
+               preexisting_graph: Graph = None) -> AgentRole:
+        if res is not None and get_short_name(res) != "ar":
+            raise ValueError(f"Given res: <{res}> is inappropriate for an AgentRole entity.")
+        if res is not None and res in self.res_to_entity:
+            return self.res_to_entity[res]
+        cur_g, count, label = self._add(self.g_ar, "ar", res)
+        return AgentRole(cur_g, self, res, GraphEntity.iri_role_in_time,
+                         resp_agent, source, count, label, "ar",
+                         preexisting_graph)
+
+    def add_be(self, resp_agent: str, source: str = None, res: URIRef = None,
+               preexisting_graph: Graph = None) -> BibliographicReference:
+        if res is not None and get_short_name(res) != "be":
+            raise ValueError(f"Given res: <{res}> is inappropriate for a BibliographicReference entity.")
+        if res is not None and res in self.res_to_entity:
+            return self.res_to_entity[res]
+        cur_g, count, label = self._add(self.g_be, "be", res)
+        return BibliographicReference(cur_g, self, res, GraphEntity.iri_bibliographic_reference,
+                                      resp_agent, source, count, label, "be",
+                                      preexisting_graph)
+
+    def add_br(self, resp_agent: str, source: str = None, res: URIRef = None,
+               preexisting_graph: Graph = None) -> BibliographicResource:
+        if res is not None and get_short_name(res) != "br":
+            raise ValueError(f"Given res: <{res}> is inappropriate for a BibliographicResource entity.")
+        if res is not None and res in self.res_to_entity:
+            return self.res_to_entity[res]
+        cur_g, count, label = self._add(self.g_br, "br", res)
+        return BibliographicResource(cur_g, self, res, GraphEntity.iri_expression,
+                                     resp_agent, source, count, label, "br",
+                                     preexisting_graph)
+
+    def add_ci(self, resp_agent: str, source: str = None, res: URIRef = None,
+               preexisting_graph: Graph = None) -> Citation:
+        if res is not None and get_short_name(res) != "ci":
+            raise ValueError(f"Given res: <{res}> is inappropriate for a Citation entity.")
+        if res is not None and res in self.res_to_entity:
+            return self.res_to_entity[res]
+        cur_g, count, label = self._add(self.g_ci, "ci", res)
+        return Citation(cur_g, self, res, GraphEntity.iri_citation,
+                        resp_agent, source, count, label, "ci",
+                        preexisting_graph)
+
+    def add_de(self, resp_agent: str, source: str = None, res: URIRef = None,
+               preexisting_graph: Graph = None) -> DiscourseElement:
+        if res is not None and get_short_name(res) != "de":
+            raise ValueError(f"Given res: <{res}> is inappropriate for a DiscourseElement entity.")
+        if res is not None and res in self.res_to_entity:
+            return self.res_to_entity[res]
+        cur_g, count, label = self._add(self.g_de, "de", res)
+        return DiscourseElement(cur_g, self, res, GraphEntity.iri_discourse_element,
+                                resp_agent, source, count, label, "de",
+                                preexisting_graph)
+
+    def add_id(self, resp_agent: str, source: str = None, res: URIRef = None,
+               preexisting_graph: Graph = None) -> Identifier:
+        if res is not None and get_short_name(res) != "id":
+            raise ValueError(f"Given res: <{res}> is inappropriate for an Identifier entity.")
+        if res is not None and res in self.res_to_entity:
+            return self.res_to_entity[res]
+        cur_g, count, label = self._add(self.g_id, "id", res)
+        return Identifier(cur_g, self, res, GraphEntity.iri_identifier,
+                          resp_agent, source, count, label, "id",
+                          preexisting_graph)
+
+    def add_pl(self, resp_agent: str, source: str = None, res: URIRef = None,
+               preexisting_graph: Graph = None) -> PointerList:
+        if res is not None and get_short_name(res) != "pl":
+            raise ValueError(f"Given res: <{res}> is inappropriate for a PointerList entity.")
+        if res is not None and res in self.res_to_entity:
+            return self.res_to_entity[res]
+        cur_g, count, label = self._add(self.g_pl, "pl", res)
+        return PointerList(cur_g, self, res, GraphEntity.iri_singleloc_pointer_list,
+                           resp_agent, source, count, label, "pl",
+                           preexisting_graph)
+
+    def add_rp(self, resp_agent: str, source: str = None, res: URIRef = None,
+               preexisting_graph: Graph = None) -> ReferencePointer:
+        if res is not None and get_short_name(res) != "rp":
+            raise ValueError(f"Given res: <{res}> is inappropriate for a ReferencePointer entity.")
+        if res is not None and res in self.res_to_entity:
+            return self.res_to_entity[res]
+        cur_g, count, label = self._add(self.g_rp, "rp", res)
+        return ReferencePointer(cur_g, self, res, GraphEntity.iri_intextref_pointer,
+                                resp_agent, source, count, label, "rp",
+                                preexisting_graph)
+
+    def add_ra(self, resp_agent: str, source: str = None, res: URIRef = None,
+               preexisting_graph: Graph = None) -> ResponsibleAgent:
+        if res is not None and get_short_name(res) != "ra":
+            raise ValueError(f"Given res: <{res}> is inappropriate for a ResponsibleAgent entity.")
+        if res is not None and res in self.res_to_entity:
+            return self.res_to_entity[res]
+        cur_g, count, label = self._add(self.g_ra, "ra", res)
+        return ResponsibleAgent(cur_g, self, res, GraphEntity.iri_agent,
+                                resp_agent, source, count, label, "ra",
+                                preexisting_graph)
+
+    def add_re(self, resp_agent: str, source: str = None, res: URIRef = None,
+               preexisting_graph: Graph = None) -> ResourceEmbodiment:
+        if res is not None and get_short_name(res) != "re":
+            raise ValueError(f"Given res: <{res}> is inappropriate for a ResourceEmbodiment entity.")
+        if res is not None and res in self.res_to_entity:
+            return self.res_to_entity[res]
+        cur_g, count, label = self._add(self.g_re, "re", res)
+        return ResourceEmbodiment(cur_g, self, res, GraphEntity.iri_manifestation,
+                                  resp_agent, source, count, label, "re",
+                                  preexisting_graph)
+
+    def _add(self, graph_url: str, short_name: str, res: URIRef = None) -> Tuple[Graph, Optional[str], Optional[str]]:
+        cur_g: Graph = Graph(identifier=graph_url)
+        self._set_ns(cur_g)
+
+        count: Optional[str] = None
+        label: Optional[str] = None
+        supplier_prefix = get_prefix(res) if res is not None else self.supplier_prefix
+        if res is not None:
+            try:
+                res_count: int = int(get_count(res))
+            except ValueError:
+                res_count: int = -1
+            if res_count > self.counter_handler.read_counter(short_name, supplier_prefix=supplier_prefix):
+                self.counter_handler.set_counter(res_count, short_name, supplier_prefix=supplier_prefix)
+            return cur_g, count, label
+
+        count = supplier_prefix + str(self.counter_handler.increment_counter(short_name, supplier_prefix=supplier_prefix))
+
+        if self.wanted_label:
+            label = "%s %s [%s/%s]" % (self.labels[short_name], count, short_name, count)
+
+        return cur_g, count, label
+
+    def get_orphans(self) -> List[GraphEntity]:
+        full_set_of_entities: Set[URIRef] = set(self.res_to_entity.keys())
+        referenced_entities: Set[URIRef] = set()
+        for res, entity in self.res_to_entity.items():
+            for obj in entity.g.objects(subject=res, predicate=None):
+                if type(obj) == URIRef:
+                    referenced_entities.add(obj)
+        set_of_orphan_res: Set[URIRef] = full_set_of_entities - referenced_entities
+
+        result_list: List[GraphEntity] = []
+        for orphan_res in set_of_orphan_res:
+            entity: Optional[GraphEntity] = self.get_entity(orphan_res)
+            if entity is not None:
+                result_list.append(entity)
+
+        return result_list
+
+    def remove_orphans_from_triplestore(self, ts_url: str, resp_agent: str) -> None:
+        sparql: SPARQLWrapper = SPARQLWrapper(ts_url)
+
+        for entity_res, entity in self.res_to_entity.items():
+            if entity.to_be_deleted:
+                query: str = f"CONSTRUCT {{?s ?p ?o}} WHERE {{?s ?p ?o ; ?p_1 <{entity_res}>}}"
+                sparql.setQuery(query)
+                sparql.setMethod('GET')
+                sparql.setReturnFormat(RDFXML)
+
+                result: ConjunctiveGraph = sparql.query().convert()
+                if result is not None:
+                    imported_entities: List[GraphEntity] = Reader.import_entities_from_graph(self, result, resp_agent)
+                    for imported_entity in imported_entities:
+                        imported_entity.g.remove((imported_entity.res, None, entity_res))
+
+    def commit_changes(self):
+        for res, entity in self.res_to_entity.items():
+            entity.commit_changes()
+            if entity.to_be_deleted:
+                del self.res_to_entity[res]
+
+    def _set_ns(self, g: Graph) -> None:
+        g.namespace_manager.bind("an", Namespace(self.g_an))
+        g.namespace_manager.bind("ar", Namespace(self.g_ar))
+        g.namespace_manager.bind("be", Namespace(self.g_be))
+        g.namespace_manager.bind("ci", Namespace(self.g_ci))
+        g.namespace_manager.bind("de", Namespace(self.g_de))
+        g.namespace_manager.bind("br", Namespace(self.g_br))
+        g.namespace_manager.bind("id", Namespace(self.g_id))
+        g.namespace_manager.bind("pl", Namespace(self.g_pl))
+        g.namespace_manager.bind("ra", Namespace(self.g_ra))
+        g.namespace_manager.bind("re", Namespace(self.g_re))
+        g.namespace_manager.bind("rp", Namespace(self.g_rp))
+        g.namespace_manager.bind("biro", GraphEntity.BIRO)
+        g.namespace_manager.bind("co", GraphEntity.CO)
+        g.namespace_manager.bind("c4o", GraphEntity.C4O)
+        g.namespace_manager.bind("cito", GraphEntity.CITO)
+        g.namespace_manager.bind("datacite", GraphEntity.DATACITE)
+        g.namespace_manager.bind("dcterms", GraphEntity.DCTERMS)
+        g.namespace_manager.bind("deo", GraphEntity.DEO)
+        g.namespace_manager.bind("doco", GraphEntity.DOCO)
+        g.namespace_manager.bind("fabio", GraphEntity.FABIO)
+        g.namespace_manager.bind("foaf", GraphEntity.FOAF)
+        g.namespace_manager.bind("frbr", GraphEntity.FRBR)
+        g.namespace_manager.bind("literal", GraphEntity.LITERAL)
+        g.namespace_manager.bind("oa", GraphEntity.OA)
+        g.namespace_manager.bind("oco", GraphEntity.OCO)
+        g.namespace_manager.bind("prism", GraphEntity.PRISM)
+        g.namespace_manager.bind("pro", GraphEntity.PRO)
+
+    def get_an(self) -> Tuple[ReferenceAnnotation]:
+        result: Tuple[ReferenceAnnotation] = tuple()
+        for ref in self.res_to_entity:
+            entity: GraphEntity = self.res_to_entity[ref]
+            if isinstance(entity, ReferenceAnnotation):
+                result += (entity, )
+        return result
+
+    def get_ar(self) -> Tuple[AgentRole]:
+        result: Tuple[AgentRole] = tuple()
+        for ref in self.res_to_entity:
+            entity: GraphEntity = self.res_to_entity[ref]
+            if isinstance(entity, AgentRole):
+                result += (entity, )
+        return result
+
+    def get_be(self) -> Tuple[BibliographicReference]:
+        result: Tuple[BibliographicReference] = tuple()
+        for ref in self.res_to_entity:
+            entity: GraphEntity = self.res_to_entity[ref]
+            if isinstance(entity, BibliographicReference):
+                result += (entity, )
+        return result
+
+    def get_br(self) -> Tuple[BibliographicResource]:
+        result: Tuple[BibliographicResource] = tuple()
+        for ref in self.res_to_entity:
+            entity: GraphEntity = self.res_to_entity[ref]
+            if isinstance(entity, BibliographicResource):
+                result += (entity, )
+        return result
+
+    def get_ci(self) -> Tuple[Citation]:
+        result: Tuple[Citation] = tuple()
+        for ref in self.res_to_entity:
+            entity: GraphEntity = self.res_to_entity[ref]
+            if isinstance(entity, Citation):
+                result += (entity, )
+        return result
+
+    def get_de(self) -> Tuple[DiscourseElement]:
+        result: Tuple[DiscourseElement] = tuple()
+        for ref in self.res_to_entity:
+            entity: GraphEntity = self.res_to_entity[ref]
+            if isinstance(entity, DiscourseElement):
+                result += (entity, )
+        return result
+
+    def get_id(self) -> Tuple[Identifier]:
+        result: Tuple[Identifier] = tuple()
+        for ref in self.res_to_entity:
+            entity: GraphEntity = self.res_to_entity[ref]
+            if isinstance(entity, Identifier):
+                result += (entity, )
+        return result
+
+    def get_pl(self) -> Tuple[PointerList]:
+        result: Tuple[PointerList] = tuple()
+        for ref in self.res_to_entity:
+            entity: GraphEntity = self.res_to_entity[ref]
+            if isinstance(entity, PointerList):
+                result += (entity, )
+        return result
+
+    def get_rp(self) -> Tuple[ReferencePointer]:
+        result: Tuple[ReferencePointer] = tuple()
+        for ref in self.res_to_entity:
+            entity: GraphEntity = self.res_to_entity[ref]
+            if isinstance(entity, ReferencePointer):
+                result += (entity, )
+        return result
+
+    def get_ra(self) -> Tuple[ResponsibleAgent]:
+        result: Tuple[ResponsibleAgent] = tuple()
+        for ref in self.res_to_entity:
+            entity: GraphEntity = self.res_to_entity[ref]
+            if isinstance(entity, ResponsibleAgent):
+                result += (entity, )
+        return result
+
+    def get_re(self) -> Tuple[ResourceEmbodiment]:
+        result: Tuple[ResourceEmbodiment] = tuple()
+        for ref in self.res_to_entity:
+            entity: GraphEntity = self.res_to_entity[ref]
+            if isinstance(entity, ResourceEmbodiment):
+                result += (entity, )
+        return result
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/metadata/__init__.py` & `oc_ocdm-8.1.0/oc_ocdm/test/counter_handler/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -9,10 +9,7 @@
 # THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 # REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 # FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
 # OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 # DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 # ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 # SOFTWARE.
-
-from oc_ocdm.metadata.metadata_entity import MetadataEntity
-from oc_ocdm.metadata.metadata_set import MetadataSet
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/metadata/entities/__init__.py` & `oc_ocdm-8.1.0/oc_ocdm/test/graph/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -9,10 +9,7 @@
 # THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 # REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 # FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
 # OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 # DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 # ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 # SOFTWARE.
-
-from oc_ocdm.metadata.entities.dataset import Dataset
-from oc_ocdm.metadata.entities.distribution import Distribution
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/metadata/entities/distribution.py` & `oc_ocdm-8.1.0/oc_ocdm/metadata/entities/distribution.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,322 +1,322 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-from rdflib import XSD
-
-from oc_ocdm.decorators import accepts_only
-from oc_ocdm.metadata.metadata_entity import MetadataEntity
-
-if TYPE_CHECKING:
-    from typing import Optional
-    from rdflib import URIRef
-
-
-class Distribution(MetadataEntity):
-    """Distribution (short: di): an accessible form of a dataset, for example a downloadable
-       file."""
-
-    @accepts_only('di')
-    def merge(self, other: Distribution) -> None:
-        """
-        The merge operation allows combining two ``Distribution`` entities into a single one,
-        by marking the second entity as to be deleted while also copying its data into the current
-        ``Distribution``. Moreover, every triple from the containing ``MetadataSet`` referring to the second
-        entity gets "redirected" to the current entity: **every other reference contained inside a
-        different source (e.g. a triplestore) must be manually handled by the user!**
-
-        In case of functional properties, values from the current entity get overwritten
-        by those coming from the second entity while, in all other cases, values from the
-        second entity are simply appended to those of the current entity. In this context,
-        ``rdfs:label`` is considered as a functional property, while ``rdf:type`` is not.
-
-        :param other: The entity which will be marked as to be deleted and whose properties will
-         be merged into the current entity.
-        :type other: Distribution
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        super(Distribution, self).merge(other)
-
-        title: Optional[str] = other.get_title()
-        if title is not None:
-            self.has_title(title)
-
-        description: Optional[str] = other.get_description()
-        if description is not None:
-            self.has_description(description)
-
-        pub_date: Optional[str] = other.get_publication_date()
-        if pub_date is not None:
-            self.has_publication_date(pub_date)
-
-        byte_size: Optional[str] = other.get_byte_size()
-        if byte_size is not None:
-            self.has_byte_size(byte_size)
-
-        license_uri: Optional[URIRef] = other.get_license()
-        if license_uri is not None:
-            self.has_license(license_uri)
-
-        download_url: Optional[URIRef] = other.get_download_url()
-        if download_url is not None:
-            self.has_download_url(download_url)
-
-        media_type: Optional[URIRef] = other.get_media_type()
-        if media_type is not None:
-            self.has_media_type(media_type)
-
-    # HAS TITLE
-    def get_title(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``dcterms:title`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(MetadataEntity.iri_title)
-
-    @accepts_only('literal')
-    def has_title(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``dcterms:title`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The title of the distribution.`
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_title()
-        self._create_literal(MetadataEntity.iri_title, string)
-
-    def remove_title(self) -> None:
-        """
-        Remover method corresponding to the ``dcterms:title`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, MetadataEntity.iri_title, None))
-
-    # HAS DESCRIPTION
-    def get_description(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``dcterms:description`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(MetadataEntity.iri_description)
-
-    @accepts_only('literal')
-    def has_description(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``dcterms:description`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `A short textual description of the content of the distribution.`
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_description()
-        self._create_literal(MetadataEntity.iri_description, string)
-
-    def remove_description(self) -> None:
-        """
-        Remover method corresponding to the ``dcterms:description`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, MetadataEntity.iri_description, None))
-
-    # HAS PUBLICATION DATE
-    def get_publication_date(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``dcterms:issued`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(MetadataEntity.iri_issued)
-
-    @accepts_only('literal')
-    def has_publication_date(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``dcterms:issued`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The date of first publication of the distribution.`
-
-        :param string: The value that will be set as the object of the property related to this method. **It must
-          be a string compliant with the** ``xsd:dateTime`` **datatype.**
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_publication_date()
-        self._create_literal(MetadataEntity.iri_issued, string, XSD.dateTime, False)
-
-    def remove_publication_date(self) -> None:
-        """
-        Remover method corresponding to the ``dcterms:issued`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, MetadataEntity.iri_issued, None))
-
-    # HAS BYTE SIZE
-    def get_byte_size(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``dcat:byte_size`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(MetadataEntity.iri_byte_size)
-
-    @accepts_only('literal')
-    def has_byte_size(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``dcat:byte_size`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The size in bytes of the distribution.`
-
-        :param string: The value that will be set as the object of the property related to this method. **It must
-          be a string compliant with the** ``xsd:decimal`` **datatype.**
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_byte_size()
-        self._create_literal(MetadataEntity.iri_byte_size, string, XSD.decimal)
-
-    def remove_byte_size(self) -> None:
-        """
-        Remover method corresponding to the ``dcat:byte_size`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, MetadataEntity.iri_byte_size, None))
-
-    # HAS LICENSE
-    def get_license(self) -> Optional[URIRef]:
-        """
-        Getter method corresponding to the ``dcterms:license`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(MetadataEntity.iri_license)
-
-    @accepts_only('thing')
-    def has_license(self, thing_res: URIRef) -> None:
-        """
-        Setter method corresponding to the ``dcterms:license`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The resource describing the license associated with the data in the distribution.`
-
-        :param thing_res: The value that will be set as the object of the property related to this method
-        :type thing_res: URIRef
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_license()
-        self.g.add((self.res, MetadataEntity.iri_license, thing_res))
-
-    def remove_license(self) -> None:
-        """
-        Remover method corresponding to the ``dcterms:license`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, MetadataEntity.iri_license, None))
-
-    # HAS DOWNLOAD URL
-    def get_download_url(self) -> Optional[URIRef]:
-        """
-        Getter method corresponding to the ``dcat:downloadURL`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(MetadataEntity.iri_download_url)
-
-    @accepts_only('thing')
-    def has_download_url(self, thing_res: URIRef) -> None:
-        """
-        Setter method corresponding to the ``dcat:downloadURL`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The URL of the document where the distribution is stored.`
-
-        :param thing_res: The value that will be set as the object of the property related to this method
-        :type thing_res: URIRef
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_download_url()
-        self.g.add((self.res, MetadataEntity.iri_download_url, thing_res))
-
-    def remove_download_url(self) -> None:
-        """
-        Remover method corresponding to the ``dcat:downloadURL`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, MetadataEntity.iri_download_url, None))
-
-    # HAS_MEDIA_TYPE
-    def get_media_type(self) -> Optional[URIRef]:
-        """
-        Getter method corresponding to the ``dcat:mediaType`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(MetadataEntity.iri_media_type)
-
-    @accepts_only('thing')
-    def has_media_type(self, thing_res: URIRef) -> None:
-        """
-        Setter method corresponding to the ``dcat:mediaType`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The file type of the representation of the distribution (according to IANA media types).`
-
-        :param thing_res: The value that will be set as the object of the property related to this method
-        :type thing_res: URIRef
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_media_type()
-        self.g.add((self.res, MetadataEntity.iri_media_type, thing_res))
-
-    def remove_media_type(self) -> None:
-        """
-        Remover method corresponding to the ``dcat:mediaType`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, MetadataEntity.iri_media_type, None))
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+from rdflib import XSD
+
+from oc_ocdm.decorators import accepts_only
+from oc_ocdm.metadata.metadata_entity import MetadataEntity
+
+if TYPE_CHECKING:
+    from typing import Optional
+    from rdflib import URIRef
+
+
+class Distribution(MetadataEntity):
+    """Distribution (short: di): an accessible form of a dataset, for example a downloadable
+       file."""
+
+    @accepts_only('di')
+    def merge(self, other: Distribution) -> None:
+        """
+        The merge operation allows combining two ``Distribution`` entities into a single one,
+        by marking the second entity as to be deleted while also copying its data into the current
+        ``Distribution``. Moreover, every triple from the containing ``MetadataSet`` referring to the second
+        entity gets "redirected" to the current entity: **every other reference contained inside a
+        different source (e.g. a triplestore) must be manually handled by the user!**
+
+        In case of functional properties, values from the current entity get overwritten
+        by those coming from the second entity while, in all other cases, values from the
+        second entity are simply appended to those of the current entity. In this context,
+        ``rdfs:label`` is considered as a functional property, while ``rdf:type`` is not.
+
+        :param other: The entity which will be marked as to be deleted and whose properties will
+         be merged into the current entity.
+        :type other: Distribution
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        super(Distribution, self).merge(other)
+
+        title: Optional[str] = other.get_title()
+        if title is not None:
+            self.has_title(title)
+
+        description: Optional[str] = other.get_description()
+        if description is not None:
+            self.has_description(description)
+
+        pub_date: Optional[str] = other.get_publication_date()
+        if pub_date is not None:
+            self.has_publication_date(pub_date)
+
+        byte_size: Optional[str] = other.get_byte_size()
+        if byte_size is not None:
+            self.has_byte_size(byte_size)
+
+        license_uri: Optional[URIRef] = other.get_license()
+        if license_uri is not None:
+            self.has_license(license_uri)
+
+        download_url: Optional[URIRef] = other.get_download_url()
+        if download_url is not None:
+            self.has_download_url(download_url)
+
+        media_type: Optional[URIRef] = other.get_media_type()
+        if media_type is not None:
+            self.has_media_type(media_type)
+
+    # HAS TITLE
+    def get_title(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``dcterms:title`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(MetadataEntity.iri_title)
+
+    @accepts_only('literal')
+    def has_title(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``dcterms:title`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The title of the distribution.`
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_title()
+        self._create_literal(MetadataEntity.iri_title, string)
+
+    def remove_title(self) -> None:
+        """
+        Remover method corresponding to the ``dcterms:title`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, MetadataEntity.iri_title, None))
+
+    # HAS DESCRIPTION
+    def get_description(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``dcterms:description`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(MetadataEntity.iri_description)
+
+    @accepts_only('literal')
+    def has_description(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``dcterms:description`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `A short textual description of the content of the distribution.`
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_description()
+        self._create_literal(MetadataEntity.iri_description, string)
+
+    def remove_description(self) -> None:
+        """
+        Remover method corresponding to the ``dcterms:description`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, MetadataEntity.iri_description, None))
+
+    # HAS PUBLICATION DATE
+    def get_publication_date(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``dcterms:issued`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(MetadataEntity.iri_issued)
+
+    @accepts_only('literal')
+    def has_publication_date(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``dcterms:issued`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The date of first publication of the distribution.`
+
+        :param string: The value that will be set as the object of the property related to this method. **It must
+          be a string compliant with the** ``xsd:dateTime`` **datatype.**
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_publication_date()
+        self._create_literal(MetadataEntity.iri_issued, string, XSD.dateTime, False)
+
+    def remove_publication_date(self) -> None:
+        """
+        Remover method corresponding to the ``dcterms:issued`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, MetadataEntity.iri_issued, None))
+
+    # HAS BYTE SIZE
+    def get_byte_size(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``dcat:byte_size`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(MetadataEntity.iri_byte_size)
+
+    @accepts_only('literal')
+    def has_byte_size(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``dcat:byte_size`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The size in bytes of the distribution.`
+
+        :param string: The value that will be set as the object of the property related to this method. **It must
+          be a string compliant with the** ``xsd:decimal`` **datatype.**
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_byte_size()
+        self._create_literal(MetadataEntity.iri_byte_size, string, XSD.decimal)
+
+    def remove_byte_size(self) -> None:
+        """
+        Remover method corresponding to the ``dcat:byte_size`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, MetadataEntity.iri_byte_size, None))
+
+    # HAS LICENSE
+    def get_license(self) -> Optional[URIRef]:
+        """
+        Getter method corresponding to the ``dcterms:license`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(MetadataEntity.iri_license)
+
+    @accepts_only('thing')
+    def has_license(self, thing_res: URIRef) -> None:
+        """
+        Setter method corresponding to the ``dcterms:license`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The resource describing the license associated with the data in the distribution.`
+
+        :param thing_res: The value that will be set as the object of the property related to this method
+        :type thing_res: URIRef
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_license()
+        self.g.add((self.res, MetadataEntity.iri_license, thing_res))
+
+    def remove_license(self) -> None:
+        """
+        Remover method corresponding to the ``dcterms:license`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, MetadataEntity.iri_license, None))
+
+    # HAS DOWNLOAD URL
+    def get_download_url(self) -> Optional[URIRef]:
+        """
+        Getter method corresponding to the ``dcat:downloadURL`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(MetadataEntity.iri_download_url)
+
+    @accepts_only('thing')
+    def has_download_url(self, thing_res: URIRef) -> None:
+        """
+        Setter method corresponding to the ``dcat:downloadURL`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The URL of the document where the distribution is stored.`
+
+        :param thing_res: The value that will be set as the object of the property related to this method
+        :type thing_res: URIRef
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_download_url()
+        self.g.add((self.res, MetadataEntity.iri_download_url, thing_res))
+
+    def remove_download_url(self) -> None:
+        """
+        Remover method corresponding to the ``dcat:downloadURL`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, MetadataEntity.iri_download_url, None))
+
+    # HAS_MEDIA_TYPE
+    def get_media_type(self) -> Optional[URIRef]:
+        """
+        Getter method corresponding to the ``dcat:mediaType`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(MetadataEntity.iri_media_type)
+
+    @accepts_only('thing')
+    def has_media_type(self, thing_res: URIRef) -> None:
+        """
+        Setter method corresponding to the ``dcat:mediaType`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The file type of the representation of the distribution (according to IANA media types).`
+
+        :param thing_res: The value that will be set as the object of the property related to this method
+        :type thing_res: URIRef
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_media_type()
+        self.g.add((self.res, MetadataEntity.iri_media_type, thing_res))
+
+    def remove_media_type(self) -> None:
+        """
+        Remover method corresponding to the ``dcat:mediaType`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, MetadataEntity.iri_media_type, None))
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/metadata/metadata_entity.py` & `oc_ocdm-8.1.0/oc_ocdm/metadata/metadata_entity.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,181 +1,181 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-from typing import TYPE_CHECKING, Tuple, List, Optional
-
-from oc_ocdm.abstract_entity import AbstractEntity
-from rdflib import URIRef, Namespace, Graph
-
-if TYPE_CHECKING:
-    from typing import ClassVar, Dict
-    from oc_ocdm.metadata.metadata_set import MetadataSet
-
-
-class MetadataEntity(AbstractEntity):
-    DCTERMS = Namespace("http://purl.org/dc/terms/")
-    DCAT = Namespace("http://www.w3.org/ns/dcat#")
-    VOID = Namespace("http://rdfs.org/ns/void#")
-
-    iri_dataset = DCAT.Dataset
-    iri_datafile = DCAT.Distribution
-
-    iri_title = DCTERMS["title"]
-    iri_description = DCTERMS.description
-    iri_issued = DCTERMS.issued
-    iri_modified = DCTERMS.modified
-    iri_keyword = DCAT.keyword
-    iri_subject = DCAT.theme
-    iri_landing_page = DCAT.landingPage
-    iri_subset = VOID.subset
-    iri_sparql_endpoint = VOID.sparqlEndpoint
-    iri_distribution = DCAT.distribution
-    iri_license = DCTERMS.license
-    iri_download_url = DCAT.downloadURL
-    iri_media_type = DCAT.mediaType
-    iri_byte_size = DCAT.byte_size
-
-    short_name_to_type_iri: ClassVar[Dict[str, URIRef]] = {
-        '_dataset_': iri_dataset,
-        'di': iri_datafile
-    }
-
-    def __init__(self, g: Graph, base_iri: str, dataset_name: str, m_set: MetadataSet,
-                 res: URIRef = None, res_type: URIRef = None, resp_agent: str = None,
-                 source: str = None, count: str = None, label: str = None, short_name: str = "",
-                 preexisting_graph: Graph = None) -> None:
-        super(MetadataEntity, self).__init__()
-        self.g: Graph = g
-        self.base_iri: str = base_iri
-        self.dataset_name: str = dataset_name
-        self.resp_agent: str = resp_agent
-        self.source: str = source
-        self.short_name: str = short_name
-        self.m_set: MetadataSet = m_set
-        self.preexisting_graph: Graph = Graph(identifier=g.identifier)
-        self._merge_list: Tuple[MetadataEntity] = tuple()
-        # FLAGS
-        self._to_be_deleted: bool = False
-        self._was_merged: bool = False
-
-        # If res was not specified, create from scratch the URI reference for this entity,
-        # otherwise use the provided one
-        if res is None:
-            base_res: str = self.base_iri + self.dataset_name
-            if base_res[-1] != '/':
-                base_res += '/'
-            self.res = self._generate_new_res(count, base_res, short_name)
-        else:
-            self.res = res
-
-        if m_set is not None:
-            # If not already done, register this MetadataEntity instance inside the MetadataSet
-            if self.res not in m_set.res_to_entity:
-                m_set.res_to_entity[self.res] = self
-
-        if preexisting_graph is not None:
-            # Triples inside self.g are entirely replaced by triples from preexisting_graph.
-            # This has maximum priority with respect to every other self.g initializations.
-            # It's fundamental that the preexisting graph gets passed as an argument of the constructor:
-            # allowing the user to set this value later through a method would mean that the user could
-            # set the preexisting graph AFTER having modified self.g (which would not make sense).
-            self.remove_every_triple()
-            for p, o in preexisting_graph.predicate_objects(self.res):
-                self.g.add((self.res, p, o))
-                self.preexisting_graph.add((self.res, p, o))
-        else:
-            # Add mandatory information to the entity graph
-            self._create_type(res_type)
-            if label is not None:
-                self.create_label(label)
-
-    @staticmethod
-    def _generate_new_res(count: str, base_res: str, short_name: str) -> URIRef:
-        if short_name == '_dataset_':
-            return URIRef(base_res)
-        else:
-            return URIRef(base_res + short_name + "/" + count)
-
-    @property
-    def to_be_deleted(self) -> bool:
-        return self._to_be_deleted
-
-    @property
-    def was_merged(self) -> bool:
-        return self._was_merged
-
-    @property
-    def merge_list(self) -> Tuple[MetadataEntity]:
-        return self._merge_list
-
-    def mark_as_to_be_deleted(self) -> None:
-        # Here we must REMOVE triples pointing
-        # to 'self' [THIS CANNOT BE UNDONE]:
-        for res, entity in self.m_set.res_to_entity.items():
-            triples_list: List[Tuple] = list(entity.g.triples((res, None, self.res)))
-            for triple in triples_list:
-                entity.g.remove(triple)
-
-        self._to_be_deleted = True
-
-    def merge(self, other: MetadataEntity) -> None:
-        """
-        **WARNING:** ``MetadataEntity`` **is an abstract class that cannot be instantiated at runtime.
-        As such, it's only possible to execute this method on entities generated from**
-        ``MetadataEntity``'s **subclasses. Please, refer to their documentation of the** `merge` **method.**
-
-        :param other: The entity which will be marked as to be deleted and whose properties will
-         be merged into the current entity.
-        :type other: MetadataEntity
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-
-        # Here we must REDIRECT triples pointing
-        # to 'other' to make them point to 'self':
-        for res, entity in self.m_set.res_to_entity.items():
-            triples_list: List[Tuple] = list(entity.g.triples((res, None, other.res)))
-            for triple in triples_list:
-                entity.g.remove(triple)
-                new_triple = (triple[0], triple[1], self.res)
-                entity.g.add(new_triple)
-
-        types: List[URIRef] = other.get_types()
-        for cur_type in types:
-            self._create_type(cur_type)
-
-        label: Optional[str] = other.get_label()
-        if label is not None:
-            self.create_label(label)
-
-        self._was_merged = True
-        self._merge_list = (*self._merge_list, other)
-
-        # 'other' must be deleted AFTER the redirection of
-        # triples pointing to it, since mark_as_to_be_deleted
-        # also removes every triple pointing to 'other'
-        other.mark_as_to_be_deleted()
-
-    def commit_changes(self):
-        self.preexisting_graph = Graph(identifier=self.g.identifier)
-        if self._to_be_deleted:
-            self.remove_every_triple()
-        else:
-            for triple in self.g.triples((self.res, None, None)):
-                self.preexisting_graph.add(triple)
-        self._to_be_deleted = False
-        self._was_merged = False
-        self._merge_list = tuple()
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+from typing import TYPE_CHECKING, Tuple, List, Optional
+
+from oc_ocdm.abstract_entity import AbstractEntity
+from rdflib import URIRef, Namespace, Graph
+
+if TYPE_CHECKING:
+    from typing import ClassVar, Dict
+    from oc_ocdm.metadata.metadata_set import MetadataSet
+
+
+class MetadataEntity(AbstractEntity):
+    DCTERMS = Namespace("http://purl.org/dc/terms/")
+    DCAT = Namespace("http://www.w3.org/ns/dcat#")
+    VOID = Namespace("http://rdfs.org/ns/void#")
+
+    iri_dataset = DCAT.Dataset
+    iri_datafile = DCAT.Distribution
+
+    iri_title = DCTERMS["title"]
+    iri_description = DCTERMS.description
+    iri_issued = DCTERMS.issued
+    iri_modified = DCTERMS.modified
+    iri_keyword = DCAT.keyword
+    iri_subject = DCAT.theme
+    iri_landing_page = DCAT.landingPage
+    iri_subset = VOID.subset
+    iri_sparql_endpoint = VOID.sparqlEndpoint
+    iri_distribution = DCAT.distribution
+    iri_license = DCTERMS.license
+    iri_download_url = DCAT.downloadURL
+    iri_media_type = DCAT.mediaType
+    iri_byte_size = DCAT.byte_size
+
+    short_name_to_type_iri: ClassVar[Dict[str, URIRef]] = {
+        '_dataset_': iri_dataset,
+        'di': iri_datafile
+    }
+
+    def __init__(self, g: Graph, base_iri: str, dataset_name: str, m_set: MetadataSet,
+                 res: URIRef = None, res_type: URIRef = None, resp_agent: str = None,
+                 source: str = None, count: str = None, label: str = None, short_name: str = "",
+                 preexisting_graph: Graph = None) -> None:
+        super(MetadataEntity, self).__init__()
+        self.g: Graph = g
+        self.base_iri: str = base_iri
+        self.dataset_name: str = dataset_name
+        self.resp_agent: str = resp_agent
+        self.source: str = source
+        self.short_name: str = short_name
+        self.m_set: MetadataSet = m_set
+        self.preexisting_graph: Graph = Graph(identifier=g.identifier)
+        self._merge_list: Tuple[MetadataEntity] = tuple()
+        # FLAGS
+        self._to_be_deleted: bool = False
+        self._was_merged: bool = False
+
+        # If res was not specified, create from scratch the URI reference for this entity,
+        # otherwise use the provided one
+        if res is None:
+            base_res: str = self.base_iri + self.dataset_name
+            if base_res[-1] != '/':
+                base_res += '/'
+            self.res = self._generate_new_res(count, base_res, short_name)
+        else:
+            self.res = res
+
+        if m_set is not None:
+            # If not already done, register this MetadataEntity instance inside the MetadataSet
+            if self.res not in m_set.res_to_entity:
+                m_set.res_to_entity[self.res] = self
+
+        if preexisting_graph is not None:
+            # Triples inside self.g are entirely replaced by triples from preexisting_graph.
+            # This has maximum priority with respect to every other self.g initializations.
+            # It's fundamental that the preexisting graph gets passed as an argument of the constructor:
+            # allowing the user to set this value later through a method would mean that the user could
+            # set the preexisting graph AFTER having modified self.g (which would not make sense).
+            self.remove_every_triple()
+            for p, o in preexisting_graph.predicate_objects(self.res):
+                self.g.add((self.res, p, o))
+                self.preexisting_graph.add((self.res, p, o))
+        else:
+            # Add mandatory information to the entity graph
+            self._create_type(res_type)
+            if label is not None:
+                self.create_label(label)
+
+    @staticmethod
+    def _generate_new_res(count: str, base_res: str, short_name: str) -> URIRef:
+        if short_name == '_dataset_':
+            return URIRef(base_res)
+        else:
+            return URIRef(base_res + short_name + "/" + count)
+
+    @property
+    def to_be_deleted(self) -> bool:
+        return self._to_be_deleted
+
+    @property
+    def was_merged(self) -> bool:
+        return self._was_merged
+
+    @property
+    def merge_list(self) -> Tuple[MetadataEntity]:
+        return self._merge_list
+
+    def mark_as_to_be_deleted(self) -> None:
+        # Here we must REMOVE triples pointing
+        # to 'self' [THIS CANNOT BE UNDONE]:
+        for res, entity in self.m_set.res_to_entity.items():
+            triples_list: List[Tuple] = list(entity.g.triples((res, None, self.res)))
+            for triple in triples_list:
+                entity.g.remove(triple)
+
+        self._to_be_deleted = True
+
+    def merge(self, other: MetadataEntity) -> None:
+        """
+        **WARNING:** ``MetadataEntity`` **is an abstract class that cannot be instantiated at runtime.
+        As such, it's only possible to execute this method on entities generated from**
+        ``MetadataEntity``'s **subclasses. Please, refer to their documentation of the** `merge` **method.**
+
+        :param other: The entity which will be marked as to be deleted and whose properties will
+         be merged into the current entity.
+        :type other: MetadataEntity
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+
+        # Here we must REDIRECT triples pointing
+        # to 'other' to make them point to 'self':
+        for res, entity in self.m_set.res_to_entity.items():
+            triples_list: List[Tuple] = list(entity.g.triples((res, None, other.res)))
+            for triple in triples_list:
+                entity.g.remove(triple)
+                new_triple = (triple[0], triple[1], self.res)
+                entity.g.add(new_triple)
+
+        types: List[URIRef] = other.get_types()
+        for cur_type in types:
+            self._create_type(cur_type)
+
+        label: Optional[str] = other.get_label()
+        if label is not None:
+            self.create_label(label)
+
+        self._was_merged = True
+        self._merge_list = (*self._merge_list, other)
+
+        # 'other' must be deleted AFTER the redirection of
+        # triples pointing to it, since mark_as_to_be_deleted
+        # also removes every triple pointing to 'other'
+        other.mark_as_to_be_deleted()
+
+    def commit_changes(self):
+        self.preexisting_graph = Graph(identifier=self.g.identifier)
+        if self._to_be_deleted:
+            self.remove_every_triple()
+        else:
+            for triple in self.g.triples((self.res, None, None)):
+                self.preexisting_graph.add(triple)
+        self._to_be_deleted = False
+        self._was_merged = False
+        self._merge_list = tuple()
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/metadata/metadata_set.py` & `oc_ocdm-8.1.0/oc_ocdm/metadata/metadata_set.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,138 +1,138 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-from oc_ocdm.counter_handler.counter_handler import CounterHandler
-from oc_ocdm.counter_handler.filesystem_counter_handler import FilesystemCounterHandler
-from oc_ocdm.counter_handler.in_memory_counter_handler import InMemoryCounterHandler
-from oc_ocdm.metadata.entities.dataset import Dataset
-from oc_ocdm.metadata.entities.distribution import Distribution
-from oc_ocdm.support.support import get_count, is_dataset, get_short_name
-
-if TYPE_CHECKING:
-    from typing import Dict, Optional, Tuple, ClassVar
-
-from rdflib import Graph, URIRef
-
-from oc_ocdm.metadata.metadata_entity import MetadataEntity
-from oc_ocdm.abstract_set import AbstractSet
-
-
-class MetadataSet(AbstractSet):
-    # Labels
-    labels: ClassVar[Dict[str, str]] = {
-        "_dataset_": "dataset",
-        "di": "distribution"
-    }
-
-    def __init__(self, base_iri: str, info_dir: str = "", wanted_label: bool = True) -> None:
-        super(MetadataSet, self).__init__()
-        # The following variable maps a URIRef with the related metadata entity
-        self.res_to_entity: Dict[URIRef, MetadataEntity] = {}
-        self.base_iri: str = base_iri
-        if self.base_iri[-1] != '/':
-            self.base_iri += '/'
-        self.wanted_label: bool = wanted_label
-
-        if info_dir is not None and info_dir != "":
-            self.counter_handler: CounterHandler = FilesystemCounterHandler(info_dir)
-        else:
-            self.counter_handler: CounterHandler = InMemoryCounterHandler()
-
-    def get_entity(self, res: URIRef) -> Optional[MetadataEntity]:
-        if res in self.res_to_entity:
-            return self.res_to_entity[res]
-
-    def add_dataset(self, dataset_name: str, resp_agent: str, source: str = None, res: URIRef = None,
-                    preexisting_graph: Graph = None) -> Dataset:
-        if res is not None and not is_dataset(res):
-            raise ValueError(f"Given res: <{res}> is inappropriate for a Dataset entity.")
-        if res is not None and res in self.res_to_entity:
-            return self.res_to_entity[res]
-        # Here we use a fictitious short name for Dataset, since the OCDM document doesn't specify
-        # any particular short name for this type of entity. It's only used internally to distinguish
-        # between different metadata entities but it's meaningless outside of this scope.
-        cur_g, count, label = self._add_metadata("_dataset_", dataset_name, res)
-        return Dataset(cur_g, self.base_iri, dataset_name, self, res,
-                       MetadataEntity.iri_dataset, resp_agent,
-                       source, count, label, "_dataset_", preexisting_graph)
-
-    def add_di(self, dataset_name: str, resp_agent: str, source: str = None,
-               res: URIRef = None, preexisting_graph: Graph = None) -> Distribution:
-        if res is not None and get_short_name(res) != "di":
-            raise ValueError(f"Given res: <{res}> is inappropriate for a Distribution entity.")
-        if res is not None and res in self.res_to_entity:
-            return self.res_to_entity[res]
-        cur_g, count, label = self._add_metadata("di", dataset_name, res)
-        return Distribution(cur_g, self.base_iri, dataset_name, self, res,
-                            MetadataEntity.iri_datafile, resp_agent,
-                            source, count, label, "di", preexisting_graph)
-
-    def _add_metadata(self, short_name: str, dataset_name: str,
-                      res: URIRef = None) -> Tuple[Graph, Optional[str], Optional[str]]:
-        cur_g: Graph = Graph()
-        self._set_ns(cur_g)
-
-        count: Optional[str] = None
-        label: Optional[str] = None
-
-        if res is not None:
-            if short_name != '_dataset_':  # Datasets don't have a counter associated with them...
-                try:
-                    res_count: int = int(get_count(res))
-                except ValueError:
-                    res_count: int = -1
-                if res_count > self.counter_handler.read_metadata_counter(short_name, dataset_name):
-                    self.counter_handler.set_metadata_counter(res_count, short_name, dataset_name)
-            return cur_g, count, label
-
-        if short_name != '_dataset_':  # Datasets don't have a counter associated with them...
-            count = str(self.counter_handler.increment_metadata_counter(short_name, dataset_name))
-
-        if self.wanted_label:
-            label = "%s %s [%s/%s]" % (self.labels[short_name], count, short_name, count)
-
-        return cur_g, count, label
-
-    def commit_changes(self):
-        for res, entity in self.res_to_entity.items():
-            entity.commit_changes()
-            if entity.to_be_deleted:
-                del self.res_to_entity[res]
-
-    @staticmethod
-    def _set_ns(g: Graph) -> None:
-        g.namespace_manager.bind("dcterms", MetadataEntity.DCTERMS)
-        g.namespace_manager.bind("dcat", MetadataEntity.DCAT)
-        g.namespace_manager.bind("void", MetadataEntity.VOID)
-
-    def get_dataset(self) -> Tuple[Dataset]:
-        result: Tuple[Dataset] = tuple()
-        for ref in self.res_to_entity:
-            entity: MetadataEntity = self.res_to_entity[ref]
-            if isinstance(entity, Dataset):
-                result += (entity, )
-        return result
-
-    def get_di(self) -> Tuple[Distribution]:
-        result: Tuple[Distribution] = tuple()
-        for ref in self.res_to_entity:
-            entity: MetadataEntity = self.res_to_entity[ref]
-            if isinstance(entity, Distribution):
-                result += (entity, )
-        return result
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+from oc_ocdm.counter_handler.counter_handler import CounterHandler
+from oc_ocdm.counter_handler.filesystem_counter_handler import FilesystemCounterHandler
+from oc_ocdm.counter_handler.in_memory_counter_handler import InMemoryCounterHandler
+from oc_ocdm.metadata.entities.dataset import Dataset
+from oc_ocdm.metadata.entities.distribution import Distribution
+from oc_ocdm.support.support import get_count, is_dataset, get_short_name
+
+if TYPE_CHECKING:
+    from typing import Dict, Optional, Tuple, ClassVar
+
+from rdflib import Graph, URIRef
+
+from oc_ocdm.metadata.metadata_entity import MetadataEntity
+from oc_ocdm.abstract_set import AbstractSet
+
+
+class MetadataSet(AbstractSet):
+    # Labels
+    labels: ClassVar[Dict[str, str]] = {
+        "_dataset_": "dataset",
+        "di": "distribution"
+    }
+
+    def __init__(self, base_iri: str, info_dir: str = "", wanted_label: bool = True) -> None:
+        super(MetadataSet, self).__init__()
+        # The following variable maps a URIRef with the related metadata entity
+        self.res_to_entity: Dict[URIRef, MetadataEntity] = {}
+        self.base_iri: str = base_iri
+        if self.base_iri[-1] != '/':
+            self.base_iri += '/'
+        self.wanted_label: bool = wanted_label
+
+        if info_dir is not None and info_dir != "":
+            self.counter_handler: CounterHandler = FilesystemCounterHandler(info_dir)
+        else:
+            self.counter_handler: CounterHandler = InMemoryCounterHandler()
+
+    def get_entity(self, res: URIRef) -> Optional[MetadataEntity]:
+        if res in self.res_to_entity:
+            return self.res_to_entity[res]
+
+    def add_dataset(self, dataset_name: str, resp_agent: str, source: str = None, res: URIRef = None,
+                    preexisting_graph: Graph = None) -> Dataset:
+        if res is not None and not is_dataset(res):
+            raise ValueError(f"Given res: <{res}> is inappropriate for a Dataset entity.")
+        if res is not None and res in self.res_to_entity:
+            return self.res_to_entity[res]
+        # Here we use a fictitious short name for Dataset, since the OCDM document doesn't specify
+        # any particular short name for this type of entity. It's only used internally to distinguish
+        # between different metadata entities but it's meaningless outside of this scope.
+        cur_g, count, label = self._add_metadata("_dataset_", dataset_name, res)
+        return Dataset(cur_g, self.base_iri, dataset_name, self, res,
+                       MetadataEntity.iri_dataset, resp_agent,
+                       source, count, label, "_dataset_", preexisting_graph)
+
+    def add_di(self, dataset_name: str, resp_agent: str, source: str = None,
+               res: URIRef = None, preexisting_graph: Graph = None) -> Distribution:
+        if res is not None and get_short_name(res) != "di":
+            raise ValueError(f"Given res: <{res}> is inappropriate for a Distribution entity.")
+        if res is not None and res in self.res_to_entity:
+            return self.res_to_entity[res]
+        cur_g, count, label = self._add_metadata("di", dataset_name, res)
+        return Distribution(cur_g, self.base_iri, dataset_name, self, res,
+                            MetadataEntity.iri_datafile, resp_agent,
+                            source, count, label, "di", preexisting_graph)
+
+    def _add_metadata(self, short_name: str, dataset_name: str,
+                      res: URIRef = None) -> Tuple[Graph, Optional[str], Optional[str]]:
+        cur_g: Graph = Graph()
+        self._set_ns(cur_g)
+
+        count: Optional[str] = None
+        label: Optional[str] = None
+
+        if res is not None:
+            if short_name != '_dataset_':  # Datasets don't have a counter associated with them...
+                try:
+                    res_count: int = int(get_count(res))
+                except ValueError:
+                    res_count: int = -1
+                if res_count > self.counter_handler.read_metadata_counter(short_name, dataset_name):
+                    self.counter_handler.set_metadata_counter(res_count, short_name, dataset_name)
+            return cur_g, count, label
+
+        if short_name != '_dataset_':  # Datasets don't have a counter associated with them...
+            count = str(self.counter_handler.increment_metadata_counter(short_name, dataset_name))
+
+        if self.wanted_label:
+            label = "%s %s [%s/%s]" % (self.labels[short_name], count, short_name, count)
+
+        return cur_g, count, label
+
+    def commit_changes(self):
+        for res, entity in self.res_to_entity.items():
+            entity.commit_changes()
+            if entity.to_be_deleted:
+                del self.res_to_entity[res]
+
+    @staticmethod
+    def _set_ns(g: Graph) -> None:
+        g.namespace_manager.bind("dcterms", MetadataEntity.DCTERMS)
+        g.namespace_manager.bind("dcat", MetadataEntity.DCAT)
+        g.namespace_manager.bind("void", MetadataEntity.VOID)
+
+    def get_dataset(self) -> Tuple[Dataset]:
+        result: Tuple[Dataset] = tuple()
+        for ref in self.res_to_entity:
+            entity: MetadataEntity = self.res_to_entity[ref]
+            if isinstance(entity, Dataset):
+                result += (entity, )
+        return result
+
+    def get_di(self) -> Tuple[Distribution]:
+        result: Tuple[Distribution] = tuple()
+        for ref in self.res_to_entity:
+            entity: MetadataEntity = self.res_to_entity[ref]
+            if isinstance(entity, Distribution):
+                result += (entity, )
+        return result
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/prov/__init__.py` & `oc_ocdm-8.1.0/oc_ocdm/resources/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,18 +1,15 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-
-from oc_ocdm.prov.prov_entity import ProvEntity
-from oc_ocdm.prov.prov_set import ProvSet
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/prov/entities/__init__.py` & `oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -9,9 +9,7 @@
 # THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 # REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 # FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
 # OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 # DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 # ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 # SOFTWARE.
-
-from oc_ocdm.prov.entities.snapshot_entity import SnapshotEntity
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/prov/entities/snapshot_entity.py` & `oc_ocdm-8.1.0/oc_ocdm/prov/entities/snapshot_entity.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,333 +1,333 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-from rdflib import XSD
-
-from oc_ocdm.decorators import accepts_only
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.prov.prov_entity import ProvEntity
-
-if TYPE_CHECKING:
-    from typing import List, Optional
-
-    from rdflib import URIRef
-
-
-class SnapshotEntity(ProvEntity):
-    """Snapshot of entity metadata (short: se): a particular snapshot recording the
-    metadata associated with an individual entity (either a bibliographic entity or an
-    identifier) at a particular date and time, including the agent, such as a person,
-    organisation or automated process that created or modified the entity metadata."""
-
-    # HAS CREATION DATE
-    def get_generation_time(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``prov:generatedAtTime`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(ProvEntity.iri_generated_at_time)
-
-    @accepts_only('literal')
-    def has_generation_time(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``prov:generatedAtTime`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The date on which a particular snapshot of a bibliographic entity's metadata was
-        created.`
-
-        :param string: The value that will be set as the object of the property related to this method. **It must
-          be a string compliant with the** ``xsd:dateTime`` **datatype.**
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_generation_time()
-        self._create_literal(ProvEntity.iri_generated_at_time, string, XSD.dateTime)
-
-    def remove_generation_time(self) -> None:
-        """
-        Remover method corresponding to the ``prov:generatedAtTime`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, ProvEntity.iri_generated_at_time, None))
-
-    # HAS INVALIDATION DATE
-    def get_invalidation_time(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``prov:invalidatedAtTime`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(ProvEntity.iri_invalidated_at_time)
-
-    @accepts_only('literal')
-    def has_invalidation_time(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``prov:invalidatedAtTime`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The date on which a snapshot of a bibliographic entity's metadata was invalidated due
-        to an update (e.g. a correction, or the addition of some metadata that was not specified
-        in the previous snapshot), or due to a merger of the entity with another one.`
-
-        :param string: The value that will be set as the object of the property related to this method. **It must
-          be a string compliant with the** ``xsd:dateTime`` **datatype.**
-        :type string: str
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.remove_invalidation_time()
-        self._create_literal(ProvEntity.iri_invalidated_at_time, string, XSD.dateTime)
-
-    def remove_invalidation_time(self) -> None:
-        """
-        Remover method corresponding to the ``prov:invalidatedAtTime`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, ProvEntity.iri_invalidated_at_time, None))
-
-    # IS SNAPSHOT OF
-    def get_is_snapshot_of(self) -> Optional[URIRef]:
-        """
-        Getter method corresponding to the ``prov:specializationOf`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        uri: Optional[URIRef] = self._get_uri_reference(ProvEntity.iri_specialization_of)
-        return uri
-
-    def is_snapshot_of(self, en_res: GraphEntity) -> None:
-        """
-        Setter method corresponding to the ``prov:specializationOf`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `This property is used to link a snapshot of entity metadata to the bibliographic entity
-        to which the snapshot refers.`
-
-        :param en_res: The value that will be set as the object of the property related to this method
-        :type en_res: GraphEntity
-        :return: None
-        """
-        self.remove_is_snapshot_of()
-        self.g.add((self.res, ProvEntity.iri_specialization_of, en_res.res))
-
-    def remove_is_snapshot_of(self) -> None:
-        """
-        Remover method corresponding to the ``prov:specializationOf`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, ProvEntity.iri_specialization_of, None))
-
-    # IS DERIVED FROM
-    def get_derives_from(self) -> List[ProvEntity]:
-        """
-        Getter method corresponding to the ``prov:wasDerivedFrom`` RDF predicate.
-
-        :return: A list containing the requested values if found, None otherwise
-        """
-        uri_list: List[URIRef] = self._get_multiple_uri_references(ProvEntity.iri_was_derived_from, 'se')
-        result: List[ProvEntity] = []
-        for uri in uri_list:
-            # TODO: what is the prov_subject of these snapshots?
-            result.append(self.p_set.add_se(None, uri))
-        return result
-
-    @accepts_only('se')
-    def derives_from(self, se_res: ProvEntity) -> None:
-        """
-        Setter method corresponding to the ``prov:wasDerivedFrom`` RDF predicate.
-
-        `This property is used to identify the immediately previous snapshot of entity metadata
-        associated with the same bibliographic entity.`
-
-        :param se_res: The value that will be set as the object of the property related to this method
-        :type se_res: ProvEntity
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        self.g.add((self.res, ProvEntity.iri_was_derived_from, se_res.res))
-
-    @accepts_only('se')
-    def remove_derives_from(self, se_res: ProvEntity = None) -> None:
-        """
-        Remover method corresponding to the ``prov:wasDerivedFrom`` RDF predicate.
-
-        **WARNING: this is a non-functional property, hence, if the parameter
-        is None, any existing value will be removed!**
-
-        :param se_res: If not None, the specific object value that will be removed from the property
-         related to this method (defaults to None)
-        :type se_res: SnapshotEntity
-        :raises TypeError: if the parameter is of the wrong type
-        :return: None
-        """
-        if se_res is not None:
-            self.g.remove((self.res, ProvEntity.iri_was_derived_from, se_res.res))
-        else:
-            self.g.remove((self.res, ProvEntity.iri_was_derived_from, None))
-
-    # HAS PRIMARY SOURCE
-    def get_primary_source(self) -> Optional[URIRef]:
-        """
-        Getter method corresponding to the ``prov:hadPrimarySource`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        uri: Optional[URIRef] = self._get_uri_reference(ProvEntity.iri_had_primary_source)
-        return uri
-
-    @accepts_only('thing')
-    def has_primary_source(self, any_res: URIRef) -> None:
-        """
-        Setter method corresponding to the ``prov:hadPrimarySource`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `This property is used to identify the primary source from which the metadata
-        described in the snapshot are derived (e.g. Crossref, as the result of querying the
-        CrossRef API).`
-
-        :param any_res: The value that will be set as the object of the property related to this method
-        :type any_res: URIRef
-        :return: None
-        """
-        self.remove_primary_source()
-        self.g.add((self.res, ProvEntity.iri_had_primary_source, any_res))
-
-    def remove_primary_source(self) -> None:
-        """
-        Remover method corresponding to the ``prov:hadPrimarySource`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, ProvEntity.iri_had_primary_source, None))
-
-    # HAS UPDATE ACTION
-    def get_update_action(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``oco:hasUpdateQuery`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(ProvEntity.iri_has_update_query)
-
-    @accepts_only('literal')
-    def has_update_action(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``oco:hasUpdateQuery`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The UPDATE SPARQL query that specifies which data, associated to the bibliographic
-        entity in consideration, have been modified (e.g. for correcting a mistake) in the
-        current snapshot starting from those associated to the previous snapshot of the entity.`
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :return: None
-        """
-        self.remove_update_action()
-        self._create_literal(ProvEntity.iri_has_update_query, string)
-
-    def remove_update_action(self) -> None:
-        """
-        Remover method corresponding to the ``oco:hasUpdateQuery`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, ProvEntity.iri_has_update_query, None))
-
-    # HAS DESCRIPTION
-    def get_description(self) -> Optional[str]:
-        """
-        Getter method corresponding to the ``dcterms:description`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        return self._get_literal(ProvEntity.iri_description)
-
-    @accepts_only('literal')
-    def has_description(self, string: str) -> None:
-        """
-        Setter method corresponding to the ``dcterms:description`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `A textual description of the events that have resulted in the current snapshot (e.g. the
-        creation of the initial snapshot, the creation of a new snapshot following the
-        modification of the entity to which the metadata relate, or the creation of a new
-        snapshot following the merger with another entity of the entity to which the previous
-        snapshot related).`
-
-        :param string: The value that will be set as the object of the property related to this method
-        :type string: str
-        :return: None
-        """
-        self.remove_description()
-        self._create_literal(ProvEntity.iri_description, string)
-
-    def remove_description(self) -> None:
-        """
-        Remover method corresponding to the ``dcterms:description`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, ProvEntity.iri_description, None))
-
-    # IS ATTRIBUTED TO
-    def get_resp_agent(self) -> Optional[URIRef]:
-        """
-        Getter method corresponding to the ``prov:wasAttributedTo`` RDF predicate.
-
-        :return: The requested value if found, None otherwise
-        """
-        uri: Optional[URIRef] = self._get_uri_reference(ProvEntity.iri_was_attributed_to)
-        return uri
-
-    @accepts_only('thing')
-    def has_resp_agent(self, se_agent: URIRef) -> None:
-        """
-        Setter method corresponding to the ``prov:wasAttributedTo`` RDF predicate.
-
-        **WARNING: this is a functional property, hence any existing value will be overwritten!**
-
-        `The agent responsible for the creation of the current entity snapshot.`
-
-        :param se_agent: The value that will be set as the object of the property related to this method
-        :type se_agent: URIRef
-        :return: None
-        """
-        self.remove_resp_agent()
-        self.g.add((self.res, ProvEntity.iri_was_attributed_to, se_agent))
-
-    def remove_resp_agent(self) -> None:
-        """
-        Remover method corresponding to the ``prov:wasAttributedTo`` RDF predicate.
-
-        :return: None
-        """
-        self.g.remove((self.res, ProvEntity.iri_was_attributed_to, None))
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+from rdflib import XSD
+
+from oc_ocdm.decorators import accepts_only
+from oc_ocdm.graph.graph_entity import GraphEntity
+from oc_ocdm.prov.prov_entity import ProvEntity
+
+if TYPE_CHECKING:
+    from typing import List, Optional
+
+    from rdflib import URIRef
+
+
+class SnapshotEntity(ProvEntity):
+    """Snapshot of entity metadata (short: se): a particular snapshot recording the
+    metadata associated with an individual entity (either a bibliographic entity or an
+    identifier) at a particular date and time, including the agent, such as a person,
+    organisation or automated process that created or modified the entity metadata."""
+
+    # HAS CREATION DATE
+    def get_generation_time(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``prov:generatedAtTime`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(ProvEntity.iri_generated_at_time)
+
+    @accepts_only('literal')
+    def has_generation_time(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``prov:generatedAtTime`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The date on which a particular snapshot of a bibliographic entity's metadata was
+        created.`
+
+        :param string: The value that will be set as the object of the property related to this method. **It must
+          be a string compliant with the** ``xsd:dateTime`` **datatype.**
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_generation_time()
+        self._create_literal(ProvEntity.iri_generated_at_time, string, XSD.dateTime)
+
+    def remove_generation_time(self) -> None:
+        """
+        Remover method corresponding to the ``prov:generatedAtTime`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, ProvEntity.iri_generated_at_time, None))
+
+    # HAS INVALIDATION DATE
+    def get_invalidation_time(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``prov:invalidatedAtTime`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(ProvEntity.iri_invalidated_at_time)
+
+    @accepts_only('literal')
+    def has_invalidation_time(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``prov:invalidatedAtTime`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The date on which a snapshot of a bibliographic entity's metadata was invalidated due
+        to an update (e.g. a correction, or the addition of some metadata that was not specified
+        in the previous snapshot), or due to a merger of the entity with another one.`
+
+        :param string: The value that will be set as the object of the property related to this method. **It must
+          be a string compliant with the** ``xsd:dateTime`` **datatype.**
+        :type string: str
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.remove_invalidation_time()
+        self._create_literal(ProvEntity.iri_invalidated_at_time, string, XSD.dateTime)
+
+    def remove_invalidation_time(self) -> None:
+        """
+        Remover method corresponding to the ``prov:invalidatedAtTime`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, ProvEntity.iri_invalidated_at_time, None))
+
+    # IS SNAPSHOT OF
+    def get_is_snapshot_of(self) -> Optional[URIRef]:
+        """
+        Getter method corresponding to the ``prov:specializationOf`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        uri: Optional[URIRef] = self._get_uri_reference(ProvEntity.iri_specialization_of)
+        return uri
+
+    def is_snapshot_of(self, en_res: GraphEntity) -> None:
+        """
+        Setter method corresponding to the ``prov:specializationOf`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `This property is used to link a snapshot of entity metadata to the bibliographic entity
+        to which the snapshot refers.`
+
+        :param en_res: The value that will be set as the object of the property related to this method
+        :type en_res: GraphEntity
+        :return: None
+        """
+        self.remove_is_snapshot_of()
+        self.g.add((self.res, ProvEntity.iri_specialization_of, en_res.res))
+
+    def remove_is_snapshot_of(self) -> None:
+        """
+        Remover method corresponding to the ``prov:specializationOf`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, ProvEntity.iri_specialization_of, None))
+
+    # IS DERIVED FROM
+    def get_derives_from(self) -> List[ProvEntity]:
+        """
+        Getter method corresponding to the ``prov:wasDerivedFrom`` RDF predicate.
+
+        :return: A list containing the requested values if found, None otherwise
+        """
+        uri_list: List[URIRef] = self._get_multiple_uri_references(ProvEntity.iri_was_derived_from, 'se')
+        result: List[ProvEntity] = []
+        for uri in uri_list:
+            # TODO: what is the prov_subject of these snapshots?
+            result.append(self.p_set.add_se(None, uri))
+        return result
+
+    @accepts_only('se')
+    def derives_from(self, se_res: ProvEntity) -> None:
+        """
+        Setter method corresponding to the ``prov:wasDerivedFrom`` RDF predicate.
+
+        `This property is used to identify the immediately previous snapshot of entity metadata
+        associated with the same bibliographic entity.`
+
+        :param se_res: The value that will be set as the object of the property related to this method
+        :type se_res: ProvEntity
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        self.g.add((self.res, ProvEntity.iri_was_derived_from, se_res.res))
+
+    @accepts_only('se')
+    def remove_derives_from(self, se_res: ProvEntity = None) -> None:
+        """
+        Remover method corresponding to the ``prov:wasDerivedFrom`` RDF predicate.
+
+        **WARNING: this is a non-functional property, hence, if the parameter
+        is None, any existing value will be removed!**
+
+        :param se_res: If not None, the specific object value that will be removed from the property
+         related to this method (defaults to None)
+        :type se_res: SnapshotEntity
+        :raises TypeError: if the parameter is of the wrong type
+        :return: None
+        """
+        if se_res is not None:
+            self.g.remove((self.res, ProvEntity.iri_was_derived_from, se_res.res))
+        else:
+            self.g.remove((self.res, ProvEntity.iri_was_derived_from, None))
+
+    # HAS PRIMARY SOURCE
+    def get_primary_source(self) -> Optional[URIRef]:
+        """
+        Getter method corresponding to the ``prov:hadPrimarySource`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        uri: Optional[URIRef] = self._get_uri_reference(ProvEntity.iri_had_primary_source)
+        return uri
+
+    @accepts_only('thing')
+    def has_primary_source(self, any_res: URIRef) -> None:
+        """
+        Setter method corresponding to the ``prov:hadPrimarySource`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `This property is used to identify the primary source from which the metadata
+        described in the snapshot are derived (e.g. Crossref, as the result of querying the
+        CrossRef API).`
+
+        :param any_res: The value that will be set as the object of the property related to this method
+        :type any_res: URIRef
+        :return: None
+        """
+        self.remove_primary_source()
+        self.g.add((self.res, ProvEntity.iri_had_primary_source, any_res))
+
+    def remove_primary_source(self) -> None:
+        """
+        Remover method corresponding to the ``prov:hadPrimarySource`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, ProvEntity.iri_had_primary_source, None))
+
+    # HAS UPDATE ACTION
+    def get_update_action(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``oco:hasUpdateQuery`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(ProvEntity.iri_has_update_query)
+
+    @accepts_only('literal')
+    def has_update_action(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``oco:hasUpdateQuery`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The UPDATE SPARQL query that specifies which data, associated to the bibliographic
+        entity in consideration, have been modified (e.g. for correcting a mistake) in the
+        current snapshot starting from those associated to the previous snapshot of the entity.`
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :return: None
+        """
+        self.remove_update_action()
+        self._create_literal(ProvEntity.iri_has_update_query, string)
+
+    def remove_update_action(self) -> None:
+        """
+        Remover method corresponding to the ``oco:hasUpdateQuery`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, ProvEntity.iri_has_update_query, None))
+
+    # HAS DESCRIPTION
+    def get_description(self) -> Optional[str]:
+        """
+        Getter method corresponding to the ``dcterms:description`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        return self._get_literal(ProvEntity.iri_description)
+
+    @accepts_only('literal')
+    def has_description(self, string: str) -> None:
+        """
+        Setter method corresponding to the ``dcterms:description`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `A textual description of the events that have resulted in the current snapshot (e.g. the
+        creation of the initial snapshot, the creation of a new snapshot following the
+        modification of the entity to which the metadata relate, or the creation of a new
+        snapshot following the merger with another entity of the entity to which the previous
+        snapshot related).`
+
+        :param string: The value that will be set as the object of the property related to this method
+        :type string: str
+        :return: None
+        """
+        self.remove_description()
+        self._create_literal(ProvEntity.iri_description, string)
+
+    def remove_description(self) -> None:
+        """
+        Remover method corresponding to the ``dcterms:description`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, ProvEntity.iri_description, None))
+
+    # IS ATTRIBUTED TO
+    def get_resp_agent(self) -> Optional[URIRef]:
+        """
+        Getter method corresponding to the ``prov:wasAttributedTo`` RDF predicate.
+
+        :return: The requested value if found, None otherwise
+        """
+        uri: Optional[URIRef] = self._get_uri_reference(ProvEntity.iri_was_attributed_to)
+        return uri
+
+    @accepts_only('thing')
+    def has_resp_agent(self, se_agent: URIRef) -> None:
+        """
+        Setter method corresponding to the ``prov:wasAttributedTo`` RDF predicate.
+
+        **WARNING: this is a functional property, hence any existing value will be overwritten!**
+
+        `The agent responsible for the creation of the current entity snapshot.`
+
+        :param se_agent: The value that will be set as the object of the property related to this method
+        :type se_agent: URIRef
+        :return: None
+        """
+        self.remove_resp_agent()
+        self.g.add((self.res, ProvEntity.iri_was_attributed_to, se_agent))
+
+    def remove_resp_agent(self) -> None:
+        """
+        Remover method corresponding to the ``prov:wasAttributedTo`` RDF predicate.
+
+        :return: None
+        """
+        self.g.remove((self.res, ProvEntity.iri_was_attributed_to, None))
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/prov/prov_entity.py` & `oc_ocdm-8.1.0/oc_ocdm/prov/prov_entity.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,86 +1,86 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-from rdflib import Graph, Namespace, URIRef
-
-from oc_ocdm.abstract_entity import AbstractEntity
-from oc_ocdm.graph.graph_entity import GraphEntity
-
-if TYPE_CHECKING:
-    from typing import ClassVar, Dict
-
-    from oc_ocdm.prov.prov_set import ProvSet
-
-
-class ProvEntity(AbstractEntity):
-    """Snapshot of entity metadata (short: se): a particular snapshot recording the
-    metadata associated with an individual entity (either a bibliographic entity or an
-    identifier) at a particular date and time, including the agent, such as a person,
-    organisation or automated process that created or modified the entity metadata.
-    """
-
-    PROV: ClassVar[Namespace] = Namespace("http://www.w3.org/ns/prov#")
-
-    iri_entity: ClassVar[URIRef] = PROV.Entity
-    iri_generated_at_time: ClassVar[URIRef] = PROV.generatedAtTime
-    iri_invalidated_at_time: ClassVar[URIRef] = PROV.invalidatedAtTime
-    iri_specialization_of: ClassVar[URIRef] = PROV.specializationOf
-    iri_was_derived_from: ClassVar[URIRef] = PROV.wasDerivedFrom
-    iri_had_primary_source: ClassVar[URIRef] = PROV.hadPrimarySource
-    iri_was_attributed_to: ClassVar[URIRef] = PROV.wasAttributedTo
-    iri_description: ClassVar[URIRef] = GraphEntity.DCTERMS.description
-    iri_has_update_query: ClassVar[URIRef] = GraphEntity.OCO.hasUpdateQuery
-
-    short_name_to_type_iri: ClassVar[Dict[str, URIRef]] = {
-        'se': iri_entity
-    }
-
-    def __init__(self, prov_subject: GraphEntity, g: Graph, p_set: ProvSet,
-                 res: URIRef = None, resp_agent: str = None, source: str = None,
-                 res_type: URIRef = None, count: str = None, label: str = None,
-                 short_name: str = "") -> None:
-        super(ProvEntity, self).__init__()
-        self.prov_subject: GraphEntity = prov_subject
-
-        self.g: Graph = g
-        self.resp_agent: str = resp_agent
-        self.source: str = source
-        self.short_name: str = short_name
-        self.p_set: ProvSet = p_set
-
-        # If res was not specified, create from scratch the URI reference for this entity,
-        # otherwise use the provided one
-        if res is None:
-            self.res = self._generate_new_res(g, count, short_name)
-        else:
-            self.res = res
-
-        if p_set is not None:
-            # If not already done, register this ProvEntity instance inside the ProvSet
-            if self.res not in p_set.res_to_entity:
-                p_set.res_to_entity[self.res] = self
-
-        # Add mandatory information to the entity graph
-        self._create_type(res_type)
-        if label is not None:
-            self.create_label(label)
-
-    @staticmethod
-    def _generate_new_res(g: Graph, count: str, short_name: str) -> URIRef:
-        return URIRef(str(g.identifier) + short_name + "/" + count)
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+from rdflib import Graph, Namespace, URIRef
+
+from oc_ocdm.abstract_entity import AbstractEntity
+from oc_ocdm.graph.graph_entity import GraphEntity
+
+if TYPE_CHECKING:
+    from typing import ClassVar, Dict
+
+    from oc_ocdm.prov.prov_set import ProvSet
+
+
+class ProvEntity(AbstractEntity):
+    """Snapshot of entity metadata (short: se): a particular snapshot recording the
+    metadata associated with an individual entity (either a bibliographic entity or an
+    identifier) at a particular date and time, including the agent, such as a person,
+    organisation or automated process that created or modified the entity metadata.
+    """
+
+    PROV: ClassVar[Namespace] = Namespace("http://www.w3.org/ns/prov#")
+
+    iri_entity: ClassVar[URIRef] = PROV.Entity
+    iri_generated_at_time: ClassVar[URIRef] = PROV.generatedAtTime
+    iri_invalidated_at_time: ClassVar[URIRef] = PROV.invalidatedAtTime
+    iri_specialization_of: ClassVar[URIRef] = PROV.specializationOf
+    iri_was_derived_from: ClassVar[URIRef] = PROV.wasDerivedFrom
+    iri_had_primary_source: ClassVar[URIRef] = PROV.hadPrimarySource
+    iri_was_attributed_to: ClassVar[URIRef] = PROV.wasAttributedTo
+    iri_description: ClassVar[URIRef] = GraphEntity.DCTERMS.description
+    iri_has_update_query: ClassVar[URIRef] = GraphEntity.OCO.hasUpdateQuery
+
+    short_name_to_type_iri: ClassVar[Dict[str, URIRef]] = {
+        'se': iri_entity
+    }
+
+    def __init__(self, prov_subject: GraphEntity, g: Graph, p_set: ProvSet,
+                 res: URIRef = None, resp_agent: str = None, source: str = None,
+                 res_type: URIRef = None, count: str = None, label: str = None,
+                 short_name: str = "") -> None:
+        super(ProvEntity, self).__init__()
+        self.prov_subject: GraphEntity = prov_subject
+
+        self.g: Graph = g
+        self.resp_agent: str = resp_agent
+        self.source: str = source
+        self.short_name: str = short_name
+        self.p_set: ProvSet = p_set
+
+        # If res was not specified, create from scratch the URI reference for this entity,
+        # otherwise use the provided one
+        if res is None:
+            self.res = self._generate_new_res(g, count, short_name)
+        else:
+            self.res = res
+
+        if p_set is not None:
+            # If not already done, register this ProvEntity instance inside the ProvSet
+            if self.res not in p_set.res_to_entity:
+                p_set.res_to_entity[self.res] = self
+
+        # Add mandatory information to the entity graph
+        self._create_type(res_type)
+        if label is not None:
+            self.create_label(label)
+
+    @staticmethod
+    def _generate_new_res(g: Graph, count: str, short_name: str) -> URIRef:
+        return URIRef(str(g.identifier) + short_name + "/" + count)
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/reader.py` & `oc_ocdm-8.1.0/oc_ocdm/reader.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,239 +1,239 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-import json
-import os
-from typing import TYPE_CHECKING
-from zipfile import ZipFile
-
-import rdflib
-from rdflib import RDF, ConjunctiveGraph, Graph, URIRef
-from SPARQLWrapper import JSON, SPARQLWrapper
-
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.support.reporter import Reporter
-from oc_ocdm.support.support import build_graph_from_results
-if TYPE_CHECKING:
-    from typing import Any, Dict, List, Optional, Set
-    from oc_ocdm.graph.graph_set import GraphSet
-
-from pyshacl import validate
-
-
-class Reader(object):
-
-    def __init__(self, repok: Reporter = None, reperr: Reporter = None, context_map: Dict[str, Any] = None) -> None:
-
-        if context_map is not None:
-            self.context_map: Dict[str, Any] = context_map
-        else:
-            self.context_map: Dict[str, Any] = {}
-        for context_url in self.context_map:
-            ctx_file_path: Any = self.context_map[context_url]
-            if type(ctx_file_path) == str and os.path.isfile(ctx_file_path):
-                # This expensive operation is done only when it's really needed
-                with open(ctx_file_path, 'rt', encoding='utf-8') as ctx_f:
-                    self.context_map[context_url] = json.load(ctx_f)
-
-        if repok is None:
-            self.repok: Reporter = Reporter(prefix="[Reader: INFO] ")
-        else:
-            self.repok: Reporter = repok
-
-        if reperr is None:
-            self.reperr: Reporter = Reporter(prefix="[Reader: ERROR] ")
-        else:
-            self.reperr: Reporter = reperr
-
-    def load(self, rdf_file_path: str) -> Optional[ConjunctiveGraph]:
-        self.repok.new_article()
-        self.reperr.new_article()
-
-        loaded_graph: Optional[ConjunctiveGraph] = None
-        if os.path.isfile(rdf_file_path):
-
-            try:
-                loaded_graph = self._load_graph(rdf_file_path)
-            except Exception as e:
-                self.reperr.add_sentence("[1] "
-                                         "It was impossible to handle the format used for "
-                                         "storing the file (stored in the temporary path) "
-                                         f"'{rdf_file_path}'. Additional details: {e}")
-        else:
-            self.reperr.add_sentence("[2] "
-                                     f"The file specified ('{rdf_file_path}') doesn't exist.")
-
-        return loaded_graph
-
-    def _load_graph(self, file_path: str) -> ConjunctiveGraph:
-        formats = ["json-ld", "rdfxml", "turtle", "trig", "nt11", "nquads"]
-        loaded_graph = ConjunctiveGraph()
-
-        if file_path.endswith('.zip'):
-            try:
-                with ZipFile(file=file_path, mode="r") as archive:
-                    for zf_name in archive.namelist():
-                        with archive.open(zf_name) as f:
-                            if self._try_parse(loaded_graph, f, formats):
-                                return loaded_graph
-            except Exception as e:
-                raise IOError(f"Error opening or reading zip file '{file_path}': {e}")
-        else:
-            try:
-                with open(file_path, 'rt', encoding='utf-8') as f:
-                    if self._try_parse(loaded_graph, f, formats):
-                        return loaded_graph
-            except Exception as e:
-                raise IOError(f"Error opening or reading file '{file_path}': {e}")
-
-        raise IOError(f"It was impossible to load the file '{file_path}' with supported formats.")
-
-    def _try_parse(self, graph: ConjunctiveGraph, file_obj, formats: List[str]) -> bool:
-        for cur_format in formats:
-            file_obj.seek(0)  # Reset file pointer to the beginning for each new attempt
-            try:
-                if cur_format == "json-ld":
-                    json_ld_file = json.load(file_obj)
-                    if isinstance(json_ld_file, dict):
-                        json_ld_file = [json_ld_file]
-                    for json_ld_resource in json_ld_file:
-                        if "@context" in json_ld_resource and json_ld_resource["@context"] in self.context_map:
-                            json_ld_resource["@context"] = self.context_map[json_ld_resource["@context"]]["@context"]
-                    data = json.dumps(json_ld_file, ensure_ascii=False)
-                    graph.parse(data=data, format=cur_format)
-                else:
-                    graph.parse(file=file_obj, format=cur_format)
-                return True  # Success, no need to try other formats
-            except Exception as e:
-                continue  # Try the next format
-        return False  # None of the formats succeeded
-
-    @staticmethod
-    def get_graph_from_subject(graph: Graph, subject: URIRef) -> Graph:
-        g: Graph = Graph(identifier=graph.identifier)
-        for p, o in graph.predicate_objects(subject, unique=True):
-            g.add((subject, p, o))
-        return g
-
-    @staticmethod
-    def _extract_subjects(graph: Graph) -> Set[URIRef]:
-        subjects: Set[URIRef] = set()
-        for s in graph.subjects(unique=True):
-            subjects.add(s)
-        return subjects
-
-    def graph_validation(self, graph: Graph, closed: bool = False) -> Graph:
-        valid_graph: Graph = Graph(identifier=graph.identifier)
-        sg = Graph()
-        if closed:
-            sg.parse(os.path.join('oc_ocdm', 'resources', 'shacle_closed.ttl'))
-        else:
-            sg.parse(os.path.join('oc_ocdm', 'resources', 'shacle.ttl'))
-        _, report_g, _ = validate(graph,
-            shacl_graph=sg,
-            ont_graph=None,
-            inference=None,
-            abort_on_first=False,
-            allow_infos=False,
-            allow_warnings=False,
-            meta_shacl=False,
-            advanced=False,
-            js=False,
-            debug=False)
-        invalid_nodes = set()
-        for triple in report_g.triples((None, URIRef('http://www.w3.org/ns/shacl#focusNode'), None)):
-            invalid_nodes.add(triple[2])
-        for subject in self._extract_subjects(graph):
-            if subject not in invalid_nodes:
-                for valid_subject_triple in graph.triples((subject, None, None)):
-                    valid_graph.add(valid_subject_triple)
-        return valid_graph
-
-    @staticmethod
-    def import_entities_from_graph(g_set: GraphSet, results: List[Dict], resp_agent: str,
-                                   enable_validation: bool = False, closed: bool = False) -> List[GraphEntity]:
-        graph = build_graph_from_results(results)
-        if enable_validation:
-            reader = Reader()
-            graph = reader.graph_validation(graph, closed)
-        imported_entities: List[GraphEntity] = []
-        for subject in Reader._extract_subjects(graph):
-            types = []
-            for o in graph.objects(subject, RDF.type):
-                types.append(o)
-            # ReferenceAnnotation
-            if GraphEntity.iri_note in types:
-                imported_entities.append(g_set.add_an(resp_agent=resp_agent, res=subject,
-                                         preexisting_graph=Reader.get_graph_from_subject(graph, subject)))
-            # AgentRole
-            elif GraphEntity.iri_role_in_time in types:
-                imported_entities.append(g_set.add_ar(resp_agent=resp_agent, res=subject,
-                                         preexisting_graph=Reader.get_graph_from_subject(graph, subject)))
-            # BibliographicReference
-            elif GraphEntity.iri_bibliographic_reference in types:
-                imported_entities.append(g_set.add_be(resp_agent=resp_agent, res=subject,
-                                         preexisting_graph=Reader.get_graph_from_subject(graph, subject)))
-            # BibliographicResource
-            elif GraphEntity.iri_expression in types:
-                imported_entities.append(g_set.add_br(resp_agent=resp_agent, res=subject,
-                                         preexisting_graph=Reader.get_graph_from_subject(graph, subject)))
-            # Citation
-            elif GraphEntity.iri_citation in types:
-                imported_entities.append(g_set.add_ci(resp_agent=resp_agent, res=subject,
-                                         preexisting_graph=Reader.get_graph_from_subject(graph, subject)))
-            # DiscourseElement
-            elif GraphEntity.iri_discourse_element in types:
-                imported_entities.append(g_set.add_de(resp_agent=resp_agent, res=subject,
-                                         preexisting_graph=Reader.get_graph_from_subject(graph, subject)))
-            # Identifier
-            elif GraphEntity.iri_identifier in types:
-                imported_entities.append(g_set.add_id(resp_agent=resp_agent, res=subject,
-                                         preexisting_graph=Reader.get_graph_from_subject(graph, subject)))
-            # PointerList
-            elif GraphEntity.iri_singleloc_pointer_list in types:
-                imported_entities.append(g_set.add_pl(resp_agent=resp_agent, res=subject,
-                                         preexisting_graph=Reader.get_graph_from_subject(graph, subject)))
-            # ResponsibleAgent
-            elif GraphEntity.iri_agent in types:
-                imported_entities.append(g_set.add_ra(resp_agent=resp_agent, res=subject,
-                                         preexisting_graph=Reader.get_graph_from_subject(graph, subject)))
-            # ResourceEmbodiment
-            elif GraphEntity.iri_manifestation in types:
-                imported_entities.append(g_set.add_re(resp_agent=resp_agent, res=subject,
-                                         preexisting_graph=Reader.get_graph_from_subject(graph, subject)))
-            # ReferencePointer
-            elif GraphEntity.iri_intextref_pointer in types:
-                imported_entities.append(g_set.add_rp(resp_agent=resp_agent, res=subject,
-                                         preexisting_graph=Reader.get_graph_from_subject(graph, subject)))
-        return imported_entities
-
-    @staticmethod
-    def import_entity_from_triplestore(g_set: GraphSet, ts_url: str, res: URIRef, resp_agent: str,
-                                       enable_validation: bool = False) -> GraphEntity:
-        sparql: SPARQLWrapper = SPARQLWrapper(ts_url)
-        query: str = f"SELECT ?s ?p ?o WHERE {{BIND (<{res}> AS ?s). ?s ?p ?o.}}"
-        sparql.setQuery(query)
-        sparql.setMethod('GET')
-        sparql.setReturnFormat(JSON)
-        result: ConjunctiveGraph = sparql.queryAndConvert()['results']['bindings']
-        if result:
-            imported_entities: List[GraphEntity] = Reader.import_entities_from_graph(g_set, result,
-                                                                                     resp_agent, enable_validation)
-            if len(imported_entities) <= 0:
-                raise ValueError("The requested entity was not found or was not recognized as a proper OCDM entity.")
-            else:
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+import json
+import os
+from typing import TYPE_CHECKING
+from zipfile import ZipFile
+
+import rdflib
+from rdflib import RDF, ConjunctiveGraph, Graph, URIRef
+from SPARQLWrapper import JSON, SPARQLWrapper
+
+from oc_ocdm.graph.graph_entity import GraphEntity
+from oc_ocdm.support.reporter import Reporter
+from oc_ocdm.support.support import build_graph_from_results
+if TYPE_CHECKING:
+    from typing import Any, Dict, List, Optional, Set
+    from oc_ocdm.graph.graph_set import GraphSet
+
+from pyshacl import validate
+
+
+class Reader(object):
+
+    def __init__(self, repok: Reporter = None, reperr: Reporter = None, context_map: Dict[str, Any] = None) -> None:
+
+        if context_map is not None:
+            self.context_map: Dict[str, Any] = context_map
+        else:
+            self.context_map: Dict[str, Any] = {}
+        for context_url in self.context_map:
+            ctx_file_path: Any = self.context_map[context_url]
+            if type(ctx_file_path) == str and os.path.isfile(ctx_file_path):
+                # This expensive operation is done only when it's really needed
+                with open(ctx_file_path, 'rt', encoding='utf-8') as ctx_f:
+                    self.context_map[context_url] = json.load(ctx_f)
+
+        if repok is None:
+            self.repok: Reporter = Reporter(prefix="[Reader: INFO] ")
+        else:
+            self.repok: Reporter = repok
+
+        if reperr is None:
+            self.reperr: Reporter = Reporter(prefix="[Reader: ERROR] ")
+        else:
+            self.reperr: Reporter = reperr
+
+    def load(self, rdf_file_path: str) -> Optional[ConjunctiveGraph]:
+        self.repok.new_article()
+        self.reperr.new_article()
+
+        loaded_graph: Optional[ConjunctiveGraph] = None
+        if os.path.isfile(rdf_file_path):
+
+            try:
+                loaded_graph = self._load_graph(rdf_file_path)
+            except Exception as e:
+                self.reperr.add_sentence("[1] "
+                                         "It was impossible to handle the format used for "
+                                         "storing the file (stored in the temporary path) "
+                                         f"'{rdf_file_path}'. Additional details: {e}")
+        else:
+            self.reperr.add_sentence("[2] "
+                                     f"The file specified ('{rdf_file_path}') doesn't exist.")
+
+        return loaded_graph
+
+    def _load_graph(self, file_path: str) -> ConjunctiveGraph:
+        formats = ["json-ld", "rdfxml", "turtle", "trig", "nt11", "nquads"]
+        loaded_graph = ConjunctiveGraph()
+
+        if file_path.endswith('.zip'):
+            try:
+                with ZipFile(file=file_path, mode="r") as archive:
+                    for zf_name in archive.namelist():
+                        with archive.open(zf_name) as f:
+                            if self._try_parse(loaded_graph, f, formats):
+                                return loaded_graph
+            except Exception as e:
+                raise IOError(f"Error opening or reading zip file '{file_path}': {e}")
+        else:
+            try:
+                with open(file_path, 'rt', encoding='utf-8') as f:
+                    if self._try_parse(loaded_graph, f, formats):
+                        return loaded_graph
+            except Exception as e:
+                raise IOError(f"Error opening or reading file '{file_path}': {e}")
+
+        raise IOError(f"It was impossible to load the file '{file_path}' with supported formats.")
+
+    def _try_parse(self, graph: ConjunctiveGraph, file_obj, formats: List[str]) -> bool:
+        for cur_format in formats:
+            file_obj.seek(0)  # Reset file pointer to the beginning for each new attempt
+            try:
+                if cur_format == "json-ld":
+                    json_ld_file = json.load(file_obj)
+                    if isinstance(json_ld_file, dict):
+                        json_ld_file = [json_ld_file]
+                    for json_ld_resource in json_ld_file:
+                        if "@context" in json_ld_resource and json_ld_resource["@context"] in self.context_map:
+                            json_ld_resource["@context"] = self.context_map[json_ld_resource["@context"]]["@context"]
+                    data = json.dumps(json_ld_file, ensure_ascii=False)
+                    graph.parse(data=data, format=cur_format)
+                else:
+                    graph.parse(file=file_obj, format=cur_format)
+                return True  # Success, no need to try other formats
+            except Exception as e:
+                continue  # Try the next format
+        return False  # None of the formats succeeded
+
+    @staticmethod
+    def get_graph_from_subject(graph: Graph, subject: URIRef) -> Graph:
+        g: Graph = Graph(identifier=graph.identifier)
+        for p, o in graph.predicate_objects(subject, unique=True):
+            g.add((subject, p, o))
+        return g
+
+    @staticmethod
+    def _extract_subjects(graph: Graph) -> Set[URIRef]:
+        subjects: Set[URIRef] = set()
+        for s in graph.subjects(unique=True):
+            subjects.add(s)
+        return subjects
+
+    def graph_validation(self, graph: Graph, closed: bool = False) -> Graph:
+        valid_graph: Graph = Graph(identifier=graph.identifier)
+        sg = Graph()
+        if closed:
+            sg.parse(os.path.join('oc_ocdm', 'resources', 'shacle_closed.ttl'))
+        else:
+            sg.parse(os.path.join('oc_ocdm', 'resources', 'shacle.ttl'))
+        _, report_g, _ = validate(graph,
+            shacl_graph=sg,
+            ont_graph=None,
+            inference=None,
+            abort_on_first=False,
+            allow_infos=False,
+            allow_warnings=False,
+            meta_shacl=False,
+            advanced=False,
+            js=False,
+            debug=False)
+        invalid_nodes = set()
+        for triple in report_g.triples((None, URIRef('http://www.w3.org/ns/shacl#focusNode'), None)):
+            invalid_nodes.add(triple[2])
+        for subject in self._extract_subjects(graph):
+            if subject not in invalid_nodes:
+                for valid_subject_triple in graph.triples((subject, None, None)):
+                    valid_graph.add(valid_subject_triple)
+        return valid_graph
+
+    @staticmethod
+    def import_entities_from_graph(g_set: GraphSet, results: List[Dict], resp_agent: str,
+                                   enable_validation: bool = False, closed: bool = False) -> List[GraphEntity]:
+        graph = build_graph_from_results(results)
+        if enable_validation:
+            reader = Reader()
+            graph = reader.graph_validation(graph, closed)
+        imported_entities: List[GraphEntity] = []
+        for subject in Reader._extract_subjects(graph):
+            types = []
+            for o in graph.objects(subject, RDF.type):
+                types.append(o)
+            # ReferenceAnnotation
+            if GraphEntity.iri_note in types:
+                imported_entities.append(g_set.add_an(resp_agent=resp_agent, res=subject,
+                                         preexisting_graph=Reader.get_graph_from_subject(graph, subject)))
+            # AgentRole
+            elif GraphEntity.iri_role_in_time in types:
+                imported_entities.append(g_set.add_ar(resp_agent=resp_agent, res=subject,
+                                         preexisting_graph=Reader.get_graph_from_subject(graph, subject)))
+            # BibliographicReference
+            elif GraphEntity.iri_bibliographic_reference in types:
+                imported_entities.append(g_set.add_be(resp_agent=resp_agent, res=subject,
+                                         preexisting_graph=Reader.get_graph_from_subject(graph, subject)))
+            # BibliographicResource
+            elif GraphEntity.iri_expression in types:
+                imported_entities.append(g_set.add_br(resp_agent=resp_agent, res=subject,
+                                         preexisting_graph=Reader.get_graph_from_subject(graph, subject)))
+            # Citation
+            elif GraphEntity.iri_citation in types:
+                imported_entities.append(g_set.add_ci(resp_agent=resp_agent, res=subject,
+                                         preexisting_graph=Reader.get_graph_from_subject(graph, subject)))
+            # DiscourseElement
+            elif GraphEntity.iri_discourse_element in types:
+                imported_entities.append(g_set.add_de(resp_agent=resp_agent, res=subject,
+                                         preexisting_graph=Reader.get_graph_from_subject(graph, subject)))
+            # Identifier
+            elif GraphEntity.iri_identifier in types:
+                imported_entities.append(g_set.add_id(resp_agent=resp_agent, res=subject,
+                                         preexisting_graph=Reader.get_graph_from_subject(graph, subject)))
+            # PointerList
+            elif GraphEntity.iri_singleloc_pointer_list in types:
+                imported_entities.append(g_set.add_pl(resp_agent=resp_agent, res=subject,
+                                         preexisting_graph=Reader.get_graph_from_subject(graph, subject)))
+            # ResponsibleAgent
+            elif GraphEntity.iri_agent in types:
+                imported_entities.append(g_set.add_ra(resp_agent=resp_agent, res=subject,
+                                         preexisting_graph=Reader.get_graph_from_subject(graph, subject)))
+            # ResourceEmbodiment
+            elif GraphEntity.iri_manifestation in types:
+                imported_entities.append(g_set.add_re(resp_agent=resp_agent, res=subject,
+                                         preexisting_graph=Reader.get_graph_from_subject(graph, subject)))
+            # ReferencePointer
+            elif GraphEntity.iri_intextref_pointer in types:
+                imported_entities.append(g_set.add_rp(resp_agent=resp_agent, res=subject,
+                                         preexisting_graph=Reader.get_graph_from_subject(graph, subject)))
+        return imported_entities
+
+    @staticmethod
+    def import_entity_from_triplestore(g_set: GraphSet, ts_url: str, res: URIRef, resp_agent: str,
+                                       enable_validation: bool = False) -> GraphEntity:
+        sparql: SPARQLWrapper = SPARQLWrapper(ts_url)
+        query: str = f"SELECT ?s ?p ?o WHERE {{BIND (<{res}> AS ?s). ?s ?p ?o.}}"
+        sparql.setQuery(query)
+        sparql.setMethod('GET')
+        sparql.setReturnFormat(JSON)
+        result: ConjunctiveGraph = sparql.queryAndConvert()['results']['bindings']
+        if result:
+            imported_entities: List[GraphEntity] = Reader.import_entities_from_graph(g_set, result,
+                                                                                     resp_agent, enable_validation)
+            if len(imported_entities) <= 0:
+                raise ValueError("The requested entity was not found or was not recognized as a proper OCDM entity.")
+            else:
                 return imported_entities[0]
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/resources/__init__.py` & `oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/bibliographic/__init__.py`

 * *Files identical despite different names*

### Comparing `oc_ocdm-8.0.2/oc_ocdm/resources/querymap.txt` & `oc_ocdm-8.1.0/oc_ocdm/resources/querymap.txt`

 * *Files identical despite different names*

### Comparing `oc_ocdm-8.0.2/oc_ocdm/resources/shacle.ttl` & `oc_ocdm-8.1.0/oc_ocdm/resources/shacle.ttl`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,1005 +1,1005 @@
-@prefix sh: <http://www.w3.org/ns/shacl#> .
-@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
-@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
-@prefix schema: <http://schema.org/> .
-@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
-
-@prefix biro: <http://purl.org/spar/biro/> .
-@prefix c4o: <http://purl.org/spar/c4o> .
-@prefix cito: <http://purl.org/spar/cito/> .
-@prefix co: <http://purl.org/co/> .
-@prefix datacite: <http://purl.org/spar/datacite/> .
-@prefix dcat: <http://www.w3.org/ns/dcat#> .
-@prefix dcterms: <http://purl.org/dc/terms/> .
-@prefix deo: <http://purl.org/spar/deo/> .
-@prefix doco: <http://purl.org/spar/doco/> .
-@prefix fabio: <http://purl.org/spar/fabio/> .
-@prefix foaf: <http://xmlns.com/foaf/0.1/> .
-@prefix frbr: <http://purl.org/vocab/frbr/core#> .
-@prefix literal: <http://www.essepuntato.it/2010/06/literalreification/> .
-@prefix oa: <http://www.w3.org/ns/oa#> .
-@prefix oco: <https://w3id.org/oc/ontology/> .
-@prefix prism: <http://prismstandard.org/namespaces/basic/2.0/> .
-@prefix pro: <http://purl.org/spar/pro/> .
-@prefix prov: <http://www.w3.org/ns/prov#> .
-@prefix void: <http://rdfs.org/ns/void#> .
-
-schema:AbstractEntityShape
-  a sh:NodeShape ;
-  sh:property
-    [
-      sh:path rdf:type ;
-      sh:nodeKind sh:IRI ;
-      sh:minCount 1 ;
-      sh:maxCount 2 ;
-    ],
-    [
-      sh:path rdfs:label ;
-      sh:datatype xsd:string ;
-      sh:minCount 0 ;
-      sh:maxCount 1 ;
-    ] 
-.
-
-schema:IdentifierShape
-  	a sh:NodeShape ;
-    rdfs:subClassOf schema:AbstractEntityShape ;
-    sh:targetClass datacite:Identifier ;
-    sh:property
-    [
-      sh:path rdf:type ;
-      sh:value datacite:Identifier ;
-    ] ;
-    sh:property
-    [
-      sh:path literal:hasLiteralValue ;
-      sh:datatype xsd:string ;
-    ] ;
-    sh:property
-    [
-      sh:path datacite:usesIdentifierScheme ;
-      sh:in (
-        datacite:oci
-        datacite:doi
-        datacite:pmid
-        datacite:pmcid
-        datacite:orcid
-        datacite:local-resource-identifier-scheme
-        datacite:intrepid
-        datacite:isbn
-        datacite:issn
-        datacite:url
-        datacite:viaf
-        datacite:crossref
-        datacite:datacite
-        datacite:wikidata
-        datacite:wikipedia        
-      ) ;
-    ] ;
-    sh:property
-    [
-      sh:path [sh:inversePath datacite:hasIdentifier] ;
-      sh:classIn (
-        biro:BibliographicReference
-        c4o:InTextReferencePointer
-        c4o:SingleLocationPointerList
-        cito:Citation
-        deo:DiscourseElement
-        fabio:BibliographicResource
-        fabio:Expression
-        fabio:Manifestation
-        foaf:Agent
-        oa:Annotation
-        pro:RoleInTime
-      ) ;
-    ] ;
-    sh:property
-    [
-      sh:path [sh:inversePath prov:specializationOf] ;
-      sh:class prov:Entity ;
-    ]
-.
-
-schema:BibliographicEntityShape
-	a sh:NodeShape ;
-	rdfs:subClassOf schema:AbstractEntityShape ;
-  sh:property
-  [
-    sh:path datacite:hasIdentifier ;
-    sh:targetNode datacite:Identifier ;
-    sh:nodeKind sh:IRI ;
-  ]
-.
-
-############################# ENTITIES #############################
-
-#SnapshotEntity
-schema:SnapshotEntityShape
-    a sh:NodeShape ;
-    rdfs:subClassOf schema:AbstractEntityShape ;
-    sh:nodeKind sh:IRI ;
-    sh:targetClass prov:Entity ;
-    sh:property
-    [
-      sh:path rdf:type ;
-      sh:targetNode prov:Entity ;
-      sh:minValue 1 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path prov:generatedAtTime ;
-      sh:datatype xsd:dateTime ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path prov:invalidatedAtTime ;
-      sh:datatype xsd:dateTime ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path prov:specializationOf ;
-      sh:classIn (
-        biro:BibliographicReference
-        c4o:InTextReferencePointer
-        c4o:SingleLocationPointerList
-        cito:Citation
-        datacite:Identifier
-        deo:DiscourseElement
-        fabio:BibliographicResource
-        fabio:Expression
-        fabio:Manifestation
-        foaf:Agent
-        oa:Annotation
-        pro:RoleInTime        
-      ) ;
-      sh:minValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path prov:wasDerivedFrom ;
-      sh:class prov:Entity ;
-      sh:minValue 0 ;
-    ] ;
-    sh:property
-    [
-      sh:path prov:hadPrimarySource ;
-      sh:nodeKind sh:IRI ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path oco:hasUpdateQuery ;
-      sh:datatype xsd:string ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path dcterms:description ;
-      sh:datatype xsd:string ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path prov:wasAttributedTo ;
-      sh:nodeKind sh:IRI ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path [sh:inversePath prov:wasDerivedFrom] ;
-      sh:class prov:Entity ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-.
-
-#Dataset
-schema:SnapshotEntityShape
-    a sh:NodeShape ;
-    rdfs:subClassOf schema:AbstractEntityShape ;
-    sh:nodeKind sh:IRI ;
-    sh:targetClass dcat:Dataset ;
-    sh:property
-    [
-      sh:path rdf:type ;
-      sh:targetNode dcat:Dataset ;
-      sh:minValue 1 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path dcterms:title ;
-      sh:datatype xsd:string ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path dcterms:description ;
-      sh:datatype xsd:string ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path dcterms:issued ;
-      sh:datatype xsd:dateTime ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path dcterms:modified ;
-      sh:datatype xsd:dateTime ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path dcat:keyword ;
-      sh:datatype xsd:string ;
-    ] ;
-    sh:property
-    [
-      sh:path dcat:theme ;
-      sh:nodeKind sh:IRI ;
-    ] ;
-    sh:property
-    [
-      sh:path dcat:landingPage ;
-      sh:nodeKind sh:IRI ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path void:subset ;
-      sh:class dcat:Dataset ;
-    ] ;
-    sh:property
-    [
-      sh:path void:sparqlEndpoint ;
-      sh:nodeKind sh:IRI ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path dcat:distribution ;
-      sh:class dcat:Distribution ;
-    ] ;
-    sh:property
-    [
-      sh:path [sh:inversePath void:subset] ;
-      sh:class dcat:Dataset ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-.
-
-#Distribution
-schema:DistributionShape
-    a sh:NodeShape ;
-    rdfs:subClassOf schema:AbstractEntityShape ;
-    sh:targetClass dcat:Distribution ;
-    sh:nodeKind sh:IRI ;
-    sh:property
-    [
-      sh:path rdf:type ;
-      sh:targetNode dcat:Distribution ;
-      sh:minValue 1 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path dcterms:title ;
-      sh:datatype xsd:string ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path dcterms:description ;
-      sh:datatype xsd:string ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path dcterms:issued ;
-      sh:datatype xsd:dateTime ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path dcat:byte_size ;
-      sh:datatype xsd:decimal ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path dcterms:license ;
-      sh:nodeKind sh:IRI ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path dcat:downloadURL ;
-      sh:nodeKind sh:IRI ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path dcat:mediaType ;
-      sh:nodeKind sh:IRI ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path [sh:inversePath dcat:distribution] ;
-      sh:class dcat:Dataset ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-.
-
-# AgentRole
-schema:AgentRoleShape
-    a sh:NodeShape ;
-    rdfs:subClassOf schema:BibliographicEntityShape ;
-    sh:targetClass pro:RoleInTime ;
-    sh:nodeKind sh:IRI ;
-    sh:property
-    [
-      sh:path rdf:type ;
-      sh:targetNode pro:RoleInTime ;
-      sh:minValue 1 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path oco:hasNext ;
-      sh:class pro:RoleInTime ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path pro:isHeldBy ;
-      sh:class foaf:Agent ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path pro:withRole ;
-      sh:classIn (pro:publisher
-                  pro:author
-                  pro:editor) ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path [sh:inversePath oco:hasNext] ;
-      sh:class pro:RoleInTime ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path [sh:inversePath pro:isDocumentContextFor] ;
-      sh:class fabio:Expression ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path [sh:inversePath prov:specializationOf] ;
-      sh:class prov:Entity ;
-    ] ;
-.
-
-# BibliographicReference
-schema:BibliographicReferenceShape
-    a sh:NodeShape ;
-    rdfs:subClassOf schema:BibliographicEntityShape ;
-    sh:targetClass biro:BibliographicReference ;
-    sh:nodeKind sh:IRI ;
-    sh:property
-    [
-      sh:path rdf:type ;
-      sh:targetNode biro:BibliographicReference ;
-      sh:minValue 1 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path c4o:hasContent ;
-      sh:datatype xsd:string ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path oco:hasAnnotation ;
-      sh:class oa:Annotation ;
-    ] ;
-    sh:property
-    [
-      sh:path biro:references ;
-      sh:class fabio:Expression ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path [sh:inversePath frbr:part] ;
-      sh:class fabio:Expression ;
-      sh:minValue 0 ;
-      sh:maxValue 1 ;
-    ] ;
-    sh:property
-    [
-      sh:path [sh:inversePath c4o:denotes] ;
-      sh:class c4o:InTextReferencePointer ;
-    ] ;
-    sh:property
-    [
-      sh:path [sh:inversePath prov:specializationOf] ;
-      sh:class prov:Entity ;
-    ] ;
-.
-
-# BibliographicResource
-schema:BibliographicResourceShape
-	a sh:NodeShape ;
-  sh:targetClass fabio:Expression ;
-	rdfs:subClassOf schema:BibliographicEntityShape ;
-  sh:property
-	[
-    sh:path rdf:type ;
-    sh:in (fabio:ArchivalDocument
-      fabio:Book
-      fabio:BookChapter
-      doco:Part
-      fabio:Expression
-      fabio:ExpressionCollection
-      fabio:BookSeries
-      fabio:BookSet
-      fabio:DataFile
-      fabio:Thesis
-      fabio:JournalArticle
-      fabio:JournalIssue
-      fabio:JournalVolume
-      fabio:Journal
-      fabio:ProceedingsPaper
-      fabio:AcademicProceedings
-      fabio:ReferenceBook
-      fabio:ReferenceEntry
-      fabio:ReportDocument
-      fabio:Series
-      fabio:SpecificationDocument) ;
-    sh:minValue 1 ;
-    sh:maxValue 2 ;
-  ] ;
-  sh:property
-  [
-    sh:path dcterms:title ;
-    sh:datatype xsd:string ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-  [
-    sh:path fabio:hasSubtitle ;
-    sh:datatype xsd:string ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-  [
-    sh:path frbr:partOf ;
-    sh:class fabio:Expression ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-  [
-    sh:path cito:cites ;
-    sh:class fabio:Expression ;
-  ] ;
-  sh:property
-  [
-    sh:path prism:publicationDate ;
-    sh:datatypeIn (xsd:date xsd:gYearMonth xsd:gYear) ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-  [
-    sh:path frbr:embodiment ;
-    sh:class fabio:ResourceEmbodiment ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-  [
-    sh:path fabio:hasSequenceIdentifier ;
-    sh:datatype xsd:string ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-  [
-    sh:path prism:edition ;
-    sh:datatype xsd:string ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-  [
-    sh:path frbr:part ;
-    sh:classIn (biro:BibliographicReference deo:DiscourseElement );
-  ] ;
-  sh:property
-  [
-    sh:path pro:isDocumentContextFor ;
-    sh:class pro:RoleInTime ;
-  ] ;
-  sh:property
-  [
-    sh:path dcterms:relation ;
-    sh:nodeKind sh:IRI ;
-  ] ;
-  sh:property
-  [
-    sh:path [sh:inversePath frbr:partOf] ;
-    sh:class fabio:Expression ;
-  ] ;
-  sh:property
-  [
-    sh:path [sh:inversePath cito:cites] ;
-    sh:class fabio:Expression ;
-  ] ;
-  sh:property
-  [
-    sh:path [sh:inversePath biro:references] ;
-    sh:class biro:BibliographicReference ;
-  ] ;
-  sh:property
-  [
-    sh:path [sh:inversePath cito:hasCitingEntity] ;
-    sh:class cito:Citation ;
-  ] ;
-  sh:property
-  [
-    sh:path [sh:inversePath cito:hasCitedEntity] ;
-    sh:class cito:Citation ;
-  ] ;
-  sh:property
-  [
-    sh:path [sh:inversePath prov:specializationOf] ;
-    sh:class prov:Entity ;
-  ] ;
-.
-
-# Citation
-schema:BibliographicReferenceShape
-    a sh:NodeShape ;
-    rdfs:subClassOf schema:BibliographicEntityShape ;
-    sh:targetClass cito:Citation ;
-    sh:nodeKind sh:IRI ;
-  sh:property
-	[
-    sh:path rdf:type ;
-    sh:in (
-      cito:Citation
-      cito:SelfCitation
-      cito:AffiliationSelfCitation
-      cito:AuthorNetworkSelfCitation
-      cito:AuthorSelfCitation
-      cito:FunderSelfCitation
-      cito:JournalSelfCitation
-      cito:JournalCartelCitation
-      cito:DistantCitation
-    ) ;
-    sh:minValue 1 ;
-    sh:maxValue 2 ;
-  ] ;
-  sh:property
-  [
-    sh:path cito:hasCitingEntity ;
-    sh:targetNode fabio:Expression ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-  [
-    sh:path cito:hasCitedEntity ;
-    sh:targetNode fabio:Expression ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-  [
-    sh:path cito:hasCitationCreationDate ;
-    sh:datatypeIn (xsd:date xsd:gYearMonth xsd:gYear) ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-  [
-    sh:path cito:hasCitationTimeSpan ;
-    sh:datatype xsd:duration ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-  [
-    sh:path cito:hasCitationCharacterisation ;
-    sh:nodeKind sh:IRI ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-  [
-    sh:path [sh:inversePath oa:hasBody] ;
-    sh:class oa:Annotation ;
-  ] ;
-  sh:property
-  [
-    sh:path [sh:inversePath prov:specializationOf] ;
-    sh:class prov:Entity ;
-  ] ;
-.
-
-# DiscourseElement
-schema:DiscourseElementShape
-  a sh:NodeShape ;
-  rdfs:subClassOf schema:BibliographicEntityShape ;
-  sh:targetClass deo:DiscourseElement ;
-  sh:nodeKind sh:IRI ;
-  sh:property
-	[
-    sh:path rdf:type ;
-    sh:in (
-      deo:DiscourseElement
-      deo:Caption
-      doco:Footnote
-      doco:Paragraph
-      doco:Section
-      doco:SectionTitle
-      doco:Sentence
-      doco:Table
-      doco:TextChunk
-    );
-    sh:minValue 1 ;
-    sh:maxValue 2 ;
-  ] ;
-  sh:property
-	[
-    sh:path dcterms:title ;
-    sh:datatype xsd:string ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path frbr:part ;
-    sh:class deo:DiscourseElement ;
-  ] ;
-  sh:property
-	[
-    sh:path oco:hasNext ;
-    sh:class deo:DiscourseElement ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path c4o:isContextOf ;
-    sh:classIn (c4o:InTextReferencePointer c4o:SingleLocationPointerList) ;
-  ] ;
-  sh:property
-	[
-    sh:path c4o:hasContent ;
-    sh:datatype xsd:string ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path fabio:hasSequenceIdentifier ;
-    sh:datatype xsd:string ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path [sh:inversePath frbr:part] ;
-    sh:classIn (fabio:Expression deo:DiscourseElement) ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path [sh:inversePath oco:hasNext] ;
-    sh:class deo:DiscourseElement ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path [sh:inversePath prov:specializationOf] ;
-    sh:class prov:Entity ;
-  ] ;
-.
-
-# PointerList
-schema:PointerListShape
-  a sh:NodeShape ;
-  rdfs:subClassOf schema:BibliographicEntityShape ;
-  sh:targetClass deo:SingleLocationPointerList ;
-  sh:nodeKind sh:IRI ;
-  sh:property
-	[
-    sh:path rdf:type ;
-    sh:targetNode c4o:SingleLocationPointerList ;
-    sh:minValue 1 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path c4o:hasContent ;
-    xsd:datatype xsd:string ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path co:element ;
-    sh:class c4o:InTextReferencePointer ;
-  ] ;
-  sh:property
-	[
-    sh:path [sh:inversePath c4o:isContextOf] ;
-    sh:class deo:DiscourseElement ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path [sh:inversePath prov:specializationOf] ;
-    sh:class prov:Entity ;
-  ] ;
-.
-
-# ReferenceAnnotation
-schema:PointerListShape
-  a sh:NodeShape ;
-  rdfs:subClassOf schema:BibliographicEntityShape ;
-  sh:targetClass oa:Annotation ;
-  sh:nodeKind sh:IRI ;
-  sh:property
-	[
-    sh:path rdf:type ;
-    sh:targetNode oa:Annotation ;
-    sh:minValue 1 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path oa:hasBody ;
-    sh:class cito:Citation ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path [sh:inversePath oco:hasAnnotation] ;
-    sh:class biro:BibliographicReference ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path [sh:inversePath oco:hasAnnotation] ;
-    sh:class c4o:InTextReferencePointer ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path [sh:inversePath prov:specializationOf] ;
-    sh:class prov:Entity ;
-  ] ;
-.
-
-# ReferencePointer
-schema:ReferencePointerShape
-  a sh:NodeShape ;
-  rdfs:subClassOf schema:BibliographicEntityShape ;
-  sh:targetClass oa:InTextReferencePointer ;
-  sh:nodeKind sh:IRI ;
-  sh:property
-	[
-    sh:path rdf:type ;
-    sh:targetNode oa:InTextReferencePointer ;
-    sh:minValue 1 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path c4o:hasContent ;
-    sh:datatype xsd:string ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path oco:hasNext ;
-    sh:class c4o:InTextReferencePointer ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path c4o:denotes ;
-    sh:class biro:BibliographicReference ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path oco:hasAnnotation ;
-    sh:class oa:Annotation ;
-  ] ;
-  sh:property
-	[
-    sh:path [sh:inversePath oco:hasNext] ;
-    sh:class oa:Annotation ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path [sh:inversePath c4o:isContextOf] ;
-    sh:class deo:DiscourseElement ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path [sh:inversePath co:element] ;
-    sh:class c4o:SingleLocationPointerList ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path [sh:inversePath prov:specializationOf] ;
-    sh:class prov:Entity ;
-  ] ;
-.
-
-# ResourceEmbodiment
-schema:ResourceEmbodimentShape
-  a sh:NodeShape ;
-  rdfs:subClassOf schema:BibliographicEntityShape ;
-  sh:targetClass fabio:Manifestation ;
-  sh:nodeKind sh:IRI ;
-  sh:property
-	[
-    sh:path rdf:type ;
-    sh:in (
-      fabio:Manifestation
-      fabio:DigitalManifestation
-      fabio:PrintObject
-      ) ;
-    sh:minValue 1 ;
-    sh:maxValue 2 ;
-  ] ;
-  sh:property
-	[
-    sh:path dcterms:format ;
-    sh:nodeKind sh:IRI ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path prism:startingPage ;
-    sh:datatype xsd:string ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path prism:endingPage ;
-    sh:datatype xsd:string ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path frbr:exemplar ;
-    sh:nodeKind sh:IRI ;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path [sh:inversePath frbr:embodiment] ;
-    sh:class fabio:Expression ;
-  ] ;
-  sh:property
-	[
-    sh:path [sh:inversePath prov:specializationOf] ;
-    sh:class prov:Entity ;
-  ] ;
-.
-
-# ResponsibleAgent
-schema:ResponsibleAgentShape
-  a sh:NodeShape ;
-  rdfs:subClassOf schema:BibliographicEntityShape ;
-  sh:targetClass foaf:Agent ;
-  sh:nodeKind sh:IRI ;
-  sh:property
-	[
-    sh:path rdf:type ;
-    sh:targetNode foaf:Agent;
-    sh:minValue 1 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path foaf:name ;
-    sh:datatype xsd:string;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path foaf:givenName ;
-    sh:datatype xsd:string;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path foaf:familyName ;
-    sh:datatype xsd:string;
-    sh:minValue 0 ;
-    sh:maxValue 1 ;
-  ] ;
-  sh:property
-	[
-    sh:path dcterms:relation ;
-    sh:nodeKind sh:IRI ;
-  ] ;
-  sh:property
-	[
-    sh:path [sh:inversePath pro:isHeldBy] ;
-    sh:class pro:RoleInTime;
-  ] ;
-  sh:property
-	[
-    sh:path [sh:inversePath prov:specializationOf] ;
-    sh:class prov:Entity;
-  ] ;
+@prefix sh: <http://www.w3.org/ns/shacl#> .
+@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
+@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
+@prefix schema: <http://schema.org/> .
+@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
+
+@prefix biro: <http://purl.org/spar/biro/> .
+@prefix c4o: <http://purl.org/spar/c4o> .
+@prefix cito: <http://purl.org/spar/cito/> .
+@prefix co: <http://purl.org/co/> .
+@prefix datacite: <http://purl.org/spar/datacite/> .
+@prefix dcat: <http://www.w3.org/ns/dcat#> .
+@prefix dcterms: <http://purl.org/dc/terms/> .
+@prefix deo: <http://purl.org/spar/deo/> .
+@prefix doco: <http://purl.org/spar/doco/> .
+@prefix fabio: <http://purl.org/spar/fabio/> .
+@prefix foaf: <http://xmlns.com/foaf/0.1/> .
+@prefix frbr: <http://purl.org/vocab/frbr/core#> .
+@prefix literal: <http://www.essepuntato.it/2010/06/literalreification/> .
+@prefix oa: <http://www.w3.org/ns/oa#> .
+@prefix oco: <https://w3id.org/oc/ontology/> .
+@prefix prism: <http://prismstandard.org/namespaces/basic/2.0/> .
+@prefix pro: <http://purl.org/spar/pro/> .
+@prefix prov: <http://www.w3.org/ns/prov#> .
+@prefix void: <http://rdfs.org/ns/void#> .
+
+schema:AbstractEntityShape
+  a sh:NodeShape ;
+  sh:property
+    [
+      sh:path rdf:type ;
+      sh:nodeKind sh:IRI ;
+      sh:minCount 1 ;
+      sh:maxCount 2 ;
+    ],
+    [
+      sh:path rdfs:label ;
+      sh:datatype xsd:string ;
+      sh:minCount 0 ;
+      sh:maxCount 1 ;
+    ] 
+.
+
+schema:IdentifierShape
+  	a sh:NodeShape ;
+    rdfs:subClassOf schema:AbstractEntityShape ;
+    sh:targetClass datacite:Identifier ;
+    sh:property
+    [
+      sh:path rdf:type ;
+      sh:value datacite:Identifier ;
+    ] ;
+    sh:property
+    [
+      sh:path literal:hasLiteralValue ;
+      sh:datatype xsd:string ;
+    ] ;
+    sh:property
+    [
+      sh:path datacite:usesIdentifierScheme ;
+      sh:in (
+        datacite:oci
+        datacite:doi
+        datacite:pmid
+        datacite:pmcid
+        datacite:orcid
+        datacite:local-resource-identifier-scheme
+        datacite:intrepid
+        datacite:isbn
+        datacite:issn
+        datacite:url
+        datacite:viaf
+        datacite:crossref
+        datacite:datacite
+        datacite:wikidata
+        datacite:wikipedia        
+      ) ;
+    ] ;
+    sh:property
+    [
+      sh:path [sh:inversePath datacite:hasIdentifier] ;
+      sh:classIn (
+        biro:BibliographicReference
+        c4o:InTextReferencePointer
+        c4o:SingleLocationPointerList
+        cito:Citation
+        deo:DiscourseElement
+        fabio:BibliographicResource
+        fabio:Expression
+        fabio:Manifestation
+        foaf:Agent
+        oa:Annotation
+        pro:RoleInTime
+      ) ;
+    ] ;
+    sh:property
+    [
+      sh:path [sh:inversePath prov:specializationOf] ;
+      sh:class prov:Entity ;
+    ]
+.
+
+schema:BibliographicEntityShape
+	a sh:NodeShape ;
+	rdfs:subClassOf schema:AbstractEntityShape ;
+  sh:property
+  [
+    sh:path datacite:hasIdentifier ;
+    sh:targetNode datacite:Identifier ;
+    sh:nodeKind sh:IRI ;
+  ]
+.
+
+############################# ENTITIES #############################
+
+#SnapshotEntity
+schema:SnapshotEntityShape
+    a sh:NodeShape ;
+    rdfs:subClassOf schema:AbstractEntityShape ;
+    sh:nodeKind sh:IRI ;
+    sh:targetClass prov:Entity ;
+    sh:property
+    [
+      sh:path rdf:type ;
+      sh:targetNode prov:Entity ;
+      sh:minValue 1 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path prov:generatedAtTime ;
+      sh:datatype xsd:dateTime ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path prov:invalidatedAtTime ;
+      sh:datatype xsd:dateTime ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path prov:specializationOf ;
+      sh:classIn (
+        biro:BibliographicReference
+        c4o:InTextReferencePointer
+        c4o:SingleLocationPointerList
+        cito:Citation
+        datacite:Identifier
+        deo:DiscourseElement
+        fabio:BibliographicResource
+        fabio:Expression
+        fabio:Manifestation
+        foaf:Agent
+        oa:Annotation
+        pro:RoleInTime        
+      ) ;
+      sh:minValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path prov:wasDerivedFrom ;
+      sh:class prov:Entity ;
+      sh:minValue 0 ;
+    ] ;
+    sh:property
+    [
+      sh:path prov:hadPrimarySource ;
+      sh:nodeKind sh:IRI ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path oco:hasUpdateQuery ;
+      sh:datatype xsd:string ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path dcterms:description ;
+      sh:datatype xsd:string ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path prov:wasAttributedTo ;
+      sh:nodeKind sh:IRI ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path [sh:inversePath prov:wasDerivedFrom] ;
+      sh:class prov:Entity ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+.
+
+#Dataset
+schema:SnapshotEntityShape
+    a sh:NodeShape ;
+    rdfs:subClassOf schema:AbstractEntityShape ;
+    sh:nodeKind sh:IRI ;
+    sh:targetClass dcat:Dataset ;
+    sh:property
+    [
+      sh:path rdf:type ;
+      sh:targetNode dcat:Dataset ;
+      sh:minValue 1 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path dcterms:title ;
+      sh:datatype xsd:string ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path dcterms:description ;
+      sh:datatype xsd:string ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path dcterms:issued ;
+      sh:datatype xsd:dateTime ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path dcterms:modified ;
+      sh:datatype xsd:dateTime ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path dcat:keyword ;
+      sh:datatype xsd:string ;
+    ] ;
+    sh:property
+    [
+      sh:path dcat:theme ;
+      sh:nodeKind sh:IRI ;
+    ] ;
+    sh:property
+    [
+      sh:path dcat:landingPage ;
+      sh:nodeKind sh:IRI ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path void:subset ;
+      sh:class dcat:Dataset ;
+    ] ;
+    sh:property
+    [
+      sh:path void:sparqlEndpoint ;
+      sh:nodeKind sh:IRI ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path dcat:distribution ;
+      sh:class dcat:Distribution ;
+    ] ;
+    sh:property
+    [
+      sh:path [sh:inversePath void:subset] ;
+      sh:class dcat:Dataset ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+.
+
+#Distribution
+schema:DistributionShape
+    a sh:NodeShape ;
+    rdfs:subClassOf schema:AbstractEntityShape ;
+    sh:targetClass dcat:Distribution ;
+    sh:nodeKind sh:IRI ;
+    sh:property
+    [
+      sh:path rdf:type ;
+      sh:targetNode dcat:Distribution ;
+      sh:minValue 1 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path dcterms:title ;
+      sh:datatype xsd:string ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path dcterms:description ;
+      sh:datatype xsd:string ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path dcterms:issued ;
+      sh:datatype xsd:dateTime ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path dcat:byte_size ;
+      sh:datatype xsd:decimal ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path dcterms:license ;
+      sh:nodeKind sh:IRI ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path dcat:downloadURL ;
+      sh:nodeKind sh:IRI ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path dcat:mediaType ;
+      sh:nodeKind sh:IRI ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path [sh:inversePath dcat:distribution] ;
+      sh:class dcat:Dataset ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+.
+
+# AgentRole
+schema:AgentRoleShape
+    a sh:NodeShape ;
+    rdfs:subClassOf schema:BibliographicEntityShape ;
+    sh:targetClass pro:RoleInTime ;
+    sh:nodeKind sh:IRI ;
+    sh:property
+    [
+      sh:path rdf:type ;
+      sh:targetNode pro:RoleInTime ;
+      sh:minValue 1 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path oco:hasNext ;
+      sh:class pro:RoleInTime ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path pro:isHeldBy ;
+      sh:class foaf:Agent ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path pro:withRole ;
+      sh:classIn (pro:publisher
+                  pro:author
+                  pro:editor) ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path [sh:inversePath oco:hasNext] ;
+      sh:class pro:RoleInTime ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path [sh:inversePath pro:isDocumentContextFor] ;
+      sh:class fabio:Expression ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path [sh:inversePath prov:specializationOf] ;
+      sh:class prov:Entity ;
+    ] ;
+.
+
+# BibliographicReference
+schema:BibliographicReferenceShape
+    a sh:NodeShape ;
+    rdfs:subClassOf schema:BibliographicEntityShape ;
+    sh:targetClass biro:BibliographicReference ;
+    sh:nodeKind sh:IRI ;
+    sh:property
+    [
+      sh:path rdf:type ;
+      sh:targetNode biro:BibliographicReference ;
+      sh:minValue 1 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path c4o:hasContent ;
+      sh:datatype xsd:string ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path oco:hasAnnotation ;
+      sh:class oa:Annotation ;
+    ] ;
+    sh:property
+    [
+      sh:path biro:references ;
+      sh:class fabio:Expression ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path [sh:inversePath frbr:part] ;
+      sh:class fabio:Expression ;
+      sh:minValue 0 ;
+      sh:maxValue 1 ;
+    ] ;
+    sh:property
+    [
+      sh:path [sh:inversePath c4o:denotes] ;
+      sh:class c4o:InTextReferencePointer ;
+    ] ;
+    sh:property
+    [
+      sh:path [sh:inversePath prov:specializationOf] ;
+      sh:class prov:Entity ;
+    ] ;
+.
+
+# BibliographicResource
+schema:BibliographicResourceShape
+	a sh:NodeShape ;
+  sh:targetClass fabio:Expression ;
+	rdfs:subClassOf schema:BibliographicEntityShape ;
+  sh:property
+	[
+    sh:path rdf:type ;
+    sh:in (fabio:ArchivalDocument
+      fabio:Book
+      fabio:BookChapter
+      doco:Part
+      fabio:Expression
+      fabio:ExpressionCollection
+      fabio:BookSeries
+      fabio:BookSet
+      fabio:DataFile
+      fabio:Thesis
+      fabio:JournalArticle
+      fabio:JournalIssue
+      fabio:JournalVolume
+      fabio:Journal
+      fabio:ProceedingsPaper
+      fabio:AcademicProceedings
+      fabio:ReferenceBook
+      fabio:ReferenceEntry
+      fabio:ReportDocument
+      fabio:Series
+      fabio:SpecificationDocument) ;
+    sh:minValue 1 ;
+    sh:maxValue 2 ;
+  ] ;
+  sh:property
+  [
+    sh:path dcterms:title ;
+    sh:datatype xsd:string ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+  [
+    sh:path fabio:hasSubtitle ;
+    sh:datatype xsd:string ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+  [
+    sh:path frbr:partOf ;
+    sh:class fabio:Expression ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+  [
+    sh:path cito:cites ;
+    sh:class fabio:Expression ;
+  ] ;
+  sh:property
+  [
+    sh:path prism:publicationDate ;
+    sh:datatypeIn (xsd:date xsd:gYearMonth xsd:gYear) ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+  [
+    sh:path frbr:embodiment ;
+    sh:class fabio:ResourceEmbodiment ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+  [
+    sh:path fabio:hasSequenceIdentifier ;
+    sh:datatype xsd:string ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+  [
+    sh:path prism:edition ;
+    sh:datatype xsd:string ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+  [
+    sh:path frbr:part ;
+    sh:classIn (biro:BibliographicReference deo:DiscourseElement );
+  ] ;
+  sh:property
+  [
+    sh:path pro:isDocumentContextFor ;
+    sh:class pro:RoleInTime ;
+  ] ;
+  sh:property
+  [
+    sh:path dcterms:relation ;
+    sh:nodeKind sh:IRI ;
+  ] ;
+  sh:property
+  [
+    sh:path [sh:inversePath frbr:partOf] ;
+    sh:class fabio:Expression ;
+  ] ;
+  sh:property
+  [
+    sh:path [sh:inversePath cito:cites] ;
+    sh:class fabio:Expression ;
+  ] ;
+  sh:property
+  [
+    sh:path [sh:inversePath biro:references] ;
+    sh:class biro:BibliographicReference ;
+  ] ;
+  sh:property
+  [
+    sh:path [sh:inversePath cito:hasCitingEntity] ;
+    sh:class cito:Citation ;
+  ] ;
+  sh:property
+  [
+    sh:path [sh:inversePath cito:hasCitedEntity] ;
+    sh:class cito:Citation ;
+  ] ;
+  sh:property
+  [
+    sh:path [sh:inversePath prov:specializationOf] ;
+    sh:class prov:Entity ;
+  ] ;
+.
+
+# Citation
+schema:BibliographicReferenceShape
+    a sh:NodeShape ;
+    rdfs:subClassOf schema:BibliographicEntityShape ;
+    sh:targetClass cito:Citation ;
+    sh:nodeKind sh:IRI ;
+  sh:property
+	[
+    sh:path rdf:type ;
+    sh:in (
+      cito:Citation
+      cito:SelfCitation
+      cito:AffiliationSelfCitation
+      cito:AuthorNetworkSelfCitation
+      cito:AuthorSelfCitation
+      cito:FunderSelfCitation
+      cito:JournalSelfCitation
+      cito:JournalCartelCitation
+      cito:DistantCitation
+    ) ;
+    sh:minValue 1 ;
+    sh:maxValue 2 ;
+  ] ;
+  sh:property
+  [
+    sh:path cito:hasCitingEntity ;
+    sh:targetNode fabio:Expression ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+  [
+    sh:path cito:hasCitedEntity ;
+    sh:targetNode fabio:Expression ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+  [
+    sh:path cito:hasCitationCreationDate ;
+    sh:datatypeIn (xsd:date xsd:gYearMonth xsd:gYear) ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+  [
+    sh:path cito:hasCitationTimeSpan ;
+    sh:datatype xsd:duration ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+  [
+    sh:path cito:hasCitationCharacterisation ;
+    sh:nodeKind sh:IRI ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+  [
+    sh:path [sh:inversePath oa:hasBody] ;
+    sh:class oa:Annotation ;
+  ] ;
+  sh:property
+  [
+    sh:path [sh:inversePath prov:specializationOf] ;
+    sh:class prov:Entity ;
+  ] ;
+.
+
+# DiscourseElement
+schema:DiscourseElementShape
+  a sh:NodeShape ;
+  rdfs:subClassOf schema:BibliographicEntityShape ;
+  sh:targetClass deo:DiscourseElement ;
+  sh:nodeKind sh:IRI ;
+  sh:property
+	[
+    sh:path rdf:type ;
+    sh:in (
+      deo:DiscourseElement
+      deo:Caption
+      doco:Footnote
+      doco:Paragraph
+      doco:Section
+      doco:SectionTitle
+      doco:Sentence
+      doco:Table
+      doco:TextChunk
+    );
+    sh:minValue 1 ;
+    sh:maxValue 2 ;
+  ] ;
+  sh:property
+	[
+    sh:path dcterms:title ;
+    sh:datatype xsd:string ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path frbr:part ;
+    sh:class deo:DiscourseElement ;
+  ] ;
+  sh:property
+	[
+    sh:path oco:hasNext ;
+    sh:class deo:DiscourseElement ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path c4o:isContextOf ;
+    sh:classIn (c4o:InTextReferencePointer c4o:SingleLocationPointerList) ;
+  ] ;
+  sh:property
+	[
+    sh:path c4o:hasContent ;
+    sh:datatype xsd:string ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path fabio:hasSequenceIdentifier ;
+    sh:datatype xsd:string ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path [sh:inversePath frbr:part] ;
+    sh:classIn (fabio:Expression deo:DiscourseElement) ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path [sh:inversePath oco:hasNext] ;
+    sh:class deo:DiscourseElement ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path [sh:inversePath prov:specializationOf] ;
+    sh:class prov:Entity ;
+  ] ;
+.
+
+# PointerList
+schema:PointerListShape
+  a sh:NodeShape ;
+  rdfs:subClassOf schema:BibliographicEntityShape ;
+  sh:targetClass deo:SingleLocationPointerList ;
+  sh:nodeKind sh:IRI ;
+  sh:property
+	[
+    sh:path rdf:type ;
+    sh:targetNode c4o:SingleLocationPointerList ;
+    sh:minValue 1 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path c4o:hasContent ;
+    xsd:datatype xsd:string ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path co:element ;
+    sh:class c4o:InTextReferencePointer ;
+  ] ;
+  sh:property
+	[
+    sh:path [sh:inversePath c4o:isContextOf] ;
+    sh:class deo:DiscourseElement ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path [sh:inversePath prov:specializationOf] ;
+    sh:class prov:Entity ;
+  ] ;
+.
+
+# ReferenceAnnotation
+schema:PointerListShape
+  a sh:NodeShape ;
+  rdfs:subClassOf schema:BibliographicEntityShape ;
+  sh:targetClass oa:Annotation ;
+  sh:nodeKind sh:IRI ;
+  sh:property
+	[
+    sh:path rdf:type ;
+    sh:targetNode oa:Annotation ;
+    sh:minValue 1 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path oa:hasBody ;
+    sh:class cito:Citation ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path [sh:inversePath oco:hasAnnotation] ;
+    sh:class biro:BibliographicReference ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path [sh:inversePath oco:hasAnnotation] ;
+    sh:class c4o:InTextReferencePointer ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path [sh:inversePath prov:specializationOf] ;
+    sh:class prov:Entity ;
+  ] ;
+.
+
+# ReferencePointer
+schema:ReferencePointerShape
+  a sh:NodeShape ;
+  rdfs:subClassOf schema:BibliographicEntityShape ;
+  sh:targetClass oa:InTextReferencePointer ;
+  sh:nodeKind sh:IRI ;
+  sh:property
+	[
+    sh:path rdf:type ;
+    sh:targetNode oa:InTextReferencePointer ;
+    sh:minValue 1 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path c4o:hasContent ;
+    sh:datatype xsd:string ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path oco:hasNext ;
+    sh:class c4o:InTextReferencePointer ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path c4o:denotes ;
+    sh:class biro:BibliographicReference ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path oco:hasAnnotation ;
+    sh:class oa:Annotation ;
+  ] ;
+  sh:property
+	[
+    sh:path [sh:inversePath oco:hasNext] ;
+    sh:class oa:Annotation ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path [sh:inversePath c4o:isContextOf] ;
+    sh:class deo:DiscourseElement ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path [sh:inversePath co:element] ;
+    sh:class c4o:SingleLocationPointerList ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path [sh:inversePath prov:specializationOf] ;
+    sh:class prov:Entity ;
+  ] ;
+.
+
+# ResourceEmbodiment
+schema:ResourceEmbodimentShape
+  a sh:NodeShape ;
+  rdfs:subClassOf schema:BibliographicEntityShape ;
+  sh:targetClass fabio:Manifestation ;
+  sh:nodeKind sh:IRI ;
+  sh:property
+	[
+    sh:path rdf:type ;
+    sh:in (
+      fabio:Manifestation
+      fabio:DigitalManifestation
+      fabio:PrintObject
+      ) ;
+    sh:minValue 1 ;
+    sh:maxValue 2 ;
+  ] ;
+  sh:property
+	[
+    sh:path dcterms:format ;
+    sh:nodeKind sh:IRI ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path prism:startingPage ;
+    sh:datatype xsd:string ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path prism:endingPage ;
+    sh:datatype xsd:string ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path frbr:exemplar ;
+    sh:nodeKind sh:IRI ;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path [sh:inversePath frbr:embodiment] ;
+    sh:class fabio:Expression ;
+  ] ;
+  sh:property
+	[
+    sh:path [sh:inversePath prov:specializationOf] ;
+    sh:class prov:Entity ;
+  ] ;
+.
+
+# ResponsibleAgent
+schema:ResponsibleAgentShape
+  a sh:NodeShape ;
+  rdfs:subClassOf schema:BibliographicEntityShape ;
+  sh:targetClass foaf:Agent ;
+  sh:nodeKind sh:IRI ;
+  sh:property
+	[
+    sh:path rdf:type ;
+    sh:targetNode foaf:Agent;
+    sh:minValue 1 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path foaf:name ;
+    sh:datatype xsd:string;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path foaf:givenName ;
+    sh:datatype xsd:string;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path foaf:familyName ;
+    sh:datatype xsd:string;
+    sh:minValue 0 ;
+    sh:maxValue 1 ;
+  ] ;
+  sh:property
+	[
+    sh:path dcterms:relation ;
+    sh:nodeKind sh:IRI ;
+  ] ;
+  sh:property
+	[
+    sh:path [sh:inversePath pro:isHeldBy] ;
+    sh:class pro:RoleInTime;
+  ] ;
+  sh:property
+	[
+    sh:path [sh:inversePath prov:specializationOf] ;
+    sh:class prov:Entity;
+  ] ;
 .
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/resources/shexc.txt` & `oc_ocdm-8.1.0/oc_ocdm/resources/shexc_closed.txt`

 * *Files 26% similar despite different names*

```diff
@@ -1,363 +1,363 @@
-PREFIX :         <https://opencitations.net/shex/>
-PREFIX rdf:      <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
-PREFIX rdfs:     <http://www.w3.org/2000/01/rdf-schema#>
-PREFIX xsd:      <http://www.w3.org/2001/XMLSchema#>
-
-PREFIX biro:     <http://purl.org/spar/biro/>
-PREFIX c4o:      <http://purl.org/spar/c4o/>
-PREFIX co:       <http://purl.org/co/>
-PREFIX cito:     <http://purl.org/spar/cito/>
-PREFIX datacite: <http://purl.org/spar/datacite/>
-PREFIX dcterms:  <http://purl.org/dc/terms/>
-PREFIX deo:      <http://purl.org/spar/deo/>
-PREFIX doco:     <http://purl.org/spar/doco/>
-PREFIX fabio:    <http://purl.org/spar/fabio/>
-PREFIX foaf:     <http://xmlns.com/foaf/0.1/>
-PREFIX frbr:     <http://purl.org/vocab/frbr/core#>
-PREFIX literal:  <http://www.essepuntato.it/2010/06/literalreification/>
-PREFIX oa:       <http://www.w3.org/ns/oa#>
-PREFIX oco:      <https://w3id.org/oc/ontology/>
-PREFIX prism:    <http://prismstandard.org/namespaces/basic/2.0/>
-PREFIX pro:      <http://purl.org/spar/pro/>
-
-PREFIX prov:     <http://www.w3.org/ns/prov#>
-
-PREFIX dcat:     <http://www.w3.org/ns/dcat#>
-PREFIX void:     <http://rdfs.org/ns/void#>
-
-:AbstractEntityShape IRI {
-    rdf:type IRI{1,2};
-    rdfs:label xsd:string?;
-}
-
-:IdentifierShape @:AbstractEntityShape AND IRI {
-    rdf:type [datacite:Identifier];
-    literal:hasLiteralValue xsd:string;
-    datacite:usesIdentifierScheme [datacite:oci
-                                   datacite:doi
-                                   datacite:pmid
-                                   datacite:pmcid
-                                   datacite:orcid
-                                   datacite:local-resource-identifier-scheme
-                                   datacite:intrepid
-                                   datacite:isbn
-                                   datacite:issn
-                                   datacite:url
-                                   datacite:viaf
-                                   datacite:crossref
-                                   datacite:datacite
-                                   datacite:wikidata
-                                   datacite:wikipedia
-                                  ];
-    # Inverse properties:
-    ^datacite:hasIdentifier (@:AgentRoleType OR
-                             @:BibliographicReferenceType OR
-                             @:BibliographicResourceType OR
-                             @:CitationType OR
-                             @:DiscourseElementType OR
-                             @:PointerListType OR
-                             @:ReferenceAnnotationType OR
-                             @:ReferencePointerType OR
-                             @:ResourceEmbodimentType OR
-                             @:ResponsibleAgentType) ?;
-    ^prov:specializationOf @:SnapshotEntityType *;
-}
-
-:BibliographicEntityShape @:AbstractEntityShape AND IRI {
-    datacite:hasIdentifier @:IdentifierType *;
-}
-
-############################# ENTITIES #############################
-
-#SnapshotEntity
-:SnapshotEntityShape @:AbstractEntityShape AND IRI {
-    rdf:type [prov:Entity];
-    prov:generatedAtTime xsd:dateTime;
-    prov:invalidatedAtTime xsd:dateTime?;
-    prov:specializationOf (@:IdentifierType OR
-                           @:AgentRoleType OR
-                           @:BibliographicReferenceType OR
-                           @:BibliographicResourceType OR
-                           @:CitationType OR
-                           @:DiscourseElementType OR
-                           @:PointerListType OR
-                           @:ReferenceAnnotationType OR
-                           @:ReferencePointerType OR
-                           @:ResourceEmbodimentType OR
-                           @:ResponsibleAgentType) +;
-    prov:wasDerivedFrom @:SnapshotEntityType *;
-    prov:hadPrimarySource IRI?;
-    oco:hasUpdateQuery xsd:string?;
-    dcterms:description xsd:string?;
-    prov:wasAttributedTo IRI?;
-    # Inverse properties:
-    ^prov:wasDerivedFrom @:SnapshotEntityType ?;
-}
-
-#Dataset
-:DatasetShape @:AbstractEntityShape AND IRI {
-    rdf:type [dcat:Dataset];
-    dcterms:title xsd:string?;
-    dcterms:description xsd:string?;
-    dcterms:issued xsd:dateTime?;
-    dcterms:modified xsd:dateTime?;
-    dcat:keyword xsd:string *;
-    dcat:theme IRI *;
-    dcat:landingPage IRI?;
-    void:subset @:DatasetType *;
-    void:sparqlEndpoint IRI?;
-    dcat:distribution @:DistributionType *;
-    # Inverse properties:
-    ^void:subset @:DatasetType ?;
-}
-
-#Distribution
-:DistributionShape @:AbstractEntityShape AND IRI {
-    rdf:type [dcat:Distribution];
-    dcterms:title xsd:string?;
-    dcterms:description xsd:string?;
-    dcterms:issued xsd:dateTime?;
-    dcat:byte_size xsd:decimal?;
-    dcterms:license IRI?;
-    dcat:downloadURL IRI?;
-    dcat:mediaType IRI?;
-    # Inverse properties:
-    ^dcat:distribution @:DatasetType ?;
-}
-
-# AgentRole
-:AgentRoleShape @:BibliographicEntityShape AND IRI {
-    rdf:type [pro:RoleInTime];
-    oco:hasNext @:AgentRoleType ?;
-    pro:isHeldBy @:ResponsibleAgentType ?;
-    pro:withRole [pro:publisher
-                  pro:author
-                  pro:editor]?;
-    # Inverse properties:
-    ^oco:hasNext @:AgentRoleType ?;
-    ^pro:isDocumentContextFor @:BibliographicResourceType ?;
-    ^prov:specializationOf @:SnapshotEntityType *;
-}
-
-# BibliographicReference
-:BibliographicReferenceShape @:BibliographicEntityShape AND IRI {
-    rdf:type [biro:BibliographicReference];
-    c4o:hasContent xsd:string?;
-    oco:hasAnnotation @:ReferenceAnnotationType *;
-    biro:references @:BibliographicResourceType ?;
-    # Inverse properties:
-    ^frbr:part @:BibliographicResourceType ?;
-    ^c4o:denotes @:ReferencePointerType *;
-    ^prov:specializationOf @:SnapshotEntityType *;
-}
-
-# BibliographicResource
-:BibliographicResourceShape @:BibliographicEntityShape AND IRI {
-    rdf:type [fabio:Expression];
-    rdf:type [fabio:ArchivalDocument
-              fabio:Book
-              fabio:BookChapter
-              doco:Part
-              fabio:ExpressionCollection
-              fabio:BookSeries
-              fabio:BookSet
-              fabio:DataFile
-              fabio:Thesis
-              fabio:JournalArticle
-              fabio:JournalIssue
-              fabio:JournalVolume
-              fabio:Journal
-              fabio:ProceedingsPaper
-              fabio:AcademicProceedings
-              fabio:ReferenceBook
-              fabio:ReferenceEntry
-              fabio:Series
-              fabio:ReportDocument
-              fabio:SpecificationDocument]?;
-    dcterms:title xsd:string?;
-    fabio:hasSubtitle xsd:string?;
-    frbr:partOf @:BibliographicResourceType ?;
-    cito:cites @:BibliographicResourceType *;
-    prism:publicationDate (xsd:date OR xsd:gYearMonth OR xsd:gYear)?;
-    frbr:embodiment @:ResourceEmbodimentType *;
-    fabio:hasSequenceIdentifier xsd:string?;
-    prism:edition xsd:string?;
-    frbr:part (@:BibliographicReferenceType OR @:DiscourseElementType) *;
-    pro:isDocumentContextFor @:AgentRoleType *;
-    dcterms:relation IRI*;
-    # Inverse properties:
-    ^frbr:partOf @:BibliographicResourceType *;
-    ^cito:cites @:BibliographicResourceType *;
-    ^biro:references @:BibliographicReferenceType *;
-    ^cito:hasCitingEntity @:CitationType *;
-    ^cito:hasCitedEntity @:CitationType *;
-    ^prov:specializationOf @:SnapshotEntityType *;
-}
-AND (NOT { rdf:type [doco:Part fabio:ExpressionCollection] }
-     OR { frbr:partOf @:BibliographicResourceType AND {rdf:type [fabio:Book]}? }
-    )
-AND (NOT { rdf:type [fabio:Series] }
-     OR { frbr:part @:DiscourseElementType AND {rdf:type [fabio:ReportDocument fabio:SpecificationDocument]}* }
-    )
-
-# Citation
-:CitationShape @:BibliographicEntityShape AND IRI {
-    rdf:type [cito:Citation];
-    rdf:type [cito:SelfCitation
-              cito:AffiliationSelfCitation
-              cito:AuthorNetworkSelfCitation
-              cito:AuthorSelfCitation
-              cito:FunderSelfCitation
-              cito:JournalSelfCitation
-              cito:JournalCartelCitation
-              cito:DistantCitation]?;
-    cito:hasCitingEntity @:BibliographicResourceType ?;
-    cito:hasCitedEntity @:BibliographicResourceType ?;
-    cito:hasCitationCreationDate (xsd:date OR xsd:gYearMonth OR xsd:gYear)?;
-    cito:hasCitationTimeSpan xsd:duration?;
-    cito:hasCitationCharacterisation IRI?;
-    # Inverse properties:
-    ^oa:hasBody @:ReferenceAnnotationType *;
-    ^prov:specializationOf @:SnapshotEntityType *;
-}
-
-# DiscourseElement
-:DiscourseElementShape @:BibliographicEntityShape AND IRI {
-    rdf:type [deo:DiscourseElement];
-    rdf:type [deo:Caption
-              doco:Footnote
-              doco:Paragraph
-              doco:Section
-              doco:SectionTitle
-              doco:Sentence
-              doco:Table
-              doco:TextChunk]?;
-    dcterms:title xsd:string?;
-    frbr:part @:DiscourseElementType *;
-    oco:hasNext @:DiscourseElementType ?;
-    c4o:isContextOf (@:ReferencePointerType OR @:PointerListType) *;
-    c4o:hasContent xsd:string?;
-    fabio:hasSequenceIdentifier xsd:string?;
-    # Inverse properties:
-    ^frbr:part (@:BibliographicResourceType OR @:DiscourseElementType) ?;
-    ^oco:hasNext @:DiscourseElementType ?;
-    ^prov:specializationOf @:SnapshotEntityType *;
-}
-
-# PointerList
-:PointerListShape @:BibliographicEntityShape AND IRI {
-    rdf:type [c4o:SingleLocationPointerList];
-    c4o:hasContent xsd:string?;
-    co:element @:ReferencePointerType *;
-    # Inverse properties:
-    ^c4o:isContextOf @:DiscourseElementType ?;
-    ^prov:specializationOf @:SnapshotEntityType *;
-}
-
-# ReferenceAnnotation
-:ReferenceAnnotationShape @:BibliographicEntityShape AND IRI {
-    rdf:type [oa:Annotation];
-    oa:hasBody @:CitationType ?;
-    # Inverse properties:
-    ^oco:hasAnnotation @:BibliographicReferenceType ?;
-    ^oco:hasAnnotation @:ReferencePointerType ?;
-    ^prov:specializationOf @:SnapshotEntityType *;
-}
-
-# ReferencePointer
-:ReferencePointerShape @:BibliographicEntityShape AND IRI {
-    rdf:type [c4o:InTextReferencePointer];
-    c4o:hasContent xsd:string?;
-    oco:hasNext @:ReferencePointerType ?;
-    c4o:denotes @:BibliographicReferenceType ?;
-    oco:hasAnnotation @:ReferenceAnnotationType *;
-    # Inverse properties:
-    ^oco:hasNext @:ReferencePointerType ?;
-    ^c4o:isContextOf @:DiscourseElementType ?;
-    ^co:element @:PointerListType ?;
-    ^prov:specializationOf @:SnapshotEntityType *;
-}
-
-# ResourceEmbodiment
-:ResourceEmbodimentShape @:BibliographicEntityShape AND IRI {
-    rdf:type [fabio:Manifestation];
-    rdf:type [fabio:DigitalManifestation
-              fabio:PrintObject]?;
-    dcterms:format IRI?;
-    prism:startingPage xsd:string?;
-    prism:endingPage xsd:string?;
-    frbr:exemplar IRI?;
-    # Inverse properties:
-    ^frbr:embodiment @:BibliographicResourceType *;
-    ^prov:specializationOf @:SnapshotEntityType *;
-}
-
-# ResponsibleAgent
-:ResponsibleAgentShape @:BibliographicEntityShape AND IRI {
-    rdf:type [foaf:Agent];
-    foaf:name xsd:string?;
-    foaf:givenName xsd:string?;
-    foaf:familyName xsd:string?;
-    dcterms:relation IRI*;
-    # Inverse properties:
-    ^pro:isHeldBy @:AgentRoleType *;
-    ^prov:specializationOf @:SnapshotEntityType *;
-}
-
-###################################################################
-
-:IdentifierType {
-    rdf:type [datacite:Identifier] ;
-}
-
-:SnapshotEntityType {
-    rdf:type [prov:Entity] ;
-}
-
-:DatasetType {
-    rdf:type [dcat:Dataset] ;
-}
-
-:DistributionType {
-    rdf:type [dcat:Distribution] ;
-}
-
-:AgentRoleType {
-    rdf:type [pro:RoleInTime] ;
-}
-
-:BibliographicReferenceType {
-    rdf:type [biro:BibliographicReference] ;
-}
-
-:BibliographicResourceType EXTRA rdf:type {
-    rdf:type [fabio:Expression] ;
-}
-
-:CitationType EXTRA rdf:type {
-    rdf:type [cito:Citation] ;
-}
-
-:DiscourseElementType EXTRA rdf:type {
-    rdf:type [deo:DiscourseElement] ;
-}
-
-:PointerListType {
-    rdf:type [c4o:SingleLocationPointerList] ;
-}
-
-:ReferenceAnnotationType {
-    rdf:type [oa:Annotation] ;
-}
-
-:ReferencePointerType {
-    rdf:type [c4o:InTextReferencePointer] ;
-}
-
-:ResourceEmbodimentType EXTRA rdf:type  {
-    rdf:type [fabio:Manifestation] ;
-}
-
-:ResponsibleAgentType {
-    rdf:type [foaf:Agent] ;
-}
+PREFIX :         <https://opencitations.net/shex/>
+PREFIX rdf:      <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
+PREFIX rdfs:     <http://www.w3.org/2000/01/rdf-schema#>
+PREFIX xsd:      <http://www.w3.org/2001/XMLSchema#>
+
+PREFIX biro:     <http://purl.org/spar/biro/>
+PREFIX c4o:      <http://purl.org/spar/c4o/>
+PREFIX co:       <http://purl.org/co/>
+PREFIX cito:     <http://purl.org/spar/cito/>
+PREFIX datacite: <http://purl.org/spar/datacite/>
+PREFIX dcterms:  <http://purl.org/dc/terms/>
+PREFIX deo:      <http://purl.org/spar/deo/>
+PREFIX doco:     <http://purl.org/spar/doco/>
+PREFIX fabio:    <http://purl.org/spar/fabio/>
+PREFIX foaf:     <http://xmlns.com/foaf/0.1/>
+PREFIX frbr:     <http://purl.org/vocab/frbr/core#>
+PREFIX literal:  <http://www.essepuntato.it/2010/06/literalreification/>
+PREFIX oa:       <http://www.w3.org/ns/oa#>
+PREFIX oco:      <https://w3id.org/oc/ontology/>
+PREFIX prism:    <http://prismstandard.org/namespaces/basic/2.0/>
+PREFIX pro:      <http://purl.org/spar/pro/>
+
+PREFIX prov:     <http://www.w3.org/ns/prov#>
+
+PREFIX dcat:     <http://www.w3.org/ns/dcat#>
+PREFIX void:     <http://rdfs.org/ns/void#>
+
+:AbstractEntityShape IRI {
+    rdf:type IRI{1,2};
+    rdfs:label xsd:string?;
+}
+
+:IdentifierShape @:AbstractEntityShape AND IRI CLOSED {
+    rdf:type [datacite:Identifier];
+    literal:hasLiteralValue xsd:string;
+    datacite:usesIdentifierScheme [datacite:oci
+                                   datacite:doi
+                                   datacite:pmid
+                                   datacite:pmcid
+                                   datacite:orcid
+                                   datacite:local-resource-identifier-scheme
+                                   datacite:intrepid
+                                   datacite:isbn
+                                   datacite:issn
+                                   datacite:url
+                                   datacite:viaf
+                                   datacite:crossref
+                                   datacite:datacite
+                                   datacite:wikidata
+                                   datacite:wikipedia
+                                  ];
+    # Inverse properties:
+    ^datacite:hasIdentifier (@:AgentRoleType OR
+                             @:BibliographicReferenceType OR
+                             @:BibliographicResourceType OR
+                             @:CitationType OR
+                             @:DiscourseElementType OR
+                             @:PointerListType OR
+                             @:ReferenceAnnotationType OR
+                             @:ReferencePointerType OR
+                             @:ResourceEmbodimentType OR
+                             @:ResponsibleAgentType) ?;
+    ^prov:specializationOf @:SnapshotEntityType *;
+}
+
+:BibliographicEntityShape @:AbstractEntityShape AND IRI {
+    datacite:hasIdentifier @:IdentifierType *;
+}
+
+############################# ENTITIES #############################
+
+#SnapshotEntity
+:SnapshotEntityShape @:AbstractEntityShape AND IRI CLOSED {
+    rdf:type [prov:Entity];
+    prov:generatedAtTime xsd:dateTime;
+    prov:invalidatedAtTime xsd:dateTime?;
+    prov:specializationOf (@:IdentifierType OR
+                           @:AgentRoleType OR
+                           @:BibliographicReferenceType OR
+                           @:BibliographicResourceType OR
+                           @:CitationType OR
+                           @:DiscourseElementType OR
+                           @:PointerListType OR
+                           @:ReferenceAnnotationType OR
+                           @:ReferencePointerType OR
+                           @:ResourceEmbodimentType OR
+                           @:ResponsibleAgentType) +;
+    prov:wasDerivedFrom @:SnapshotEntityType *;
+    prov:hadPrimarySource IRI?;
+    oco:hasUpdateQuery xsd:string?;
+    dcterms:description xsd:string?;
+    prov:wasAttributedTo IRI?;
+    # Inverse properties:
+    ^prov:wasDerivedFrom @:SnapshotEntityType ?;
+}
+
+#Dataset
+:DatasetShape @:AbstractEntityShape AND IRI CLOSED {
+    rdf:type [dcat:Dataset];
+    dcterms:title xsd:string?;
+    dcterms:description xsd:string?;
+    dcterms:issued xsd:dateTime?;
+    dcterms:modified xsd:dateTime?;
+    dcat:keyword xsd:string *;
+    dcat:theme IRI *;
+    dcat:landingPage IRI?;
+    void:subset @:DatasetType *;
+    void:sparqlEndpoint IRI?;
+    dcat:distribution @:DistributionType *;
+    # Inverse properties:
+    ^void:subset @:DatasetType ?;
+}
+
+#Distribution
+:DistributionShape @:AbstractEntityShape AND IRI CLOSED {
+    rdf:type [dcat:Distribution];
+    dcterms:title xsd:string?;
+    dcterms:description xsd:string?;
+    dcterms:issued xsd:dateTime?;
+    dcat:byte_size xsd:decimal?;
+    dcterms:license IRI?;
+    dcat:downloadURL IRI?;
+    dcat:mediaType IRI?;
+    # Inverse properties:
+    ^dcat:distribution @:DatasetType ?;
+}
+
+# AgentRole
+:AgentRoleShape @:BibliographicEntityShape AND IRI CLOSED {
+    rdf:type [pro:RoleInTime];
+    oco:hasNext @:AgentRoleType ?;
+    pro:isHeldBy @:ResponsibleAgentType ?;
+    pro:withRole [pro:publisher
+                  pro:author
+                  pro:editor]?;
+    # Inverse properties:
+    ^oco:hasNext @:AgentRoleType ?;
+    ^pro:isDocumentContextFor @:BibliographicResourceType ?;
+    ^prov:specializationOf @:SnapshotEntityType *;
+}
+
+# BibliographicReference
+:BibliographicReferenceShape @:BibliographicEntityShape AND IRI CLOSED {
+    rdf:type [biro:BibliographicReference];
+    c4o:hasContent xsd:string?;
+    oco:hasAnnotation @:ReferenceAnnotationType *;
+    biro:references @:BibliographicResourceType ?;
+    # Inverse properties:
+    ^frbr:part @:BibliographicResourceType ?;
+    ^c4o:denotes @:ReferencePointerType *;
+    ^prov:specializationOf @:SnapshotEntityType *;
+}
+
+# BibliographicResource
+:BibliographicResourceShape @:BibliographicEntityShape AND IRI CLOSED {
+    rdf:type [fabio:Expression];
+    rdf:type [fabio:ArchivalDocument
+              fabio:Book
+              fabio:BookChapter
+              doco:Part
+              fabio:ExpressionCollection
+              fabio:BookSeries
+              fabio:BookSet
+              fabio:DataFile
+              fabio:Thesis
+              fabio:JournalArticle
+              fabio:JournalIssue
+              fabio:JournalVolume
+              fabio:Journal
+              fabio:ProceedingsPaper
+              fabio:AcademicProceedings
+              fabio:ReferenceBook
+              fabio:ReferenceEntry
+              fabio:Series
+              fabio:ReportDocument
+              fabio:SpecificationDocument]?;
+    dcterms:title xsd:string?;
+    fabio:hasSubtitle xsd:string?;
+    frbr:partOf @:BibliographicResourceType ?;
+    cito:cites @:BibliographicResourceType *;
+    prism:publicationDate (xsd:date OR xsd:gYearMonth OR xsd:gYear)?;
+    frbr:embodiment @:ResourceEmbodimentType *;
+    fabio:hasSequenceIdentifier xsd:string?;
+    prism:edition xsd:string?;
+    frbr:part (@:BibliographicReferenceType OR @:DiscourseElementType) *;
+    pro:isDocumentContextFor @:AgentRoleType *;
+    dcterms:relation IRI*;
+    # Inverse properties:
+    ^frbr:partOf @:BibliographicResourceType *;
+    ^cito:cites @:BibliographicResourceType *;
+    ^biro:references @:BibliographicReferenceType *;
+    ^cito:hasCitingEntity @:CitationType *;
+    ^cito:hasCitedEntity @:CitationType *;
+    ^prov:specializationOf @:SnapshotEntityType *;
+}
+AND (NOT { rdf:type [doco:Part fabio:ExpressionCollection] }
+     OR { frbr:partOf @:BibliographicResourceType AND {rdf:type [fabio:Book]}? }
+    )
+AND (NOT { rdf:type [fabio:Series] }
+     OR { frbr:part @:DiscourseElementType AND {rdf:type [fabio:ReportDocument fabio:SpecificationDocument]}* }
+    )
+
+# Citation
+:CitationShape @:BibliographicEntityShape AND IRI CLOSED {
+    rdf:type [cito:Citation];
+    rdf:type [cito:SelfCitation
+              cito:AffiliationSelfCitation
+              cito:AuthorNetworkSelfCitation
+              cito:AuthorSelfCitation
+              cito:FunderSelfCitation
+              cito:JournalSelfCitation
+              cito:JournalCartelCitation
+              cito:DistantCitation]?;
+    cito:hasCitingEntity @:BibliographicResourceType ?;
+    cito:hasCitedEntity @:BibliographicResourceType ?;
+    cito:hasCitationCreationDate (xsd:date OR xsd:gYearMonth OR xsd:gYear)?;
+    cito:hasCitationTimeSpan xsd:duration?;
+    cito:hasCitationCharacterisation IRI?;
+    # Inverse properties:
+    ^oa:hasBody @:ReferenceAnnotationType *;
+    ^prov:specializationOf @:SnapshotEntityType *;
+}
+
+# DiscourseElement
+:DiscourseElementShape @:BibliographicEntityShape AND IRI CLOSED {
+    rdf:type [deo:DiscourseElement];
+    rdf:type [deo:Caption
+              doco:Footnote
+              doco:Paragraph
+              doco:Section
+              doco:SectionTitle
+              doco:Sentence
+              doco:Table
+              doco:TextChunk]?;
+    dcterms:title xsd:string?;
+    frbr:part @:DiscourseElementType *;
+    oco:hasNext @:DiscourseElementType ?;
+    c4o:isContextOf (@:ReferencePointerType OR @:PointerListType) *;
+    c4o:hasContent xsd:string?;
+    fabio:hasSequenceIdentifier xsd:string?;
+    # Inverse properties:
+    ^frbr:part (@:BibliographicResourceType OR @:DiscourseElementType) ?;
+    ^oco:hasNext @:DiscourseElementType ?;
+    ^prov:specializationOf @:SnapshotEntityType *;
+}
+
+# PointerList
+:PointerListShape @:BibliographicEntityShape AND IRI CLOSED {
+    rdf:type [c4o:SingleLocationPointerList];
+    c4o:hasContent xsd:string?;
+    co:element @:ReferencePointerType *;
+    # Inverse properties:
+    ^c4o:isContextOf @:DiscourseElementType ?;
+    ^prov:specializationOf @:SnapshotEntityType *;
+}
+
+# ReferenceAnnotation
+:ReferenceAnnotationShape @:BibliographicEntityShape AND IRI CLOSED {
+    rdf:type [oa:Annotation];
+    oa:hasBody @:CitationType ?;
+    # Inverse properties:
+    ^oco:hasAnnotation @:BibliographicReferenceType ?;
+    ^oco:hasAnnotation @:ReferencePointerType ?;
+    ^prov:specializationOf @:SnapshotEntityType *;
+}
+
+# ReferencePointer
+:ReferencePointerShape @:BibliographicEntityShape AND IRI CLOSED {
+    rdf:type [c4o:InTextReferencePointer];
+    c4o:hasContent xsd:string?;
+    oco:hasNext @:ReferencePointerType ?;
+    c4o:denotes @:BibliographicReferenceType ?;
+    oco:hasAnnotation @:ReferenceAnnotationType *;
+    # Inverse properties:
+    ^oco:hasNext @:ReferencePointerType ?;
+    ^c4o:isContextOf @:DiscourseElementType ?;
+    ^co:element @:PointerListType ?;
+    ^prov:specializationOf @:SnapshotEntityType *;
+}
+
+# ResourceEmbodiment
+:ResourceEmbodimentShape @:BibliographicEntityShape AND IRI CLOSED {
+    rdf:type [fabio:Manifestation];
+    rdf:type [fabio:DigitalManifestation
+              fabio:PrintObject]?;
+    dcterms:format IRI?;
+    prism:startingPage xsd:string?;
+    prism:endingPage xsd:string?;
+    frbr:exemplar IRI?;
+    # Inverse properties:
+    ^frbr:embodiment @:BibliographicResourceType *;
+    ^prov:specializationOf @:SnapshotEntityType *;
+}
+
+# ResponsibleAgent
+:ResponsibleAgentShape @:BibliographicEntityShape AND IRI CLOSED {
+    rdf:type [foaf:Agent];
+    foaf:name xsd:string?;
+    foaf:givenName xsd:string?;
+    foaf:familyName xsd:string?;
+    dcterms:relation IRI*;
+    # Inverse properties:
+    ^pro:isHeldBy @:AgentRoleType *;
+    ^prov:specializationOf @:SnapshotEntityType *;
+}
+
+###################################################################
+
+:IdentifierType {
+    rdf:type [datacite:Identifier] ;
+}
+
+:SnapshotEntityType {
+    rdf:type [prov:Entity] ;
+}
+
+:DatasetType {
+    rdf:type [dcat:Dataset] ;
+}
+
+:DistributionType {
+    rdf:type [dcat:Distribution] ;
+}
+
+:AgentRoleType {
+    rdf:type [pro:RoleInTime] ;
+}
+
+:BibliographicReferenceType {
+    rdf:type [biro:BibliographicReference] ;
+}
+
+:BibliographicResourceType EXTRA rdf:type {
+    rdf:type [fabio:Expression] ;
+}
+
+:CitationType EXTRA rdf:type {
+    rdf:type [cito:Citation] ;
+}
+
+:DiscourseElementType EXTRA rdf:type {
+    rdf:type [deo:DiscourseElement] ;
+}
+
+:PointerListType {
+    rdf:type [c4o:SingleLocationPointerList] ;
+}
+
+:ReferenceAnnotationType {
+    rdf:type [oa:Annotation] ;
+}
+
+:ReferencePointerType {
+    rdf:type [c4o:InTextReferencePointer] ;
+}
+
+:ResourceEmbodimentType EXTRA rdf:type  {
+    rdf:type [fabio:Manifestation] ;
+}
+
+:ResponsibleAgentType {
+    rdf:type [foaf:Agent] ;
+}
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/resources/shexc_closed.txt` & `oc_ocdm-8.1.0/oc_ocdm/resources/shexc.txt`

 * *Files 23% similar despite different names*

```diff
@@ -1,363 +1,363 @@
-PREFIX :         <https://opencitations.net/shex/>
-PREFIX rdf:      <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
-PREFIX rdfs:     <http://www.w3.org/2000/01/rdf-schema#>
-PREFIX xsd:      <http://www.w3.org/2001/XMLSchema#>
-
-PREFIX biro:     <http://purl.org/spar/biro/>
-PREFIX c4o:      <http://purl.org/spar/c4o/>
-PREFIX co:       <http://purl.org/co/>
-PREFIX cito:     <http://purl.org/spar/cito/>
-PREFIX datacite: <http://purl.org/spar/datacite/>
-PREFIX dcterms:  <http://purl.org/dc/terms/>
-PREFIX deo:      <http://purl.org/spar/deo/>
-PREFIX doco:     <http://purl.org/spar/doco/>
-PREFIX fabio:    <http://purl.org/spar/fabio/>
-PREFIX foaf:     <http://xmlns.com/foaf/0.1/>
-PREFIX frbr:     <http://purl.org/vocab/frbr/core#>
-PREFIX literal:  <http://www.essepuntato.it/2010/06/literalreification/>
-PREFIX oa:       <http://www.w3.org/ns/oa#>
-PREFIX oco:      <https://w3id.org/oc/ontology/>
-PREFIX prism:    <http://prismstandard.org/namespaces/basic/2.0/>
-PREFIX pro:      <http://purl.org/spar/pro/>
-
-PREFIX prov:     <http://www.w3.org/ns/prov#>
-
-PREFIX dcat:     <http://www.w3.org/ns/dcat#>
-PREFIX void:     <http://rdfs.org/ns/void#>
-
-:AbstractEntityShape IRI {
-    rdf:type IRI{1,2};
-    rdfs:label xsd:string?;
-}
-
-:IdentifierShape @:AbstractEntityShape AND IRI CLOSED {
-    rdf:type [datacite:Identifier];
-    literal:hasLiteralValue xsd:string;
-    datacite:usesIdentifierScheme [datacite:oci
-                                   datacite:doi
-                                   datacite:pmid
-                                   datacite:pmcid
-                                   datacite:orcid
-                                   datacite:local-resource-identifier-scheme
-                                   datacite:intrepid
-                                   datacite:isbn
-                                   datacite:issn
-                                   datacite:url
-                                   datacite:viaf
-                                   datacite:crossref
-                                   datacite:datacite
-                                   datacite:wikidata
-                                   datacite:wikipedia
-                                  ];
-    # Inverse properties:
-    ^datacite:hasIdentifier (@:AgentRoleType OR
-                             @:BibliographicReferenceType OR
-                             @:BibliographicResourceType OR
-                             @:CitationType OR
-                             @:DiscourseElementType OR
-                             @:PointerListType OR
-                             @:ReferenceAnnotationType OR
-                             @:ReferencePointerType OR
-                             @:ResourceEmbodimentType OR
-                             @:ResponsibleAgentType) ?;
-    ^prov:specializationOf @:SnapshotEntityType *;
-}
-
-:BibliographicEntityShape @:AbstractEntityShape AND IRI {
-    datacite:hasIdentifier @:IdentifierType *;
-}
-
-############################# ENTITIES #############################
-
-#SnapshotEntity
-:SnapshotEntityShape @:AbstractEntityShape AND IRI CLOSED {
-    rdf:type [prov:Entity];
-    prov:generatedAtTime xsd:dateTime;
-    prov:invalidatedAtTime xsd:dateTime?;
-    prov:specializationOf (@:IdentifierType OR
-                           @:AgentRoleType OR
-                           @:BibliographicReferenceType OR
-                           @:BibliographicResourceType OR
-                           @:CitationType OR
-                           @:DiscourseElementType OR
-                           @:PointerListType OR
-                           @:ReferenceAnnotationType OR
-                           @:ReferencePointerType OR
-                           @:ResourceEmbodimentType OR
-                           @:ResponsibleAgentType) +;
-    prov:wasDerivedFrom @:SnapshotEntityType *;
-    prov:hadPrimarySource IRI?;
-    oco:hasUpdateQuery xsd:string?;
-    dcterms:description xsd:string?;
-    prov:wasAttributedTo IRI?;
-    # Inverse properties:
-    ^prov:wasDerivedFrom @:SnapshotEntityType ?;
-}
-
-#Dataset
-:DatasetShape @:AbstractEntityShape AND IRI CLOSED {
-    rdf:type [dcat:Dataset];
-    dcterms:title xsd:string?;
-    dcterms:description xsd:string?;
-    dcterms:issued xsd:dateTime?;
-    dcterms:modified xsd:dateTime?;
-    dcat:keyword xsd:string *;
-    dcat:theme IRI *;
-    dcat:landingPage IRI?;
-    void:subset @:DatasetType *;
-    void:sparqlEndpoint IRI?;
-    dcat:distribution @:DistributionType *;
-    # Inverse properties:
-    ^void:subset @:DatasetType ?;
-}
-
-#Distribution
-:DistributionShape @:AbstractEntityShape AND IRI CLOSED {
-    rdf:type [dcat:Distribution];
-    dcterms:title xsd:string?;
-    dcterms:description xsd:string?;
-    dcterms:issued xsd:dateTime?;
-    dcat:byte_size xsd:decimal?;
-    dcterms:license IRI?;
-    dcat:downloadURL IRI?;
-    dcat:mediaType IRI?;
-    # Inverse properties:
-    ^dcat:distribution @:DatasetType ?;
-}
-
-# AgentRole
-:AgentRoleShape @:BibliographicEntityShape AND IRI CLOSED {
-    rdf:type [pro:RoleInTime];
-    oco:hasNext @:AgentRoleType ?;
-    pro:isHeldBy @:ResponsibleAgentType ?;
-    pro:withRole [pro:publisher
-                  pro:author
-                  pro:editor]?;
-    # Inverse properties:
-    ^oco:hasNext @:AgentRoleType ?;
-    ^pro:isDocumentContextFor @:BibliographicResourceType ?;
-    ^prov:specializationOf @:SnapshotEntityType *;
-}
-
-# BibliographicReference
-:BibliographicReferenceShape @:BibliographicEntityShape AND IRI CLOSED {
-    rdf:type [biro:BibliographicReference];
-    c4o:hasContent xsd:string?;
-    oco:hasAnnotation @:ReferenceAnnotationType *;
-    biro:references @:BibliographicResourceType ?;
-    # Inverse properties:
-    ^frbr:part @:BibliographicResourceType ?;
-    ^c4o:denotes @:ReferencePointerType *;
-    ^prov:specializationOf @:SnapshotEntityType *;
-}
-
-# BibliographicResource
-:BibliographicResourceShape @:BibliographicEntityShape AND IRI CLOSED {
-    rdf:type [fabio:Expression];
-    rdf:type [fabio:ArchivalDocument
-              fabio:Book
-              fabio:BookChapter
-              doco:Part
-              fabio:ExpressionCollection
-              fabio:BookSeries
-              fabio:BookSet
-              fabio:DataFile
-              fabio:Thesis
-              fabio:JournalArticle
-              fabio:JournalIssue
-              fabio:JournalVolume
-              fabio:Journal
-              fabio:ProceedingsPaper
-              fabio:AcademicProceedings
-              fabio:ReferenceBook
-              fabio:ReferenceEntry
-              fabio:Series
-              fabio:ReportDocument
-              fabio:SpecificationDocument]?;
-    dcterms:title xsd:string?;
-    fabio:hasSubtitle xsd:string?;
-    frbr:partOf @:BibliographicResourceType ?;
-    cito:cites @:BibliographicResourceType *;
-    prism:publicationDate (xsd:date OR xsd:gYearMonth OR xsd:gYear)?;
-    frbr:embodiment @:ResourceEmbodimentType *;
-    fabio:hasSequenceIdentifier xsd:string?;
-    prism:edition xsd:string?;
-    frbr:part (@:BibliographicReferenceType OR @:DiscourseElementType) *;
-    pro:isDocumentContextFor @:AgentRoleType *;
-    dcterms:relation IRI*;
-    # Inverse properties:
-    ^frbr:partOf @:BibliographicResourceType *;
-    ^cito:cites @:BibliographicResourceType *;
-    ^biro:references @:BibliographicReferenceType *;
-    ^cito:hasCitingEntity @:CitationType *;
-    ^cito:hasCitedEntity @:CitationType *;
-    ^prov:specializationOf @:SnapshotEntityType *;
-}
-AND (NOT { rdf:type [doco:Part fabio:ExpressionCollection] }
-     OR { frbr:partOf @:BibliographicResourceType AND {rdf:type [fabio:Book]}? }
-    )
-AND (NOT { rdf:type [fabio:Series] }
-     OR { frbr:part @:DiscourseElementType AND {rdf:type [fabio:ReportDocument fabio:SpecificationDocument]}* }
-    )
-
-# Citation
-:CitationShape @:BibliographicEntityShape AND IRI CLOSED {
-    rdf:type [cito:Citation];
-    rdf:type [cito:SelfCitation
-              cito:AffiliationSelfCitation
-              cito:AuthorNetworkSelfCitation
-              cito:AuthorSelfCitation
-              cito:FunderSelfCitation
-              cito:JournalSelfCitation
-              cito:JournalCartelCitation
-              cito:DistantCitation]?;
-    cito:hasCitingEntity @:BibliographicResourceType ?;
-    cito:hasCitedEntity @:BibliographicResourceType ?;
-    cito:hasCitationCreationDate (xsd:date OR xsd:gYearMonth OR xsd:gYear)?;
-    cito:hasCitationTimeSpan xsd:duration?;
-    cito:hasCitationCharacterisation IRI?;
-    # Inverse properties:
-    ^oa:hasBody @:ReferenceAnnotationType *;
-    ^prov:specializationOf @:SnapshotEntityType *;
-}
-
-# DiscourseElement
-:DiscourseElementShape @:BibliographicEntityShape AND IRI CLOSED {
-    rdf:type [deo:DiscourseElement];
-    rdf:type [deo:Caption
-              doco:Footnote
-              doco:Paragraph
-              doco:Section
-              doco:SectionTitle
-              doco:Sentence
-              doco:Table
-              doco:TextChunk]?;
-    dcterms:title xsd:string?;
-    frbr:part @:DiscourseElementType *;
-    oco:hasNext @:DiscourseElementType ?;
-    c4o:isContextOf (@:ReferencePointerType OR @:PointerListType) *;
-    c4o:hasContent xsd:string?;
-    fabio:hasSequenceIdentifier xsd:string?;
-    # Inverse properties:
-    ^frbr:part (@:BibliographicResourceType OR @:DiscourseElementType) ?;
-    ^oco:hasNext @:DiscourseElementType ?;
-    ^prov:specializationOf @:SnapshotEntityType *;
-}
-
-# PointerList
-:PointerListShape @:BibliographicEntityShape AND IRI CLOSED {
-    rdf:type [c4o:SingleLocationPointerList];
-    c4o:hasContent xsd:string?;
-    co:element @:ReferencePointerType *;
-    # Inverse properties:
-    ^c4o:isContextOf @:DiscourseElementType ?;
-    ^prov:specializationOf @:SnapshotEntityType *;
-}
-
-# ReferenceAnnotation
-:ReferenceAnnotationShape @:BibliographicEntityShape AND IRI CLOSED {
-    rdf:type [oa:Annotation];
-    oa:hasBody @:CitationType ?;
-    # Inverse properties:
-    ^oco:hasAnnotation @:BibliographicReferenceType ?;
-    ^oco:hasAnnotation @:ReferencePointerType ?;
-    ^prov:specializationOf @:SnapshotEntityType *;
-}
-
-# ReferencePointer
-:ReferencePointerShape @:BibliographicEntityShape AND IRI CLOSED {
-    rdf:type [c4o:InTextReferencePointer];
-    c4o:hasContent xsd:string?;
-    oco:hasNext @:ReferencePointerType ?;
-    c4o:denotes @:BibliographicReferenceType ?;
-    oco:hasAnnotation @:ReferenceAnnotationType *;
-    # Inverse properties:
-    ^oco:hasNext @:ReferencePointerType ?;
-    ^c4o:isContextOf @:DiscourseElementType ?;
-    ^co:element @:PointerListType ?;
-    ^prov:specializationOf @:SnapshotEntityType *;
-}
-
-# ResourceEmbodiment
-:ResourceEmbodimentShape @:BibliographicEntityShape AND IRI CLOSED {
-    rdf:type [fabio:Manifestation];
-    rdf:type [fabio:DigitalManifestation
-              fabio:PrintObject]?;
-    dcterms:format IRI?;
-    prism:startingPage xsd:string?;
-    prism:endingPage xsd:string?;
-    frbr:exemplar IRI?;
-    # Inverse properties:
-    ^frbr:embodiment @:BibliographicResourceType *;
-    ^prov:specializationOf @:SnapshotEntityType *;
-}
-
-# ResponsibleAgent
-:ResponsibleAgentShape @:BibliographicEntityShape AND IRI CLOSED {
-    rdf:type [foaf:Agent];
-    foaf:name xsd:string?;
-    foaf:givenName xsd:string?;
-    foaf:familyName xsd:string?;
-    dcterms:relation IRI*;
-    # Inverse properties:
-    ^pro:isHeldBy @:AgentRoleType *;
-    ^prov:specializationOf @:SnapshotEntityType *;
-}
-
-###################################################################
-
-:IdentifierType {
-    rdf:type [datacite:Identifier] ;
-}
-
-:SnapshotEntityType {
-    rdf:type [prov:Entity] ;
-}
-
-:DatasetType {
-    rdf:type [dcat:Dataset] ;
-}
-
-:DistributionType {
-    rdf:type [dcat:Distribution] ;
-}
-
-:AgentRoleType {
-    rdf:type [pro:RoleInTime] ;
-}
-
-:BibliographicReferenceType {
-    rdf:type [biro:BibliographicReference] ;
-}
-
-:BibliographicResourceType EXTRA rdf:type {
-    rdf:type [fabio:Expression] ;
-}
-
-:CitationType EXTRA rdf:type {
-    rdf:type [cito:Citation] ;
-}
-
-:DiscourseElementType EXTRA rdf:type {
-    rdf:type [deo:DiscourseElement] ;
-}
-
-:PointerListType {
-    rdf:type [c4o:SingleLocationPointerList] ;
-}
-
-:ReferenceAnnotationType {
-    rdf:type [oa:Annotation] ;
-}
-
-:ReferencePointerType {
-    rdf:type [c4o:InTextReferencePointer] ;
-}
-
-:ResourceEmbodimentType EXTRA rdf:type  {
-    rdf:type [fabio:Manifestation] ;
-}
-
-:ResponsibleAgentType {
-    rdf:type [foaf:Agent] ;
-}
+PREFIX :         <https://opencitations.net/shex/>
+PREFIX rdf:      <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
+PREFIX rdfs:     <http://www.w3.org/2000/01/rdf-schema#>
+PREFIX xsd:      <http://www.w3.org/2001/XMLSchema#>
+
+PREFIX biro:     <http://purl.org/spar/biro/>
+PREFIX c4o:      <http://purl.org/spar/c4o/>
+PREFIX co:       <http://purl.org/co/>
+PREFIX cito:     <http://purl.org/spar/cito/>
+PREFIX datacite: <http://purl.org/spar/datacite/>
+PREFIX dcterms:  <http://purl.org/dc/terms/>
+PREFIX deo:      <http://purl.org/spar/deo/>
+PREFIX doco:     <http://purl.org/spar/doco/>
+PREFIX fabio:    <http://purl.org/spar/fabio/>
+PREFIX foaf:     <http://xmlns.com/foaf/0.1/>
+PREFIX frbr:     <http://purl.org/vocab/frbr/core#>
+PREFIX literal:  <http://www.essepuntato.it/2010/06/literalreification/>
+PREFIX oa:       <http://www.w3.org/ns/oa#>
+PREFIX oco:      <https://w3id.org/oc/ontology/>
+PREFIX prism:    <http://prismstandard.org/namespaces/basic/2.0/>
+PREFIX pro:      <http://purl.org/spar/pro/>
+
+PREFIX prov:     <http://www.w3.org/ns/prov#>
+
+PREFIX dcat:     <http://www.w3.org/ns/dcat#>
+PREFIX void:     <http://rdfs.org/ns/void#>
+
+:AbstractEntityShape IRI {
+    rdf:type IRI{1,2};
+    rdfs:label xsd:string?;
+}
+
+:IdentifierShape @:AbstractEntityShape AND IRI {
+    rdf:type [datacite:Identifier];
+    literal:hasLiteralValue xsd:string;
+    datacite:usesIdentifierScheme [datacite:oci
+                                   datacite:doi
+                                   datacite:pmid
+                                   datacite:pmcid
+                                   datacite:orcid
+                                   datacite:local-resource-identifier-scheme
+                                   datacite:intrepid
+                                   datacite:isbn
+                                   datacite:issn
+                                   datacite:url
+                                   datacite:viaf
+                                   datacite:crossref
+                                   datacite:datacite
+                                   datacite:wikidata
+                                   datacite:wikipedia
+                                  ];
+    # Inverse properties:
+    ^datacite:hasIdentifier (@:AgentRoleType OR
+                             @:BibliographicReferenceType OR
+                             @:BibliographicResourceType OR
+                             @:CitationType OR
+                             @:DiscourseElementType OR
+                             @:PointerListType OR
+                             @:ReferenceAnnotationType OR
+                             @:ReferencePointerType OR
+                             @:ResourceEmbodimentType OR
+                             @:ResponsibleAgentType) ?;
+    ^prov:specializationOf @:SnapshotEntityType *;
+}
+
+:BibliographicEntityShape @:AbstractEntityShape AND IRI {
+    datacite:hasIdentifier @:IdentifierType *;
+}
+
+############################# ENTITIES #############################
+
+#SnapshotEntity
+:SnapshotEntityShape @:AbstractEntityShape AND IRI {
+    rdf:type [prov:Entity];
+    prov:generatedAtTime xsd:dateTime;
+    prov:invalidatedAtTime xsd:dateTime?;
+    prov:specializationOf (@:IdentifierType OR
+                           @:AgentRoleType OR
+                           @:BibliographicReferenceType OR
+                           @:BibliographicResourceType OR
+                           @:CitationType OR
+                           @:DiscourseElementType OR
+                           @:PointerListType OR
+                           @:ReferenceAnnotationType OR
+                           @:ReferencePointerType OR
+                           @:ResourceEmbodimentType OR
+                           @:ResponsibleAgentType) +;
+    prov:wasDerivedFrom @:SnapshotEntityType *;
+    prov:hadPrimarySource IRI?;
+    oco:hasUpdateQuery xsd:string?;
+    dcterms:description xsd:string?;
+    prov:wasAttributedTo IRI?;
+    # Inverse properties:
+    ^prov:wasDerivedFrom @:SnapshotEntityType ?;
+}
+
+#Dataset
+:DatasetShape @:AbstractEntityShape AND IRI {
+    rdf:type [dcat:Dataset];
+    dcterms:title xsd:string?;
+    dcterms:description xsd:string?;
+    dcterms:issued xsd:dateTime?;
+    dcterms:modified xsd:dateTime?;
+    dcat:keyword xsd:string *;
+    dcat:theme IRI *;
+    dcat:landingPage IRI?;
+    void:subset @:DatasetType *;
+    void:sparqlEndpoint IRI?;
+    dcat:distribution @:DistributionType *;
+    # Inverse properties:
+    ^void:subset @:DatasetType ?;
+}
+
+#Distribution
+:DistributionShape @:AbstractEntityShape AND IRI {
+    rdf:type [dcat:Distribution];
+    dcterms:title xsd:string?;
+    dcterms:description xsd:string?;
+    dcterms:issued xsd:dateTime?;
+    dcat:byte_size xsd:decimal?;
+    dcterms:license IRI?;
+    dcat:downloadURL IRI?;
+    dcat:mediaType IRI?;
+    # Inverse properties:
+    ^dcat:distribution @:DatasetType ?;
+}
+
+# AgentRole
+:AgentRoleShape @:BibliographicEntityShape AND IRI {
+    rdf:type [pro:RoleInTime];
+    oco:hasNext @:AgentRoleType ?;
+    pro:isHeldBy @:ResponsibleAgentType ?;
+    pro:withRole [pro:publisher
+                  pro:author
+                  pro:editor]?;
+    # Inverse properties:
+    ^oco:hasNext @:AgentRoleType ?;
+    ^pro:isDocumentContextFor @:BibliographicResourceType ?;
+    ^prov:specializationOf @:SnapshotEntityType *;
+}
+
+# BibliographicReference
+:BibliographicReferenceShape @:BibliographicEntityShape AND IRI {
+    rdf:type [biro:BibliographicReference];
+    c4o:hasContent xsd:string?;
+    oco:hasAnnotation @:ReferenceAnnotationType *;
+    biro:references @:BibliographicResourceType ?;
+    # Inverse properties:
+    ^frbr:part @:BibliographicResourceType ?;
+    ^c4o:denotes @:ReferencePointerType *;
+    ^prov:specializationOf @:SnapshotEntityType *;
+}
+
+# BibliographicResource
+:BibliographicResourceShape @:BibliographicEntityShape AND IRI {
+    rdf:type [fabio:Expression];
+    rdf:type [fabio:ArchivalDocument
+              fabio:Book
+              fabio:BookChapter
+              doco:Part
+              fabio:ExpressionCollection
+              fabio:BookSeries
+              fabio:BookSet
+              fabio:DataFile
+              fabio:Thesis
+              fabio:JournalArticle
+              fabio:JournalIssue
+              fabio:JournalVolume
+              fabio:Journal
+              fabio:ProceedingsPaper
+              fabio:AcademicProceedings
+              fabio:ReferenceBook
+              fabio:ReferenceEntry
+              fabio:Series
+              fabio:ReportDocument
+              fabio:SpecificationDocument]?;
+    dcterms:title xsd:string?;
+    fabio:hasSubtitle xsd:string?;
+    frbr:partOf @:BibliographicResourceType ?;
+    cito:cites @:BibliographicResourceType *;
+    prism:publicationDate (xsd:date OR xsd:gYearMonth OR xsd:gYear)?;
+    frbr:embodiment @:ResourceEmbodimentType *;
+    fabio:hasSequenceIdentifier xsd:string?;
+    prism:edition xsd:string?;
+    frbr:part (@:BibliographicReferenceType OR @:DiscourseElementType) *;
+    pro:isDocumentContextFor @:AgentRoleType *;
+    dcterms:relation IRI*;
+    # Inverse properties:
+    ^frbr:partOf @:BibliographicResourceType *;
+    ^cito:cites @:BibliographicResourceType *;
+    ^biro:references @:BibliographicReferenceType *;
+    ^cito:hasCitingEntity @:CitationType *;
+    ^cito:hasCitedEntity @:CitationType *;
+    ^prov:specializationOf @:SnapshotEntityType *;
+}
+AND (NOT { rdf:type [doco:Part fabio:ExpressionCollection] }
+     OR { frbr:partOf @:BibliographicResourceType AND {rdf:type [fabio:Book]}? }
+    )
+AND (NOT { rdf:type [fabio:Series] }
+     OR { frbr:part @:DiscourseElementType AND {rdf:type [fabio:ReportDocument fabio:SpecificationDocument]}* }
+    )
+
+# Citation
+:CitationShape @:BibliographicEntityShape AND IRI {
+    rdf:type [cito:Citation];
+    rdf:type [cito:SelfCitation
+              cito:AffiliationSelfCitation
+              cito:AuthorNetworkSelfCitation
+              cito:AuthorSelfCitation
+              cito:FunderSelfCitation
+              cito:JournalSelfCitation
+              cito:JournalCartelCitation
+              cito:DistantCitation]?;
+    cito:hasCitingEntity @:BibliographicResourceType ?;
+    cito:hasCitedEntity @:BibliographicResourceType ?;
+    cito:hasCitationCreationDate (xsd:date OR xsd:gYearMonth OR xsd:gYear)?;
+    cito:hasCitationTimeSpan xsd:duration?;
+    cito:hasCitationCharacterisation IRI?;
+    # Inverse properties:
+    ^oa:hasBody @:ReferenceAnnotationType *;
+    ^prov:specializationOf @:SnapshotEntityType *;
+}
+
+# DiscourseElement
+:DiscourseElementShape @:BibliographicEntityShape AND IRI {
+    rdf:type [deo:DiscourseElement];
+    rdf:type [deo:Caption
+              doco:Footnote
+              doco:Paragraph
+              doco:Section
+              doco:SectionTitle
+              doco:Sentence
+              doco:Table
+              doco:TextChunk]?;
+    dcterms:title xsd:string?;
+    frbr:part @:DiscourseElementType *;
+    oco:hasNext @:DiscourseElementType ?;
+    c4o:isContextOf (@:ReferencePointerType OR @:PointerListType) *;
+    c4o:hasContent xsd:string?;
+    fabio:hasSequenceIdentifier xsd:string?;
+    # Inverse properties:
+    ^frbr:part (@:BibliographicResourceType OR @:DiscourseElementType) ?;
+    ^oco:hasNext @:DiscourseElementType ?;
+    ^prov:specializationOf @:SnapshotEntityType *;
+}
+
+# PointerList
+:PointerListShape @:BibliographicEntityShape AND IRI {
+    rdf:type [c4o:SingleLocationPointerList];
+    c4o:hasContent xsd:string?;
+    co:element @:ReferencePointerType *;
+    # Inverse properties:
+    ^c4o:isContextOf @:DiscourseElementType ?;
+    ^prov:specializationOf @:SnapshotEntityType *;
+}
+
+# ReferenceAnnotation
+:ReferenceAnnotationShape @:BibliographicEntityShape AND IRI {
+    rdf:type [oa:Annotation];
+    oa:hasBody @:CitationType ?;
+    # Inverse properties:
+    ^oco:hasAnnotation @:BibliographicReferenceType ?;
+    ^oco:hasAnnotation @:ReferencePointerType ?;
+    ^prov:specializationOf @:SnapshotEntityType *;
+}
+
+# ReferencePointer
+:ReferencePointerShape @:BibliographicEntityShape AND IRI {
+    rdf:type [c4o:InTextReferencePointer];
+    c4o:hasContent xsd:string?;
+    oco:hasNext @:ReferencePointerType ?;
+    c4o:denotes @:BibliographicReferenceType ?;
+    oco:hasAnnotation @:ReferenceAnnotationType *;
+    # Inverse properties:
+    ^oco:hasNext @:ReferencePointerType ?;
+    ^c4o:isContextOf @:DiscourseElementType ?;
+    ^co:element @:PointerListType ?;
+    ^prov:specializationOf @:SnapshotEntityType *;
+}
+
+# ResourceEmbodiment
+:ResourceEmbodimentShape @:BibliographicEntityShape AND IRI {
+    rdf:type [fabio:Manifestation];
+    rdf:type [fabio:DigitalManifestation
+              fabio:PrintObject]?;
+    dcterms:format IRI?;
+    prism:startingPage xsd:string?;
+    prism:endingPage xsd:string?;
+    frbr:exemplar IRI?;
+    # Inverse properties:
+    ^frbr:embodiment @:BibliographicResourceType *;
+    ^prov:specializationOf @:SnapshotEntityType *;
+}
+
+# ResponsibleAgent
+:ResponsibleAgentShape @:BibliographicEntityShape AND IRI {
+    rdf:type [foaf:Agent];
+    foaf:name xsd:string?;
+    foaf:givenName xsd:string?;
+    foaf:familyName xsd:string?;
+    dcterms:relation IRI*;
+    # Inverse properties:
+    ^pro:isHeldBy @:AgentRoleType *;
+    ^prov:specializationOf @:SnapshotEntityType *;
+}
+
+###################################################################
+
+:IdentifierType {
+    rdf:type [datacite:Identifier] ;
+}
+
+:SnapshotEntityType {
+    rdf:type [prov:Entity] ;
+}
+
+:DatasetType {
+    rdf:type [dcat:Dataset] ;
+}
+
+:DistributionType {
+    rdf:type [dcat:Distribution] ;
+}
+
+:AgentRoleType {
+    rdf:type [pro:RoleInTime] ;
+}
+
+:BibliographicReferenceType {
+    rdf:type [biro:BibliographicReference] ;
+}
+
+:BibliographicResourceType EXTRA rdf:type {
+    rdf:type [fabio:Expression] ;
+}
+
+:CitationType EXTRA rdf:type {
+    rdf:type [cito:Citation] ;
+}
+
+:DiscourseElementType EXTRA rdf:type {
+    rdf:type [deo:DiscourseElement] ;
+}
+
+:PointerListType {
+    rdf:type [c4o:SingleLocationPointerList] ;
+}
+
+:ReferenceAnnotationType {
+    rdf:type [oa:Annotation] ;
+}
+
+:ReferencePointerType {
+    rdf:type [c4o:InTextReferencePointer] ;
+}
+
+:ResourceEmbodimentType EXTRA rdf:type  {
+    rdf:type [fabio:Manifestation] ;
+}
+
+:ResponsibleAgentType {
+    rdf:type [foaf:Agent] ;
+}
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/storer.py` & `oc_ocdm-8.1.0/oc_ocdm/storer.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,342 +1,342 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-import json
-import os
-from datetime import datetime
-from typing import TYPE_CHECKING
-from zipfile import ZIP_DEFLATED, ZipFile
-
-from rdflib import ConjunctiveGraph
-from SPARQLWrapper import SPARQLWrapper
-
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.metadata.metadata_entity import MetadataEntity
-from oc_ocdm.prov.prov_entity import ProvEntity
-from oc_ocdm.reader import Reader
-from oc_ocdm.support.query_utils import get_update_query
-from oc_ocdm.support.reporter import Reporter
-from oc_ocdm.support.support import find_paths
-from filelock import FileLock
-
-if TYPE_CHECKING:
-    from typing import Any, Dict, List, Optional, Set, Tuple
-
-    from rdflib import URIRef
-
-    from oc_ocdm.abstract_entity import AbstractEntity
-    from oc_ocdm.abstract_set import AbstractSet
-
-
-class Storer(object):
-
-    def __init__(self, abstract_set: AbstractSet, repok: Reporter = None, reperr: Reporter = None,
-                 context_map: Dict[str, Any] = None, default_dir: str = "_", dir_split: int = 0,
-                 n_file_item: int = 1, output_format: str = "json-ld", zip_output: bool = False, modified_entities: set = None) -> None:
-        # We only accept format strings that:
-        # 1. are supported by rdflib
-        # 2. correspond to an output format which is effectively either NT or NQ
-        # The only exception to this rule is the 'json-ld' format, which is the default value of 'output_format'.
-        supported_formats: Set[str] = {'application/n-triples', 'ntriples', 'nt', 'nt11',
-                                       'application/n-quads', 'nquads', 'json-ld'}
-        if output_format not in supported_formats:
-            raise ValueError(f"Given output_format '{self.output_format}' is not supported."
-                             f" Available formats: {supported_formats}.")
-        else:
-            self.output_format: str = output_format
-        self.zip_output = zip_output
-        self.dir_split: int = dir_split
-        self.n_file_item: int = n_file_item
-        self.default_dir: str = default_dir if default_dir != "" else "_"
-        self.a_set: AbstractSet = abstract_set
-        self.modified_entities = modified_entities
-
-        if context_map is not None:
-            self.context_map: Dict[str, Any] = context_map
-        else:
-            self.context_map: Dict[str, Any] = {}
-
-        if self.output_format == "json-ld":
-            for context_url in self.context_map:
-                ctx_file_path: Any = self.context_map[context_url]
-                if type(ctx_file_path) == str and os.path.isfile(ctx_file_path):
-                    # This expensive operation is done only when it's really needed
-                    with open(ctx_file_path, 'rt', encoding='utf-8') as ctx_f:
-                        self.context_map[context_url] = json.load(ctx_f)
-
-        if repok is None:
-            self.repok: Reporter = Reporter(prefix="[Storer: INFO] ")
-        else:
-            self.repok: Reporter = repok
-
-        if reperr is None:
-            self.reperr: Reporter = Reporter(prefix="[Storer: ERROR] ")
-        else:
-            self.reperr: Reporter = reperr
-
-    def store_graphs_in_file(self, file_path: str, context_path: str = None) -> None:
-        self.repok.new_article()
-        self.reperr.new_article()
-        self.repok.add_sentence("Store the graphs into a file: starting process")
-
-        cg: ConjunctiveGraph = ConjunctiveGraph()
-        for g in self.a_set.graphs():
-            cg.addN([item + (g.identifier,) for item in list(g)])
-
-        self._store_in_file(cg, file_path, context_path)
-
-    def _store_in_file(self, cur_g: ConjunctiveGraph, cur_file_path: str, context_path: str = None) -> None:
-        # Note: the following lines from here and until 'cur_json_ld' are a sort of hack for including all
-        # the triples of the input graph into the final stored file. Somehow, some of them are not written
-        # in such file otherwise - in particular the provenance ones.
-        new_g: ConjunctiveGraph = ConjunctiveGraph()
-        for s, p, o in cur_g.triples((None, None, None)):
-            g_iri: Optional[URIRef] = None
-            for g_context in cur_g.contexts((s, p, o)):
-                g_iri = g_context.identifier
-                break
-            new_g.addN([(s, p, o, g_iri)])
-
-        zip_file_path = cur_file_path.replace(os.path.splitext(cur_file_path)[1], ".zip")
-        
-        if self.zip_output:
-            with ZipFile(zip_file_path, mode="w", compression=ZIP_DEFLATED, allowZip64=True) as zip_file:
-                self._write_graph(new_g, zip_file, cur_file_path, context_path)
-        else:
-            # Handle non-zipped output directly to a file
-            self._write_graph(new_g, None, cur_file_path, context_path)
-
-        self.repok.add_sentence(f"File '{cur_file_path}' added.")
-
-    def _write_graph(self, graph: ConjunctiveGraph, zip_file: ZipFile, cur_file_path, context_path):
-        if self.output_format == "json-ld":
-            # Serialize the graph in JSON-LD format
-            cur_json_ld = json.loads(graph.serialize(format="json-ld", context=self.context_map.get(context_path)))
-            if context_path is not None and context_path in self.context_map:
-                if isinstance(cur_json_ld, dict):
-                    cur_json_ld["@context"] = context_path
-                else:  # When cur_json_ld is a list
-                    for item in cur_json_ld:
-                        item["@context"] = context_path
-
-            # Determine how to write based on zip file presence
-            if zip_file is not None:
-                dumped_json = json.dumps(cur_json_ld, ensure_ascii=False).encode('utf-8')
-                zip_file.writestr(zinfo_or_arcname=os.path.basename(cur_file_path), data=dumped_json)
-            else:
-                with open(cur_file_path, 'wt', encoding='utf-8') as f:
-                    json.dump(cur_json_ld, f, ensure_ascii=False)
-        else:
-            # Handle other RDF formats
-            if zip_file is not None:
-                rdf_serialization = graph.serialize(destination=None, format=self.output_format, encoding="utf-8")
-                zip_file.writestr(zinfo_or_arcname=os.path.basename(cur_file_path), data=rdf_serialization)
-            else:
-                graph.serialize(destination=cur_file_path, format=self.output_format, encoding="utf-8")
-
-    def store_all(self, base_dir: str, base_iri: str, context_path: str = None, process_id: int|str = None) -> List[str]:
-        self.repok.new_article()
-        self.reperr.new_article()
-
-        self.repok.add_sentence("Starting the process")
-
-        relevant_paths: Dict[str, list] = dict()
-        for entity in self.a_set.res_to_entity.values():
-            is_relevant = True
-            if self.modified_entities is not None and entity.res not in self.modified_entities:
-                is_relevant = False
-            if is_relevant:
-                cur_dir_path, cur_file_path = self._dir_and_file_paths(entity.res, base_dir, base_iri, process_id)
-                if not os.path.exists(cur_dir_path):
-                    os.makedirs(cur_dir_path)
-                relevant_paths.setdefault(cur_file_path, list())
-                relevant_paths[cur_file_path].append(entity)
-
-        for relevant_path, entities_in_path in relevant_paths.items():
-            stored_g = None
-            # Here we try to obtain a reference to the currently stored graph
-            output_filepath = relevant_path.replace(os.path.splitext(relevant_path)[1], ".zip") if self.zip_output else relevant_path
-            lock = FileLock(f"{output_filepath}.lock")
-            with lock:
-                if os.path.exists(output_filepath):
-                    stored_g = Reader(context_map=self.context_map).load(output_filepath)
-                if stored_g is None:
-                    stored_g = ConjunctiveGraph()
-                for entity_in_path in entities_in_path:
-                    self.store(entity_in_path, stored_g, relevant_path, context_path, False)
-                self._store_in_file(stored_g, relevant_path, context_path)
-
-        return list(relevant_paths.keys())
-
-    def store(self, entity: AbstractEntity, destination_g: ConjunctiveGraph, cur_file_path: str, context_path: str = None, store_now: bool = True) -> ConjunctiveGraph:
-        self.repok.new_article()
-        self.reperr.new_article()
-
-        try:
-            if isinstance(entity, ProvEntity):
-                quads: List[Tuple] = []
-                graph_identifier: URIRef = entity.g.identifier
-                for triple in entity.g.triples((entity.res, None, None)):
-                    quads.append((*triple, graph_identifier))
-                destination_g.addN(quads)
-            elif isinstance(entity, GraphEntity) or isinstance(entity, MetadataEntity):
-                if entity.to_be_deleted:
-                    destination_g.remove((entity.res, None, None, None))
-                else:
-                    if len(entity.preexisting_graph) > 0:
-                        """
-                        We're not in 'append mode', so we need to remove
-                        the entity that we're going to overwrite.
-                        """
-                        destination_g.remove((entity.res, None, None, None))
-                    """
-                    Here we copy data from the entity into the stored graph.
-                    If the entity was marked as to be deleted, then we're
-                    done because we already removed all of its triples.
-                    """
-                    quads: List[Tuple] = []
-                    graph_identifier: URIRef = entity.g.identifier
-                    for triple in entity.g.triples((entity.res, None, None)):
-                        quads.append((*triple, graph_identifier))
-                    destination_g.addN(quads)
-
-            if store_now:
-                self._store_in_file(destination_g, cur_file_path, context_path)
-
-            return destination_g
-        except Exception as e:
-            self.reperr.add_sentence(f"[1] It was impossible to store the RDF statements in {cur_file_path}. {e}")
-
-    def upload_and_store(self, base_dir: str, triplestore_url: str, base_iri: str, context_path: str = None,
-                         batch_size: int = 10) -> None:
-        stored_graph_path: List[str] = self.store_all(base_dir, base_iri, context_path)
-
-        # If some graphs were not stored properly, then no one will be uploaded to the triplestore
-        # Anyway, we should highlight those ones that could have been added in principle, by
-        # mentioning them with a ".notuploaded" marker
-        if None in stored_graph_path:
-            for file_path in stored_graph_path:
-                if file_path is not None:
-                    # Create a marker for the file not uploaded in the triplestore
-                    open(f'{file_path}.notuploaded', 'wt', encoding='utf-8').close()
-                    self.reperr.add_sentence("[2] "
-                                             f"The statements contained in the JSON-LD file '{file_path}' "
-                                             "were not uploaded into the triplestore.")
-        else:  # All the files have been stored
-            self.upload_all(triplestore_url, base_dir, batch_size)
-
-    def _dir_and_file_paths(self, res: URIRef, base_dir: str, base_iri: str, process_id: int|str = None) -> Tuple[str, str]:
-        is_json: bool = (self.output_format == "json-ld")
-        return find_paths(res, base_dir, base_iri, self.default_dir, self.dir_split, self.n_file_item, is_json=is_json, process_id=process_id)
-
-    @staticmethod
-    def _class_to_entity_type(entity: AbstractEntity) -> Optional[str]:
-        if isinstance(entity, GraphEntity):
-            return "graph"
-        elif isinstance(entity, ProvEntity):
-            return "prov"
-        elif isinstance(entity, MetadataEntity):
-            return "metadata"
-        else:
-            return None
-
-    def upload_all(self, triplestore_url: str, base_dir: str = None, batch_size: int = 10) -> bool:
-        self.repok.new_article()
-        self.reperr.new_article()
-
-        if batch_size <= 0:
-            batch_size = 10
-
-        query_string: str = ""
-        added_statements: int = 0
-        removed_statements: int = 0
-        skipped_queries: int = 0
-        result: bool = True
-
-        for idx, entity in enumerate(self.a_set.res_to_entity.values()):
-            update_query, n_added, n_removed = get_update_query(entity, entity_type=self._class_to_entity_type(entity))
-
-            if update_query == "":
-                skipped_queries += 1
-            else:
-                index = idx - skipped_queries
-                if index == 0:
-                    # First query
-                    query_string = update_query
-                    added_statements = n_added
-                    removed_statements = n_removed
-                elif index % batch_size == 0:
-                    # batch_size-multiple query
-                    result &= self._query(query_string, triplestore_url, base_dir, added_statements, removed_statements)
-                    query_string = update_query
-                    added_statements = n_added
-                    removed_statements = n_removed
-                else:
-                    # Accumulated query
-                    query_string += " ; " + update_query
-                    added_statements += n_added
-                    removed_statements += n_removed
-
-        if query_string != "":
-            result &= self._query(query_string, triplestore_url, base_dir, added_statements, removed_statements)
-
-        return result
-
-    def upload(self, entity: AbstractEntity, triplestore_url: str, base_dir: str = None) -> bool:
-        self.repok.new_article()
-        self.reperr.new_article()
-
-        update_query, n_added, n_removed = get_update_query(entity, entity_type=self._class_to_entity_type(entity))
-
-        return self._query(update_query, triplestore_url, base_dir, n_added, n_removed)
-
-    def execute_query(self, query_string: str, triplestore_url: str) -> bool:
-        self.repok.new_article()
-        self.reperr.new_article()
-
-        return self._query(query_string, triplestore_url)
-
-    def _query(self, query_string: str, triplestore_url: str, base_dir: str = None,
-               added_statements: int = 0, removed_statements: int = 0) -> bool:
-        if query_string != "":
-            try:
-                sparql: SPARQLWrapper = SPARQLWrapper(triplestore_url)
-                sparql.setQuery(query_string)
-                sparql.setMethod('POST')
-
-                sparql.query()
-
-                self.repok.add_sentence(
-                    f"Triplestore updated with {added_statements} added statements and "
-                    f"with {removed_statements} removed statements.")
-
-                return True
-
-            except Exception as e:
-                self.reperr.add_sentence("[3] "
-                                         "Graph was not loaded into the "
-                                         f"triplestore due to communication problems: {e}")
-                if base_dir is not None:
-                    tp_err_dir: str = base_dir + os.sep + "tp_err"
-                    if not os.path.exists(tp_err_dir):
-                        os.makedirs(tp_err_dir)
-                    cur_file_err: str = tp_err_dir + os.sep + \
-                        datetime.now().strftime('%Y-%m-%d-%H-%M-%S-%f_not_uploaded.txt')
-                    with open(cur_file_err, 'wt', encoding='utf-8') as f:
-                        f.write(query_string)
-
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+import json
+import os
+from datetime import datetime
+from typing import TYPE_CHECKING
+from zipfile import ZIP_DEFLATED, ZipFile
+
+from rdflib import ConjunctiveGraph
+from SPARQLWrapper import SPARQLWrapper
+
+from oc_ocdm.graph.graph_entity import GraphEntity
+from oc_ocdm.metadata.metadata_entity import MetadataEntity
+from oc_ocdm.prov.prov_entity import ProvEntity
+from oc_ocdm.reader import Reader
+from oc_ocdm.support.query_utils import get_update_query
+from oc_ocdm.support.reporter import Reporter
+from oc_ocdm.support.support import find_paths
+from filelock import FileLock
+
+if TYPE_CHECKING:
+    from typing import Any, Dict, List, Optional, Set, Tuple
+
+    from rdflib import URIRef
+
+    from oc_ocdm.abstract_entity import AbstractEntity
+    from oc_ocdm.abstract_set import AbstractSet
+
+
+class Storer(object):
+
+    def __init__(self, abstract_set: AbstractSet, repok: Reporter = None, reperr: Reporter = None,
+                 context_map: Dict[str, Any] = None, default_dir: str = "_", dir_split: int = 0,
+                 n_file_item: int = 1, output_format: str = "json-ld", zip_output: bool = False, modified_entities: set = None) -> None:
+        # We only accept format strings that:
+        # 1. are supported by rdflib
+        # 2. correspond to an output format which is effectively either NT or NQ
+        # The only exception to this rule is the 'json-ld' format, which is the default value of 'output_format'.
+        supported_formats: Set[str] = {'application/n-triples', 'ntriples', 'nt', 'nt11',
+                                       'application/n-quads', 'nquads', 'json-ld'}
+        if output_format not in supported_formats:
+            raise ValueError(f"Given output_format '{self.output_format}' is not supported."
+                             f" Available formats: {supported_formats}.")
+        else:
+            self.output_format: str = output_format
+        self.zip_output = zip_output
+        self.dir_split: int = dir_split
+        self.n_file_item: int = n_file_item
+        self.default_dir: str = default_dir if default_dir != "" else "_"
+        self.a_set: AbstractSet = abstract_set
+        self.modified_entities = modified_entities
+
+        if context_map is not None:
+            self.context_map: Dict[str, Any] = context_map
+        else:
+            self.context_map: Dict[str, Any] = {}
+
+        if self.output_format == "json-ld":
+            for context_url in self.context_map:
+                ctx_file_path: Any = self.context_map[context_url]
+                if type(ctx_file_path) == str and os.path.isfile(ctx_file_path):
+                    # This expensive operation is done only when it's really needed
+                    with open(ctx_file_path, 'rt', encoding='utf-8') as ctx_f:
+                        self.context_map[context_url] = json.load(ctx_f)
+
+        if repok is None:
+            self.repok: Reporter = Reporter(prefix="[Storer: INFO] ")
+        else:
+            self.repok: Reporter = repok
+
+        if reperr is None:
+            self.reperr: Reporter = Reporter(prefix="[Storer: ERROR] ")
+        else:
+            self.reperr: Reporter = reperr
+
+    def store_graphs_in_file(self, file_path: str, context_path: str = None) -> None:
+        self.repok.new_article()
+        self.reperr.new_article()
+        self.repok.add_sentence("Store the graphs into a file: starting process")
+
+        cg: ConjunctiveGraph = ConjunctiveGraph()
+        for g in self.a_set.graphs():
+            cg.addN([item + (g.identifier,) for item in list(g)])
+
+        self._store_in_file(cg, file_path, context_path)
+
+    def _store_in_file(self, cur_g: ConjunctiveGraph, cur_file_path: str, context_path: str = None) -> None:
+        # Note: the following lines from here and until 'cur_json_ld' are a sort of hack for including all
+        # the triples of the input graph into the final stored file. Somehow, some of them are not written
+        # in such file otherwise - in particular the provenance ones.
+        new_g: ConjunctiveGraph = ConjunctiveGraph()
+        for s, p, o in cur_g.triples((None, None, None)):
+            g_iri: Optional[URIRef] = None
+            for g_context in cur_g.contexts((s, p, o)):
+                g_iri = g_context.identifier
+                break
+            new_g.addN([(s, p, o, g_iri)])
+
+        zip_file_path = cur_file_path.replace(os.path.splitext(cur_file_path)[1], ".zip")
+        
+        if self.zip_output:
+            with ZipFile(zip_file_path, mode="w", compression=ZIP_DEFLATED, allowZip64=True) as zip_file:
+                self._write_graph(new_g, zip_file, cur_file_path, context_path)
+        else:
+            # Handle non-zipped output directly to a file
+            self._write_graph(new_g, None, cur_file_path, context_path)
+
+        self.repok.add_sentence(f"File '{cur_file_path}' added.")
+
+    def _write_graph(self, graph: ConjunctiveGraph, zip_file: ZipFile, cur_file_path, context_path):
+        if self.output_format == "json-ld":
+            # Serialize the graph in JSON-LD format
+            cur_json_ld = json.loads(graph.serialize(format="json-ld", context=self.context_map.get(context_path)))
+            if context_path is not None and context_path in self.context_map:
+                if isinstance(cur_json_ld, dict):
+                    cur_json_ld["@context"] = context_path
+                else:  # When cur_json_ld is a list
+                    for item in cur_json_ld:
+                        item["@context"] = context_path
+
+            # Determine how to write based on zip file presence
+            if zip_file is not None:
+                dumped_json = json.dumps(cur_json_ld, ensure_ascii=False).encode('utf-8')
+                zip_file.writestr(zinfo_or_arcname=os.path.basename(cur_file_path), data=dumped_json)
+            else:
+                with open(cur_file_path, 'wt', encoding='utf-8') as f:
+                    json.dump(cur_json_ld, f, ensure_ascii=False)
+        else:
+            # Handle other RDF formats
+            if zip_file is not None:
+                rdf_serialization = graph.serialize(destination=None, format=self.output_format, encoding="utf-8")
+                zip_file.writestr(zinfo_or_arcname=os.path.basename(cur_file_path), data=rdf_serialization)
+            else:
+                graph.serialize(destination=cur_file_path, format=self.output_format, encoding="utf-8")
+
+    def store_all(self, base_dir: str, base_iri: str, context_path: str = None, process_id: int|str = None) -> List[str]:
+        self.repok.new_article()
+        self.reperr.new_article()
+
+        self.repok.add_sentence("Starting the process")
+
+        relevant_paths: Dict[str, list] = dict()
+        for entity in self.a_set.res_to_entity.values():
+            is_relevant = True
+            if self.modified_entities is not None and entity.res not in self.modified_entities:
+                is_relevant = False
+            if is_relevant:
+                cur_dir_path, cur_file_path = self._dir_and_file_paths(entity.res, base_dir, base_iri, process_id)
+                if not os.path.exists(cur_dir_path):
+                    os.makedirs(cur_dir_path)
+                relevant_paths.setdefault(cur_file_path, list())
+                relevant_paths[cur_file_path].append(entity)
+
+        for relevant_path, entities_in_path in relevant_paths.items():
+            stored_g = None
+            # Here we try to obtain a reference to the currently stored graph
+            output_filepath = relevant_path.replace(os.path.splitext(relevant_path)[1], ".zip") if self.zip_output else relevant_path
+            lock = FileLock(f"{output_filepath}.lock")
+            with lock:
+                if os.path.exists(output_filepath):
+                    stored_g = Reader(context_map=self.context_map).load(output_filepath)
+                if stored_g is None:
+                    stored_g = ConjunctiveGraph()
+                for entity_in_path in entities_in_path:
+                    self.store(entity_in_path, stored_g, relevant_path, context_path, False)
+                self._store_in_file(stored_g, relevant_path, context_path)
+
+        return list(relevant_paths.keys())
+
+    def store(self, entity: AbstractEntity, destination_g: ConjunctiveGraph, cur_file_path: str, context_path: str = None, store_now: bool = True) -> ConjunctiveGraph:
+        self.repok.new_article()
+        self.reperr.new_article()
+
+        try:
+            if isinstance(entity, ProvEntity):
+                quads: List[Tuple] = []
+                graph_identifier: URIRef = entity.g.identifier
+                for triple in entity.g.triples((entity.res, None, None)):
+                    quads.append((*triple, graph_identifier))
+                destination_g.addN(quads)
+            elif isinstance(entity, GraphEntity) or isinstance(entity, MetadataEntity):
+                if entity.to_be_deleted:
+                    destination_g.remove((entity.res, None, None, None))
+                else:
+                    if len(entity.preexisting_graph) > 0:
+                        """
+                        We're not in 'append mode', so we need to remove
+                        the entity that we're going to overwrite.
+                        """
+                        destination_g.remove((entity.res, None, None, None))
+                    """
+                    Here we copy data from the entity into the stored graph.
+                    If the entity was marked as to be deleted, then we're
+                    done because we already removed all of its triples.
+                    """
+                    quads: List[Tuple] = []
+                    graph_identifier: URIRef = entity.g.identifier
+                    for triple in entity.g.triples((entity.res, None, None)):
+                        quads.append((*triple, graph_identifier))
+                    destination_g.addN(quads)
+
+            if store_now:
+                self._store_in_file(destination_g, cur_file_path, context_path)
+
+            return destination_g
+        except Exception as e:
+            self.reperr.add_sentence(f"[1] It was impossible to store the RDF statements in {cur_file_path}. {e}")
+
+    def upload_and_store(self, base_dir: str, triplestore_url: str, base_iri: str, context_path: str = None,
+                         batch_size: int = 10) -> None:
+        stored_graph_path: List[str] = self.store_all(base_dir, base_iri, context_path)
+
+        # If some graphs were not stored properly, then no one will be uploaded to the triplestore
+        # Anyway, we should highlight those ones that could have been added in principle, by
+        # mentioning them with a ".notuploaded" marker
+        if None in stored_graph_path:
+            for file_path in stored_graph_path:
+                if file_path is not None:
+                    # Create a marker for the file not uploaded in the triplestore
+                    open(f'{file_path}.notuploaded', 'wt', encoding='utf-8').close()
+                    self.reperr.add_sentence("[2] "
+                                             f"The statements contained in the JSON-LD file '{file_path}' "
+                                             "were not uploaded into the triplestore.")
+        else:  # All the files have been stored
+            self.upload_all(triplestore_url, base_dir, batch_size)
+
+    def _dir_and_file_paths(self, res: URIRef, base_dir: str, base_iri: str, process_id: int|str = None) -> Tuple[str, str]:
+        is_json: bool = (self.output_format == "json-ld")
+        return find_paths(res, base_dir, base_iri, self.default_dir, self.dir_split, self.n_file_item, is_json=is_json, process_id=process_id)
+
+    @staticmethod
+    def _class_to_entity_type(entity: AbstractEntity) -> Optional[str]:
+        if isinstance(entity, GraphEntity):
+            return "graph"
+        elif isinstance(entity, ProvEntity):
+            return "prov"
+        elif isinstance(entity, MetadataEntity):
+            return "metadata"
+        else:
+            return None
+
+    def upload_all(self, triplestore_url: str, base_dir: str = None, batch_size: int = 10) -> bool:
+        self.repok.new_article()
+        self.reperr.new_article()
+
+        if batch_size <= 0:
+            batch_size = 10
+
+        query_string: str = ""
+        added_statements: int = 0
+        removed_statements: int = 0
+        skipped_queries: int = 0
+        result: bool = True
+
+        for idx, entity in enumerate(self.a_set.res_to_entity.values()):
+            update_query, n_added, n_removed = get_update_query(entity, entity_type=self._class_to_entity_type(entity))
+
+            if update_query == "":
+                skipped_queries += 1
+            else:
+                index = idx - skipped_queries
+                if index == 0:
+                    # First query
+                    query_string = update_query
+                    added_statements = n_added
+                    removed_statements = n_removed
+                elif index % batch_size == 0:
+                    # batch_size-multiple query
+                    result &= self._query(query_string, triplestore_url, base_dir, added_statements, removed_statements)
+                    query_string = update_query
+                    added_statements = n_added
+                    removed_statements = n_removed
+                else:
+                    # Accumulated query
+                    query_string += " ; " + update_query
+                    added_statements += n_added
+                    removed_statements += n_removed
+
+        if query_string != "":
+            result &= self._query(query_string, triplestore_url, base_dir, added_statements, removed_statements)
+
+        return result
+
+    def upload(self, entity: AbstractEntity, triplestore_url: str, base_dir: str = None) -> bool:
+        self.repok.new_article()
+        self.reperr.new_article()
+
+        update_query, n_added, n_removed = get_update_query(entity, entity_type=self._class_to_entity_type(entity))
+
+        return self._query(update_query, triplestore_url, base_dir, n_added, n_removed)
+
+    def execute_query(self, query_string: str, triplestore_url: str) -> bool:
+        self.repok.new_article()
+        self.reperr.new_article()
+
+        return self._query(query_string, triplestore_url)
+
+    def _query(self, query_string: str, triplestore_url: str, base_dir: str = None,
+               added_statements: int = 0, removed_statements: int = 0) -> bool:
+        if query_string != "":
+            try:
+                sparql: SPARQLWrapper = SPARQLWrapper(triplestore_url)
+                sparql.setQuery(query_string)
+                sparql.setMethod('POST')
+
+                sparql.query()
+
+                self.repok.add_sentence(
+                    f"Triplestore updated with {added_statements} added statements and "
+                    f"with {removed_statements} removed statements.")
+
+                return True
+
+            except Exception as e:
+                self.reperr.add_sentence("[3] "
+                                         "Graph was not loaded into the "
+                                         f"triplestore due to communication problems: {e}")
+                if base_dir is not None:
+                    tp_err_dir: str = base_dir + os.sep + "tp_err"
+                    if not os.path.exists(tp_err_dir):
+                        os.makedirs(tp_err_dir)
+                    cur_file_err: str = tp_err_dir + os.sep + \
+                        datetime.now().strftime('%Y-%m-%d-%H-%M-%S-%f_not_uploaded.txt')
+                    with open(cur_file_err, 'wt', encoding='utf-8') as f:
+                        f.write(query_string)
+
         return False
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/support/__init__.py` & `oc_ocdm-8.1.0/oc_ocdm/support/__init__.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,22 +1,22 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-
-from oc_ocdm.support.support import create_date, get_datatype_from_iso_8601, encode_url, create_literal,\
-                                    create_type, is_string_empty, get_short_name, get_prefix, get_count,\
-                                    get_resource_number, find_local_line_id, find_paths, has_supplier_prefix,\
-                                    is_dataset
-from oc_ocdm.support.reporter import Reporter
-from oc_ocdm.support.query_utils import get_update_query, get_insert_query, get_delete_query
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+
+from oc_ocdm.support.support import create_date, get_datatype_from_iso_8601, encode_url, create_literal,\
+                                    create_type, is_string_empty, get_short_name, get_prefix, get_count,\
+                                    get_resource_number, find_local_line_id, find_paths, has_supplier_prefix,\
+                                    is_dataset
+from oc_ocdm.support.reporter import Reporter
+from oc_ocdm.support.query_utils import get_update_query, get_insert_query, get_delete_query
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/support/query_utils.py` & `oc_ocdm-8.1.0/oc_ocdm/support/query_utils.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,80 +1,80 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-if TYPE_CHECKING:
-    from typing import Tuple
-    from rdflib import URIRef
-    from rdflib.compare import IsomorphicGraph
-    from oc_ocdm.abstract_entity import AbstractEntity
-
-from rdflib import Graph
-from rdflib.compare import graph_diff, to_isomorphic
-
-
-def get_delete_query(graph_iri: URIRef, data: Graph) -> Tuple[str, int]:
-    num_of_statements: int = len(data)
-    if num_of_statements <= 0:
-        return "", 0
-    else:
-        statements: str = data.serialize(format="nt11").replace('\n', '')
-        delete_string: str = f"DELETE DATA {{ GRAPH <{graph_iri}> {{ {statements} }} }}"
-        return delete_string, num_of_statements
-
-
-def get_insert_query(graph_iri: URIRef, data: Graph) -> Tuple[str, int]:
-    num_of_statements: int = len(data)
-    if num_of_statements <= 0:
-        return "", 0
-    else:
-        statements: str = data.serialize(format="nt11").replace('\n', '')
-        insert_string: str = f"INSERT DATA {{ GRAPH <{graph_iri}> {{ {statements} }} }}"
-        return insert_string, num_of_statements
-
-
-def get_update_query(entity: AbstractEntity, entity_type: str = "graph") -> Tuple[str, int, int]:
-    if entity_type in ["graph", "metadata"]:
-        to_be_deleted: bool = entity.to_be_deleted
-        preexisting_graph: Graph = entity.preexisting_graph
-    elif entity_type == "prov":
-        to_be_deleted: bool = False
-        preexisting_graph: Graph = Graph(identifier=entity.g.identifier)
-
-    if to_be_deleted:
-        delete_string, removed_triples = get_delete_query(entity.g.identifier, preexisting_graph)
-        if delete_string != "":
-            return delete_string, 0, removed_triples
-        else:
-            return "", 0, 0
-    else:
-        preexisting_iso: IsomorphicGraph = to_isomorphic(preexisting_graph)
-        current_iso: IsomorphicGraph = to_isomorphic(entity.g)
-        if preexisting_iso == current_iso:
-            # Both graphs have exactly the same content!
-            return "", 0, 0
-        in_both, in_first, in_second = graph_diff(preexisting_iso, current_iso)
-        delete_string, removed_triples = get_delete_query(entity.g.identifier, in_first)
-        insert_string, added_triples = get_insert_query(entity.g.identifier, in_second)
-        if delete_string != "" and insert_string != "":
-            return delete_string + '; ' + insert_string, added_triples, removed_triples
-        elif delete_string != "":
-            return delete_string, 0, removed_triples
-        elif insert_string != "":
-            return insert_string, added_triples, 0
-        else:
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from typing import Tuple
+    from rdflib import URIRef
+    from rdflib.compare import IsomorphicGraph
+    from oc_ocdm.abstract_entity import AbstractEntity
+
+from rdflib import Graph
+from rdflib.compare import graph_diff, to_isomorphic
+
+
+def get_delete_query(graph_iri: URIRef, data: Graph) -> Tuple[str, int]:
+    num_of_statements: int = len(data)
+    if num_of_statements <= 0:
+        return "", 0
+    else:
+        statements: str = data.serialize(format="nt11").replace('\n', '')
+        delete_string: str = f"DELETE DATA {{ GRAPH <{graph_iri}> {{ {statements} }} }}"
+        return delete_string, num_of_statements
+
+
+def get_insert_query(graph_iri: URIRef, data: Graph) -> Tuple[str, int]:
+    num_of_statements: int = len(data)
+    if num_of_statements <= 0:
+        return "", 0
+    else:
+        statements: str = data.serialize(format="nt11").replace('\n', '')
+        insert_string: str = f"INSERT DATA {{ GRAPH <{graph_iri}> {{ {statements} }} }}"
+        return insert_string, num_of_statements
+
+
+def get_update_query(entity: AbstractEntity, entity_type: str = "graph") -> Tuple[str, int, int]:
+    if entity_type in ["graph", "metadata"]:
+        to_be_deleted: bool = entity.to_be_deleted
+        preexisting_graph: Graph = entity.preexisting_graph
+    elif entity_type == "prov":
+        to_be_deleted: bool = False
+        preexisting_graph: Graph = Graph(identifier=entity.g.identifier)
+
+    if to_be_deleted:
+        delete_string, removed_triples = get_delete_query(entity.g.identifier, preexisting_graph)
+        if delete_string != "":
+            return delete_string, 0, removed_triples
+        else:
+            return "", 0, 0
+    else:
+        preexisting_iso: IsomorphicGraph = to_isomorphic(preexisting_graph)
+        current_iso: IsomorphicGraph = to_isomorphic(entity.g)
+        if preexisting_iso == current_iso:
+            # Both graphs have exactly the same content!
+            return "", 0, 0
+        in_both, in_first, in_second = graph_diff(preexisting_iso, current_iso)
+        delete_string, removed_triples = get_delete_query(entity.g.identifier, in_first)
+        insert_string, added_triples = get_insert_query(entity.g.identifier, in_second)
+        if delete_string != "" and insert_string != "":
+            return delete_string + '; ' + insert_string, added_triples, removed_triples
+        elif delete_string != "":
+            return delete_string, 0, removed_triples
+        elif insert_string != "":
+            return insert_string, added_triples, 0
+        else:
             return "", 0, 0
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/support/reporter.py` & `oc_ocdm-8.1.0/oc_ocdm/support/reporter.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,65 +1,65 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-from __future__ import annotations
-
-from typing import TYPE_CHECKING
-
-if TYPE_CHECKING:
-    from typing import List, Optional
-
-
-class Reporter(object):
-    """This class is used as a metaphoric agent being a reporter"""
-
-    def __init__(self, print_sentences: bool = True, prefix: str = "") -> None:
-        self.articles: List[List[str]] = []
-        self.last_article: Optional[List[str]] = None
-        self.last_sentence: Optional[str] = None
-        self.print_sentences: bool = print_sentences
-        self.prefix: str = prefix
-
-    def new_article(self) -> None:
-        if self.last_article is None or len(self.last_article) > 0:
-            self.last_article = []
-            self.last_sentence = None
-            self.articles.append(self.last_article)
-            if self.print_sentences and len(self.last_article) > 0:
-                print("\n")
-
-    def add_sentence(self, sentence: str, print_this_sentence: bool = True) -> None:
-        cur_sentence: str = self.prefix + sentence
-        self.last_sentence = cur_sentence
-        self.last_article.append(cur_sentence)
-        if self.print_sentences and print_this_sentence:
-            print(cur_sentence)
-
-    def get_last_sentence(self) -> Optional[str]:
-        return self.last_sentence
-
-    def get_articles_as_string(self) -> str:
-        result: str = ""
-        for article in self.articles:
-            for sentence in article:
-                result += sentence + "\n"
-            result += "\n"
-        return result
-
-    def write_file(self, file_path) -> None:
-        with open(file_path, 'wt', encoding='utf-8') as f:
-            f.write(self.get_articles_as_string())
-
-    def is_empty(self) -> bool:
-        return self.last_sentence is None
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from typing import List, Optional
+
+
+class Reporter(object):
+    """This class is used as a metaphoric agent being a reporter"""
+
+    def __init__(self, print_sentences: bool = True, prefix: str = "") -> None:
+        self.articles: List[List[str]] = []
+        self.last_article: Optional[List[str]] = None
+        self.last_sentence: Optional[str] = None
+        self.print_sentences: bool = print_sentences
+        self.prefix: str = prefix
+
+    def new_article(self) -> None:
+        if self.last_article is None or len(self.last_article) > 0:
+            self.last_article = []
+            self.last_sentence = None
+            self.articles.append(self.last_article)
+            if self.print_sentences and len(self.last_article) > 0:
+                print("\n")
+
+    def add_sentence(self, sentence: str, print_this_sentence: bool = True) -> None:
+        cur_sentence: str = self.prefix + sentence
+        self.last_sentence = cur_sentence
+        self.last_article.append(cur_sentence)
+        if self.print_sentences and print_this_sentence:
+            print(cur_sentence)
+
+    def get_last_sentence(self) -> Optional[str]:
+        return self.last_sentence
+
+    def get_articles_as_string(self) -> str:
+        result: str = ""
+        for article in self.articles:
+            for sentence in article:
+                result += sentence + "\n"
+            result += "\n"
+        return result
+
+    def write_file(self, file_path) -> None:
+        with open(file_path, 'wt', encoding='utf-8') as f:
+            f.write(self.get_articles_as_string())
+
+    def is_empty(self) -> bool:
+        return self.last_sentence is None
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/__init__.py` & `oc_ocdm-8.1.0/oc_ocdm/test/metadata/__init__.py`

 * *Files identical despite different names*

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/counter_handler/__init__.py` & `oc_ocdm-8.1.0/oc_ocdm/test/metadata/entities/__init__.py`

 * *Files identical despite different names*

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/counter_handler/test_filesystem_counter_handler.py` & `oc_ocdm-8.1.0/oc_ocdm/test/counter_handler/test_filesystem_counter_handler.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,179 +1,179 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-import os
-import unittest
-
-from oc_ocdm.counter_handler.filesystem_counter_handler import FilesystemCounterHandler
-
-
-class TestFilesystemCounterHandler(unittest.TestCase):
-    @classmethod
-    def setUpClass(cls) -> None:
-        cls.info_dir = './info_dir/'
-        cls.counter_handler = FilesystemCounterHandler(cls.info_dir)
-
-        cls.file_path = cls.info_dir + 'test_file.txt'
-        if not os.path.exists(os.path.dirname(cls.file_path)):
-            os.makedirs(os.path.dirname(cls.file_path))
-
-        if not os.path.isfile(cls.file_path):
-            with open(cls.file_path, 'wb') as file:
-                first_line = cls.counter_handler._trailing_char * (cls.counter_handler._initial_line_len - 1) + '\n'
-                file.write(first_line.encode('ascii'))
-
-    def setUp(self):
-        # Reset test file content:
-        with open(self.file_path, 'wb') as file:
-            first_line = self.counter_handler._trailing_char * (self.counter_handler._initial_line_len - 1) + '\n'
-            file.write(first_line.encode('ascii'))
-
-    def test_get_line_len(self):
-        with open(self.file_path, 'rb') as test_file:
-            line_len = self.counter_handler._get_line_len(test_file)
-            self.assertIsNotNone(line_len)
-            self.assertEqual(line_len, self.counter_handler._initial_line_len)
-            self.assertEqual(test_file.tell(), 0)
-
-    def test_increase_line_len(self):
-        increment = 1
-        result = self.counter_handler._increase_line_len(self.file_path,
-                                                         self.counter_handler._initial_line_len + increment)
-        self.assertIsNone(result)
-        with open(self.file_path, 'rt', encoding='ascii') as test_file:
-            for line in test_file:
-                self.assertEqual(len(line), self.counter_handler._initial_line_len + increment)
-
-        self.assertRaises(ValueError, self.counter_handler._increase_line_len, self.file_path, -1)
-        self.assertRaises(ValueError, self.counter_handler._increase_line_len, self.file_path,
-                          self.counter_handler._initial_line_len - 1)
-
-    def test_is_a_valid_line(self):
-        with self.subTest("line is 'abc \\n'"):
-            line = 'abc \n'.encode('ascii')
-            result = self.counter_handler._is_a_valid_line(line)
-            self.assertIsNotNone(result)
-            self.assertTrue(result)
-        with self.subTest("line is 'a\\0c \\n'"):
-            line = 'a\0c \n'.encode('ascii')
-            result = self.counter_handler._is_a_valid_line(line)
-            self.assertIsNotNone(result)
-            self.assertFalse(result)
-        with self.subTest("line is 'abc'"):
-            line = 'abc'.encode('ascii')
-            result = self.counter_handler._is_a_valid_line(line)
-            self.assertIsNotNone(result)
-            self.assertFalse(result)
-        with self.subTest("line is 'a\\0c'"):
-            line = 'a\\0c'.encode('ascii')
-            result = self.counter_handler._is_a_valid_line(line)
-            self.assertIsNotNone(result)
-            self.assertFalse(result)
-
-    def test_fix_previous_lines(self):
-        with open(self.file_path, 'wb') as test_file:
-            num_lines = 10
-            for i in range(0, num_lines):
-                line = '\0' * self.counter_handler._initial_line_len
-                test_file.write(line.encode('ascii'))
-            last_line = '1'.ljust(self.counter_handler._initial_line_len - 1, self.counter_handler._trailing_char) + '\n'
-            test_file.write(last_line.encode('ascii'))
-
-        with open(self.file_path, 'r+b') as test_file:
-            test_file.seek(self.counter_handler._initial_line_len * num_lines)
-            result = self.counter_handler._fix_previous_lines(test_file, self.counter_handler._initial_line_len)
-            self.assertIsNone(result)
-
-        with open(self.file_path, 'rt', encoding='ascii') as test_file:
-            count = 0
-            for line in test_file:
-                count += 1
-                if count >= num_lines:
-                    break
-                self.assertTrue(self.counter_handler._is_a_valid_line(line.encode('ascii')))
-
-    def test_set_number(self):
-        number = 18
-        with open(self.file_path, 'r+b') as test_file:
-            num_of_line = 35
-            test_file.seek(self.counter_handler._initial_line_len * (num_of_line - 1))
-            line = str(number).ljust(self.counter_handler._initial_line_len - 1, self.counter_handler._trailing_char) + '\n'
-            test_file.write(line.encode('ascii'))
-
-        new_number = 205
-        result = self.counter_handler._set_number(new_number, self.file_path, num_of_line)
-        self.assertIsNone(result)
-        with open(self.file_path, 'rt', encoding='ascii') as test_file:
-            count = 0
-            for line in test_file:
-                count += 1
-                if count >= num_of_line:
-                    self.assertEqual(int(line), new_number)
-                    break
-                self.assertTrue(self.counter_handler._is_a_valid_line(line.encode('ascii')))
-
-        self.assertRaises(ValueError, self.counter_handler._set_number, -1, self.file_path, 1)
-        self.assertRaises(ValueError, self.counter_handler._set_number, 1, self.file_path, -1)
-
-    def test_read_number(self):
-        number = 18
-        with open(self.file_path, 'r+b') as test_file:
-            num_of_line = 35
-            test_file.seek(self.counter_handler._initial_line_len * (num_of_line - 1))
-            line = str(number).ljust(self.counter_handler._initial_line_len - 1, self.counter_handler._trailing_char) + '\n'
-            test_file.write(line.encode('ascii'))
-
-        read_number, line_len = self.counter_handler._read_number(self.file_path, num_of_line)
-        self.assertIsNotNone(read_number)
-        self.assertIsNotNone(line_len)
-        self.assertEqual(read_number, number)
-        self.assertEqual(line_len, self.counter_handler._initial_line_len)
-
-        self.assertRaises(ValueError, self.counter_handler._read_number, self.file_path, -1)
-
-    def test_add_number(self):
-        number = 18
-        with open(self.file_path, 'r+b') as test_file:
-            num_of_line = 35
-            test_file.seek(self.counter_handler._initial_line_len * (num_of_line - 1))
-            line = str(number).ljust(self.counter_handler._initial_line_len - 1, self.counter_handler._trailing_char) + '\n'
-            test_file.write(line.encode('ascii'))
-
-        read_number = self.counter_handler._add_number(self.file_path, num_of_line)
-        self.assertIsNotNone(read_number)
-        self.assertEqual(read_number, number + 1)
-        with open(self.file_path, 'rt', encoding='ascii') as test_file:
-            count = 0
-            for line in test_file:
-                count += 1
-                if count >= num_of_line:
-                    break
-                self.assertTrue(self.counter_handler._is_a_valid_line(line.encode('ascii')))
-
-        self.assertRaises(ValueError, self.counter_handler._add_number, self.file_path, -1)
-
-    def test_read_metadata_counter(self):
-        dataset_name: str = "http://dataset/"
-        self.assertRaises(ValueError, self.counter_handler.read_metadata_counter, "xyz", dataset_name)
-        self.assertRaises(ValueError, self.counter_handler.read_metadata_counter, "di", None)
-
-    def test_increment_metadata_counter(self):
-        dataset_name: str = "http://dataset/"
-        self.assertRaises(ValueError, self.counter_handler.increment_metadata_counter, "xyz", dataset_name)
-        self.assertRaises(ValueError, self.counter_handler.increment_metadata_counter, "di", None)
-
-
-if __name__ == '__main__':
-    unittest.main()
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+import os
+import unittest
+
+from oc_ocdm.counter_handler.filesystem_counter_handler import FilesystemCounterHandler
+
+
+class TestFilesystemCounterHandler(unittest.TestCase):
+    @classmethod
+    def setUpClass(cls) -> None:
+        cls.info_dir = './info_dir/'
+        cls.counter_handler = FilesystemCounterHandler(cls.info_dir)
+
+        cls.file_path = cls.info_dir + 'test_file.txt'
+        if not os.path.exists(os.path.dirname(cls.file_path)):
+            os.makedirs(os.path.dirname(cls.file_path))
+
+        if not os.path.isfile(cls.file_path):
+            with open(cls.file_path, 'wb') as file:
+                first_line = cls.counter_handler._trailing_char * (cls.counter_handler._initial_line_len - 1) + '\n'
+                file.write(first_line.encode('ascii'))
+
+    def setUp(self):
+        # Reset test file content:
+        with open(self.file_path, 'wb') as file:
+            first_line = self.counter_handler._trailing_char * (self.counter_handler._initial_line_len - 1) + '\n'
+            file.write(first_line.encode('ascii'))
+
+    def test_get_line_len(self):
+        with open(self.file_path, 'rb') as test_file:
+            line_len = self.counter_handler._get_line_len(test_file)
+            self.assertIsNotNone(line_len)
+            self.assertEqual(line_len, self.counter_handler._initial_line_len)
+            self.assertEqual(test_file.tell(), 0)
+
+    def test_increase_line_len(self):
+        increment = 1
+        result = self.counter_handler._increase_line_len(self.file_path,
+                                                         self.counter_handler._initial_line_len + increment)
+        self.assertIsNone(result)
+        with open(self.file_path, 'rt', encoding='ascii') as test_file:
+            for line in test_file:
+                self.assertEqual(len(line), self.counter_handler._initial_line_len + increment)
+
+        self.assertRaises(ValueError, self.counter_handler._increase_line_len, self.file_path, -1)
+        self.assertRaises(ValueError, self.counter_handler._increase_line_len, self.file_path,
+                          self.counter_handler._initial_line_len - 1)
+
+    def test_is_a_valid_line(self):
+        with self.subTest("line is 'abc \\n'"):
+            line = 'abc \n'.encode('ascii')
+            result = self.counter_handler._is_a_valid_line(line)
+            self.assertIsNotNone(result)
+            self.assertTrue(result)
+        with self.subTest("line is 'a\\0c \\n'"):
+            line = 'a\0c \n'.encode('ascii')
+            result = self.counter_handler._is_a_valid_line(line)
+            self.assertIsNotNone(result)
+            self.assertFalse(result)
+        with self.subTest("line is 'abc'"):
+            line = 'abc'.encode('ascii')
+            result = self.counter_handler._is_a_valid_line(line)
+            self.assertIsNotNone(result)
+            self.assertFalse(result)
+        with self.subTest("line is 'a\\0c'"):
+            line = 'a\\0c'.encode('ascii')
+            result = self.counter_handler._is_a_valid_line(line)
+            self.assertIsNotNone(result)
+            self.assertFalse(result)
+
+    def test_fix_previous_lines(self):
+        with open(self.file_path, 'wb') as test_file:
+            num_lines = 10
+            for i in range(0, num_lines):
+                line = '\0' * self.counter_handler._initial_line_len
+                test_file.write(line.encode('ascii'))
+            last_line = '1'.ljust(self.counter_handler._initial_line_len - 1, self.counter_handler._trailing_char) + '\n'
+            test_file.write(last_line.encode('ascii'))
+
+        with open(self.file_path, 'r+b') as test_file:
+            test_file.seek(self.counter_handler._initial_line_len * num_lines)
+            result = self.counter_handler._fix_previous_lines(test_file, self.counter_handler._initial_line_len)
+            self.assertIsNone(result)
+
+        with open(self.file_path, 'rt', encoding='ascii') as test_file:
+            count = 0
+            for line in test_file:
+                count += 1
+                if count >= num_lines:
+                    break
+                self.assertTrue(self.counter_handler._is_a_valid_line(line.encode('ascii')))
+
+    def test_set_number(self):
+        number = 18
+        with open(self.file_path, 'r+b') as test_file:
+            num_of_line = 35
+            test_file.seek(self.counter_handler._initial_line_len * (num_of_line - 1))
+            line = str(number).ljust(self.counter_handler._initial_line_len - 1, self.counter_handler._trailing_char) + '\n'
+            test_file.write(line.encode('ascii'))
+
+        new_number = 205
+        result = self.counter_handler._set_number(new_number, self.file_path, num_of_line)
+        self.assertIsNone(result)
+        with open(self.file_path, 'rt', encoding='ascii') as test_file:
+            count = 0
+            for line in test_file:
+                count += 1
+                if count >= num_of_line:
+                    self.assertEqual(int(line), new_number)
+                    break
+                self.assertTrue(self.counter_handler._is_a_valid_line(line.encode('ascii')))
+
+        self.assertRaises(ValueError, self.counter_handler._set_number, -1, self.file_path, 1)
+        self.assertRaises(ValueError, self.counter_handler._set_number, 1, self.file_path, -1)
+
+    def test_read_number(self):
+        number = 18
+        with open(self.file_path, 'r+b') as test_file:
+            num_of_line = 35
+            test_file.seek(self.counter_handler._initial_line_len * (num_of_line - 1))
+            line = str(number).ljust(self.counter_handler._initial_line_len - 1, self.counter_handler._trailing_char) + '\n'
+            test_file.write(line.encode('ascii'))
+
+        read_number, line_len = self.counter_handler._read_number(self.file_path, num_of_line)
+        self.assertIsNotNone(read_number)
+        self.assertIsNotNone(line_len)
+        self.assertEqual(read_number, number)
+        self.assertEqual(line_len, self.counter_handler._initial_line_len)
+
+        self.assertRaises(ValueError, self.counter_handler._read_number, self.file_path, -1)
+
+    def test_add_number(self):
+        number = 18
+        with open(self.file_path, 'r+b') as test_file:
+            num_of_line = 35
+            test_file.seek(self.counter_handler._initial_line_len * (num_of_line - 1))
+            line = str(number).ljust(self.counter_handler._initial_line_len - 1, self.counter_handler._trailing_char) + '\n'
+            test_file.write(line.encode('ascii'))
+
+        read_number = self.counter_handler._add_number(self.file_path, num_of_line)
+        self.assertIsNotNone(read_number)
+        self.assertEqual(read_number, number + 1)
+        with open(self.file_path, 'rt', encoding='ascii') as test_file:
+            count = 0
+            for line in test_file:
+                count += 1
+                if count >= num_of_line:
+                    break
+                self.assertTrue(self.counter_handler._is_a_valid_line(line.encode('ascii')))
+
+        self.assertRaises(ValueError, self.counter_handler._add_number, self.file_path, -1)
+
+    def test_read_metadata_counter(self):
+        dataset_name: str = "http://dataset/"
+        self.assertRaises(ValueError, self.counter_handler.read_metadata_counter, "xyz", dataset_name)
+        self.assertRaises(ValueError, self.counter_handler.read_metadata_counter, "di", None)
+
+    def test_increment_metadata_counter(self):
+        dataset_name: str = "http://dataset/"
+        self.assertRaises(ValueError, self.counter_handler.increment_metadata_counter, "xyz", dataset_name)
+        self.assertRaises(ValueError, self.counter_handler.increment_metadata_counter, "di", None)
+
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/counter_handler/test_in_memory_counter_handler.py` & `oc_ocdm-8.1.0/oc_ocdm/test/counter_handler/test_in_memory_counter_handler.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,222 +1,222 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-import unittest
-
-from oc_ocdm.counter_handler.in_memory_counter_handler import InMemoryCounterHandler
-
-
-class TestFilesystemCounterHandler(unittest.TestCase):
-
-    def setUp(self) -> None:
-        self.counter_handler = InMemoryCounterHandler()
-
-    def test_set_counter(self):
-        with self.subTest("Set BR counter"):
-            count = 99
-            self.counter_handler.entity_counters["br"] = count
-
-            new_count = 205
-            result = self.counter_handler.set_counter(new_count, "br")
-            self.assertIsNone(result)
-            self.assertEqual(self.counter_handler.entity_counters["br"], new_count)
-        with self.subTest("Set BR counter, long number"):
-            long_count = 2**256
-            self.counter_handler.entity_counters["br"] = long_count
-
-            new_count = 2**512
-            result = self.counter_handler.set_counter(new_count, "br")
-            self.assertIsNone(result)
-            self.assertEqual(self.counter_handler.entity_counters["br"], new_count)
-        with self.subTest("Set SE counter"):
-            count = 99
-            identifier = 1234
-            counter_list = [0]*identifier
-            counter_list[-1] = count
-            self.counter_handler.prov_counters["br"]["se"] = counter_list
-
-            new_count = 205
-            result = self.counter_handler.set_counter(new_count, "br", "se", identifier)
-            self.assertIsNone(result)
-            self.assertEqual(self.counter_handler.prov_counters["br"]["se"][identifier - 1], new_count)
-        with self.subTest("Set SE counter, long number"):
-            long_count = 2**256
-            identifier = 1234
-            counter_list = [0]*identifier
-            counter_list[-1] = long_count
-            self.counter_handler.prov_counters["br"]["se"] = counter_list
-
-            new_count = 2**512
-            result = self.counter_handler.set_counter(new_count, "br", "se", identifier)
-            self.assertIsNone(result)
-            self.assertEqual(self.counter_handler.prov_counters["br"]["se"][identifier - 1], new_count)
-        with self.subTest("Wrong inputs"):
-            self.assertRaises(ValueError, self.counter_handler.set_counter, -1, "xyz")
-            self.assertRaises(ValueError, self.counter_handler.set_counter, 1, "xyz")
-            self.assertRaises(ValueError, self.counter_handler.set_counter, 1, "br", "xyz")
-            self.assertRaises(ValueError, self.counter_handler.set_counter, 1, "br", "se", -1)
-
-    def test_read_counter(self):
-        with self.subTest("Read BR counter"):
-            count = 99
-            self.counter_handler.entity_counters["br"] = count
-
-            result = self.counter_handler.read_counter("br")
-            self.assertIsNotNone(result)
-            self.assertEqual(result, count)
-        with self.subTest("Read BR counter, long number"):
-            long_count = 2**256
-            self.counter_handler.entity_counters["br"] = long_count
-
-            result = self.counter_handler.read_counter("br")
-            self.assertIsNotNone(result)
-            self.assertEqual(result, long_count)
-        with self.subTest("Read SE counter"):
-            count = 99
-            identifier = 1234
-            counter_list = [0]*identifier
-            counter_list[-1] = count
-            self.counter_handler.prov_counters["br"]["se"] = counter_list
-
-            result = self.counter_handler.read_counter("br", "se", identifier)
-            self.assertIsNotNone(result)
-            self.assertEqual(result, count)
-        with self.subTest("Read SE counter, long number"):
-            long_count = 2**256
-            identifier = 1234
-            counter_list = [0]*identifier
-            counter_list[-1] = long_count
-            self.counter_handler.prov_counters["br"]["se"] = counter_list
-
-            result = self.counter_handler.read_counter("br", "se", identifier)
-            self.assertIsNotNone(result)
-            self.assertEqual(result, long_count)
-        with self.subTest("Wrong inputs"):
-            self.assertRaises(ValueError, self.counter_handler.read_counter, "xyz")
-            self.assertRaises(ValueError, self.counter_handler.read_counter, "br", "xyz")
-            self.assertRaises(ValueError, self.counter_handler.read_counter, "br", "se", -1)
-
-    def test_increment_counter(self):
-        with self.subTest("Increment BR counter"):
-            count = 99
-            self.counter_handler.entity_counters["br"] = count
-
-            result = self.counter_handler.increment_counter("br")
-            self.assertIsNotNone(result)
-            self.assertEqual(result, count + 1)
-            self.assertEqual(self.counter_handler.entity_counters["br"], count + 1)
-        with self.subTest("Increment BR counter, long number"):
-            long_count = 2**256
-            self.counter_handler.entity_counters["br"] = long_count
-
-            result = self.counter_handler.increment_counter("br")
-            self.assertIsNotNone(result)
-            self.assertEqual(result, long_count + 1)
-            self.assertEqual(self.counter_handler.entity_counters["br"], long_count + 1)
-        with self.subTest("Increment SE counter"):
-            count = 99
-            identifier = 1234
-            counter_list = [0]*identifier
-            counter_list[-1] = count
-            self.counter_handler.prov_counters["br"]["se"] = counter_list
-
-            result = self.counter_handler.increment_counter("br", "se", identifier)
-            self.assertIsNotNone(result)
-            self.assertEqual(result, count + 1)
-            self.assertEqual(self.counter_handler.prov_counters["br"]["se"][identifier - 1], count + 1)
-        with self.subTest("Increment SE counter, long number"):
-            long_count = 2**256
-            identifier = 1234
-            counter_list = [0]*identifier
-            counter_list[-1] = long_count
-            self.counter_handler.prov_counters["br"]["se"] = counter_list
-
-            result = self.counter_handler.increment_counter("br", "se", identifier)
-            self.assertIsNotNone(result)
-            self.assertEqual(result, long_count + 1)
-            self.assertEqual(self.counter_handler.prov_counters["br"]["se"][identifier - 1], long_count + 1)
-        with self.subTest("Wrong inputs"):
-            self.assertRaises(ValueError, self.counter_handler.increment_counter, "xyz")
-            self.assertRaises(ValueError, self.counter_handler.increment_counter, "br", "xyz")
-            self.assertRaises(ValueError, self.counter_handler.increment_counter, "br", "se", -1)
-
-    def test_set_metadata_counter(self):
-        dataset_name: str = "http://dataset/"
-        with self.subTest("Set DI counter"):
-            count = 99
-            self.counter_handler.metadata_counters[dataset_name] = {"di": count}
-
-            new_count = 205
-            result = self.counter_handler.set_metadata_counter(new_count, "di", dataset_name)
-            self.assertIsNone(result)
-            self.assertEqual(self.counter_handler.metadata_counters[dataset_name]["di"], new_count)
-        with self.subTest("Set DI counter, long number"):
-            long_count = 2 ** 256
-            self.counter_handler.metadata_counters[dataset_name] = {"di": long_count}
-
-            new_count = 2**512
-            result = self.counter_handler.set_metadata_counter(new_count, "di", dataset_name)
-            self.assertIsNone(result)
-            self.assertEqual(self.counter_handler.metadata_counters[dataset_name]["di"], new_count)
-        with self.subTest("Wrong inputs"):
-            self.assertRaises(ValueError, self.counter_handler.set_metadata_counter, -1, "xyz", dataset_name)
-            self.assertRaises(ValueError, self.counter_handler.set_metadata_counter, 1, "xyz", dataset_name)
-            self.assertRaises(ValueError, self.counter_handler.set_metadata_counter, 1, "di", None)
-
-    def test_read_metadata_counter(self):
-        dataset_name: str = "http://dataset/"
-        with self.subTest("Read DI counter"):
-            count = 99
-            self.counter_handler.metadata_counters[dataset_name] = {"di": count}
-
-            result = self.counter_handler.read_metadata_counter("di", dataset_name)
-            self.assertIsNotNone(result)
-            self.assertEqual(result, count)
-        with self.subTest("Read DI counter, long number"):
-            long_count = 2**256
-            self.counter_handler.metadata_counters[dataset_name] = {"di": long_count}
-
-            result = self.counter_handler.read_metadata_counter("di", dataset_name)
-            self.assertIsNotNone(result)
-            self.assertEqual(result, long_count)
-        with self.subTest("Wrong inputs"):
-            self.assertRaises(ValueError, self.counter_handler.read_metadata_counter, "xyz", dataset_name)
-            self.assertRaises(ValueError, self.counter_handler.read_metadata_counter, "di", None)
-
-    def test_increment_metadata_counter(self):
-        dataset_name: str = "http://dataset/"
-        with self.subTest("Increment DI counter"):
-            count = 99
-            self.counter_handler.metadata_counters[dataset_name] = {"di": count}
-
-            result = self.counter_handler.increment_metadata_counter("di", dataset_name)
-            self.assertIsNotNone(result)
-            self.assertEqual(result, count + 1)
-            self.assertEqual(self.counter_handler.metadata_counters[dataset_name]["di"], count + 1)
-        with self.subTest("Increment DI counter, long number"):
-            long_count = 2**256
-            self.counter_handler.metadata_counters[dataset_name] = {"di": long_count}
-
-            result = self.counter_handler.increment_metadata_counter("di", dataset_name)
-            self.assertIsNotNone(result)
-            self.assertEqual(result, long_count + 1)
-            self.assertEqual(self.counter_handler.metadata_counters[dataset_name]["di"], long_count + 1)
-        with self.subTest("Wrong inputs"):
-            self.assertRaises(ValueError, self.counter_handler.increment_metadata_counter, "xyz", dataset_name)
-            self.assertRaises(ValueError, self.counter_handler.increment_metadata_counter, "di", None)
-
-
-if __name__ == '__main__':
-    unittest.main()
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+import unittest
+
+from oc_ocdm.counter_handler.in_memory_counter_handler import InMemoryCounterHandler
+
+
+class TestFilesystemCounterHandler(unittest.TestCase):
+
+    def setUp(self) -> None:
+        self.counter_handler = InMemoryCounterHandler()
+
+    def test_set_counter(self):
+        with self.subTest("Set BR counter"):
+            count = 99
+            self.counter_handler.entity_counters["br"] = count
+
+            new_count = 205
+            result = self.counter_handler.set_counter(new_count, "br")
+            self.assertIsNone(result)
+            self.assertEqual(self.counter_handler.entity_counters["br"], new_count)
+        with self.subTest("Set BR counter, long number"):
+            long_count = 2**256
+            self.counter_handler.entity_counters["br"] = long_count
+
+            new_count = 2**512
+            result = self.counter_handler.set_counter(new_count, "br")
+            self.assertIsNone(result)
+            self.assertEqual(self.counter_handler.entity_counters["br"], new_count)
+        with self.subTest("Set SE counter"):
+            count = 99
+            identifier = 1234
+            counter_list = [0]*identifier
+            counter_list[-1] = count
+            self.counter_handler.prov_counters["br"]["se"] = counter_list
+
+            new_count = 205
+            result = self.counter_handler.set_counter(new_count, "br", "se", identifier)
+            self.assertIsNone(result)
+            self.assertEqual(self.counter_handler.prov_counters["br"]["se"][identifier - 1], new_count)
+        with self.subTest("Set SE counter, long number"):
+            long_count = 2**256
+            identifier = 1234
+            counter_list = [0]*identifier
+            counter_list[-1] = long_count
+            self.counter_handler.prov_counters["br"]["se"] = counter_list
+
+            new_count = 2**512
+            result = self.counter_handler.set_counter(new_count, "br", "se", identifier)
+            self.assertIsNone(result)
+            self.assertEqual(self.counter_handler.prov_counters["br"]["se"][identifier - 1], new_count)
+        with self.subTest("Wrong inputs"):
+            self.assertRaises(ValueError, self.counter_handler.set_counter, -1, "xyz")
+            self.assertRaises(ValueError, self.counter_handler.set_counter, 1, "xyz")
+            self.assertRaises(ValueError, self.counter_handler.set_counter, 1, "br", "xyz")
+            self.assertRaises(ValueError, self.counter_handler.set_counter, 1, "br", "se", -1)
+
+    def test_read_counter(self):
+        with self.subTest("Read BR counter"):
+            count = 99
+            self.counter_handler.entity_counters["br"] = count
+
+            result = self.counter_handler.read_counter("br")
+            self.assertIsNotNone(result)
+            self.assertEqual(result, count)
+        with self.subTest("Read BR counter, long number"):
+            long_count = 2**256
+            self.counter_handler.entity_counters["br"] = long_count
+
+            result = self.counter_handler.read_counter("br")
+            self.assertIsNotNone(result)
+            self.assertEqual(result, long_count)
+        with self.subTest("Read SE counter"):
+            count = 99
+            identifier = 1234
+            counter_list = [0]*identifier
+            counter_list[-1] = count
+            self.counter_handler.prov_counters["br"]["se"] = counter_list
+
+            result = self.counter_handler.read_counter("br", "se", identifier)
+            self.assertIsNotNone(result)
+            self.assertEqual(result, count)
+        with self.subTest("Read SE counter, long number"):
+            long_count = 2**256
+            identifier = 1234
+            counter_list = [0]*identifier
+            counter_list[-1] = long_count
+            self.counter_handler.prov_counters["br"]["se"] = counter_list
+
+            result = self.counter_handler.read_counter("br", "se", identifier)
+            self.assertIsNotNone(result)
+            self.assertEqual(result, long_count)
+        with self.subTest("Wrong inputs"):
+            self.assertRaises(ValueError, self.counter_handler.read_counter, "xyz")
+            self.assertRaises(ValueError, self.counter_handler.read_counter, "br", "xyz")
+            self.assertRaises(ValueError, self.counter_handler.read_counter, "br", "se", -1)
+
+    def test_increment_counter(self):
+        with self.subTest("Increment BR counter"):
+            count = 99
+            self.counter_handler.entity_counters["br"] = count
+
+            result = self.counter_handler.increment_counter("br")
+            self.assertIsNotNone(result)
+            self.assertEqual(result, count + 1)
+            self.assertEqual(self.counter_handler.entity_counters["br"], count + 1)
+        with self.subTest("Increment BR counter, long number"):
+            long_count = 2**256
+            self.counter_handler.entity_counters["br"] = long_count
+
+            result = self.counter_handler.increment_counter("br")
+            self.assertIsNotNone(result)
+            self.assertEqual(result, long_count + 1)
+            self.assertEqual(self.counter_handler.entity_counters["br"], long_count + 1)
+        with self.subTest("Increment SE counter"):
+            count = 99
+            identifier = 1234
+            counter_list = [0]*identifier
+            counter_list[-1] = count
+            self.counter_handler.prov_counters["br"]["se"] = counter_list
+
+            result = self.counter_handler.increment_counter("br", "se", identifier)
+            self.assertIsNotNone(result)
+            self.assertEqual(result, count + 1)
+            self.assertEqual(self.counter_handler.prov_counters["br"]["se"][identifier - 1], count + 1)
+        with self.subTest("Increment SE counter, long number"):
+            long_count = 2**256
+            identifier = 1234
+            counter_list = [0]*identifier
+            counter_list[-1] = long_count
+            self.counter_handler.prov_counters["br"]["se"] = counter_list
+
+            result = self.counter_handler.increment_counter("br", "se", identifier)
+            self.assertIsNotNone(result)
+            self.assertEqual(result, long_count + 1)
+            self.assertEqual(self.counter_handler.prov_counters["br"]["se"][identifier - 1], long_count + 1)
+        with self.subTest("Wrong inputs"):
+            self.assertRaises(ValueError, self.counter_handler.increment_counter, "xyz")
+            self.assertRaises(ValueError, self.counter_handler.increment_counter, "br", "xyz")
+            self.assertRaises(ValueError, self.counter_handler.increment_counter, "br", "se", -1)
+
+    def test_set_metadata_counter(self):
+        dataset_name: str = "http://dataset/"
+        with self.subTest("Set DI counter"):
+            count = 99
+            self.counter_handler.metadata_counters[dataset_name] = {"di": count}
+
+            new_count = 205
+            result = self.counter_handler.set_metadata_counter(new_count, "di", dataset_name)
+            self.assertIsNone(result)
+            self.assertEqual(self.counter_handler.metadata_counters[dataset_name]["di"], new_count)
+        with self.subTest("Set DI counter, long number"):
+            long_count = 2 ** 256
+            self.counter_handler.metadata_counters[dataset_name] = {"di": long_count}
+
+            new_count = 2**512
+            result = self.counter_handler.set_metadata_counter(new_count, "di", dataset_name)
+            self.assertIsNone(result)
+            self.assertEqual(self.counter_handler.metadata_counters[dataset_name]["di"], new_count)
+        with self.subTest("Wrong inputs"):
+            self.assertRaises(ValueError, self.counter_handler.set_metadata_counter, -1, "xyz", dataset_name)
+            self.assertRaises(ValueError, self.counter_handler.set_metadata_counter, 1, "xyz", dataset_name)
+            self.assertRaises(ValueError, self.counter_handler.set_metadata_counter, 1, "di", None)
+
+    def test_read_metadata_counter(self):
+        dataset_name: str = "http://dataset/"
+        with self.subTest("Read DI counter"):
+            count = 99
+            self.counter_handler.metadata_counters[dataset_name] = {"di": count}
+
+            result = self.counter_handler.read_metadata_counter("di", dataset_name)
+            self.assertIsNotNone(result)
+            self.assertEqual(result, count)
+        with self.subTest("Read DI counter, long number"):
+            long_count = 2**256
+            self.counter_handler.metadata_counters[dataset_name] = {"di": long_count}
+
+            result = self.counter_handler.read_metadata_counter("di", dataset_name)
+            self.assertIsNotNone(result)
+            self.assertEqual(result, long_count)
+        with self.subTest("Wrong inputs"):
+            self.assertRaises(ValueError, self.counter_handler.read_metadata_counter, "xyz", dataset_name)
+            self.assertRaises(ValueError, self.counter_handler.read_metadata_counter, "di", None)
+
+    def test_increment_metadata_counter(self):
+        dataset_name: str = "http://dataset/"
+        with self.subTest("Increment DI counter"):
+            count = 99
+            self.counter_handler.metadata_counters[dataset_name] = {"di": count}
+
+            result = self.counter_handler.increment_metadata_counter("di", dataset_name)
+            self.assertIsNotNone(result)
+            self.assertEqual(result, count + 1)
+            self.assertEqual(self.counter_handler.metadata_counters[dataset_name]["di"], count + 1)
+        with self.subTest("Increment DI counter, long number"):
+            long_count = 2**256
+            self.counter_handler.metadata_counters[dataset_name] = {"di": long_count}
+
+            result = self.counter_handler.increment_metadata_counter("di", dataset_name)
+            self.assertIsNotNone(result)
+            self.assertEqual(result, long_count + 1)
+            self.assertEqual(self.counter_handler.metadata_counters[dataset_name]["di"], long_count + 1)
+        with self.subTest("Wrong inputs"):
+            self.assertRaises(ValueError, self.counter_handler.increment_metadata_counter, "xyz", dataset_name)
+            self.assertRaises(ValueError, self.counter_handler.increment_metadata_counter, "di", None)
+
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/coverage/.coverage` & `oc_ocdm-8.1.0/oc_ocdm/test/coverage/.coverage`

 * *Files 1% similar despite different names*

#### sqlite3 {} .dump

```diff
@@ -14,15 +14,15 @@
     --  'has_arcs' boolean      -- Is this data recording branches?
     --  'sys_argv' text         -- The coverage command line that recorded the data.
     --  'version' text          -- The version of coverage.py that made the file.
     --  'when' text             -- Datetime when the file was created.
 );
 INSERT INTO meta VALUES('sys_argv','[''python -m unittest'', ''discover'', ''-s'', ''oc_ocdm/test'', ''-p'', ''test_*.py'']');
 INSERT INTO meta VALUES('version','6.5.0');
-INSERT INTO meta VALUES('when','2024-03-27 14:21:27');
+INSERT INTO meta VALUES('when','2024-04-04 21:08:54');
 INSERT INTO meta VALUES('has_arcs','0');
 CREATE TABLE file (
     -- A row per file measured.
     id integer primary key,
     path text,
     unique (path)
 );
@@ -122,29 +122,29 @@
     foreign key (file_id) references file (id),
     foreign key (context_id) references context (id),
     unique (file_id, context_id)
 );
 INSERT INTO line_bits VALUES(1,1,X'02');
 INSERT INTO line_bits VALUES(2,1,X'0000cb77affbfdbbffffefdffbfbfbbffd7dfdfdaff704');
 INSERT INTO line_bits VALUES(3,1,X'00000d');
-INSERT INTO line_bits VALUES(4,1,X'00007dfb0b50a0f81b03630420fe3ab50137d7f57edbd7fd27045f2200807bc0e55bf6805b01415f17');
+INSERT INTO line_bits VALUES(4,1,X'00007dfb17a043f13706c60840fc756a036eaeebfdf6beee3f63f8120300dc032edfb207dc0a08feba');
 INSERT INTO line_bits VALUES(5,1,X'000006');
-INSERT INTO line_bits VALUES(6,1,X'000055c1fffffeffffffffffffffffffffffffffffdfff937f63b5e099bbbb9c0200879ba1f301');
+INSERT INTO line_bits VALUES(6,1,X'000055c1fffffeffffffffffffffffffffffffffffdffff37f63b5e099bbbb9c0200879ba1f301');
 INSERT INTO line_bits VALUES(7,1,X'00006d61282e00090a604101408205c002340b00fe029fbbcf06');
 INSERT INTO line_bits VALUES(8,1,X'000062');
-INSERT INTO line_bits VALUES(9,1,X'00007d410900a8f195feafc11bf7defdffa45ce6cc98978097879387938097002060411ad4f8e55e0600000080e2ef73');
+INSERT INTO line_bits VALUES(9,1,X'00007d410900a8f195feafc11bf7defdffa45ce6cc98978097879387938097006060415ef4fae55e0600000080e2ef73');
 INSERT INTO line_bits VALUES(10,1,X'000015fbfdfc121001');
 INSERT INTO line_bits VALUES(11,1,X'000015cc03e73c9cee6b');
-INSERT INTO line_bits VALUES(12,1,X'0000d5456b6dd5f4ffd487ff5ba77af5ab5ef5ea57bdfa55af7af5abdefd5fe9df5700c0f3ffffff02fe02020202020202fe02');
+INSERT INTO line_bits VALUES(12,1,X'0000d5456b6dd5f4ffdc87ff5be77af7bbdef5ee77bdfb5def7af7bbdefd5fe9df5700c0f3ffffff02fe02020202020202fe02');
 INSERT INTO line_bits VALUES(13,1,X'0000ad301405be011880');
-INSERT INTO line_bits VALUES(14,1,X'0000bdbb4865608c00000800000400c0eff7fcffbffd171717717197f63f01');
+INSERT INTO line_bits VALUES(14,1,X'0000bd7ba432304600000400000200e0f77bfeffdfff8b8b8bb8b84bff9f');
 INSERT INTO line_bits VALUES(15,1,X'00000e');
 INSERT INTO line_bits VALUES(16,1,X'0000d9010060000006006000c00060');
-INSERT INTO line_bits VALUES(17,1,X'0000bdcc2c20fb2f0000000200b60080edbdddbbfe8faebd7fb77a7fffa974f7277bf3bc00000002b02100db');
-INSERT INTO line_bits VALUES(18,1,X'0000954cfc0500c0f66d2900c0be3d0500d8b7cd02806d29005b5200b60c');
+INSERT INTO line_bits VALUES(17,1,X'0000bdcc2c20fb6f0000000200b60080edbdddbbfe8faebd7fb77a7fffa974f7277bf3bd00000002b02100db');
+INSERT INTO line_bits VALUES(18,1,X'0000954cfc0d00c0f66d2900c0be3d0500d8b7cd02806d29005b5200b60c');
 INSERT INTO line_bits VALUES(19,1,X'000006');
 INSERT INTO line_bits VALUES(20,1,X'0000556401d020c137003400a40020e1df0d');
 INSERT INTO line_bits VALUES(21,1,X'0000ad1200d03f0c');
 INSERT INTO line_bits VALUES(22,1,X'00002dce1800809ea060030006000d001800a00100038006000d00e006006800001a0034006800d000a00140030006000d001a00f40506');
 INSERT INTO line_bits VALUES(23,1,X'0000fe07');
 INSERT INTO line_bits VALUES(24,1,X'000055cc0600000000821b002c487003c082040bc002b0002c08');
 INSERT INTO line_bits VALUES(25,1,X'00005598c1000000000206008005098001d000000430002c08');
@@ -153,22 +153,22 @@
 INSERT INTO line_bits VALUES(28,1,X'00005598610000000000000103c08204c00068000002180016240006400300100003a0010008180016246000106000001000140014001400140014001400140004');
 INSERT INTO line_bits VALUES(29,1,X'000055cc18000000040cc08204c00068');
 INSERT INTO line_bits VALUES(30,1,X'000055cc800100000430005810');
 INSERT INTO line_bits VALUES(31,1,X'00005598610000000010300058900006000b12c000604102600068');
 INSERT INTO line_bits VALUES(32,1,X'00002dce0c00000000020c000b123000c02948c00000a7200106800509000580');
 INSERT INTO line_bits VALUES(33,1,X'000055660c000000000206000b1230002c48c000b02001064003');
 INSERT INTO line_bits VALUES(34,1,X'000006');
-INSERT INTO line_bits VALUES(35,1,X'0000b5f0f6ff3bf1bff1d102605e3313400000000010');
-INSERT INTO line_bits VALUES(36,1,X'0000f54bd3d935aec2ab5e5b004bc11710');
+INSERT INTO line_bits VALUES(35,1,X'0000b5f0f6ff3bffbff1d102605e3313400000000010');
+INSERT INTO line_bits VALUES(36,1,X'0000f54bd3d935eec2bbde5b004bc11710');
 INSERT INTO line_bits VALUES(37,1,X'000006');
 INSERT INTO line_bits VALUES(38,1,X'000075c10c000000000000000206800509180016246000b02001038005091880060020c0003400000103c08204c0003400000106800509800168');
 INSERT INTO line_bits VALUES(39,1,X'0000d5c20c00000000002060005890800160410206000b123000589080016041020680050918001604');
 INSERT INTO line_bits VALUES(40,1,X'000006');
-INSERT INTO line_bits VALUES(41,1,X'0000d58241ff4dec633477');
-INSERT INTO line_bits VALUES(42,1,X'0000dd45ebd1bcffd771fbfbeeef9f6d19766fbfff992e77fbdb0f00006d01807cb7eee7bd02');
+INSERT INTO line_bits VALUES(41,1,X'0000d58241ffcdef633477');
+INSERT INTO line_bits VALUES(42,1,X'0000dd45ebd1bcffd771fbfbeeef9f6d59766fbfff992e77fbdb0f00006f01807cb7eee7bd02');
 INSERT INTO line_bits VALUES(43,1,X'000002');
 INSERT INTO line_bits VALUES(44,1,X'0000d50583a0018005091a00b020c102c08204b701d000000418002c48d00060418206002c48b001b020');
 INSERT INTO line_bits VALUES(45,1,X'0000ca041e0100023e080092');
 INSERT INTO line_bits VALUES(46,1,X'0000a5bdbffffdefbff7fbefbfbff7f7bffffdfbfefe7dbfdff7f727');
 INSERT INTO line_bits VALUES(47,1,X'02');
 INSERT INTO line_bits VALUES(48,1,X'02');
 INSERT INTO line_bits VALUES(49,1,X'02');
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/coverage/coverage.svg` & `oc_ocdm-8.1.0/oc_ocdm/test/coverage/coverage.svg`

 * *Files 20% similar despite different names*

```diff
@@ -1,58 +1,57 @@
 00000000: 3c3f 786d 6c20 7665 7273 696f 6e3d 2231  <?xml version="1
 00000010: 2e30 2220 656e 636f 6469 6e67 3d22 5554  .0" encoding="UT
-00000020: 462d 3822 3f3e 0d0a 3c73 7667 2078 6d6c  F-8"?>..<svg xml
-00000030: 6e73 3d22 6874 7470 3a2f 2f77 7777 2e77  ns="http://www.w
-00000040: 332e 6f72 672f 3230 3030 2f73 7667 2220  3.org/2000/svg" 
-00000050: 7769 6474 683d 2239 3922 2068 6569 6768  width="99" heigh
-00000060: 743d 2232 3022 3e0d 0a20 2020 203c 6c69  t="20">..    <li
-00000070: 6e65 6172 4772 6164 6965 6e74 2069 643d  nearGradient id=
-00000080: 2262 2220 7832 3d22 3022 2079 323d 2231  "b" x2="0" y2="1
-00000090: 3030 2522 3e0d 0a20 2020 2020 2020 203c  00%">..        <
-000000a0: 7374 6f70 206f 6666 7365 743d 2230 2220  stop offset="0" 
-000000b0: 7374 6f70 2d63 6f6c 6f72 3d22 2362 6262  stop-color="#bbb
-000000c0: 2220 7374 6f70 2d6f 7061 6369 7479 3d22  " stop-opacity="
-000000d0: 2e31 222f 3e0d 0a20 2020 2020 2020 203c  .1"/>..        <
-000000e0: 7374 6f70 206f 6666 7365 743d 2231 2220  stop offset="1" 
-000000f0: 7374 6f70 2d6f 7061 6369 7479 3d22 2e31  stop-opacity=".1
-00000100: 222f 3e0d 0a20 2020 203c 2f6c 696e 6561  "/>..    </linea
-00000110: 7247 7261 6469 656e 743e 0d0a 2020 2020  rGradient>..    
-00000120: 3c6d 6173 6b20 6964 3d22 6122 3e0d 0a20  <mask id="a">.. 
-00000130: 2020 2020 2020 203c 7265 6374 2077 6964         <rect wid
-00000140: 7468 3d22 3939 2220 6865 6967 6874 3d22  th="99" height="
-00000150: 3230 2220 7278 3d22 3322 2066 696c 6c3d  20" rx="3" fill=
-00000160: 2223 6666 6622 2f3e 0d0a 2020 2020 3c2f  "#fff"/>..    </
-00000170: 6d61 736b 3e0d 0a20 2020 203c 6720 6d61  mask>..    <g ma
-00000180: 736b 3d22 7572 6c28 2361 2922 3e0d 0a20  sk="url(#a)">.. 
-00000190: 2020 2020 2020 203c 7061 7468 2066 696c         <path fil
-000001a0: 6c3d 2223 3535 3522 2064 3d22 4d30 2030  l="#555" d="M0 0
-000001b0: 6836 3376 3230 4830 7a22 2f3e 0d0a 2020  h63v20H0z"/>..  
-000001c0: 2020 2020 2020 3c70 6174 6820 6669 6c6c        <path fill
-000001d0: 3d22 2361 3461 3631 6422 2064 3d22 4d36  ="#a4a61d" d="M6
-000001e0: 3320 3068 3336 7632 3048 3633 7a22 2f3e  3 0h36v20H63z"/>
-000001f0: 0d0a 2020 2020 2020 2020 3c70 6174 6820  ..        <path 
-00000200: 6669 6c6c 3d22 7572 6c28 2362 2922 2064  fill="url(#b)" d
-00000210: 3d22 4d30 2030 6839 3976 3230 4830 7a22  ="M0 0h99v20H0z"
-00000220: 2f3e 0d0a 2020 2020 3c2f 673e 0d0a 2020  />..    </g>..  
-00000230: 2020 3c67 2066 696c 6c3d 2223 6666 6622    <g fill="#fff"
-00000240: 2074 6578 742d 616e 6368 6f72 3d22 6d69   text-anchor="mi
-00000250: 6464 6c65 2220 666f 6e74 2d66 616d 696c  ddle" font-famil
-00000260: 793d 2244 656a 6156 7520 5361 6e73 2c56  y="DejaVu Sans,V
-00000270: 6572 6461 6e61 2c47 656e 6576 612c 7361  erdana,Geneva,sa
-00000280: 6e73 2d73 6572 6966 2220 666f 6e74 2d73  ns-serif" font-s
-00000290: 697a 653d 2231 3122 3e0d 0a20 2020 2020  ize="11">..     
-000002a0: 2020 203c 7465 7874 2078 3d22 3331 2e35     <text x="31.5
-000002b0: 2220 793d 2231 3522 2066 696c 6c3d 2223  " y="15" fill="#
-000002c0: 3031 3031 3031 2220 6669 6c6c 2d6f 7061  010101" fill-opa
-000002d0: 6369 7479 3d22 2e33 223e 636f 7665 7261  city=".3">covera
-000002e0: 6765 3c2f 7465 7874 3e0d 0a20 2020 2020  ge</text>..     
-000002f0: 2020 203c 7465 7874 2078 3d22 3331 2e35     <text x="31.5
-00000300: 2220 793d 2231 3422 3e63 6f76 6572 6167  " y="14">coverag
-00000310: 653c 2f74 6578 743e 0d0a 2020 2020 2020  e</text>..      
-00000320: 2020 3c74 6578 7420 783d 2238 3022 2079    <text x="80" y
-00000330: 3d22 3135 2220 6669 6c6c 3d22 2330 3130  ="15" fill="#010
-00000340: 3130 3122 2066 696c 6c2d 6f70 6163 6974  101" fill-opacit
-00000350: 793d 222e 3322 3e38 3225 3c2f 7465 7874  y=".3">82%</text
-00000360: 3e0d 0a20 2020 2020 2020 203c 7465 7874  >..        <text
-00000370: 2078 3d22 3830 2220 793d 2231 3422 3e38   x="80" y="14">8
-00000380: 3225 3c2f 7465 7874 3e0d 0a20 2020 203c  2%</text>..    <
-00000390: 2f67 3e0d 0a3c 2f73 7667 3e0d 0a         /g>..</svg>..
+00000020: 462d 3822 3f3e 0a3c 7376 6720 786d 6c6e  F-8"?>.<svg xmln
+00000030: 733d 2268 7474 703a 2f2f 7777 772e 7733  s="http://www.w3
+00000040: 2e6f 7267 2f32 3030 302f 7376 6722 2077  .org/2000/svg" w
+00000050: 6964 7468 3d22 3939 2220 6865 6967 6874  idth="99" height
+00000060: 3d22 3230 223e 0a20 2020 203c 6c69 6e65  ="20">.    <line
+00000070: 6172 4772 6164 6965 6e74 2069 643d 2262  arGradient id="b
+00000080: 2220 7832 3d22 3022 2079 323d 2231 3030  " x2="0" y2="100
+00000090: 2522 3e0a 2020 2020 2020 2020 3c73 746f  %">.        <sto
+000000a0: 7020 6f66 6673 6574 3d22 3022 2073 746f  p offset="0" sto
+000000b0: 702d 636f 6c6f 723d 2223 6262 6222 2073  p-color="#bbb" s
+000000c0: 746f 702d 6f70 6163 6974 793d 222e 3122  top-opacity=".1"
+000000d0: 2f3e 0a20 2020 2020 2020 203c 7374 6f70  />.        <stop
+000000e0: 206f 6666 7365 743d 2231 2220 7374 6f70   offset="1" stop
+000000f0: 2d6f 7061 6369 7479 3d22 2e31 222f 3e0a  -opacity=".1"/>.
+00000100: 2020 2020 3c2f 6c69 6e65 6172 4772 6164      </linearGrad
+00000110: 6965 6e74 3e0a 2020 2020 3c6d 6173 6b20  ient>.    <mask 
+00000120: 6964 3d22 6122 3e0a 2020 2020 2020 2020  id="a">.        
+00000130: 3c72 6563 7420 7769 6474 683d 2239 3922  <rect width="99"
+00000140: 2068 6569 6768 743d 2232 3022 2072 783d   height="20" rx=
+00000150: 2233 2220 6669 6c6c 3d22 2366 6666 222f  "3" fill="#fff"/
+00000160: 3e0a 2020 2020 3c2f 6d61 736b 3e0a 2020  >.    </mask>.  
+00000170: 2020 3c67 206d 6173 6b3d 2275 726c 2823    <g mask="url(#
+00000180: 6129 223e 0a20 2020 2020 2020 203c 7061  a)">.        <pa
+00000190: 7468 2066 696c 6c3d 2223 3535 3522 2064  th fill="#555" d
+000001a0: 3d22 4d30 2030 6836 3376 3230 4830 7a22  ="M0 0h63v20H0z"
+000001b0: 2f3e 0a20 2020 2020 2020 203c 7061 7468  />.        <path
+000001c0: 2066 696c 6c3d 2223 6134 6136 3164 2220   fill="#a4a61d" 
+000001d0: 643d 224d 3633 2030 6833 3676 3230 4836  d="M63 0h36v20H6
+000001e0: 337a 222f 3e0a 2020 2020 2020 2020 3c70  3z"/>.        <p
+000001f0: 6174 6820 6669 6c6c 3d22 7572 6c28 2362  ath fill="url(#b
+00000200: 2922 2064 3d22 4d30 2030 6839 3976 3230  )" d="M0 0h99v20
+00000210: 4830 7a22 2f3e 0a20 2020 203c 2f67 3e0a  H0z"/>.    </g>.
+00000220: 2020 2020 3c67 2066 696c 6c3d 2223 6666      <g fill="#ff
+00000230: 6622 2074 6578 742d 616e 6368 6f72 3d22  f" text-anchor="
+00000240: 6d69 6464 6c65 2220 666f 6e74 2d66 616d  middle" font-fam
+00000250: 696c 793d 2244 656a 6156 7520 5361 6e73  ily="DejaVu Sans
+00000260: 2c56 6572 6461 6e61 2c47 656e 6576 612c  ,Verdana,Geneva,
+00000270: 7361 6e73 2d73 6572 6966 2220 666f 6e74  sans-serif" font
+00000280: 2d73 697a 653d 2231 3122 3e0a 2020 2020  -size="11">.    
+00000290: 2020 2020 3c74 6578 7420 783d 2233 312e      <text x="31.
+000002a0: 3522 2079 3d22 3135 2220 6669 6c6c 3d22  5" y="15" fill="
+000002b0: 2330 3130 3130 3122 2066 696c 6c2d 6f70  #010101" fill-op
+000002c0: 6163 6974 793d 222e 3322 3e63 6f76 6572  acity=".3">cover
+000002d0: 6167 653c 2f74 6578 743e 0a20 2020 2020  age</text>.     
+000002e0: 2020 203c 7465 7874 2078 3d22 3331 2e35     <text x="31.5
+000002f0: 2220 793d 2231 3422 3e63 6f76 6572 6167  " y="14">coverag
+00000300: 653c 2f74 6578 743e 0a20 2020 2020 2020  e</text>.       
+00000310: 203c 7465 7874 2078 3d22 3830 2220 793d   <text x="80" y=
+00000320: 2231 3522 2066 696c 6c3d 2223 3031 3031  "15" fill="#0101
+00000330: 3031 2220 6669 6c6c 2d6f 7061 6369 7479  01" fill-opacity
+00000340: 3d22 2e33 223e 3832 253c 2f74 6578 743e  =".3">82%</text>
+00000350: 0a20 2020 2020 2020 203c 7465 7874 2078  .        <text x
+00000360: 3d22 3830 2220 793d 2231 3422 3e38 3225  ="80" y="14">82%
+00000370: 3c2f 7465 7874 3e0a 2020 2020 3c2f 673e  </text>.    </g>
+00000380: 0a3c 2f73 7667 3e0a                      .</svg>.
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/graph/__init__.py` & `oc_ocdm-8.1.0/oc_ocdm/test/prov/__init__.py`

 * *Files identical despite different names*

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/__init__.py` & `oc_ocdm-8.1.0/oc_ocdm/test/prov/entities/__init__.py`

 * *Files identical despite different names*

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/bibliographic/__init__.py` & `oc_ocdm-8.1.0/oc_ocdm/test/support/__init__.py`

 * *Files identical despite different names*

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/bibliographic/test_agent_role.py` & `oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/bibliographic/test_agent_role.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,72 +1,72 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-import unittest
-
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.graph.graph_set import GraphSet
-
-
-class TestAgentRole(unittest.TestCase):
-    resp_agent = 'http://resp_agent.test/'
-
-    @classmethod
-    def setUpClass(cls) -> None:
-        cls.graph_set = GraphSet("http://test/", "./info_dir/", "", False)
-
-    def setUp(self):
-        self.ar1 = self.graph_set.add_ar(self.resp_agent)
-        self.ar2 = self.graph_set.add_ar(self.resp_agent)
-        self.ra = self.graph_set.add_ra(self.resp_agent)
-        self.br = self.graph_set.add_br(self.resp_agent)
-
-    def test_has_next(self):
-        result = self.ar1.has_next(self.ar2)
-        self.assertIsNone(result)
-
-        triple = self.ar1.res, GraphEntity.iri_has_next, self.ar2.res
-        self.assertIn(triple, self.ar1.g)
-
-    def test_is_held_by(self):
-        result = self.ar1.is_held_by(self.ra)
-        self.assertIsNone(result)
-
-        triple = self.ar1.res, GraphEntity.iri_is_held_by, self.ra.res
-        self.assertIn(triple, self.ar1.g)
-
-    def test_create_publisher(self):
-        result = self.ar1.create_publisher()
-        self.assertIsNone(result)
-
-        triple = self.ar1.res, GraphEntity.iri_with_role, GraphEntity.iri_publisher
-        self.assertIn(triple, self.ar1.g)
-
-    def test_create_author(self):
-        result = self.ar1.create_author()
-        self.assertIsNone(result)
-
-        triple = self.ar1.res, GraphEntity.iri_with_role, GraphEntity.iri_author
-        self.assertIn(triple, self.ar1.g)
-
-    def test_create_editor(self):
-        result = self.ar1.create_editor()
-        self.assertIsNone(result)
-
-        triple = self.ar1.res, GraphEntity.iri_with_role, GraphEntity.iri_editor
-        self.assertIn(triple, self.ar1.g)
-
-
-if __name__ == '__main__':
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+import unittest
+
+from oc_ocdm.graph.graph_entity import GraphEntity
+from oc_ocdm.graph.graph_set import GraphSet
+
+
+class TestAgentRole(unittest.TestCase):
+    resp_agent = 'http://resp_agent.test/'
+
+    @classmethod
+    def setUpClass(cls) -> None:
+        cls.graph_set = GraphSet("http://test/", "./info_dir/", "", False)
+
+    def setUp(self):
+        self.ar1 = self.graph_set.add_ar(self.resp_agent)
+        self.ar2 = self.graph_set.add_ar(self.resp_agent)
+        self.ra = self.graph_set.add_ra(self.resp_agent)
+        self.br = self.graph_set.add_br(self.resp_agent)
+
+    def test_has_next(self):
+        result = self.ar1.has_next(self.ar2)
+        self.assertIsNone(result)
+
+        triple = self.ar1.res, GraphEntity.iri_has_next, self.ar2.res
+        self.assertIn(triple, self.ar1.g)
+
+    def test_is_held_by(self):
+        result = self.ar1.is_held_by(self.ra)
+        self.assertIsNone(result)
+
+        triple = self.ar1.res, GraphEntity.iri_is_held_by, self.ra.res
+        self.assertIn(triple, self.ar1.g)
+
+    def test_create_publisher(self):
+        result = self.ar1.create_publisher()
+        self.assertIsNone(result)
+
+        triple = self.ar1.res, GraphEntity.iri_with_role, GraphEntity.iri_publisher
+        self.assertIn(triple, self.ar1.g)
+
+    def test_create_author(self):
+        result = self.ar1.create_author()
+        self.assertIsNone(result)
+
+        triple = self.ar1.res, GraphEntity.iri_with_role, GraphEntity.iri_author
+        self.assertIn(triple, self.ar1.g)
+
+    def test_create_editor(self):
+        result = self.ar1.create_editor()
+        self.assertIsNone(result)
+
+        triple = self.ar1.res, GraphEntity.iri_with_role, GraphEntity.iri_editor
+        self.assertIn(triple, self.ar1.g)
+
+
+if __name__ == '__main__':
     unittest.main()
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/bibliographic/test_bibliographic_reference.py` & `oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/bibliographic/test_pointer_list.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,60 +1,52 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-import unittest
-
-from rdflib import Literal
-
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.graph.graph_set import GraphSet
-
-
-class TestBibliographicReference(unittest.TestCase):
-    resp_agent = 'http://resp_agent.test/'
-
-    @classmethod
-    def setUpClass(cls) -> None:
-        cls.graph_set = GraphSet("http://test/", "./info_dir/", "", False)
-
-    def setUp(self):
-        self.be = self.graph_set.add_be(self.resp_agent)
-        self.br = self.graph_set.add_br(self.resp_agent)
-        self.an = self.graph_set.add_an(self.resp_agent)
-
-    def test_has_content(self):
-        content = "Content"
-        result = self.be.has_content(content)
-        self.assertIsNone(result)
-
-        triple = self.be.res, GraphEntity.iri_has_content, Literal(content)
-        self.assertIn(triple, self.be.g)
-
-    def test_has_annotation(self):
-        result = self.be.has_annotation(self.an)
-        self.assertIsNone(result)
-
-        triple = self.be.res, GraphEntity.iri_has_annotation, self.an.res
-        self.assertIn(triple, self.be.g)
-
-    def test_references(self):
-        result = self.be.references_br(self.br)
-        self.assertIsNone(result)
-
-        triple = self.be.res, GraphEntity.iri_references, self.br.res
-        self.assertIn(triple, self.be.g)
-
-
-if __name__ == '__main__':
-    unittest.main()
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+import unittest
+
+from rdflib import Literal
+
+from oc_ocdm.graph.graph_entity import GraphEntity
+from oc_ocdm.graph.graph_set import GraphSet
+
+
+class TestPointerList(unittest.TestCase):
+    resp_agent = 'http://resp_agent.test/'
+
+    @classmethod
+    def setUpClass(cls) -> None:
+        cls.graph_set = GraphSet("http://test/", "./info_dir/", "", False)
+
+    def setUp(self):
+        self.rp = self.graph_set.add_rp(self.resp_agent)
+        self.pl = self.graph_set.add_pl(self.resp_agent)
+
+    def test_has_content(self):
+        content = "Content"
+        result = self.pl.has_content(content)
+        self.assertIsNone(result)
+
+        triple = self.pl.res, GraphEntity.iri_has_content, Literal(content)
+        self.assertIn(triple, self.pl.g)
+
+    def test_contains_element(self):
+        result = self.pl.contains_element(self.rp)
+        self.assertIsNone(result)
+
+        triple = self.pl.res, GraphEntity.iri_has_element, self.rp.res
+        self.assertIn(triple, self.pl.g)
+
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/bibliographic/test_bibliographic_resource.py` & `oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/bibliographic/test_bibliographic_resource.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,348 +1,348 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-import unittest
-
-from rdflib import URIRef, Literal, XSD, RDF
-
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.graph.graph_set import GraphSet
-
-
-class TestBibliographicResource(unittest.TestCase):
-    resp_agent = 'http://resp_agent.test/'
-
-    @classmethod
-    def setUpClass(cls) -> None:
-        cls.graph_set = GraphSet("http://test/", "./info_dir/", "", False)
-
-    def setUp(self):
-        self.br1 = self.graph_set.add_br(self.resp_agent)
-        self.br2 = self.graph_set.add_br(self.resp_agent)
-        self.re = self.graph_set.add_re(self.resp_agent)
-        self.be = self.graph_set.add_be(self.resp_agent)
-        self.de = self.graph_set.add_de(self.resp_agent)
-        self.ar = self.graph_set.add_ar(self.resp_agent)
-
-    def test_has_title(self):
-        title = "Resource"
-        result = self.br1.has_title(title)
-        self.assertIsNone(result)
-
-        triple = self.br1.res, GraphEntity.iri_title, Literal(title)
-        self.assertIn(triple, self.br1.g)
-
-    def test_has_subtitle(self):
-        subtitle = "Resource"
-        result = self.br1.has_subtitle(subtitle)
-        self.assertIsNone(result)
-
-        triple = self.br1.res, GraphEntity.iri_has_subtitle, Literal(subtitle)
-        self.assertIn(triple, self.br1.g)
-
-    def test_is_part_of(self):
-        result = self.br1.is_part_of(self.br2)
-        self.assertIsNone(result)
-
-        triple = self.br1.res, GraphEntity.iri_part_of, self.br2.res
-        self.assertIn(triple, self.br1.g)
-
-    def test_has_citation(self):
-        result = self.br1.has_citation(self.br2)
-        self.assertIsNone(result)
-
-        triple = self.br1.res, GraphEntity.iri_cites, self.br2.res
-        self.assertIn(triple, self.br1.g)
-
-    def test_has_pub_date(self):
-        with self.subTest("date is '2020-05-25'"):
-            string = "2020-05-25"
-            datatype = XSD.date
-            result = self.br1.has_pub_date(string)
-            self.assertIsNone(result)
-
-            triple = self.br1.res, GraphEntity.iri_has_publication_date, Literal(string, datatype=datatype,
-                                                                                 normalize=False)
-            self.assertIn(triple, self.br1.g)
-        with self.subTest("date is '2020-05'"):
-            string = "2020-05"
-            datatype = XSD.gYearMonth
-            result = self.br1.has_pub_date(string)
-            self.assertIsNone(result)
-
-            triple = self.br1.res, GraphEntity.iri_has_publication_date, Literal(string, datatype=datatype,
-                                                                                 normalize=False)
-            self.assertIn(triple, self.br1.g)
-        with self.subTest("date is '2020'"):
-            string = "2020"
-            datatype = XSD.gYear
-            result = self.br1.has_pub_date(string)
-            self.assertIsNone(result)
-
-            triple = self.br1.res, GraphEntity.iri_has_publication_date, Literal(string, datatype=datatype,
-                                                                                 normalize=False)
-            self.assertIn(triple, self.br1.g)
-
-    def test_has_format(self):
-        result = self.br1.has_format(self.re)
-        self.assertIsNone(result)
-
-        triple = self.br1.res, GraphEntity.iri_embodiment, self.re.res
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_number(self):
-        number = "1234"
-        result = self.br1.has_number(number)
-        self.assertIsNone(result)
-
-        triple = self.br1.res, GraphEntity.iri_has_sequence_identifier, Literal(number)
-        self.assertIn(triple, self.br1.g)
-
-    def test_has_edition(self):
-        edition = "abcde"
-        result = self.br1.has_edition(edition)
-        self.assertIsNone(result)
-
-        triple = self.br1.res, GraphEntity.iri_has_edition, Literal(edition)
-        self.assertIn(triple, self.br1.g)
-
-    def test_contains_in_reference_list(self):
-        result = self.br1.contains_in_reference_list(self.be)
-        self.assertIsNone(result)
-
-        triple = self.br1.res, GraphEntity.iri_contains_reference, self.be.res
-        self.assertIn(triple, self.br1.g)
-
-    def test_contains_discourse_element(self):
-        result = self.br1.contains_discourse_element(self.de)
-        self.assertIsNone(result)
-
-        triple = self.br1.res, GraphEntity.iri_contains_de, self.de.res
-        self.assertIn(triple, self.br1.g)
-
-    def test_has_contributor(self):
-        result = self.br1.has_contributor(self.ar)
-        self.assertIsNone(result)
-
-        triple = self.br1.res, GraphEntity.iri_is_document_context_for, self.ar.res
-        self.assertIn(triple, self.br1.g)
-
-    def test_has_related_document(self):
-        document = URIRef("http://test/document")
-        result = self.br1.has_related_document(document)
-        self.assertIsNone(result)
-
-        triple = self.br1.res, GraphEntity.iri_relation, document
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_archival_document(self):
-        result = self.br1.create_archival_document()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_archival_document
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_book(self):
-        result = self.br1.create_book()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_book
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_book_chapter(self):
-        result = self.br1.create_book_chapter()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_book_chapter
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_book_part(self):
-        result = self.br1.create_book_part()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_part
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_book_section(self):
-        result = self.br1.create_book_section()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_expression_collection
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_book_series(self):
-        result = self.br1.create_book_series()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_book_series
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_book_set(self):
-        result = self.br1.create_book_set()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_book_set
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_book_track(self):
-        result = self.br1.create_book_track()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_expression
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_component(self):
-        result = self.br1.create_component()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_expression
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_dataset(self):
-        result = self.br1.create_dataset()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_data_file
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_dissertation(self):
-        result = self.br1.create_dissertation()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_thesis
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_edited_book(self):
-        result = self.br1.create_edited_book()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_book
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_journal_article(self):
-        result = self.br1.create_journal_article()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_journal_article
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_issue(self):
-        result = self.br1.create_issue()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_journal_issue
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_volume(self):
-        result = self.br1.create_volume()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_journal_volume
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_journal(self):
-        result = self.br1.create_journal()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_journal
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_monograph(self):
-        result = self.br1.create_monograph()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_book
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_proceedings_article(self):
-        result = self.br1.create_proceedings_article()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_proceedings_paper
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_proceedings(self):
-        result = self.br1.create_proceedings()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_academic_proceedings
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_reference_book(self):
-        result = self.br1.create_reference_book()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_reference_book
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_reference_entry(self):
-        result = self.br1.create_reference_entry()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_reference_entry
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_report_series(self):
-        result = self.br1.create_report_series()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_series
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_report(self):
-        result = self.br1.create_report()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_report_document
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_standard_series(self):
-        result = self.br1.create_standard_series()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_series
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_standard(self):
-        result = self.br1.create_standard()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_specification_document
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_series(self):
-        result = self.br1.create_series()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_series
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_expression_collection(self):
-        result = self.br1.create_expression_collection()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_expression_collection
-        self.assertIn(triple, self.br1.g)
-
-    def test_create_other(self):
-        result = self.br1.create_other()
-        self.assertIsNone(result)
-
-        triple = self.br1.res, RDF.type, GraphEntity.iri_expression
-        self.assertIn(triple, self.br1.g)
-
-
-if __name__ == '__main__':
-    unittest.main()
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+import unittest
+
+from rdflib import URIRef, Literal, XSD, RDF
+
+from oc_ocdm.graph.graph_entity import GraphEntity
+from oc_ocdm.graph.graph_set import GraphSet
+
+
+class TestBibliographicResource(unittest.TestCase):
+    resp_agent = 'http://resp_agent.test/'
+
+    @classmethod
+    def setUpClass(cls) -> None:
+        cls.graph_set = GraphSet("http://test/", "./info_dir/", "", False)
+
+    def setUp(self):
+        self.br1 = self.graph_set.add_br(self.resp_agent)
+        self.br2 = self.graph_set.add_br(self.resp_agent)
+        self.re = self.graph_set.add_re(self.resp_agent)
+        self.be = self.graph_set.add_be(self.resp_agent)
+        self.de = self.graph_set.add_de(self.resp_agent)
+        self.ar = self.graph_set.add_ar(self.resp_agent)
+
+    def test_has_title(self):
+        title = "Resource"
+        result = self.br1.has_title(title)
+        self.assertIsNone(result)
+
+        triple = self.br1.res, GraphEntity.iri_title, Literal(title)
+        self.assertIn(triple, self.br1.g)
+
+    def test_has_subtitle(self):
+        subtitle = "Resource"
+        result = self.br1.has_subtitle(subtitle)
+        self.assertIsNone(result)
+
+        triple = self.br1.res, GraphEntity.iri_has_subtitle, Literal(subtitle)
+        self.assertIn(triple, self.br1.g)
+
+    def test_is_part_of(self):
+        result = self.br1.is_part_of(self.br2)
+        self.assertIsNone(result)
+
+        triple = self.br1.res, GraphEntity.iri_part_of, self.br2.res
+        self.assertIn(triple, self.br1.g)
+
+    def test_has_citation(self):
+        result = self.br1.has_citation(self.br2)
+        self.assertIsNone(result)
+
+        triple = self.br1.res, GraphEntity.iri_cites, self.br2.res
+        self.assertIn(triple, self.br1.g)
+
+    def test_has_pub_date(self):
+        with self.subTest("date is '2020-05-25'"):
+            string = "2020-05-25"
+            datatype = XSD.date
+            result = self.br1.has_pub_date(string)
+            self.assertIsNone(result)
+
+            triple = self.br1.res, GraphEntity.iri_has_publication_date, Literal(string, datatype=datatype,
+                                                                                 normalize=False)
+            self.assertIn(triple, self.br1.g)
+        with self.subTest("date is '2020-05'"):
+            string = "2020-05"
+            datatype = XSD.gYearMonth
+            result = self.br1.has_pub_date(string)
+            self.assertIsNone(result)
+
+            triple = self.br1.res, GraphEntity.iri_has_publication_date, Literal(string, datatype=datatype,
+                                                                                 normalize=False)
+            self.assertIn(triple, self.br1.g)
+        with self.subTest("date is '2020'"):
+            string = "2020"
+            datatype = XSD.gYear
+            result = self.br1.has_pub_date(string)
+            self.assertIsNone(result)
+
+            triple = self.br1.res, GraphEntity.iri_has_publication_date, Literal(string, datatype=datatype,
+                                                                                 normalize=False)
+            self.assertIn(triple, self.br1.g)
+
+    def test_has_format(self):
+        result = self.br1.has_format(self.re)
+        self.assertIsNone(result)
+
+        triple = self.br1.res, GraphEntity.iri_embodiment, self.re.res
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_number(self):
+        number = "1234"
+        result = self.br1.has_number(number)
+        self.assertIsNone(result)
+
+        triple = self.br1.res, GraphEntity.iri_has_sequence_identifier, Literal(number)
+        self.assertIn(triple, self.br1.g)
+
+    def test_has_edition(self):
+        edition = "abcde"
+        result = self.br1.has_edition(edition)
+        self.assertIsNone(result)
+
+        triple = self.br1.res, GraphEntity.iri_has_edition, Literal(edition)
+        self.assertIn(triple, self.br1.g)
+
+    def test_contains_in_reference_list(self):
+        result = self.br1.contains_in_reference_list(self.be)
+        self.assertIsNone(result)
+
+        triple = self.br1.res, GraphEntity.iri_contains_reference, self.be.res
+        self.assertIn(triple, self.br1.g)
+
+    def test_contains_discourse_element(self):
+        result = self.br1.contains_discourse_element(self.de)
+        self.assertIsNone(result)
+
+        triple = self.br1.res, GraphEntity.iri_contains_de, self.de.res
+        self.assertIn(triple, self.br1.g)
+
+    def test_has_contributor(self):
+        result = self.br1.has_contributor(self.ar)
+        self.assertIsNone(result)
+
+        triple = self.br1.res, GraphEntity.iri_is_document_context_for, self.ar.res
+        self.assertIn(triple, self.br1.g)
+
+    def test_has_related_document(self):
+        document = URIRef("http://test/document")
+        result = self.br1.has_related_document(document)
+        self.assertIsNone(result)
+
+        triple = self.br1.res, GraphEntity.iri_relation, document
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_archival_document(self):
+        result = self.br1.create_archival_document()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_archival_document
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_book(self):
+        result = self.br1.create_book()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_book
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_book_chapter(self):
+        result = self.br1.create_book_chapter()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_book_chapter
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_book_part(self):
+        result = self.br1.create_book_part()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_part
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_book_section(self):
+        result = self.br1.create_book_section()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_expression_collection
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_book_series(self):
+        result = self.br1.create_book_series()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_book_series
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_book_set(self):
+        result = self.br1.create_book_set()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_book_set
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_book_track(self):
+        result = self.br1.create_book_track()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_expression
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_component(self):
+        result = self.br1.create_component()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_expression
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_dataset(self):
+        result = self.br1.create_dataset()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_data_file
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_dissertation(self):
+        result = self.br1.create_dissertation()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_thesis
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_edited_book(self):
+        result = self.br1.create_edited_book()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_book
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_journal_article(self):
+        result = self.br1.create_journal_article()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_journal_article
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_issue(self):
+        result = self.br1.create_issue()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_journal_issue
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_volume(self):
+        result = self.br1.create_volume()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_journal_volume
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_journal(self):
+        result = self.br1.create_journal()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_journal
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_monograph(self):
+        result = self.br1.create_monograph()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_book
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_proceedings_article(self):
+        result = self.br1.create_proceedings_article()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_proceedings_paper
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_proceedings(self):
+        result = self.br1.create_proceedings()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_academic_proceedings
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_reference_book(self):
+        result = self.br1.create_reference_book()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_reference_book
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_reference_entry(self):
+        result = self.br1.create_reference_entry()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_reference_entry
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_report_series(self):
+        result = self.br1.create_report_series()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_series
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_report(self):
+        result = self.br1.create_report()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_report_document
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_standard_series(self):
+        result = self.br1.create_standard_series()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_series
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_standard(self):
+        result = self.br1.create_standard()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_specification_document
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_series(self):
+        result = self.br1.create_series()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_series
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_expression_collection(self):
+        result = self.br1.create_expression_collection()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_expression_collection
+        self.assertIn(triple, self.br1.g)
+
+    def test_create_other(self):
+        result = self.br1.create_other()
+        self.assertIsNone(result)
+
+        triple = self.br1.res, RDF.type, GraphEntity.iri_expression
+        self.assertIn(triple, self.br1.g)
+
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/bibliographic/test_citation.py` & `oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/bibliographic/test_citation.py`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,157 +1,157 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-import unittest
-
-from rdflib import URIRef, XSD, Literal, RDF
-
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.graph.graph_set import GraphSet
-
-from oc_ocdm.counter_handler.sqlite_counter_handler import SqliteCounterHandler
-
-
-class TestCitation(unittest.TestCase):
-    resp_agent = 'http://resp_agent.test/'
-
-    @classmethod
-    def setUpClass(cls) -> None:
-        cls.graph_set = GraphSet("https://w3id.org/oc/index/coci/", "./info_dir/", "", False)
-
-    def setUp(self):
-        self.br1 = self.graph_set.add_br(self.resp_agent)
-        self.br2 = self.graph_set.add_br(self.resp_agent)
-        self.ci = self.graph_set.add_ci(self.resp_agent)
-        self.ci_oci = self.graph_set.add_ci(self.resp_agent, res=URIRef('https://w3id.org/oc/index/coci/ci/020010000023601000907630001040258020000010008010559090238044008040338381018136312231227010309014203370037122439026325-020010305093619112227370109090937010437073701020309'))
-
-    def test_has_citing_entity(self):
-        result = self.ci.has_citing_entity(self.br1)
-        self.assertIsNone(result)
-
-        triple = self.ci.res, GraphEntity.iri_has_citing_entity, self.br1.res
-        self.assertIn(triple, self.ci.g)
-
-    def test_create_cited_entity(self):
-        result = self.ci.has_cited_entity(self.br2)
-        self.assertIsNone(result)
-
-        triple = self.ci.res, GraphEntity.iri_has_cited_entity, self.br2.res
-        self.assertIn(triple, self.ci.g)
-
-    def test_has_citation_creation_date(self):
-        with self.subTest("date is '2020-05-25'"):
-            string = "2020-05-25"
-            datatype = XSD.date
-            result = self.ci.has_citation_creation_date(string)
-            self.assertIsNone(result)
-
-            triple = self.ci.res, GraphEntity.iri_has_citation_creation_date, Literal(string, datatype=datatype,
-                                                                                      normalize=False)
-            self.assertIn(triple, self.ci.g)
-        with self.subTest("date is '2020-05'"):
-            string = "2020-05"
-            datatype = XSD.gYearMonth
-            result = self.ci.has_citation_creation_date(string)
-            self.assertIsNone(result)
-
-            triple = self.ci.res, GraphEntity.iri_has_citation_creation_date, Literal(string, datatype=datatype,
-                                                                                      normalize=False)
-            self.assertIn(triple, self.ci.g)
-        with self.subTest("date is '2020'"):
-            string = "2020"
-            datatype = XSD.gYear
-            result = self.ci.has_citation_creation_date(string)
-            self.assertIsNone(result)
-
-            triple = self.ci.res, GraphEntity.iri_has_citation_creation_date, Literal(string, datatype=datatype,
-                                                                                      normalize=False)
-            self.assertIn(triple, self.ci.g)
-
-    def test_has_citation_time_span(self):
-        duration = "P2Y6M5DT12H35M30S"  # 2 years, 6 months, 5 days, 12 hours, 35 minutes, 30 seconds
-        datatype = XSD.duration
-        result = self.ci.has_citation_time_span(duration)
-        self.assertIsNone(result)
-
-        triple = self.ci.res, GraphEntity.iri_has_citation_time_span, Literal(duration, datatype=datatype,
-                                                                              normalize=False)
-        self.assertIn(triple, self.ci.g)
-
-    def test_has_citation_characterization(self):
-        characterization = URIRef("http://test/characterization")
-        result = self.ci.has_citation_characterization(characterization)
-        self.assertIsNone(result)
-
-        triple = self.ci.res, GraphEntity.iri_citation_characterisation, characterization
-        self.assertIn(triple, self.ci.g)
-
-    def test_create_self_citation(self):
-        result = self.ci.create_self_citation()
-        self.assertIsNone(result)
-
-        triple = self.ci.res, RDF.type, GraphEntity.iri_self_citation
-        self.assertIn(triple, self.ci.g)
-
-    def test_create_affiliation_self_citation(self):
-        result = self.ci.create_affiliation_self_citation()
-        self.assertIsNone(result)
-
-        triple = self.ci.res, RDF.type, GraphEntity.iri_affiliation_self_citation
-        self.assertIn(triple, self.ci.g)
-
-    def test_create_author_network_self_citation(self):
-        result = self.ci.create_author_network_self_citation()
-        self.assertIsNone(result)
-
-        triple = self.ci.res, RDF.type, GraphEntity.iri_author_network_self_citation
-        self.assertIn(triple, self.ci.g)
-
-    def test_create_author_self_citation(self):
-        result = self.ci.create_author_self_citation()
-        self.assertIsNone(result)
-
-        triple = self.ci.res, RDF.type, GraphEntity.iri_author_self_citation
-        self.assertIn(triple, self.ci.g)
-
-    def test_create_funder_self_citation(self):
-        result = self.ci.create_funder_self_citation()
-        self.assertIsNone(result)
-
-        triple = self.ci.res, RDF.type, GraphEntity.iri_funder_self_citation
-        self.assertIn(triple, self.ci.g)
-
-    def test_create_journal_self_citation(self):
-        result = self.ci.create_journal_self_citation()
-        self.assertIsNone(result)
-
-        triple = self.ci.res, RDF.type, GraphEntity.iri_journal_self_citation
-        self.assertIn(triple, self.ci.g)
-
-    def test_create_journal_cartel_citation(self):
-        result = self.ci.create_journal_cartel_citation()
-        self.assertIsNone(result)
-
-        triple = self.ci.res, RDF.type, GraphEntity.iri_journal_cartel_citation
-        self.assertIn(triple, self.ci.g)
-
-    def test_create_distant_citation(self):
-        result = self.ci.create_distant_citation()
-        self.assertIsNone(result)
-        triple = self.ci.res, RDF.type, GraphEntity.iri_distant_citation
-        self.assertIn(triple, self.ci.g)
-
-
-if __name__ == '__main__':
-    unittest.main()
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+import unittest
+
+from rdflib import URIRef, XSD, Literal, RDF
+
+from oc_ocdm.graph.graph_entity import GraphEntity
+from oc_ocdm.graph.graph_set import GraphSet
+
+from oc_ocdm.counter_handler.sqlite_counter_handler import SqliteCounterHandler
+
+
+class TestCitation(unittest.TestCase):
+    resp_agent = 'http://resp_agent.test/'
+
+    @classmethod
+    def setUpClass(cls) -> None:
+        cls.graph_set = GraphSet("https://w3id.org/oc/index/coci/", "./info_dir/", "", False)
+
+    def setUp(self):
+        self.br1 = self.graph_set.add_br(self.resp_agent)
+        self.br2 = self.graph_set.add_br(self.resp_agent)
+        self.ci = self.graph_set.add_ci(self.resp_agent)
+        self.ci_oci = self.graph_set.add_ci(self.resp_agent, res=URIRef('https://w3id.org/oc/index/coci/ci/020010000023601000907630001040258020000010008010559090238044008040338381018136312231227010309014203370037122439026325-020010305093619112227370109090937010437073701020309'))
+
+    def test_has_citing_entity(self):
+        result = self.ci.has_citing_entity(self.br1)
+        self.assertIsNone(result)
+
+        triple = self.ci.res, GraphEntity.iri_has_citing_entity, self.br1.res
+        self.assertIn(triple, self.ci.g)
+
+    def test_create_cited_entity(self):
+        result = self.ci.has_cited_entity(self.br2)
+        self.assertIsNone(result)
+
+        triple = self.ci.res, GraphEntity.iri_has_cited_entity, self.br2.res
+        self.assertIn(triple, self.ci.g)
+
+    def test_has_citation_creation_date(self):
+        with self.subTest("date is '2020-05-25'"):
+            string = "2020-05-25"
+            datatype = XSD.date
+            result = self.ci.has_citation_creation_date(string)
+            self.assertIsNone(result)
+
+            triple = self.ci.res, GraphEntity.iri_has_citation_creation_date, Literal(string, datatype=datatype,
+                                                                                      normalize=False)
+            self.assertIn(triple, self.ci.g)
+        with self.subTest("date is '2020-05'"):
+            string = "2020-05"
+            datatype = XSD.gYearMonth
+            result = self.ci.has_citation_creation_date(string)
+            self.assertIsNone(result)
+
+            triple = self.ci.res, GraphEntity.iri_has_citation_creation_date, Literal(string, datatype=datatype,
+                                                                                      normalize=False)
+            self.assertIn(triple, self.ci.g)
+        with self.subTest("date is '2020'"):
+            string = "2020"
+            datatype = XSD.gYear
+            result = self.ci.has_citation_creation_date(string)
+            self.assertIsNone(result)
+
+            triple = self.ci.res, GraphEntity.iri_has_citation_creation_date, Literal(string, datatype=datatype,
+                                                                                      normalize=False)
+            self.assertIn(triple, self.ci.g)
+
+    def test_has_citation_time_span(self):
+        duration = "P2Y6M5DT12H35M30S"  # 2 years, 6 months, 5 days, 12 hours, 35 minutes, 30 seconds
+        datatype = XSD.duration
+        result = self.ci.has_citation_time_span(duration)
+        self.assertIsNone(result)
+
+        triple = self.ci.res, GraphEntity.iri_has_citation_time_span, Literal(duration, datatype=datatype,
+                                                                              normalize=False)
+        self.assertIn(triple, self.ci.g)
+
+    def test_has_citation_characterization(self):
+        characterization = URIRef("http://test/characterization")
+        result = self.ci.has_citation_characterization(characterization)
+        self.assertIsNone(result)
+
+        triple = self.ci.res, GraphEntity.iri_citation_characterisation, characterization
+        self.assertIn(triple, self.ci.g)
+
+    def test_create_self_citation(self):
+        result = self.ci.create_self_citation()
+        self.assertIsNone(result)
+
+        triple = self.ci.res, RDF.type, GraphEntity.iri_self_citation
+        self.assertIn(triple, self.ci.g)
+
+    def test_create_affiliation_self_citation(self):
+        result = self.ci.create_affiliation_self_citation()
+        self.assertIsNone(result)
+
+        triple = self.ci.res, RDF.type, GraphEntity.iri_affiliation_self_citation
+        self.assertIn(triple, self.ci.g)
+
+    def test_create_author_network_self_citation(self):
+        result = self.ci.create_author_network_self_citation()
+        self.assertIsNone(result)
+
+        triple = self.ci.res, RDF.type, GraphEntity.iri_author_network_self_citation
+        self.assertIn(triple, self.ci.g)
+
+    def test_create_author_self_citation(self):
+        result = self.ci.create_author_self_citation()
+        self.assertIsNone(result)
+
+        triple = self.ci.res, RDF.type, GraphEntity.iri_author_self_citation
+        self.assertIn(triple, self.ci.g)
+
+    def test_create_funder_self_citation(self):
+        result = self.ci.create_funder_self_citation()
+        self.assertIsNone(result)
+
+        triple = self.ci.res, RDF.type, GraphEntity.iri_funder_self_citation
+        self.assertIn(triple, self.ci.g)
+
+    def test_create_journal_self_citation(self):
+        result = self.ci.create_journal_self_citation()
+        self.assertIsNone(result)
+
+        triple = self.ci.res, RDF.type, GraphEntity.iri_journal_self_citation
+        self.assertIn(triple, self.ci.g)
+
+    def test_create_journal_cartel_citation(self):
+        result = self.ci.create_journal_cartel_citation()
+        self.assertIsNone(result)
+
+        triple = self.ci.res, RDF.type, GraphEntity.iri_journal_cartel_citation
+        self.assertIn(triple, self.ci.g)
+
+    def test_create_distant_citation(self):
+        result = self.ci.create_distant_citation()
+        self.assertIsNone(result)
+        triple = self.ci.res, RDF.type, GraphEntity.iri_distant_citation
+        self.assertIn(triple, self.ci.g)
+
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/bibliographic/test_discourse_element.py` & `oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/bibliographic/test_discourse_element.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,139 +1,139 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-import unittest
-
-from rdflib import Literal, RDF
-
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.graph.graph_set import GraphSet
-
-
-class TestDiscourseElement(unittest.TestCase):
-    resp_agent = 'http://resp_agent.test/'
-
-    @classmethod
-    def setUpClass(cls) -> None:
-        cls.graph_set = GraphSet("http://test/", "./info_dir/", "", False)
-
-    def setUp(self):
-        self.rp = self.graph_set.add_rp(self.resp_agent)
-        self.pl = self.graph_set.add_pl(self.resp_agent)
-        self.de1 = self.graph_set.add_de(self.resp_agent)
-        self.de2 = self.graph_set.add_de(self.resp_agent)
-
-    def test_has_title(self):
-        title = "DiscourseElement"
-        result = self.de1.has_title(title)
-        self.assertIsNone(result)
-
-        triple = self.de1.res, GraphEntity.iri_title, Literal(title)
-        self.assertIn(triple, self.de1.g)
-
-    def test_contains_discourse_element(self):
-        result = self.de1.contains_discourse_element(self.de2)
-        self.assertIsNone(result)
-
-        triple = self.de1.res, GraphEntity.iri_contains_de, self.de2.res
-        self.assertIn(triple, self.de1.g)
-
-    def test_has_next_de(self):
-        result = self.de1.has_next_de(self.de2)
-        self.assertIsNone(result)
-
-        triple = self.de1.res, GraphEntity.iri_has_next, self.de2.res
-        self.assertIn(triple, self.de1.g)
-
-    def test_is_context_of_rp(self):
-        result = self.de1.is_context_of_rp(self.rp)
-        self.assertIsNone(result)
-
-        triple = self.de1.res, GraphEntity.iri_is_context_of, self.rp.res
-        self.assertIn(triple, self.de1.g)
-
-    def test_is_context_of_pl(self):
-        result = self.de1.is_context_of_pl(self.pl)
-        self.assertIsNone(result)
-
-        triple = self.de1.res, GraphEntity.iri_is_context_of, self.pl.res
-        self.assertIn(triple, self.de1.g)
-
-    def test_has_content(self):
-        content = "Content"
-        result = self.de1.has_content(content)
-        self.assertIsNone(result)
-
-        triple = self.de1.res, GraphEntity.iri_has_content, Literal(content)
-        self.assertIn(triple, self.de1.g)
-
-    def test_create_section(self):
-        result = self.de1.create_section()
-        self.assertIsNone(result)
-
-        triple = self.de1.res, RDF.type, GraphEntity.iri_section
-        self.assertIn(triple, self.de1.g)
-
-    def test_create_section_title(self):
-        result = self.de1.create_section_title()
-        self.assertIsNone(result)
-
-        triple = self.de1.res, RDF.type, GraphEntity.iri_section_title
-        self.assertIn(triple, self.de1.g)
-
-    def test_create_paragraph(self):
-        result = self.de1.create_paragraph()
-        self.assertIsNone(result)
-
-        triple = self.de1.res, RDF.type, GraphEntity.iri_paragraph
-        self.assertIn(triple, self.de1.g)
-
-    def test_create_sentence(self):
-        result = self.de1.create_sentence()
-        self.assertIsNone(result)
-
-        triple = self.de1.res, RDF.type, GraphEntity.iri_sentence
-        self.assertIn(triple, self.de1.g)
-
-    def test_create_text_chunk(self):
-        result = self.de1.create_text_chunk()
-        self.assertIsNone(result)
-
-        triple = self.de1.res, RDF.type, GraphEntity.iri_text_chunk
-        self.assertIn(triple, self.de1.g)
-
-    def test_create_table(self):
-        result = self.de1.create_table()
-        self.assertIsNone(result)
-
-        triple = self.de1.res, RDF.type, GraphEntity.iri_table
-        self.assertIn(triple, self.de1.g)
-
-    def test_create_footnote(self):
-        result = self.de1.create_footnote()
-        self.assertIsNone(result)
-
-        triple = self.de1.res, RDF.type, GraphEntity.iri_footnote
-        self.assertIn(triple, self.de1.g)
-
-    def test_create_caption(self):
-        result = self.de1.create_caption()
-        self.assertIsNone(result)
-
-        triple = self.de1.res, RDF.type, GraphEntity.iri_caption
-        self.assertIn(triple, self.de1.g)
-
-
-if __name__ == '__main__':
-    unittest.main()
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+import unittest
+
+from rdflib import Literal, RDF
+
+from oc_ocdm.graph.graph_entity import GraphEntity
+from oc_ocdm.graph.graph_set import GraphSet
+
+
+class TestDiscourseElement(unittest.TestCase):
+    resp_agent = 'http://resp_agent.test/'
+
+    @classmethod
+    def setUpClass(cls) -> None:
+        cls.graph_set = GraphSet("http://test/", "./info_dir/", "", False)
+
+    def setUp(self):
+        self.rp = self.graph_set.add_rp(self.resp_agent)
+        self.pl = self.graph_set.add_pl(self.resp_agent)
+        self.de1 = self.graph_set.add_de(self.resp_agent)
+        self.de2 = self.graph_set.add_de(self.resp_agent)
+
+    def test_has_title(self):
+        title = "DiscourseElement"
+        result = self.de1.has_title(title)
+        self.assertIsNone(result)
+
+        triple = self.de1.res, GraphEntity.iri_title, Literal(title)
+        self.assertIn(triple, self.de1.g)
+
+    def test_contains_discourse_element(self):
+        result = self.de1.contains_discourse_element(self.de2)
+        self.assertIsNone(result)
+
+        triple = self.de1.res, GraphEntity.iri_contains_de, self.de2.res
+        self.assertIn(triple, self.de1.g)
+
+    def test_has_next_de(self):
+        result = self.de1.has_next_de(self.de2)
+        self.assertIsNone(result)
+
+        triple = self.de1.res, GraphEntity.iri_has_next, self.de2.res
+        self.assertIn(triple, self.de1.g)
+
+    def test_is_context_of_rp(self):
+        result = self.de1.is_context_of_rp(self.rp)
+        self.assertIsNone(result)
+
+        triple = self.de1.res, GraphEntity.iri_is_context_of, self.rp.res
+        self.assertIn(triple, self.de1.g)
+
+    def test_is_context_of_pl(self):
+        result = self.de1.is_context_of_pl(self.pl)
+        self.assertIsNone(result)
+
+        triple = self.de1.res, GraphEntity.iri_is_context_of, self.pl.res
+        self.assertIn(triple, self.de1.g)
+
+    def test_has_content(self):
+        content = "Content"
+        result = self.de1.has_content(content)
+        self.assertIsNone(result)
+
+        triple = self.de1.res, GraphEntity.iri_has_content, Literal(content)
+        self.assertIn(triple, self.de1.g)
+
+    def test_create_section(self):
+        result = self.de1.create_section()
+        self.assertIsNone(result)
+
+        triple = self.de1.res, RDF.type, GraphEntity.iri_section
+        self.assertIn(triple, self.de1.g)
+
+    def test_create_section_title(self):
+        result = self.de1.create_section_title()
+        self.assertIsNone(result)
+
+        triple = self.de1.res, RDF.type, GraphEntity.iri_section_title
+        self.assertIn(triple, self.de1.g)
+
+    def test_create_paragraph(self):
+        result = self.de1.create_paragraph()
+        self.assertIsNone(result)
+
+        triple = self.de1.res, RDF.type, GraphEntity.iri_paragraph
+        self.assertIn(triple, self.de1.g)
+
+    def test_create_sentence(self):
+        result = self.de1.create_sentence()
+        self.assertIsNone(result)
+
+        triple = self.de1.res, RDF.type, GraphEntity.iri_sentence
+        self.assertIn(triple, self.de1.g)
+
+    def test_create_text_chunk(self):
+        result = self.de1.create_text_chunk()
+        self.assertIsNone(result)
+
+        triple = self.de1.res, RDF.type, GraphEntity.iri_text_chunk
+        self.assertIn(triple, self.de1.g)
+
+    def test_create_table(self):
+        result = self.de1.create_table()
+        self.assertIsNone(result)
+
+        triple = self.de1.res, RDF.type, GraphEntity.iri_table
+        self.assertIn(triple, self.de1.g)
+
+    def test_create_footnote(self):
+        result = self.de1.create_footnote()
+        self.assertIsNone(result)
+
+        triple = self.de1.res, RDF.type, GraphEntity.iri_footnote
+        self.assertIn(triple, self.de1.g)
+
+    def test_create_caption(self):
+        result = self.de1.create_caption()
+        self.assertIsNone(result)
+
+        triple = self.de1.res, RDF.type, GraphEntity.iri_caption
+        self.assertIn(triple, self.de1.g)
+
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/bibliographic/test_pointer_list.py` & `oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/bibliographic/test_reference_pointer.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,52 +1,68 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-import unittest
-
-from rdflib import Literal
-
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.graph.graph_set import GraphSet
-
-
-class TestPointerList(unittest.TestCase):
-    resp_agent = 'http://resp_agent.test/'
-
-    @classmethod
-    def setUpClass(cls) -> None:
-        cls.graph_set = GraphSet("http://test/", "./info_dir/", "", False)
-
-    def setUp(self):
-        self.rp = self.graph_set.add_rp(self.resp_agent)
-        self.pl = self.graph_set.add_pl(self.resp_agent)
-
-    def test_has_content(self):
-        content = "Content"
-        result = self.pl.has_content(content)
-        self.assertIsNone(result)
-
-        triple = self.pl.res, GraphEntity.iri_has_content, Literal(content)
-        self.assertIn(triple, self.pl.g)
-
-    def test_contains_element(self):
-        result = self.pl.contains_element(self.rp)
-        self.assertIsNone(result)
-
-        triple = self.pl.res, GraphEntity.iri_has_element, self.rp.res
-        self.assertIn(triple, self.pl.g)
-
-
-if __name__ == '__main__':
-    unittest.main()
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+import unittest
+
+from rdflib import Literal
+
+from oc_ocdm.graph.graph_entity import GraphEntity
+from oc_ocdm.graph.graph_set import GraphSet
+
+
+class TestReferencePointer(unittest.TestCase):
+    resp_agent = 'http://resp_agent.test/'
+
+    @classmethod
+    def setUpClass(cls) -> None:
+        cls.graph_set = GraphSet("http://test/", "./info_dir/", "", False)
+
+    def setUp(self):
+        self.an = self.graph_set.add_an(self.resp_agent)
+        self.rp1 = self.graph_set.add_rp(self.resp_agent)
+        self.rp2 = self.graph_set.add_rp(self.resp_agent)
+        self.be = self.graph_set.add_be(self.resp_agent)
+
+    def test_has_content(self):
+        content = "Content"
+        result = self.rp1.has_content(content)
+        self.assertIsNone(result)
+
+        triple = self.rp1.res, GraphEntity.iri_has_content, Literal(content)
+        self.assertIn(triple, self.rp1.g)
+
+    def test_has_next_rp(self):
+        result = self.rp1.has_next_rp(self.rp2)
+        self.assertIsNone(result)
+
+        triple = self.rp1.res, GraphEntity.iri_has_next, self.rp2.res
+        self.assertIn(triple, self.rp1.g)
+
+    def test_denotes_be(self):
+        result = self.rp1.denotes_be(self.be)
+        self.assertIsNone(result)
+
+        triple = self.rp1.res, GraphEntity.iri_denotes, self.be.res
+        self.assertIn(triple, self.rp1.g)
+
+    def test_has_annotation(self):
+        result = self.rp1.has_annotation(self.an)
+        self.assertIsNone(result)
+
+        triple = self.rp1.res, GraphEntity.iri_has_annotation, self.an.res
+        self.assertIn(triple, self.rp1.g)
+
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/bibliographic/test_reference_annotation.py` & `oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/bibliographic/test_reference_annotation.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,44 +1,44 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-import unittest
-
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.graph.graph_set import GraphSet
-
-
-class TestReferenceAnnotation(unittest.TestCase):
-    resp_agent = 'http://resp_agent.test/'
-
-    @classmethod
-    def setUpClass(cls) -> None:
-        cls.graph_set = GraphSet("http://test/", "./info_dir/", "", False)
-
-    def setUp(self):
-        self.an = self.graph_set.add_an(self.resp_agent)
-        self.br1 = self.graph_set.add_br(self.resp_agent)
-        self.br2 = self.graph_set.add_br(self.resp_agent)
-        self.ci = self.graph_set.add_ci(self.resp_agent)
-
-    def test_has_body_annotation(self):
-        result = self.an.has_body_annotation(self.ci)
-        self.assertIsNone(result)
-
-        triple = self.an.res, GraphEntity.iri_has_body, self.ci.res
-        self.assertIn(triple, self.an.g)
-
-
-if __name__ == '__main__':
-    unittest.main()
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+import unittest
+
+from oc_ocdm.graph.graph_entity import GraphEntity
+from oc_ocdm.graph.graph_set import GraphSet
+
+
+class TestReferenceAnnotation(unittest.TestCase):
+    resp_agent = 'http://resp_agent.test/'
+
+    @classmethod
+    def setUpClass(cls) -> None:
+        cls.graph_set = GraphSet("http://test/", "./info_dir/", "", False)
+
+    def setUp(self):
+        self.an = self.graph_set.add_an(self.resp_agent)
+        self.br1 = self.graph_set.add_br(self.resp_agent)
+        self.br2 = self.graph_set.add_br(self.resp_agent)
+        self.ci = self.graph_set.add_ci(self.resp_agent)
+
+    def test_has_body_annotation(self):
+        result = self.an.has_body_annotation(self.ci)
+        self.assertIsNone(result)
+
+        triple = self.an.res, GraphEntity.iri_has_body, self.ci.res
+        self.assertIn(triple, self.an.g)
+
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/bibliographic/test_resource_embodiment.py` & `oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/bibliographic/test_resource_embodiment.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,82 +1,82 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-import unittest
-
-from rdflib import URIRef, Literal, RDF
-
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.graph.graph_set import GraphSet
-
-
-class TestResourceEmbodiment(unittest.TestCase):
-    resp_agent = 'http://resp_agent.test/'
-
-    @classmethod
-    def setUpClass(cls) -> None:
-        cls.graph_set = GraphSet("http://test/", "./info_dir/", "", False)
-
-    def setUp(self):
-        self.re = self.graph_set.add_re(self.resp_agent)
-
-    def test_has_media_type(self):
-        media_type = URIRef("http://test/MediaType")
-        result = self.re.has_media_type(media_type)
-        self.assertIsNone(result)
-
-        triple = self.re.res, GraphEntity.iri_has_format, media_type
-        self.assertIn(triple, self.re.g)
-
-    def test_has_starting_page(self):
-        starting_page = "15"
-        result = self.re.has_starting_page(starting_page)
-        self.assertIsNone(result)
-
-        triple = self.re.res, GraphEntity.iri_starting_page, Literal(starting_page)
-        self.assertIn(triple, self.re.g)
-
-    def test_has_ending_page(self):
-        ending_page = "288"
-        result = self.re.has_ending_page(ending_page)
-        self.assertIsNone(result)
-
-        triple = self.re.res, GraphEntity.iri_ending_page, Literal(ending_page)
-        self.assertIn(triple, self.re.g)
-
-    def test_has_url(self):
-        url = URIRef("http://test/url")
-        result = self.re.has_url(url)
-        self.assertIsNone(result)
-
-        triple = self.re.res, GraphEntity.iri_has_url, url
-        self.assertIn(triple, self.re.g)
-
-    def test_create_digital_embodiment(self):
-        result = self.re.create_digital_embodiment()
-        self.assertIsNone(result)
-
-        triple = self.re.res, RDF.type, GraphEntity.iri_digital_manifestation
-        self.assertIn(triple, self.re.g)
-
-    def test_create_print_embodiment(self):
-        result = self.re.create_print_embodiment()
-        self.assertIsNone(result)
-
-        triple = self.re.res, RDF.type, GraphEntity.iri_print_object
-        self.assertIn(triple, self.re.g)
-
-
-if __name__ == '__main__':
-    unittest.main()
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+import unittest
+
+from rdflib import URIRef, Literal, RDF
+
+from oc_ocdm.graph.graph_entity import GraphEntity
+from oc_ocdm.graph.graph_set import GraphSet
+
+
+class TestResourceEmbodiment(unittest.TestCase):
+    resp_agent = 'http://resp_agent.test/'
+
+    @classmethod
+    def setUpClass(cls) -> None:
+        cls.graph_set = GraphSet("http://test/", "./info_dir/", "", False)
+
+    def setUp(self):
+        self.re = self.graph_set.add_re(self.resp_agent)
+
+    def test_has_media_type(self):
+        media_type = URIRef("http://test/MediaType")
+        result = self.re.has_media_type(media_type)
+        self.assertIsNone(result)
+
+        triple = self.re.res, GraphEntity.iri_has_format, media_type
+        self.assertIn(triple, self.re.g)
+
+    def test_has_starting_page(self):
+        starting_page = "15"
+        result = self.re.has_starting_page(starting_page)
+        self.assertIsNone(result)
+
+        triple = self.re.res, GraphEntity.iri_starting_page, Literal(starting_page)
+        self.assertIn(triple, self.re.g)
+
+    def test_has_ending_page(self):
+        ending_page = "288"
+        result = self.re.has_ending_page(ending_page)
+        self.assertIsNone(result)
+
+        triple = self.re.res, GraphEntity.iri_ending_page, Literal(ending_page)
+        self.assertIn(triple, self.re.g)
+
+    def test_has_url(self):
+        url = URIRef("http://test/url")
+        result = self.re.has_url(url)
+        self.assertIsNone(result)
+
+        triple = self.re.res, GraphEntity.iri_has_url, url
+        self.assertIn(triple, self.re.g)
+
+    def test_create_digital_embodiment(self):
+        result = self.re.create_digital_embodiment()
+        self.assertIsNone(result)
+
+        triple = self.re.res, RDF.type, GraphEntity.iri_digital_manifestation
+        self.assertIn(triple, self.re.g)
+
+    def test_create_print_embodiment(self):
+        result = self.re.create_print_embodiment()
+        self.assertIsNone(result)
+
+        triple = self.re.res, RDF.type, GraphEntity.iri_print_object
+        self.assertIn(triple, self.re.g)
+
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/test_bibliographic_entity.py` & `oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/test_bibliographic_entity.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,77 +1,77 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-import unittest
-
-from rdflib import Namespace
-
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.graph.graph_set import GraphSet
-
-
-class TestBibliographicEntity(unittest.TestCase):
-    resp_agent = 'http://resp_agent.test/'
-
-    @classmethod
-    def setUpClass(cls) -> None:
-        cls.graph_set = GraphSet("http://test/", "./info_dir/", "", False)
-
-    def setUp(self):
-        self.entity = self.graph_set.add_ar(self.resp_agent)
-        self.identifier = self.graph_set.add_id(self.resp_agent)
-
-    def test_has_identifier(self):
-        result = self.entity.has_identifier(self.identifier)
-        self.assertIsNone(result)
-
-        triple = self.entity.res, GraphEntity.iri_has_identifier, self.identifier.res
-        self.assertIn(triple, self.entity.g)
-
-    def test_remove_duplicated_identifiers(self):
-        id1 = self.graph_set.add_id(self.resp_agent)
-        id2 = self.graph_set.add_id(self.resp_agent)
-        id3 = self.graph_set.add_id(self.resp_agent)
-        id4 = self.graph_set.add_id(self.resp_agent)
-
-        id1.create_issn('1111-2222')
-        id2.create_doi('1111-2222')
-        id3.create_issn('3333-4444')
-        id4.create_issn('1111-2222')
-
-        self.entity.has_identifier(id1)
-        self.entity.has_identifier(id2)
-        self.entity.has_identifier(id3)
-        self.entity.has_identifier(id4)
-
-        result = self.entity.remove_duplicated_identifiers()
-
-        self.assertIsNone(result)
-
-        id_list = self.entity.get_identifiers()
-        self.assertEqual(3, len(id_list))
-
-        # Tuples were used down below inside the sets because they're are hashable (since they're immutable):
-        id_list_set = {(i.get_scheme(), i.get_literal_value()) for i in id_list}
-
-        datacite = Namespace("http://purl.org/spar/datacite/")
-        non_duplicated_ids = {(datacite.issn, '1111-2222'),
-                              (datacite.issn, '3333-4444'),
-                              (datacite.doi, '1111-2222')}
-
-        self.assertSetEqual(id_list_set, non_duplicated_ids)
-
-
-if __name__ == '__main__':
-    unittest.main()
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+import unittest
+
+from rdflib import Namespace
+
+from oc_ocdm.graph.graph_entity import GraphEntity
+from oc_ocdm.graph.graph_set import GraphSet
+
+
+class TestBibliographicEntity(unittest.TestCase):
+    resp_agent = 'http://resp_agent.test/'
+
+    @classmethod
+    def setUpClass(cls) -> None:
+        cls.graph_set = GraphSet("http://test/", "./info_dir/", "", False)
+
+    def setUp(self):
+        self.entity = self.graph_set.add_ar(self.resp_agent)
+        self.identifier = self.graph_set.add_id(self.resp_agent)
+
+    def test_has_identifier(self):
+        result = self.entity.has_identifier(self.identifier)
+        self.assertIsNone(result)
+
+        triple = self.entity.res, GraphEntity.iri_has_identifier, self.identifier.res
+        self.assertIn(triple, self.entity.g)
+
+    def test_remove_duplicated_identifiers(self):
+        id1 = self.graph_set.add_id(self.resp_agent)
+        id2 = self.graph_set.add_id(self.resp_agent)
+        id3 = self.graph_set.add_id(self.resp_agent)
+        id4 = self.graph_set.add_id(self.resp_agent)
+
+        id1.create_issn('1111-2222')
+        id2.create_doi('1111-2222')
+        id3.create_issn('3333-4444')
+        id4.create_issn('1111-2222')
+
+        self.entity.has_identifier(id1)
+        self.entity.has_identifier(id2)
+        self.entity.has_identifier(id3)
+        self.entity.has_identifier(id4)
+
+        result = self.entity.remove_duplicated_identifiers()
+
+        self.assertIsNone(result)
+
+        id_list = self.entity.get_identifiers()
+        self.assertEqual(3, len(id_list))
+
+        # Tuples were used down below inside the sets because they're are hashable (since they're immutable):
+        id_list_set = {(i.get_scheme(), i.get_literal_value()) for i in id_list}
+
+        datacite = Namespace("http://purl.org/spar/datacite/")
+        non_duplicated_ids = {(datacite.issn, '1111-2222'),
+                              (datacite.issn, '3333-4444'),
+                              (datacite.doi, '1111-2222')}
+
+        self.assertSetEqual(id_list_set, non_duplicated_ids)
+
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/graph/entities/test_identifier.py` & `oc_ocdm-8.1.0/oc_ocdm/test/graph/entities/test_identifier.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,201 +1,201 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-import unittest
-
-from rdflib import Literal
-
-from oc_ocdm.graph.graph_entity import GraphEntity
-from oc_ocdm.graph.graph_set import GraphSet
-
-
-class TestIdentifier(unittest.TestCase):
-    resp_agent = 'http://resp_agent.test/'
-
-    @classmethod
-    def setUpClass(cls) -> None:
-        cls.graph_set = GraphSet("http://test/", "./info_dir/", "", False)
-
-    def setUp(self):
-        self.identifier = self.graph_set.add_id(self.resp_agent)
-
-    def test_create_orcid(self):
-        orcid = "abcdefghi"
-        result = self.identifier.create_orcid(orcid)
-        self.assertIsNone(result)
-
-        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(orcid)
-        self.assertIn(triple, self.identifier.g)
-
-        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_orcid
-        self.assertIn(triple, self.identifier.g)
-
-    def test_create_doi(self):
-        doi = "abcdefghi"
-        result = self.identifier.create_doi(doi)
-        self.assertIsNone(result)
-
-        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(doi)
-        self.assertIn(triple, self.identifier.g)
-
-        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_doi
-        self.assertIn(triple, self.identifier.g)
-
-    def test_create_pmid(self):
-        pmid = "abcdefghi"
-        result = self.identifier.create_pmid(pmid)
-        self.assertIsNone(result)
-
-        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(pmid)
-        self.assertIn(triple, self.identifier.g)
-
-        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_pmid
-        self.assertIn(triple, self.identifier.g)
-
-    def test_create_pmcid(self):
-        pmcid = "abcdefghi"
-        result = self.identifier.create_pmcid(pmcid)
-        self.assertIsNone(result)
-
-        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(pmcid)
-        self.assertIn(triple, self.identifier.g)
-
-        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_pmcid
-        self.assertIn(triple, self.identifier.g)
-
-    def test_create_issn(self):
-        issn = "abcdefghi"
-        result = self.identifier.create_issn(issn)
-        self.assertIsNone(result)
-
-        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(issn)
-        self.assertIn(triple, self.identifier.g)
-
-        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_issn
-        self.assertIn(triple, self.identifier.g)
-
-    def test_create_isbn(self):
-        isbn = "abcdefghi"
-        result = self.identifier.create_isbn(isbn)
-        self.assertIsNone(result)
-
-        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(isbn)
-        self.assertIn(triple, self.identifier.g)
-
-        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_isbn
-        self.assertIn(triple, self.identifier.g)
-
-    def test_create_url(self):
-        url = "abcdefghi"
-        result = self.identifier.create_url(url)
-        self.assertIsNone(result)
-
-        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(url)
-        self.assertIn(triple, self.identifier.g)
-
-        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_url
-        self.assertIn(triple, self.identifier.g)
-
-    def test_create_xpath(self):
-        xpath = "abcdefghi"
-        result = self.identifier.create_xpath(xpath)
-        self.assertIsNone(result)
-
-        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(xpath)
-        self.assertIn(triple, self.identifier.g)
-
-        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_xpath
-        self.assertIn(triple, self.identifier.g)
-
-    def test_create_intrepid(self):
-        intrepid = "abcdefghi"
-        result = self.identifier.create_intrepid(intrepid)
-        self.assertIsNone(result)
-
-        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(intrepid)
-        self.assertIn(triple, self.identifier.g)
-
-        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_intrepid
-        self.assertIn(triple, self.identifier.g)
-
-    def test_create_xmlid(self):
-        xmlid = "abcdefghi"
-        result = self.identifier.create_xmlid(xmlid)
-        self.assertIsNone(result)
-
-        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(xmlid)
-        self.assertIn(triple, self.identifier.g)
-
-        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_xmlid
-        self.assertIn(triple, self.identifier.g)
-
-    def test_create_wikidata(self):
-        wikidata = "abcdefghi"
-        result = self.identifier.create_wikidata(wikidata)
-        self.assertIsNone(result)
-
-        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(wikidata)
-        self.assertIn(triple, self.identifier.g)
-
-        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_wikidata
-        self.assertIn(triple, self.identifier.g)
-
-    def test_create_wikipedia(self):
-        wikipedia = "abcdefghi"
-        result = self.identifier.create_wikipedia(wikipedia)
-        self.assertIsNone(result)
-
-        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(wikipedia)
-        self.assertIn(triple, self.identifier.g)
-
-        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_wikipedia
-        self.assertIn(triple, self.identifier.g)
-
-    def test_create_crossref(self):
-        crossref = "abcdefghi"
-        result = self.identifier.create_crossref(crossref)
-        self.assertIsNone(result)
-
-        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(crossref)
-        self.assertIn(triple, self.identifier.g)
-
-        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_crossref
-        self.assertIn(triple, self.identifier.g)
-
-    def test_create_datacite(self):
-        datacite = "332"
-        result = self.identifier.create_datacite(datacite)
-        self.assertIsNone(result)
-
-        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(datacite)
-        self.assertIn(triple, self.identifier.g)
-
-        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_datacite
-        self.assertIn(triple, self.identifier.g)
-
-    def test_create_viaf(self):
-        viaf = "abcdefghi"
-        result = self.identifier.create_viaf(viaf)
-        self.assertIsNone(result)
-
-        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(viaf)
-        self.assertIn(triple, self.identifier.g)
-
-        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_viaf
-        self.assertIn(triple, self.identifier.g)
-
-
-if __name__ == '__main__':
-    unittest.main()
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+import unittest
+
+from rdflib import Literal
+
+from oc_ocdm.graph.graph_entity import GraphEntity
+from oc_ocdm.graph.graph_set import GraphSet
+
+
+class TestIdentifier(unittest.TestCase):
+    resp_agent = 'http://resp_agent.test/'
+
+    @classmethod
+    def setUpClass(cls) -> None:
+        cls.graph_set = GraphSet("http://test/", "./info_dir/", "", False)
+
+    def setUp(self):
+        self.identifier = self.graph_set.add_id(self.resp_agent)
+
+    def test_create_orcid(self):
+        orcid = "abcdefghi"
+        result = self.identifier.create_orcid(orcid)
+        self.assertIsNone(result)
+
+        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(orcid)
+        self.assertIn(triple, self.identifier.g)
+
+        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_orcid
+        self.assertIn(triple, self.identifier.g)
+
+    def test_create_doi(self):
+        doi = "abcdefghi"
+        result = self.identifier.create_doi(doi)
+        self.assertIsNone(result)
+
+        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(doi)
+        self.assertIn(triple, self.identifier.g)
+
+        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_doi
+        self.assertIn(triple, self.identifier.g)
+
+    def test_create_pmid(self):
+        pmid = "abcdefghi"
+        result = self.identifier.create_pmid(pmid)
+        self.assertIsNone(result)
+
+        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(pmid)
+        self.assertIn(triple, self.identifier.g)
+
+        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_pmid
+        self.assertIn(triple, self.identifier.g)
+
+    def test_create_pmcid(self):
+        pmcid = "abcdefghi"
+        result = self.identifier.create_pmcid(pmcid)
+        self.assertIsNone(result)
+
+        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(pmcid)
+        self.assertIn(triple, self.identifier.g)
+
+        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_pmcid
+        self.assertIn(triple, self.identifier.g)
+
+    def test_create_issn(self):
+        issn = "abcdefghi"
+        result = self.identifier.create_issn(issn)
+        self.assertIsNone(result)
+
+        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(issn)
+        self.assertIn(triple, self.identifier.g)
+
+        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_issn
+        self.assertIn(triple, self.identifier.g)
+
+    def test_create_isbn(self):
+        isbn = "abcdefghi"
+        result = self.identifier.create_isbn(isbn)
+        self.assertIsNone(result)
+
+        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(isbn)
+        self.assertIn(triple, self.identifier.g)
+
+        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_isbn
+        self.assertIn(triple, self.identifier.g)
+
+    def test_create_url(self):
+        url = "abcdefghi"
+        result = self.identifier.create_url(url)
+        self.assertIsNone(result)
+
+        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(url)
+        self.assertIn(triple, self.identifier.g)
+
+        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_url
+        self.assertIn(triple, self.identifier.g)
+
+    def test_create_xpath(self):
+        xpath = "abcdefghi"
+        result = self.identifier.create_xpath(xpath)
+        self.assertIsNone(result)
+
+        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(xpath)
+        self.assertIn(triple, self.identifier.g)
+
+        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_xpath
+        self.assertIn(triple, self.identifier.g)
+
+    def test_create_intrepid(self):
+        intrepid = "abcdefghi"
+        result = self.identifier.create_intrepid(intrepid)
+        self.assertIsNone(result)
+
+        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(intrepid)
+        self.assertIn(triple, self.identifier.g)
+
+        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_intrepid
+        self.assertIn(triple, self.identifier.g)
+
+    def test_create_xmlid(self):
+        xmlid = "abcdefghi"
+        result = self.identifier.create_xmlid(xmlid)
+        self.assertIsNone(result)
+
+        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(xmlid)
+        self.assertIn(triple, self.identifier.g)
+
+        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_xmlid
+        self.assertIn(triple, self.identifier.g)
+
+    def test_create_wikidata(self):
+        wikidata = "abcdefghi"
+        result = self.identifier.create_wikidata(wikidata)
+        self.assertIsNone(result)
+
+        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(wikidata)
+        self.assertIn(triple, self.identifier.g)
+
+        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_wikidata
+        self.assertIn(triple, self.identifier.g)
+
+    def test_create_wikipedia(self):
+        wikipedia = "abcdefghi"
+        result = self.identifier.create_wikipedia(wikipedia)
+        self.assertIsNone(result)
+
+        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(wikipedia)
+        self.assertIn(triple, self.identifier.g)
+
+        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_wikipedia
+        self.assertIn(triple, self.identifier.g)
+
+    def test_create_crossref(self):
+        crossref = "abcdefghi"
+        result = self.identifier.create_crossref(crossref)
+        self.assertIsNone(result)
+
+        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(crossref)
+        self.assertIn(triple, self.identifier.g)
+
+        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_crossref
+        self.assertIn(triple, self.identifier.g)
+
+    def test_create_datacite(self):
+        datacite = "332"
+        result = self.identifier.create_datacite(datacite)
+        self.assertIsNone(result)
+
+        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(datacite)
+        self.assertIn(triple, self.identifier.g)
+
+        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_datacite
+        self.assertIn(triple, self.identifier.g)
+
+    def test_create_viaf(self):
+        viaf = "abcdefghi"
+        result = self.identifier.create_viaf(viaf)
+        self.assertIsNone(result)
+
+        triple = self.identifier.res, GraphEntity.iri_has_literal_value, Literal(viaf)
+        self.assertIn(triple, self.identifier.g)
+
+        triple = self.identifier.res, GraphEntity.iri_uses_identifier_scheme, GraphEntity.iri_viaf
+        self.assertIn(triple, self.identifier.g)
+
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/graph/test_graph_entity.py` & `oc_ocdm-8.1.0/oc_ocdm/test/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,24 +1,15 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-import unittest
-
-
-class TestGraphEntity(unittest.TestCase):
-    pass
-
-
-if __name__ == '__main__':
-    unittest.main()
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/metadata/__init__.py` & `oc_ocdm-8.1.0/oc_ocdm/test/resources/__init__.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,15 +1,15 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/metadata/entities/__init__.py` & `oc_ocdm-8.1.0/oc_ocdm/test/storer/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,15 +1,15 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright 2022 Arcangelo Massari <arcangelo.massari@unibo.it>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED 'AS IS' AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/metadata/entities/test_dataset.py` & `oc_ocdm-8.1.0/oc_ocdm/test/metadata/entities/test_dataset.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,118 +1,118 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-import unittest
-
-from rdflib import URIRef, Literal, XSD
-
-from oc_ocdm.metadata.metadata_set import MetadataSet
-from oc_ocdm.metadata.metadata_entity import MetadataEntity
-
-
-class TestDataset(unittest.TestCase):
-    resp_agent = 'http://resp_agent.test/'
-
-    @classmethod
-    def setUpClass(cls) -> None:
-        cls.metadata_set = MetadataSet("http://test/", "./info_dir/", False)
-
-    def setUp(self):
-        self.dataset = self.metadata_set.add_dataset("ocdmTest", self.resp_agent)
-        self.sub_dataset = self.metadata_set.add_dataset("subDataset", self.resp_agent)
-        self.di = self.metadata_set.add_di("ocdmTest", self.resp_agent)
-
-    def test_has_title(self):
-        title = "Resource"
-        result = self.dataset.has_title(title)
-        self.assertIsNone(result)
-
-        triple = self.dataset.res, MetadataEntity.iri_title, Literal(title)
-        self.assertIn(triple, self.dataset.g)
-
-    def test_has_description(self):
-        description = "Resource"
-        result = self.dataset.has_description(description)
-        self.assertIsNone(result)
-
-        triple = self.dataset.res, MetadataEntity.iri_description, Literal(description)
-        self.assertIn(triple, self.dataset.g)
-
-    def test_has_publication_date(self):
-        string = "2020-05-25T12:12:00"
-        result = self.dataset.has_publication_date(string)
-        self.assertIsNone(result)
-
-        triple = self.dataset.res, MetadataEntity.iri_issued, Literal(string, datatype=XSD.dateTime,
-                                                                      normalize=False)
-        self.assertIn(triple, self.dataset.g)
-
-    def test_has_modification_date(self):
-        string = "2020-05-25T12:12:00"
-        result = self.dataset.has_modification_date(string)
-        self.assertIsNone(result)
-
-        triple = self.dataset.res, MetadataEntity.iri_modified, Literal(string, datatype=XSD.dateTime,
-                                                                        normalize=False)
-        self.assertIn(triple, self.dataset.g)
-
-    def test_has_keyword(self):
-        keyword = "Resource"
-        result = self.dataset.has_keyword(keyword)
-        self.assertIsNone(result)
-
-        triple = self.dataset.res, MetadataEntity.iri_keyword, Literal(keyword)
-        self.assertIn(triple, self.dataset.g)
-
-    def test_has_subject(self):
-        subject = URIRef("http://subject/")
-        result = self.dataset.has_subject(subject)
-        self.assertIsNone(result)
-
-        triple = self.dataset.res, MetadataEntity.iri_subject, subject
-        self.assertIn(triple, self.dataset.g)
-
-    def test_has_landing_page(self):
-        page = URIRef("http://landing.page/")
-        result = self.dataset.has_landing_page(page)
-        self.assertIsNone(result)
-
-        triple = self.dataset.res, MetadataEntity.iri_landing_page, page
-        self.assertIn(triple, self.dataset.g)
-
-    def test_has_sub_dataset(self):
-        result = self.dataset.has_sub_dataset(self.sub_dataset)
-        self.assertIsNone(result)
-
-        triple = self.dataset.res, MetadataEntity.iri_subset, self.sub_dataset.res
-        self.assertIn(triple, self.dataset.g)
-
-    def test_has_sparql_endpoint(self):
-        endpoint = URIRef("http://sparql/")
-        result = self.dataset.has_sparql_endpoint(endpoint)
-        self.assertIsNone(result)
-
-        triple = self.dataset.res, MetadataEntity.iri_sparql_endpoint, endpoint
-        self.assertIn(triple, self.dataset.g)
-
-    def test_has_distribution(self):
-        result = self.dataset.has_distribution(self.di)
-        self.assertIsNone(result)
-
-        triple = self.dataset.res, MetadataEntity.iri_distribution, self.di.res
-        self.assertIn(triple, self.dataset.g)
-
-
-if __name__ == '__main__':
-    unittest.main()
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+import unittest
+
+from rdflib import URIRef, Literal, XSD
+
+from oc_ocdm.metadata.metadata_set import MetadataSet
+from oc_ocdm.metadata.metadata_entity import MetadataEntity
+
+
+class TestDataset(unittest.TestCase):
+    resp_agent = 'http://resp_agent.test/'
+
+    @classmethod
+    def setUpClass(cls) -> None:
+        cls.metadata_set = MetadataSet("http://test/", "./info_dir/", False)
+
+    def setUp(self):
+        self.dataset = self.metadata_set.add_dataset("ocdmTest", self.resp_agent)
+        self.sub_dataset = self.metadata_set.add_dataset("subDataset", self.resp_agent)
+        self.di = self.metadata_set.add_di("ocdmTest", self.resp_agent)
+
+    def test_has_title(self):
+        title = "Resource"
+        result = self.dataset.has_title(title)
+        self.assertIsNone(result)
+
+        triple = self.dataset.res, MetadataEntity.iri_title, Literal(title)
+        self.assertIn(triple, self.dataset.g)
+
+    def test_has_description(self):
+        description = "Resource"
+        result = self.dataset.has_description(description)
+        self.assertIsNone(result)
+
+        triple = self.dataset.res, MetadataEntity.iri_description, Literal(description)
+        self.assertIn(triple, self.dataset.g)
+
+    def test_has_publication_date(self):
+        string = "2020-05-25T12:12:00"
+        result = self.dataset.has_publication_date(string)
+        self.assertIsNone(result)
+
+        triple = self.dataset.res, MetadataEntity.iri_issued, Literal(string, datatype=XSD.dateTime,
+                                                                      normalize=False)
+        self.assertIn(triple, self.dataset.g)
+
+    def test_has_modification_date(self):
+        string = "2020-05-25T12:12:00"
+        result = self.dataset.has_modification_date(string)
+        self.assertIsNone(result)
+
+        triple = self.dataset.res, MetadataEntity.iri_modified, Literal(string, datatype=XSD.dateTime,
+                                                                        normalize=False)
+        self.assertIn(triple, self.dataset.g)
+
+    def test_has_keyword(self):
+        keyword = "Resource"
+        result = self.dataset.has_keyword(keyword)
+        self.assertIsNone(result)
+
+        triple = self.dataset.res, MetadataEntity.iri_keyword, Literal(keyword)
+        self.assertIn(triple, self.dataset.g)
+
+    def test_has_subject(self):
+        subject = URIRef("http://subject/")
+        result = self.dataset.has_subject(subject)
+        self.assertIsNone(result)
+
+        triple = self.dataset.res, MetadataEntity.iri_subject, subject
+        self.assertIn(triple, self.dataset.g)
+
+    def test_has_landing_page(self):
+        page = URIRef("http://landing.page/")
+        result = self.dataset.has_landing_page(page)
+        self.assertIsNone(result)
+
+        triple = self.dataset.res, MetadataEntity.iri_landing_page, page
+        self.assertIn(triple, self.dataset.g)
+
+    def test_has_sub_dataset(self):
+        result = self.dataset.has_sub_dataset(self.sub_dataset)
+        self.assertIsNone(result)
+
+        triple = self.dataset.res, MetadataEntity.iri_subset, self.sub_dataset.res
+        self.assertIn(triple, self.dataset.g)
+
+    def test_has_sparql_endpoint(self):
+        endpoint = URIRef("http://sparql/")
+        result = self.dataset.has_sparql_endpoint(endpoint)
+        self.assertIsNone(result)
+
+        triple = self.dataset.res, MetadataEntity.iri_sparql_endpoint, endpoint
+        self.assertIn(triple, self.dataset.g)
+
+    def test_has_distribution(self):
+        result = self.dataset.has_distribution(self.di)
+        self.assertIsNone(result)
+
+        triple = self.dataset.res, MetadataEntity.iri_distribution, self.di.res
+        self.assertIn(triple, self.dataset.g)
+
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/metadata/entities/test_distribution.py` & `oc_ocdm-8.1.0/oc_ocdm/test/metadata/entities/test_distribution.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,94 +1,94 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-import unittest
-
-from rdflib import URIRef, Literal, XSD
-
-from oc_ocdm.metadata.metadata_set import MetadataSet
-from oc_ocdm.metadata.metadata_entity import MetadataEntity
-
-
-class TestBibliographicResource(unittest.TestCase):
-    resp_agent = 'http://resp_agent.test/'
-
-    @classmethod
-    def setUpClass(cls) -> None:
-        cls.metadata_set = MetadataSet("http://test/", "./info_dir/", False)
-
-    def setUp(self):
-        self.di = self.metadata_set.add_di("ocdmTest", self.resp_agent)
-
-    def test_has_title(self):
-        title = "Resource"
-        result = self.di.has_title(title)
-        self.assertIsNone(result)
-
-        triple = self.di.res, MetadataEntity.iri_title, Literal(title)
-        self.assertIn(triple, self.di.g)
-
-    def test_has_description(self):
-        description = "Resource"
-        result = self.di.has_description(description)
-        self.assertIsNone(result)
-
-        triple = self.di.res, MetadataEntity.iri_description, Literal(description)
-        self.assertIn(triple, self.di.g)
-
-    def test_has_publication_date(self):
-        string = "2020-05-25T12:12:00"
-        result = self.di.has_publication_date(string)
-        self.assertIsNone(result)
-
-        triple = self.di.res, MetadataEntity.iri_issued, Literal(string, datatype=XSD.dateTime,
-                                                                 normalize=False)
-        self.assertIn(triple, self.di.g)
-
-    def test_has_license(self):
-        license = URIRef("http://license/")
-        result = self.di.has_license(license)
-        self.assertIsNone(result)
-
-        triple = self.di.res, MetadataEntity.iri_license, license
-        self.assertIn(triple, self.di.g)
-
-    def test_has_download_url(self):
-        download_url = URIRef("http://download.here/")
-        result = self.di.has_download_url(download_url)
-        self.assertIsNone(result)
-
-        triple = self.di.res, MetadataEntity.iri_download_url, download_url
-        self.assertIn(triple, self.di.g)
-
-    def test_has_media_type(self):
-        media_type = URIRef("http://media.type/")
-        result = self.di.has_media_type(media_type)
-        self.assertIsNone(result)
-
-        triple = self.di.res, MetadataEntity.iri_media_type, media_type
-        self.assertIn(triple, self.di.g)
-
-    def test_has_byte_size(self):
-        byte_size = "1024"
-        result = self.di.has_byte_size(byte_size)
-        self.assertIsNone(result)
-
-        triple = self.di.res, MetadataEntity.iri_byte_size, Literal(byte_size, datatype=XSD.decimal,
-                                                                    normalize=False)
-        self.assertIn(triple, self.di.g)
-
-
-if __name__ == '__main__':
-    unittest.main()
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+import unittest
+
+from rdflib import URIRef, Literal, XSD
+
+from oc_ocdm.metadata.metadata_set import MetadataSet
+from oc_ocdm.metadata.metadata_entity import MetadataEntity
+
+
+class TestBibliographicResource(unittest.TestCase):
+    resp_agent = 'http://resp_agent.test/'
+
+    @classmethod
+    def setUpClass(cls) -> None:
+        cls.metadata_set = MetadataSet("http://test/", "./info_dir/", False)
+
+    def setUp(self):
+        self.di = self.metadata_set.add_di("ocdmTest", self.resp_agent)
+
+    def test_has_title(self):
+        title = "Resource"
+        result = self.di.has_title(title)
+        self.assertIsNone(result)
+
+        triple = self.di.res, MetadataEntity.iri_title, Literal(title)
+        self.assertIn(triple, self.di.g)
+
+    def test_has_description(self):
+        description = "Resource"
+        result = self.di.has_description(description)
+        self.assertIsNone(result)
+
+        triple = self.di.res, MetadataEntity.iri_description, Literal(description)
+        self.assertIn(triple, self.di.g)
+
+    def test_has_publication_date(self):
+        string = "2020-05-25T12:12:00"
+        result = self.di.has_publication_date(string)
+        self.assertIsNone(result)
+
+        triple = self.di.res, MetadataEntity.iri_issued, Literal(string, datatype=XSD.dateTime,
+                                                                 normalize=False)
+        self.assertIn(triple, self.di.g)
+
+    def test_has_license(self):
+        license = URIRef("http://license/")
+        result = self.di.has_license(license)
+        self.assertIsNone(result)
+
+        triple = self.di.res, MetadataEntity.iri_license, license
+        self.assertIn(triple, self.di.g)
+
+    def test_has_download_url(self):
+        download_url = URIRef("http://download.here/")
+        result = self.di.has_download_url(download_url)
+        self.assertIsNone(result)
+
+        triple = self.di.res, MetadataEntity.iri_download_url, download_url
+        self.assertIn(triple, self.di.g)
+
+    def test_has_media_type(self):
+        media_type = URIRef("http://media.type/")
+        result = self.di.has_media_type(media_type)
+        self.assertIsNone(result)
+
+        triple = self.di.res, MetadataEntity.iri_media_type, media_type
+        self.assertIn(triple, self.di.g)
+
+    def test_has_byte_size(self):
+        byte_size = "1024"
+        result = self.di.has_byte_size(byte_size)
+        self.assertIsNone(result)
+
+        triple = self.di.res, MetadataEntity.iri_byte_size, Literal(byte_size, datatype=XSD.decimal,
+                                                                    normalize=False)
+        self.assertIn(triple, self.di.g)
+
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/metadata/test_metadata_set.py` & `oc_ocdm-8.1.0/oc_ocdm/test/metadata/test_metadata_set.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,73 +1,73 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-import unittest
-
-from rdflib import Graph, BNode
-
-from oc_ocdm.graph.graph_set import GraphSet
-
-from oc_ocdm.metadata.metadata_set import MetadataSet
-from oc_ocdm.metadata.entities.dataset import Dataset
-from oc_ocdm.metadata.entities.distribution import Distribution
-
-
-class TestMetadataSet(unittest.TestCase):
-    resp_agent = 'http://resp_agent.test/'
-
-    def setUp(self):
-        self.metadata_set = MetadataSet("http://test/", "./info_dir/", False)
-
-    def test_get_entity(self):
-        di = self.metadata_set.add_di("ocdmTest", self.resp_agent)
-        ref = di.res
-        result = self.metadata_set.get_entity(ref)
-        self.assertIsNotNone(result)
-        self.assertIs(result, di)
-
-    def test_add_dataset(self):
-        dataset = self.metadata_set.add_dataset("ocdmTest", self.resp_agent)
-
-        self.assertIsNotNone(dataset)
-        self.assertIsInstance(dataset, Dataset)
-        self.assertIsInstance(dataset.g.identifier, BNode)
-
-    def test_add_di(self):
-        di = self.metadata_set.add_di("ocdmTest", self.resp_agent)
-
-        self.assertIsNotNone(di)
-        self.assertIsInstance(di, Distribution)
-        self.assertIsInstance(di.g.identifier, BNode)
-
-    def test_graphs(self):
-        count = 10
-        for i in range(count):
-            self.metadata_set.add_di("ocdmTest", self.resp_agent)
-        result = self.metadata_set.graphs()
-        self.assertIsNotNone(result)
-        self.assertEqual(len(result), count)
-        for graph in result:
-            self.assertIsInstance(graph, Graph)
-
-    def test_get_graph_iri(self):
-        ar = self.metadata_set.add_dataset("ocdmTest", self.resp_agent)
-        iri = str(ar.g.identifier)
-        result = GraphSet.get_graph_iri(ar.g)
-        self.assertIsNotNone(result)
-        self.assertEqual(iri, result)
-
-
-if __name__ == '__main__':
-    unittest.main()
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+import unittest
+
+from rdflib import Graph, BNode
+
+from oc_ocdm.graph.graph_set import GraphSet
+
+from oc_ocdm.metadata.metadata_set import MetadataSet
+from oc_ocdm.metadata.entities.dataset import Dataset
+from oc_ocdm.metadata.entities.distribution import Distribution
+
+
+class TestMetadataSet(unittest.TestCase):
+    resp_agent = 'http://resp_agent.test/'
+
+    def setUp(self):
+        self.metadata_set = MetadataSet("http://test/", "./info_dir/", False)
+
+    def test_get_entity(self):
+        di = self.metadata_set.add_di("ocdmTest", self.resp_agent)
+        ref = di.res
+        result = self.metadata_set.get_entity(ref)
+        self.assertIsNotNone(result)
+        self.assertIs(result, di)
+
+    def test_add_dataset(self):
+        dataset = self.metadata_set.add_dataset("ocdmTest", self.resp_agent)
+
+        self.assertIsNotNone(dataset)
+        self.assertIsInstance(dataset, Dataset)
+        self.assertIsInstance(dataset.g.identifier, BNode)
+
+    def test_add_di(self):
+        di = self.metadata_set.add_di("ocdmTest", self.resp_agent)
+
+        self.assertIsNotNone(di)
+        self.assertIsInstance(di, Distribution)
+        self.assertIsInstance(di.g.identifier, BNode)
+
+    def test_graphs(self):
+        count = 10
+        for i in range(count):
+            self.metadata_set.add_di("ocdmTest", self.resp_agent)
+        result = self.metadata_set.graphs()
+        self.assertIsNotNone(result)
+        self.assertEqual(len(result), count)
+        for graph in result:
+            self.assertIsInstance(graph, Graph)
+
+    def test_get_graph_iri(self):
+        ar = self.metadata_set.add_dataset("ocdmTest", self.resp_agent)
+        iri = str(ar.g.identifier)
+        result = GraphSet.get_graph_iri(ar.g)
+        self.assertIsNotNone(result)
+        self.assertEqual(iri, result)
+
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/prov/entities/test_snapshot_entity.py` & `oc_ocdm-8.1.0/oc_ocdm/test/prov/entities/test_snapshot_entity.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,107 +1,107 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-import unittest
-
-from rdflib import URIRef, Literal, XSD
-
-from oc_ocdm.graph.graph_set import GraphSet
-from oc_ocdm.prov.prov_entity import ProvEntity
-from oc_ocdm.prov.prov_set import ProvSet
-
-
-class TestSnapshotEntity(unittest.TestCase):
-    resp_agent = 'http://resp_agent.test/'
-
-    @classmethod
-    def setUpClass(cls) -> None:
-        cls.graph_set = GraphSet("http://test/", "./info_dir/", "", False)
-        cls.prov_set = ProvSet(cls.graph_set, "http://test/", "./info_dir/", False)
-
-    def setUp(self):
-        self.prov_subject = self.graph_set.add_br(self.resp_agent)
-        self.se = self.prov_set.add_se(self.prov_subject)
-        self.prev_se = self.prov_set.add_se(self.prov_subject)
-
-    def test_has_generation_time(self):
-        time = "2001-10-26T21:32:52"
-        datatype = XSD.dateTime
-        result = self.se.has_generation_time(time)
-        self.assertIsNone(result)
-
-        triple = self.se.res, ProvEntity.iri_generated_at_time, Literal(time, datatype=datatype,
-                                                                        normalize=False)
-        self.assertIn(triple, self.se.g)
-
-    def test_has_invalidation_time(self):
-        time = "2001-10-26T21:32:52"
-        datatype = XSD.dateTime
-        result = self.se.has_invalidation_time(time)
-        self.assertIsNone(result)
-
-        triple = self.se.res, ProvEntity.iri_invalidated_at_time, Literal(time, datatype=datatype,
-                                                                          normalize=False)
-        self.assertIn(triple, self.se.g)
-
-    def test_is_snapshot_of(self):
-        ar = self.graph_set.add_ar(self.resp_agent)
-        result = self.se.is_snapshot_of(self.prov_subject)
-        self.assertIsNone(result)
-
-        triple = self.se.res, ProvEntity.iri_specialization_of, self.prov_subject.res
-        self.assertIn(triple, self.se.g)
-
-    def test_derives_from(self):
-        result = self.se.derives_from(self.prev_se)
-        self.assertIsNone(result)
-
-        triple = self.se.res, ProvEntity.iri_was_derived_from, self.prev_se.res
-        self.assertIn(triple, self.se.g)
-
-    def test_has_primary_source(self):
-        primary_source = URIRef("http://test/primarySource")
-        result = self.se.has_primary_source(primary_source)
-        self.assertIsNone(result)
-
-        triple = self.se.res, ProvEntity.iri_had_primary_source, primary_source
-        self.assertIn(triple, self.se.g)
-
-    def test_has_update_action(self):
-        update_query = "DELETE {} INSERT {}"
-        result = self.se.has_update_action(update_query)
-        self.assertIsNone(result)
-
-        triple = self.se.res, ProvEntity.iri_has_update_query, Literal(update_query)
-        self.assertIn(triple, self.se.g)
-
-    def test_has_description(self):
-        description = "Description"
-        result = self.se.has_description(description)
-        self.assertIsNone(result)
-
-        triple = self.se.res, ProvEntity.iri_description, Literal(description)
-        self.assertIn(triple, self.se.g)
-
-    def test_has_resp_agent(self):
-        ra = URIRef("http://test/ra")
-        result = self.se.has_resp_agent(ra)
-        self.assertIsNone(result)
-
-        triple = self.se.res, ProvEntity.iri_was_attributed_to, ra
-        self.assertIn(triple, self.se.g)
-
-
-if __name__ == '__main__':
-    unittest.main()
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+import unittest
+
+from rdflib import URIRef, Literal, XSD
+
+from oc_ocdm.graph.graph_set import GraphSet
+from oc_ocdm.prov.prov_entity import ProvEntity
+from oc_ocdm.prov.prov_set import ProvSet
+
+
+class TestSnapshotEntity(unittest.TestCase):
+    resp_agent = 'http://resp_agent.test/'
+
+    @classmethod
+    def setUpClass(cls) -> None:
+        cls.graph_set = GraphSet("http://test/", "./info_dir/", "", False)
+        cls.prov_set = ProvSet(cls.graph_set, "http://test/", "./info_dir/", False)
+
+    def setUp(self):
+        self.prov_subject = self.graph_set.add_br(self.resp_agent)
+        self.se = self.prov_set.add_se(self.prov_subject)
+        self.prev_se = self.prov_set.add_se(self.prov_subject)
+
+    def test_has_generation_time(self):
+        time = "2001-10-26T21:32:52"
+        datatype = XSD.dateTime
+        result = self.se.has_generation_time(time)
+        self.assertIsNone(result)
+
+        triple = self.se.res, ProvEntity.iri_generated_at_time, Literal(time, datatype=datatype,
+                                                                        normalize=False)
+        self.assertIn(triple, self.se.g)
+
+    def test_has_invalidation_time(self):
+        time = "2001-10-26T21:32:52"
+        datatype = XSD.dateTime
+        result = self.se.has_invalidation_time(time)
+        self.assertIsNone(result)
+
+        triple = self.se.res, ProvEntity.iri_invalidated_at_time, Literal(time, datatype=datatype,
+                                                                          normalize=False)
+        self.assertIn(triple, self.se.g)
+
+    def test_is_snapshot_of(self):
+        ar = self.graph_set.add_ar(self.resp_agent)
+        result = self.se.is_snapshot_of(self.prov_subject)
+        self.assertIsNone(result)
+
+        triple = self.se.res, ProvEntity.iri_specialization_of, self.prov_subject.res
+        self.assertIn(triple, self.se.g)
+
+    def test_derives_from(self):
+        result = self.se.derives_from(self.prev_se)
+        self.assertIsNone(result)
+
+        triple = self.se.res, ProvEntity.iri_was_derived_from, self.prev_se.res
+        self.assertIn(triple, self.se.g)
+
+    def test_has_primary_source(self):
+        primary_source = URIRef("http://test/primarySource")
+        result = self.se.has_primary_source(primary_source)
+        self.assertIsNone(result)
+
+        triple = self.se.res, ProvEntity.iri_had_primary_source, primary_source
+        self.assertIn(triple, self.se.g)
+
+    def test_has_update_action(self):
+        update_query = "DELETE {} INSERT {}"
+        result = self.se.has_update_action(update_query)
+        self.assertIsNone(result)
+
+        triple = self.se.res, ProvEntity.iri_has_update_query, Literal(update_query)
+        self.assertIn(triple, self.se.g)
+
+    def test_has_description(self):
+        description = "Description"
+        result = self.se.has_description(description)
+        self.assertIsNone(result)
+
+        triple = self.se.res, ProvEntity.iri_description, Literal(description)
+        self.assertIn(triple, self.se.g)
+
+    def test_has_resp_agent(self):
+        ra = URIRef("http://test/ra")
+        result = self.se.has_resp_agent(ra)
+        self.assertIsNone(result)
+
+        triple = self.se.res, ProvEntity.iri_was_attributed_to, ra
+        self.assertIn(triple, self.se.g)
+
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/prov/prov_counter.db` & `oc_ocdm-8.1.0/oc_ocdm/test/prov/prov_counter.db`

 * *Files identical despite different names*

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/prov/test_prov_set.py` & `oc_ocdm-8.1.0/oc_ocdm/test/prov/test_prov_set.py`

 * *Ordering differences only*

 * *Files 27% similar despite different names*

```diff
@@ -1,258 +1,258 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-import unittest
-
-from rdflib import Graph, Literal, URIRef
-
-from oc_ocdm.counter_handler.sqlite_counter_handler import SqliteCounterHandler
-from oc_ocdm.graph.graph_set import GraphSet
-from oc_ocdm.prov.entities.snapshot_entity import SnapshotEntity
-from oc_ocdm.prov.prov_set import ProvSet
-
-
-class TestProvSet(unittest.TestCase):
-    resp_agent = 'http://resp_agent.test/'
-
-    def setUp(self):
-        self.graph_set = GraphSet("http://test/", "./info_dir/", "", False)
-        self.prov_set = ProvSet(self.graph_set, "http://test/", "./info_dir/", False, custom_counters={'ci': SqliteCounterHandler('oc_ocdm/test/prov/prov_counter.db')}, supplier_prefix="")
-
-    def test_add_se(self):
-        prov_subj = self.graph_set.add_br(self.resp_agent)
-        se = self.prov_set.add_se(prov_subj)
-
-        self.assertIsNotNone(se)
-        self.assertIsInstance(se, SnapshotEntity)
-        self.assertEqual(str(se.g.identifier), str(prov_subj.res) + "/prov/")
-
-    def test_generate_provenance(self):
-        cur_time = 1607375859.846196
-        cur_time_str = '2020-12-07T21:17:39+00:00'
-
-        with self.subTest('Creation [Merged entity]'):
-            a = self.graph_set.add_br(self.resp_agent)
-            b = self.graph_set.add_br(self.resp_agent)
-            a.merge(b)
-
-            result = self.prov_set.generate_provenance(cur_time)
-
-            se_a = self.prov_set.get_entity(URIRef(a.res + '/prov/se/1'))
-            self.assertIsNotNone(se_a)
-            self.assertIsInstance(se_a, SnapshotEntity)
-            self.assertEqual(a.res, se_a.get_is_snapshot_of())
-            self.assertEqual(cur_time_str, se_a.get_generation_time())
-            if a.source is not None:
-                self.assertEqual(a.source, str(se_a.get_primary_source()))
-            if a.resp_agent is not None:
-                self.assertEqual(a.resp_agent, str(se_a.get_resp_agent()))
-
-            self.assertEqual(f"The entity '{a.res}' has been created.", se_a.get_description())
-        with self.subTest('No snapshot [Merged entity]'):
-            a = self.graph_set.add_br(self.resp_agent)
-            b = self.graph_set.add_br(self.resp_agent)
-            a.merge(b)
-            se_a_1 = self.prov_set.add_se(a)
-
-            # This avoids that the presence of the mandatory rdf:type gets interpreted
-            # as a modification with respect to an empty preexisting_graph:
-            a.remove_every_triple()
-
-            result = self.prov_set.generate_provenance(cur_time)
-            
-
-            se_a_2 = self.prov_set.get_entity(URIRef(a.res + '/prov/se/2'))
-            self.assertIsNone(se_a_2)
-        with self.subTest('Modification [Merged entity]'):
-            title = "TEST TITLE"
-            a = self.graph_set.add_br(self.resp_agent)
-            b = self.graph_set.add_br(self.resp_agent)
-            b.has_title(title)
-            a.merge(b)
-            se_a_1 = self.prov_set.add_se(a)
-
-            result = self.prov_set.generate_provenance(cur_time)
-            
-            self.assertEqual(cur_time_str, se_a_1.get_invalidation_time())
-
-            se_a_2 = self.prov_set.get_entity(URIRef(a.res + '/prov/se/2'))
-            self.assertIsNotNone(se_a_2)
-            self.assertIsInstance(se_a_2, SnapshotEntity)
-            self.assertEqual(a.res, se_a_2.get_is_snapshot_of())
-
-
-            self.assertEqual(cur_time_str, se_a_2.get_generation_time())
-            if a.source is not None:
-                self.assertEqual(a.source, str(se_a_2.get_primary_source()))
-            if a.resp_agent is not None:
-                self.assertEqual(a.resp_agent, str(se_a_2.get_resp_agent()))
-
-            self.assertSetEqual({se_a_1}, set(se_a_2.get_derives_from()))
-            self.assertIsNotNone(se_a_2.get_update_action())
-            self.assertEqual(f"The entity '{a.res}' has been modified.", se_a_2.get_description())
-        with self.subTest('Merge [Merged entity]'):
-            a = self.graph_set.add_br(self.resp_agent)
-            b = self.graph_set.add_br(self.resp_agent)
-            c = self.graph_set.add_br(self.resp_agent)
-            a.merge(b)
-            a.merge(c)
-            se_a_1 = self.prov_set.add_se(a)
-            se_b_1 = self.prov_set.add_se(b)
-
-            result = self.prov_set.generate_provenance(cur_time)
-            
-
-            self.assertEqual(cur_time_str, se_a_1.get_invalidation_time())
-
-            se_a_2 = self.prov_set.get_entity(URIRef(a.res + '/prov/se/2'))
-            self.assertIsNotNone(se_a_2)
-            self.assertIsInstance(se_a_2, SnapshotEntity)
-            self.assertEqual(a.res, se_a_2.get_is_snapshot_of())
-            self.assertEqual(cur_time_str, se_a_2.get_generation_time())
-            if a.source is not None:
-                self.assertEqual(a.source, str(se_a_2.get_primary_source()))
-            if a.resp_agent is not None:
-                self.assertEqual(a.resp_agent, str(se_a_2.get_resp_agent()))
-
-            self.assertSetEqual({se_a_1, se_b_1}, set(se_a_2.get_derives_from()))
-            self.assertEqual(f"The entity '{a.res}' has been merged with '{b.res}'.", se_a_2.get_description())
-        with self.subTest('Creation [Non-Merged entity]'):
-            a = self.graph_set.add_br(self.resp_agent)
-
-            result = self.prov_set.generate_provenance(cur_time)
-            
-
-            se_a = self.prov_set.get_entity(URIRef(a.res + '/prov/se/1'))
-            self.assertIsNotNone(se_a)
-            self.assertIsInstance(se_a, SnapshotEntity)
-            self.assertEqual(a.res, se_a.get_is_snapshot_of())
-            self.assertEqual(cur_time_str, se_a.get_generation_time())
-            if a.source is not None:
-                self.assertEqual(a.source, str(se_a.get_primary_source()))
-            if a.resp_agent is not None:
-                self.assertEqual(a.resp_agent, str(se_a.get_resp_agent()))
-
-            self.assertEqual(f"The entity '{a.res}' has been created.", se_a.get_description())
-        with self.subTest('No snapshot [Non-Merged entity] (Scenario 1)'):
-            a = self.graph_set.add_br(self.resp_agent)
-            a.mark_as_to_be_deleted()
-
-            result = self.prov_set.generate_provenance(cur_time)
-            
-
-            se_a = self.prov_set.get_entity(URIRef(a.res + '/prov/se/1'))
-            self.assertIsNone(se_a)
-        with self.subTest('No snapshot [Merged entity] (Scenario 2)'):
-            a = self.graph_set.add_br(self.resp_agent)
-            se_a_1 = self.prov_set.add_se(a)
-
-            # This avoids that the presence of the mandatory rdf:type gets interpreted
-            # as a modification with respect to an empty preexisting_graph:
-            a.remove_every_triple()
-
-            result = self.prov_set.generate_provenance(cur_time)
-            
-
-            se_a_2 = self.prov_set.get_entity(URIRef(a.res + '/prov/se/2'))
-            self.assertIsNone(se_a_2)
-        with self.subTest('Deletion [Non-Merged entity]'):
-            title = "TEST TITLE"
-            a = self.graph_set.add_br(self.resp_agent)
-            se_a_1 = self.prov_set.add_se(a)
-            a.has_title(title)
-            a.mark_as_to_be_deleted()
-
-            result = self.prov_set.generate_provenance(cur_time)
-            
-
-            self.assertEqual(cur_time_str, se_a_1.get_invalidation_time())
-
-            se_a_2 = self.prov_set.get_entity(URIRef(a.res + '/prov/se/2'))
-            self.assertIsNotNone(se_a_2)
-            self.assertIsInstance(se_a_2, SnapshotEntity)
-            self.assertEqual(a.res, se_a_2.get_is_snapshot_of())
-            self.assertEqual(cur_time_str, se_a_2.get_generation_time())
-            if a.source is not None:
-                self.assertEqual(a.source, str(se_a_2.get_primary_source()))
-            if a.resp_agent is not None:
-                self.assertEqual(a.resp_agent, str(se_a_2.get_resp_agent()))
-
-            self.assertSetEqual({se_a_1}, set(se_a_2.get_derives_from()))
-            self.assertEqual(f"The entity '{a.res}' has been deleted.", se_a_2.get_description())
-        with self.subTest('Modification [Non-Merged entity]'):
-            title = "TEST TITLE"
-            a = self.graph_set.add_br(self.resp_agent)
-            se_a_1 = self.prov_set.add_se(a)
-            a.has_title(title)
-
-            result = self.prov_set.generate_provenance(cur_time)
-            
-
-            self.assertEqual(cur_time_str, se_a_1.get_invalidation_time())
-
-            se_a_2 = self.prov_set.get_entity(URIRef(a.res + '/prov/se/2'))
-            self.assertIsNotNone(se_a_2)
-            self.assertIsInstance(se_a_2, SnapshotEntity)
-            self.assertEqual(a.res, se_a_2.get_is_snapshot_of())
-            self.assertEqual(cur_time_str, se_a_2.get_generation_time())
-            if a.source is not None:
-                self.assertEqual(a.source, str(se_a_2.get_primary_source()))
-            if a.resp_agent is not None:
-                self.assertEqual(a.resp_agent, str(se_a_2.get_resp_agent()))
-
-            self.assertSetEqual({se_a_1}, set(se_a_2.get_derives_from()))
-            self.assertIsNotNone(se_a_2.get_update_action())
-            self.assertEqual(f"The entity '{a.res}' has been modified.", se_a_2.get_description())
-
-    def test_retrieve_last_snapshot(self):
-        br = self.graph_set.add_br(self.resp_agent)
-        br_res = br.res
-        result = self.prov_set._retrieve_last_snapshot(br_res)
-        self.assertIsNone(result)
-
-        se = self.prov_set.add_se(br)
-        result = self.prov_set._retrieve_last_snapshot(br_res)
-        self.assertIsNotNone(result)
-        self.assertEqual(str(result), str(se))
-
-        prov_subject = URIRef('https://w3id.org/oc/corpus/br/0')
-        self.assertRaises(ValueError, self.prov_set._retrieve_last_snapshot, prov_subject)
-
-        prov_subject = URIRef('https://w3id.org/oc/corpus/br/-1')
-        self.assertRaises(ValueError, self.prov_set._retrieve_last_snapshot, prov_subject)
-
-        prov_subject = URIRef('https://w3id.org/oc/corpus/br/abc')
-        self.assertRaises(ValueError, self.prov_set._retrieve_last_snapshot, prov_subject)
-
-    def test_generate_provenance_for_citations(self):
-        preexisting_graph = Graph()
-        preexisting_graph.add((
-            URIRef('https://w3id.org/oc/index/coci/ci/020010000023601000907630001040258020000010008010559090238044008040338381018136312231227010309014203370037122439026325-020010305093619112227370109090937010437073701020309'),
-            URIRef('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
-            URIRef('http://purl.org/spar/cito/Citation')))
-        preexisting_graph.add((
-            URIRef('https://w3id.org/oc/index/coci/ci/020010000023601000907630001040258020000010008010559090238044008040338381018136312231227010309014203370037122439026325-020010305093619112227370109090937010437073701020309'),
-            URIRef('http://purl.org/spar/cito/hasCitationCreationDate'),
-            Literal('2022', datatype='http://www.w3.org/2001/XMLSchema#gYear')))
-        ci = self.graph_set.add_ci(self.resp_agent, res=URIRef('https://w3id.org/oc/index/coci/ci/020010000023601000907630001040258020000010008010559090238044008040338381018136312231227010309014203370037122439026325-020010305093619112227370109090937010437073701020309'), preexisting_graph=preexisting_graph)
-        self.prov_set.generate_provenance()
-        self.graph_set.commit_changes()
-        ci.has_citation_creation_date('2022')
-        self.prov_set.generate_provenance()
-        prov_entity = self.prov_set._retrieve_last_snapshot(URIRef('https://w3id.org/oc/index/coci/ci/020010000023601000907630001040258020000010008010559090238044008040338381018136312231227010309014203370037122439026325-020010305093619112227370109090937010437073701020309'))
-        self.assertEqual(prov_entity, URIRef('https://w3id.org/oc/index/coci/ci/020010000023601000907630001040258020000010008010559090238044008040338381018136312231227010309014203370037122439026325-020010305093619112227370109090937010437073701020309/prov/se/1'))
-
-if __name__ == '__main__':
-    unittest.main()
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+import unittest
+
+from rdflib import Graph, Literal, URIRef
+
+from oc_ocdm.counter_handler.sqlite_counter_handler import SqliteCounterHandler
+from oc_ocdm.graph.graph_set import GraphSet
+from oc_ocdm.prov.entities.snapshot_entity import SnapshotEntity
+from oc_ocdm.prov.prov_set import ProvSet
+
+
+class TestProvSet(unittest.TestCase):
+    resp_agent = 'http://resp_agent.test/'
+
+    def setUp(self):
+        self.graph_set = GraphSet("http://test/", "./info_dir/", "", False)
+        self.prov_set = ProvSet(self.graph_set, "http://test/", "./info_dir/", False, custom_counters={'ci': SqliteCounterHandler('oc_ocdm/test/prov/prov_counter.db')}, supplier_prefix="")
+
+    def test_add_se(self):
+        prov_subj = self.graph_set.add_br(self.resp_agent)
+        se = self.prov_set.add_se(prov_subj)
+
+        self.assertIsNotNone(se)
+        self.assertIsInstance(se, SnapshotEntity)
+        self.assertEqual(str(se.g.identifier), str(prov_subj.res) + "/prov/")
+
+    def test_generate_provenance(self):
+        cur_time = 1607375859.846196
+        cur_time_str = '2020-12-07T21:17:39+00:00'
+
+        with self.subTest('Creation [Merged entity]'):
+            a = self.graph_set.add_br(self.resp_agent)
+            b = self.graph_set.add_br(self.resp_agent)
+            a.merge(b)
+
+            result = self.prov_set.generate_provenance(cur_time)
+
+            se_a = self.prov_set.get_entity(URIRef(a.res + '/prov/se/1'))
+            self.assertIsNotNone(se_a)
+            self.assertIsInstance(se_a, SnapshotEntity)
+            self.assertEqual(a.res, se_a.get_is_snapshot_of())
+            self.assertEqual(cur_time_str, se_a.get_generation_time())
+            if a.source is not None:
+                self.assertEqual(a.source, str(se_a.get_primary_source()))
+            if a.resp_agent is not None:
+                self.assertEqual(a.resp_agent, str(se_a.get_resp_agent()))
+
+            self.assertEqual(f"The entity '{a.res}' has been created.", se_a.get_description())
+        with self.subTest('No snapshot [Merged entity]'):
+            a = self.graph_set.add_br(self.resp_agent)
+            b = self.graph_set.add_br(self.resp_agent)
+            a.merge(b)
+            se_a_1 = self.prov_set.add_se(a)
+
+            # This avoids that the presence of the mandatory rdf:type gets interpreted
+            # as a modification with respect to an empty preexisting_graph:
+            a.remove_every_triple()
+
+            result = self.prov_set.generate_provenance(cur_time)
+            
+
+            se_a_2 = self.prov_set.get_entity(URIRef(a.res + '/prov/se/2'))
+            self.assertIsNone(se_a_2)
+        with self.subTest('Modification [Merged entity]'):
+            title = "TEST TITLE"
+            a = self.graph_set.add_br(self.resp_agent)
+            b = self.graph_set.add_br(self.resp_agent)
+            b.has_title(title)
+            a.merge(b)
+            se_a_1 = self.prov_set.add_se(a)
+
+            result = self.prov_set.generate_provenance(cur_time)
+            
+            self.assertEqual(cur_time_str, se_a_1.get_invalidation_time())
+
+            se_a_2 = self.prov_set.get_entity(URIRef(a.res + '/prov/se/2'))
+            self.assertIsNotNone(se_a_2)
+            self.assertIsInstance(se_a_2, SnapshotEntity)
+            self.assertEqual(a.res, se_a_2.get_is_snapshot_of())
+
+
+            self.assertEqual(cur_time_str, se_a_2.get_generation_time())
+            if a.source is not None:
+                self.assertEqual(a.source, str(se_a_2.get_primary_source()))
+            if a.resp_agent is not None:
+                self.assertEqual(a.resp_agent, str(se_a_2.get_resp_agent()))
+
+            self.assertSetEqual({se_a_1}, set(se_a_2.get_derives_from()))
+            self.assertIsNotNone(se_a_2.get_update_action())
+            self.assertEqual(f"The entity '{a.res}' has been modified.", se_a_2.get_description())
+        with self.subTest('Merge [Merged entity]'):
+            a = self.graph_set.add_br(self.resp_agent)
+            b = self.graph_set.add_br(self.resp_agent)
+            c = self.graph_set.add_br(self.resp_agent)
+            a.merge(b)
+            a.merge(c)
+            se_a_1 = self.prov_set.add_se(a)
+            se_b_1 = self.prov_set.add_se(b)
+
+            result = self.prov_set.generate_provenance(cur_time)
+            
+
+            self.assertEqual(cur_time_str, se_a_1.get_invalidation_time())
+
+            se_a_2 = self.prov_set.get_entity(URIRef(a.res + '/prov/se/2'))
+            self.assertIsNotNone(se_a_2)
+            self.assertIsInstance(se_a_2, SnapshotEntity)
+            self.assertEqual(a.res, se_a_2.get_is_snapshot_of())
+            self.assertEqual(cur_time_str, se_a_2.get_generation_time())
+            if a.source is not None:
+                self.assertEqual(a.source, str(se_a_2.get_primary_source()))
+            if a.resp_agent is not None:
+                self.assertEqual(a.resp_agent, str(se_a_2.get_resp_agent()))
+
+            self.assertSetEqual({se_a_1, se_b_1}, set(se_a_2.get_derives_from()))
+            self.assertEqual(f"The entity '{a.res}' has been merged with '{b.res}'.", se_a_2.get_description())
+        with self.subTest('Creation [Non-Merged entity]'):
+            a = self.graph_set.add_br(self.resp_agent)
+
+            result = self.prov_set.generate_provenance(cur_time)
+            
+
+            se_a = self.prov_set.get_entity(URIRef(a.res + '/prov/se/1'))
+            self.assertIsNotNone(se_a)
+            self.assertIsInstance(se_a, SnapshotEntity)
+            self.assertEqual(a.res, se_a.get_is_snapshot_of())
+            self.assertEqual(cur_time_str, se_a.get_generation_time())
+            if a.source is not None:
+                self.assertEqual(a.source, str(se_a.get_primary_source()))
+            if a.resp_agent is not None:
+                self.assertEqual(a.resp_agent, str(se_a.get_resp_agent()))
+
+            self.assertEqual(f"The entity '{a.res}' has been created.", se_a.get_description())
+        with self.subTest('No snapshot [Non-Merged entity] (Scenario 1)'):
+            a = self.graph_set.add_br(self.resp_agent)
+            a.mark_as_to_be_deleted()
+
+            result = self.prov_set.generate_provenance(cur_time)
+            
+
+            se_a = self.prov_set.get_entity(URIRef(a.res + '/prov/se/1'))
+            self.assertIsNone(se_a)
+        with self.subTest('No snapshot [Merged entity] (Scenario 2)'):
+            a = self.graph_set.add_br(self.resp_agent)
+            se_a_1 = self.prov_set.add_se(a)
+
+            # This avoids that the presence of the mandatory rdf:type gets interpreted
+            # as a modification with respect to an empty preexisting_graph:
+            a.remove_every_triple()
+
+            result = self.prov_set.generate_provenance(cur_time)
+            
+
+            se_a_2 = self.prov_set.get_entity(URIRef(a.res + '/prov/se/2'))
+            self.assertIsNone(se_a_2)
+        with self.subTest('Deletion [Non-Merged entity]'):
+            title = "TEST TITLE"
+            a = self.graph_set.add_br(self.resp_agent)
+            se_a_1 = self.prov_set.add_se(a)
+            a.has_title(title)
+            a.mark_as_to_be_deleted()
+
+            result = self.prov_set.generate_provenance(cur_time)
+            
+
+            self.assertEqual(cur_time_str, se_a_1.get_invalidation_time())
+
+            se_a_2 = self.prov_set.get_entity(URIRef(a.res + '/prov/se/2'))
+            self.assertIsNotNone(se_a_2)
+            self.assertIsInstance(se_a_2, SnapshotEntity)
+            self.assertEqual(a.res, se_a_2.get_is_snapshot_of())
+            self.assertEqual(cur_time_str, se_a_2.get_generation_time())
+            if a.source is not None:
+                self.assertEqual(a.source, str(se_a_2.get_primary_source()))
+            if a.resp_agent is not None:
+                self.assertEqual(a.resp_agent, str(se_a_2.get_resp_agent()))
+
+            self.assertSetEqual({se_a_1}, set(se_a_2.get_derives_from()))
+            self.assertEqual(f"The entity '{a.res}' has been deleted.", se_a_2.get_description())
+        with self.subTest('Modification [Non-Merged entity]'):
+            title = "TEST TITLE"
+            a = self.graph_set.add_br(self.resp_agent)
+            se_a_1 = self.prov_set.add_se(a)
+            a.has_title(title)
+
+            result = self.prov_set.generate_provenance(cur_time)
+            
+
+            self.assertEqual(cur_time_str, se_a_1.get_invalidation_time())
+
+            se_a_2 = self.prov_set.get_entity(URIRef(a.res + '/prov/se/2'))
+            self.assertIsNotNone(se_a_2)
+            self.assertIsInstance(se_a_2, SnapshotEntity)
+            self.assertEqual(a.res, se_a_2.get_is_snapshot_of())
+            self.assertEqual(cur_time_str, se_a_2.get_generation_time())
+            if a.source is not None:
+                self.assertEqual(a.source, str(se_a_2.get_primary_source()))
+            if a.resp_agent is not None:
+                self.assertEqual(a.resp_agent, str(se_a_2.get_resp_agent()))
+
+            self.assertSetEqual({se_a_1}, set(se_a_2.get_derives_from()))
+            self.assertIsNotNone(se_a_2.get_update_action())
+            self.assertEqual(f"The entity '{a.res}' has been modified.", se_a_2.get_description())
+
+    def test_retrieve_last_snapshot(self):
+        br = self.graph_set.add_br(self.resp_agent)
+        br_res = br.res
+        result = self.prov_set._retrieve_last_snapshot(br_res)
+        self.assertIsNone(result)
+
+        se = self.prov_set.add_se(br)
+        result = self.prov_set._retrieve_last_snapshot(br_res)
+        self.assertIsNotNone(result)
+        self.assertEqual(str(result), str(se))
+
+        prov_subject = URIRef('https://w3id.org/oc/corpus/br/0')
+        self.assertRaises(ValueError, self.prov_set._retrieve_last_snapshot, prov_subject)
+
+        prov_subject = URIRef('https://w3id.org/oc/corpus/br/-1')
+        self.assertRaises(ValueError, self.prov_set._retrieve_last_snapshot, prov_subject)
+
+        prov_subject = URIRef('https://w3id.org/oc/corpus/br/abc')
+        self.assertRaises(ValueError, self.prov_set._retrieve_last_snapshot, prov_subject)
+
+    def test_generate_provenance_for_citations(self):
+        preexisting_graph = Graph()
+        preexisting_graph.add((
+            URIRef('https://w3id.org/oc/index/coci/ci/020010000023601000907630001040258020000010008010559090238044008040338381018136312231227010309014203370037122439026325-020010305093619112227370109090937010437073701020309'),
+            URIRef('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
+            URIRef('http://purl.org/spar/cito/Citation')))
+        preexisting_graph.add((
+            URIRef('https://w3id.org/oc/index/coci/ci/020010000023601000907630001040258020000010008010559090238044008040338381018136312231227010309014203370037122439026325-020010305093619112227370109090937010437073701020309'),
+            URIRef('http://purl.org/spar/cito/hasCitationCreationDate'),
+            Literal('2022', datatype='http://www.w3.org/2001/XMLSchema#gYear')))
+        ci = self.graph_set.add_ci(self.resp_agent, res=URIRef('https://w3id.org/oc/index/coci/ci/020010000023601000907630001040258020000010008010559090238044008040338381018136312231227010309014203370037122439026325-020010305093619112227370109090937010437073701020309'), preexisting_graph=preexisting_graph)
+        self.prov_set.generate_provenance()
+        self.graph_set.commit_changes()
+        ci.has_citation_creation_date('2022')
+        self.prov_set.generate_provenance()
+        prov_entity = self.prov_set._retrieve_last_snapshot(URIRef('https://w3id.org/oc/index/coci/ci/020010000023601000907630001040258020000010008010559090238044008040338381018136312231227010309014203370037122439026325-020010305093619112227370109090937010437073701020309'))
+        self.assertEqual(prov_entity, URIRef('https://w3id.org/oc/index/coci/ci/020010000023601000907630001040258020000010008010559090238044008040338381018136312231227010309014203370037122439026325-020010305093619112227370109090937010437073701020309/prov/se/1'))
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/reader/br.nt` & `oc_ocdm-8.1.0/oc_ocdm/test/reader/br.nt`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,19 +1,19 @@
-<https://w3id.org/oc/meta/br/0605> <http://prismstandard.org/namespaces/basic/2.0/publicationDate> "1999-05-01"^^<http://www.w3.org/2001/XMLSchema#date> .
-<https://w3id.org/oc/meta/br/0605> <http://purl.org/dc/terms/title> "A Review Of Hemolytic Uremic Syndrome In Patients Treated With Gemcitabine Therapy" .
-<https://w3id.org/oc/meta/br/0605> <http://purl.org/spar/datacite/hasIdentifier> <https://w3id.org/oc/meta/id/0605> .
-<https://w3id.org/oc/meta/br/0605> <http://purl.org/vocab/frbr/core#embodiment> <https://w3id.org/oc/meta/re/0605> .
-<https://w3id.org/oc/meta/br/0605> <http://purl.org/vocab/frbr/core#partOf> <https://w3id.org/oc/meta/br/066015746> .
-<https://w3id.org/oc/meta/br/0605> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://purl.org/spar/fabio/Expression> .
-<https://w3id.org/oc/meta/br/0605> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://purl.org/spar/fabio/JournalArticle> .
-<https://w3id.org/oc/meta/br/0636066666> <http://prismstandard.org/namespaces/basic/2.0/publicationDate> "2012-02"^^<http://www.w3.org/2001/XMLSchema#gYearMonth> .
-<https://w3id.org/oc/meta/br/0636066666> <http://purl.org/dc/terms/title> "Ironing Out Tau'S Role In Parkinsonism" .
-<https://w3id.org/oc/meta/br/0636066666> <http://purl.org/spar/datacite/hasIdentifier> <https://w3id.org/oc/meta/id/0636064270> .
-<https://w3id.org/oc/meta/br/0636066666> <http://purl.org/spar/pro/isDocumentContextFor> <https://w3id.org/oc/meta/ar/06360300897> .
-<https://w3id.org/oc/meta/br/0636066666> <http://purl.org/spar/pro/isDocumentContextFor> <https://w3id.org/oc/meta/ar/06360300898> .
-<https://w3id.org/oc/meta/br/0636066666> <http://purl.org/spar/pro/isDocumentContextFor> <https://w3id.org/oc/meta/ar/06360300899> .
-<https://w3id.org/oc/meta/br/0636066666> <http://purl.org/spar/pro/isDocumentContextFor> <https://w3id.org/oc/meta/ar/06360300900> .
-<https://w3id.org/oc/meta/br/0636066666> <http://purl.org/vocab/frbr/core#embodiment> <https://w3id.org/oc/meta/re/0636059994> .
-<https://w3id.org/oc/meta/br/0636066666> <http://purl.org/vocab/frbr/core#partOf> <https://w3id.org/oc/meta/br/0636067351> .
-<https://w3id.org/oc/meta/br/0636066666> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://purl.org/spar/fabio/Expression> .
-<https://w3id.org/oc/meta/br/0636066666> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://purl.org/spar/fabio/JournalArticle> .
-<https://w3id.org/oc/meta/re/0605> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://purl.org/spar/fabio/ResourceEmbodiment> .
+<https://w3id.org/oc/meta/br/0605> <http://prismstandard.org/namespaces/basic/2.0/publicationDate> "1999-05-01"^^<http://www.w3.org/2001/XMLSchema#date> .
+<https://w3id.org/oc/meta/br/0605> <http://purl.org/dc/terms/title> "A Review Of Hemolytic Uremic Syndrome In Patients Treated With Gemcitabine Therapy" .
+<https://w3id.org/oc/meta/br/0605> <http://purl.org/spar/datacite/hasIdentifier> <https://w3id.org/oc/meta/id/0605> .
+<https://w3id.org/oc/meta/br/0605> <http://purl.org/vocab/frbr/core#embodiment> <https://w3id.org/oc/meta/re/0605> .
+<https://w3id.org/oc/meta/br/0605> <http://purl.org/vocab/frbr/core#partOf> <https://w3id.org/oc/meta/br/066015746> .
+<https://w3id.org/oc/meta/br/0605> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://purl.org/spar/fabio/Expression> .
+<https://w3id.org/oc/meta/br/0605> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://purl.org/spar/fabio/JournalArticle> .
+<https://w3id.org/oc/meta/br/0636066666> <http://prismstandard.org/namespaces/basic/2.0/publicationDate> "2012-02"^^<http://www.w3.org/2001/XMLSchema#gYearMonth> .
+<https://w3id.org/oc/meta/br/0636066666> <http://purl.org/dc/terms/title> "Ironing Out Tau'S Role In Parkinsonism" .
+<https://w3id.org/oc/meta/br/0636066666> <http://purl.org/spar/datacite/hasIdentifier> <https://w3id.org/oc/meta/id/0636064270> .
+<https://w3id.org/oc/meta/br/0636066666> <http://purl.org/spar/pro/isDocumentContextFor> <https://w3id.org/oc/meta/ar/06360300897> .
+<https://w3id.org/oc/meta/br/0636066666> <http://purl.org/spar/pro/isDocumentContextFor> <https://w3id.org/oc/meta/ar/06360300898> .
+<https://w3id.org/oc/meta/br/0636066666> <http://purl.org/spar/pro/isDocumentContextFor> <https://w3id.org/oc/meta/ar/06360300899> .
+<https://w3id.org/oc/meta/br/0636066666> <http://purl.org/spar/pro/isDocumentContextFor> <https://w3id.org/oc/meta/ar/06360300900> .
+<https://w3id.org/oc/meta/br/0636066666> <http://purl.org/vocab/frbr/core#embodiment> <https://w3id.org/oc/meta/re/0636059994> .
+<https://w3id.org/oc/meta/br/0636066666> <http://purl.org/vocab/frbr/core#partOf> <https://w3id.org/oc/meta/br/0636067351> .
+<https://w3id.org/oc/meta/br/0636066666> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://purl.org/spar/fabio/Expression> .
+<https://w3id.org/oc/meta/br/0636066666> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://purl.org/spar/fabio/JournalArticle> .
+<https://w3id.org/oc/meta/re/0605> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://purl.org/spar/fabio/ResourceEmbodiment> .
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/reader/test_reader.py` & `oc_ocdm-8.1.0/oc_ocdm/test/reader/test_reader.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,41 +1,41 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2023, Arcangelo Massari <arcangelo.massari@unibo.it>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-
-import os
-import unittest
-
-from rdflib import URIRef
-from SPARQLWrapper import JSON, SPARQLWrapper
-
-from oc_ocdm.graph import GraphSet
-from oc_ocdm.reader import Reader
-
-
-class TestReader(unittest.TestCase):
-    @classmethod
-    def setUpClass(cls):
-        cls.endpoint = 'http://127.0.0.1:9999/blazegraph/sparql'
-        BASE = os.path.join('oc_ocdm', 'test', 'reader')
-        server = SPARQLWrapper(cls.endpoint)
-        query = 'LOAD <file:' + os.path.abspath(os.path.join(BASE, f'br.nt')).replace('\\', '/') + '> INTO GRAPH <' + f'https://w3id.org/oc/meta/' + '>'
-        server.setQuery(query)
-        server.query()
-    
-    def test_import_entity_from_triplestore(self):
-        reader = Reader()
-        g_set = GraphSet('https://w3id.org/oc/meta')
-        reader.import_entity_from_triplestore(g_set, self.endpoint, URIRef('https://w3id.org/oc/meta/br/0605'), 'https://orcid.org/0000-0002-8420-0696', False)
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2023, Arcangelo Massari <arcangelo.massari@unibo.it>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+
+import os
+import unittest
+
+from rdflib import URIRef
+from SPARQLWrapper import JSON, SPARQLWrapper
+
+from oc_ocdm.graph import GraphSet
+from oc_ocdm.reader import Reader
+
+
+class TestReader(unittest.TestCase):
+    @classmethod
+    def setUpClass(cls):
+        cls.endpoint = 'http://127.0.0.1:9999/blazegraph/sparql'
+        BASE = os.path.join('oc_ocdm', 'test', 'reader')
+        server = SPARQLWrapper(cls.endpoint)
+        query = 'LOAD <file:' + os.path.abspath(os.path.join(BASE, f'br.nt')).replace('\\', '/') + '> INTO GRAPH <' + f'https://w3id.org/oc/meta/' + '>'
+        server.setQuery(query)
+        server.query()
+    
+    def test_import_entity_from_triplestore(self):
+        reader = Reader()
+        g_set = GraphSet('https://w3id.org/oc/meta')
+        reader.import_entity_from_triplestore(g_set, self.endpoint, URIRef('https://w3id.org/oc/meta/br/0605'), 'https://orcid.org/0000-0002-8420-0696', False)
         self.assertEqual(set(str(s) for s in g_set.res_to_entity.keys()), {'https://w3id.org/oc/meta/br/0605'})
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/resources/test_shacle.py` & `oc_ocdm-8.1.0/oc_ocdm/test/resources/test_shacle.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,76 +1,76 @@
-import os
-import unittest
-
-from pyshacl import validate
-from rdflib import ConjunctiveGraph, Graph, URIRef
-
-from oc_ocdm.graph.graph_set import GraphSet
-from oc_ocdm.reader import Reader
-
-
-class TestShacle(unittest.TestCase):
-    def test_validate(self):
-      data_graph = ConjunctiveGraph()
-      sg = Graph()
-      data_graph.parse(source=os.path.join('oc_ocdm', 'test', 'resources', 'data.json'), format='json-ld')
-      sg.parse(source=os.path.join('oc_ocdm', 'resources', 'shacle.ttl'), format='text/turtle')
-      r = validate(data_graph,
-        shacl_graph=sg,
-        ont_graph=None,
-        inference=None,
-        abort_on_first=False,
-        allow_infos=False,
-        allow_warnings=False,
-        meta_shacl=False,
-        advanced=False,
-        js=False,
-        debug=False)
-      conforms, _, _ = r
-      self.assertEqual(conforms, True)
-    
-    def test_reader(self):
-      reader = Reader()
-      g_set = GraphSet(base_iri='https://w3id.org/oc/meta/')
-      g = ConjunctiveGraph()
-      g.parse(source=os.path.join('oc_ocdm', 'test', 'resources', 'data_reader.json'))
-      results = []
-      for triple in g:
-        o = triple[2]
-        o_type = 'uri' if isinstance(o, URIRef) else 'literal'
-        if o_type == 'literal' and o.datatype:
-          results.append({'s': {'type': 'uri', 'value': str(triple[0])}, 'p': {'type': 'uri', 'value': str(triple[1])}, 'o': {'type': o_type, 'value': str(triple[2]), 'datatype': str(o.datatype)}})
-        else:
-          results.append({'s': {'type': 'uri', 'value': str(triple[0])}, 'p': {'type': 'uri', 'value': str(triple[1])}, 'o': {'type': o_type, 'value': str(triple[2])}})
-      reader.import_entities_from_graph(g_set, results, resp_agent='https://orcid.org/0000-0002-8420-0696', enable_validation=True, closed=False)
-      self.assertEqual(set(str(s) for s in g_set.res_to_entity.keys()), {
-         'https://w3id.org/oc/meta/br/060209',
-         'https://w3id.org/oc/meta/br/060182', 
-         'https://w3id.org/oc/meta/ar/06034124', 
-         'https://w3id.org/oc/meta/ra/06099', 
-         'https://w3id.org/oc/meta/ar/060128', 
-         'https://w3id.org/oc/meta/id/060313', 
-         'https://w3id.org/oc/meta/ra/06098', 
-         'https://w3id.org/oc/meta/re/06011'})
-
-    def test_reader_invalid(self):
-      reader = Reader()
-      g_set = GraphSet(base_iri='https://w3id.org/oc/meta/')
-      g = ConjunctiveGraph()
-      g.parse(source=os.path.join('oc_ocdm', 'test', 'resources', 'data_reader_invalid.json'))
-      results = []
-      for triple in g:
-        o = triple[2]
-        o_type = 'uri' if isinstance(o, URIRef) else 'literal'
-        if o_type == 'literal' and o.datatype:
-          results.append({'s': {'type': 'uri', 'value': str(triple[0])}, 'p': {'type': 'uri', 'value': str(triple[1])}, 'o': {'type': o_type, 'value': str(triple[2]), 'datatype': str(o.datatype)}})
-        else:
-          results.append({'s': {'type': 'uri', 'value': str(triple[0])}, 'p': {'type': 'uri', 'value': str(triple[1])}, 'o': {'type': o_type, 'value': str(triple[2])}})
-      reader.import_entities_from_graph(g_set, results, resp_agent='https://orcid.org/0000-0002-8420-0696', enable_validation=True, closed=False)
-      self.assertEqual(set(str(s) for s in g_set.res_to_entity.keys()), {
-         'https://w3id.org/oc/meta/br/060182', 
-         'https://w3id.org/oc/meta/ar/06034124', 
-         'https://w3id.org/oc/meta/ra/06099', 
-         'https://w3id.org/oc/meta/ar/060128', 
-         'https://w3id.org/oc/meta/id/060313', 
-         'https://w3id.org/oc/meta/ra/06098', 
+import os
+import unittest
+
+from pyshacl import validate
+from rdflib import ConjunctiveGraph, Graph, URIRef
+
+from oc_ocdm.graph.graph_set import GraphSet
+from oc_ocdm.reader import Reader
+
+
+class TestShacle(unittest.TestCase):
+    def test_validate(self):
+      data_graph = ConjunctiveGraph()
+      sg = Graph()
+      data_graph.parse(source=os.path.join('oc_ocdm', 'test', 'resources', 'data.json'), format='json-ld')
+      sg.parse(source=os.path.join('oc_ocdm', 'resources', 'shacle.ttl'), format='text/turtle')
+      r = validate(data_graph,
+        shacl_graph=sg,
+        ont_graph=None,
+        inference=None,
+        abort_on_first=False,
+        allow_infos=False,
+        allow_warnings=False,
+        meta_shacl=False,
+        advanced=False,
+        js=False,
+        debug=False)
+      conforms, _, _ = r
+      self.assertEqual(conforms, True)
+    
+    def test_reader(self):
+      reader = Reader()
+      g_set = GraphSet(base_iri='https://w3id.org/oc/meta/')
+      g = ConjunctiveGraph()
+      g.parse(source=os.path.join('oc_ocdm', 'test', 'resources', 'data_reader.json'))
+      results = []
+      for triple in g:
+        o = triple[2]
+        o_type = 'uri' if isinstance(o, URIRef) else 'literal'
+        if o_type == 'literal' and o.datatype:
+          results.append({'s': {'type': 'uri', 'value': str(triple[0])}, 'p': {'type': 'uri', 'value': str(triple[1])}, 'o': {'type': o_type, 'value': str(triple[2]), 'datatype': str(o.datatype)}})
+        else:
+          results.append({'s': {'type': 'uri', 'value': str(triple[0])}, 'p': {'type': 'uri', 'value': str(triple[1])}, 'o': {'type': o_type, 'value': str(triple[2])}})
+      reader.import_entities_from_graph(g_set, results, resp_agent='https://orcid.org/0000-0002-8420-0696', enable_validation=True, closed=False)
+      self.assertEqual(set(str(s) for s in g_set.res_to_entity.keys()), {
+         'https://w3id.org/oc/meta/br/060209',
+         'https://w3id.org/oc/meta/br/060182', 
+         'https://w3id.org/oc/meta/ar/06034124', 
+         'https://w3id.org/oc/meta/ra/06099', 
+         'https://w3id.org/oc/meta/ar/060128', 
+         'https://w3id.org/oc/meta/id/060313', 
+         'https://w3id.org/oc/meta/ra/06098', 
+         'https://w3id.org/oc/meta/re/06011'})
+
+    def test_reader_invalid(self):
+      reader = Reader()
+      g_set = GraphSet(base_iri='https://w3id.org/oc/meta/')
+      g = ConjunctiveGraph()
+      g.parse(source=os.path.join('oc_ocdm', 'test', 'resources', 'data_reader_invalid.json'))
+      results = []
+      for triple in g:
+        o = triple[2]
+        o_type = 'uri' if isinstance(o, URIRef) else 'literal'
+        if o_type == 'literal' and o.datatype:
+          results.append({'s': {'type': 'uri', 'value': str(triple[0])}, 'p': {'type': 'uri', 'value': str(triple[1])}, 'o': {'type': o_type, 'value': str(triple[2]), 'datatype': str(o.datatype)}})
+        else:
+          results.append({'s': {'type': 'uri', 'value': str(triple[0])}, 'p': {'type': 'uri', 'value': str(triple[1])}, 'o': {'type': o_type, 'value': str(triple[2])}})
+      reader.import_entities_from_graph(g_set, results, resp_agent='https://orcid.org/0000-0002-8420-0696', enable_validation=True, closed=False)
+      self.assertEqual(set(str(s) for s in g_set.res_to_entity.keys()), {
+         'https://w3id.org/oc/meta/br/060182', 
+         'https://w3id.org/oc/meta/ar/06034124', 
+         'https://w3id.org/oc/meta/ra/06099', 
+         'https://w3id.org/oc/meta/ar/060128', 
+         'https://w3id.org/oc/meta/id/060313', 
+         'https://w3id.org/oc/meta/ra/06098', 
          'https://w3id.org/oc/meta/re/06011'})
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/storer/test_storer.py` & `oc_ocdm-8.1.0/oc_ocdm/test/storer/test_storer.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,204 +1,204 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-import json
-import os
-import unittest
-from platform import system
-from zipfile import ZipFile
-from multiprocessing import Pool
-from SPARQLWrapper import POST, SPARQLWrapper
-
-from rdflib import ConjunctiveGraph, URIRef, compare
-
-from oc_ocdm.graph.graph_set import GraphSet
-from oc_ocdm.prov.prov_set import ProvSet
-from oc_ocdm.storer import Storer
-from oc_ocdm.reader import Reader
-
-from shutil import rmtree
-
-class TestStorer(unittest.TestCase):
-    def setUp(self):
-        self.resp_agent = "http://resp_agent.test/"
-        self.base_iri = "http://test/"
-        self.ts = 'http://127.0.0.1:9999/blazegraph/sparql'
-        self.graph_set = GraphSet(self.base_iri, "", "060", False)
-        self.prov_set = ProvSet(self.graph_set, self.base_iri, "", False)
-        self.br = self.graph_set.add_br(self.resp_agent)
-        self.data_dir = os.path.join("oc_ocdm", "test", "storer", "data")
-        self.prov_dir = os.path.join("oc_ocdm", "test", "storer", "test_provenance")
-        self.info_dir = os.path.join(self.prov_dir, "info_dir")
-
-    def tearDown(self):
-        if os.path.exists(self.data_dir):
-            rmtree(self.data_dir)
-        if os.path.exists(self.prov_dir):
-            rmtree(os.path.join(self.prov_dir))
-
-    def test_store_graphs_in_file(self):
-        base_dir = os.path.join("oc_ocdm", "test", "storer", "data", "rdf") + os.sep
-        with self.subTest("output_format=json-ld, zip_output=True"):
-            modified_entities = self.prov_set.generate_provenance()
-            prov_storer = Storer(self.prov_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='json-ld', zip_output=True)
-            storer = Storer(self.graph_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='json-ld', zip_output=True, modified_entities=modified_entities)
-            storer.store_all(base_dir, self.base_iri)
-            prov_storer.store_all(base_dir, self.base_iri)
-            self.graph_set.commit_changes()
-            with ZipFile(os.path.join(base_dir, "br", "060", "10000", "1000.zip"), mode="r") as archive:
-                with archive.open("1000.json") as f:
-                    data = json.load(f)
-                    self.assertEqual(data, [{'@graph': [{'@id': 'http://test/br/0601', '@type': ['http://purl.org/spar/fabio/Expression']}], '@id': 'http://test/br/'}])
-            with ZipFile(os.path.join(base_dir, "br", "060", "10000", "1000", "prov", "se.zip"), mode="r") as archive:
-                with archive.open("se.json") as f:
-                    data = [{g:[{k:v for k,v in datum.items() if k != "http://www.w3.org/ns/prov#generatedAtTime"} for datum in data] if g == "@graph" else data for g, data in graph.items()} for graph in json.load(f)]
-                    self.assertEqual(data, [{'@graph': [{
-                        '@id': 'http://test/br/0601/prov/se/1', 
-                        '@type': ['http://www.w3.org/ns/prov#Entity'], 
-                        'http://purl.org/dc/terms/description': [{'@value': "The entity 'http://test/br/0601' has been created."}], 
-                        'http://www.w3.org/ns/prov#specializationOf': [{'@id': 'http://test/br/0601'}], 
-                        'http://www.w3.org/ns/prov#wasAttributedTo': [{'@id': 'http://resp_agent.test/'}]}], '@id': 'http://test/br/0601/prov/'}])
-        with self.subTest("output_format=json-ld, zip_output=False"):
-            base_dir_1 = os.path.join("oc_ocdm", "test", "storer", "data", "rdf_1") + os.sep
-            storer = Storer(self.graph_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='json-ld', zip_output=False)
-            self.prov_set.generate_provenance()
-            prov_storer = Storer(self.prov_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='json-ld', zip_output=False)
-            storer.store_all(base_dir_1, self.base_iri)
-            prov_storer.store_all(base_dir_1, self.base_iri)
-            self.graph_set.commit_changes()
-            with open(os.path.join(base_dir_1, "br", "060", "10000", "1000.json")) as f:
-                data = json.load(f)
-                self.assertEqual(data, [{'@graph': [{'@id': 'http://test/br/0601', '@type': ['http://purl.org/spar/fabio/Expression']}], '@id': 'http://test/br/'}])
-            with open(os.path.join(base_dir_1, "br", "060", "10000", "1000", "prov", "se.json")) as f:
-                data = [{g:[{k:v for k,v in datum.items() if k != "http://www.w3.org/ns/prov#generatedAtTime"} for datum in data] if g == "@graph" else data for g, data in graph.items()} for graph in json.load(f)]
-                self.assertEqual(data, [{'@graph': [{
-                    '@id': 'http://test/br/0601/prov/se/1', 
-                    '@type': ['http://www.w3.org/ns/prov#Entity'], 
-                    'http://purl.org/dc/terms/description': [{'@value': "The entity 'http://test/br/0601' has been created."}], 
-                    'http://www.w3.org/ns/prov#specializationOf': [{'@id': 'http://test/br/0601'}], 
-                    'http://www.w3.org/ns/prov#wasAttributedTo': [{'@id': 'http://resp_agent.test/'}]}], '@id': 'http://test/br/0601/prov/'}])
-        with self.subTest("output_format=nquads, zip_output=True"):
-            base_dir_2 = os.path.join("oc_ocdm", "test", "storer", "data", "rdf_2") + os.sep
-            storer = Storer(self.graph_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='nquads', zip_output=True)
-            self.prov_set.generate_provenance()
-            prov_storer = Storer(self.prov_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='nquads', zip_output=True)
-            storer.store_all(base_dir_2, self.base_iri)
-            prov_storer.store_all(base_dir_2, self.base_iri)
-            self.graph_set.commit_changes()
-            with ZipFile(os.path.join(base_dir_2, "br", "060", "10000", "1000.zip"), mode="r") as archive:
-                with archive.open("1000.nt") as f:
-                    data = f.read().decode("utf-8")
-                    self.assertEqual(data, "<http://test/br/0601> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://purl.org/spar/fabio/Expression> <http://test/br/> .\n\n")
-            with ZipFile(os.path.join(base_dir_2, "br", "060", "10000", "1000", "prov", "se.zip"), mode="r") as archive:
-                with archive.open("se.nq") as f:
-                    data = f.read().decode("utf-8")
-                    data_g = ConjunctiveGraph()
-                    expected_data_g = ConjunctiveGraph()
-                    data_g.parse(data=data, format="nquads")
-                    expected_data_g.parse(data="""
-                        <http://test/br/0601/prov/se/1> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://www.w3.org/ns/prov#Entity> <http://test/br/0601/prov/> .
-                        <http://test/br/0601/prov/se/1> <http://www.w3.org/ns/prov#specializationOf> <http://test/br/0601> <http://test/br/0601/prov/> .
-                        <http://test/br/0601/prov/se/1> <http://www.w3.org/ns/prov#wasAttributedTo> <http://resp_agent.test/> <http://test/br/0601/prov/> .
-                        <http://test/br/0601/prov/se/1> <http://purl.org/dc/terms/description> "The entity 'http://test/br/0601' has been created." <http://test/br/0601/prov/> .
-                    """, format="nquads")
-                    for s, p, o, c in data_g.quads():
-                        if p == URIRef("http://www.w3.org/ns/prov#generatedAtTime"):
-                            data_g.remove((s, p, o, c))
-                    self.assertTrue(compare.isomorphic(data_g, expected_data_g))
-        with self.subTest("output_format=nquads, zip_output=False"):
-            base_dir_3 = os.path.join("oc_ocdm", "test", "storer", "data", "rdf_3") + os.sep
-            storer = Storer(self.graph_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='nquads', zip_output=False)
-            self.prov_set.generate_provenance()
-            prov_storer = Storer(self.prov_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='nquads', zip_output=False)
-            storer.store_all(base_dir_3, self.base_iri)
-            prov_storer.store_all(base_dir_3, self.base_iri)
-            self.graph_set.commit_changes()
-            prov_unzipped = ConjunctiveGraph()
-            expected_prov_unzipped = ConjunctiveGraph()
-            with open(os.path.join(base_dir_3, "br", "060", "10000", "1000.nt"), "r", encoding="utf-8") as f:
-                data_unzipped = f.read()
-            prov_unzipped.parse(source=os.path.join(base_dir_3, "br", "060", "10000", "1000", "prov", "se.nq"), format="nquads")
-            expected_prov_unzipped.parse(data="""
-                <http://test/br/0601/prov/se/1> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://www.w3.org/ns/prov#Entity> <http://test/br/0601/prov/> .
-                <http://test/br/0601/prov/se/1> <http://www.w3.org/ns/prov#specializationOf> <http://test/br/0601> <http://test/br/0601/prov/> .
-                <http://test/br/0601/prov/se/1> <http://www.w3.org/ns/prov#wasAttributedTo> <http://resp_agent.test/> <http://test/br/0601/prov/> .
-                <http://test/br/0601/prov/se/1> <http://purl.org/dc/terms/description> "The entity 'http://test/br/0601' has been created." <http://test/br/0601/prov/> .
-            """, format="nquads")
-            for s, p, o, c in prov_unzipped.quads():
-                if p == URIRef("http://www.w3.org/ns/prov#generatedAtTime"):
-                    prov_unzipped.remove((s, p, o, c))
-            self.assertEqual(data_unzipped, "<http://test/br/0601> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://purl.org/spar/fabio/Expression> <http://test/br/> .\n\n")
-            self.assertTrue(compare.isomorphic(prov_unzipped, expected_prov_unzipped))
-
-    def test_store_graphs_in_file_multiprocessing(self):
-        base_dir = os.path.join("oc_ocdm", "test", "storer", "data", "multiprocessing") + os.sep
-        storer = Storer(self.graph_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='json-ld', zip_output=False)
-        self.prov_set.generate_provenance()
-        prov_storer = Storer(self.prov_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='json-ld', zip_output=False)
-        storer.store_all(base_dir, self.base_iri, process_id=7)
-        prov_storer.store_all(base_dir, self.base_iri, process_id=7)
-        with open(os.path.join(base_dir, "br", "060", "10000", "1000_7.json")) as f:
-            data = json.load(f)
-            self.assertEqual(data, [{'@graph': [{'@id': 'http://test/br/0601', '@type': ['http://purl.org/spar/fabio/Expression']}], '@id': 'http://test/br/'}])
-        with open(os.path.join(base_dir, "br", "060", "10000", "1000", "prov", "se_7.json")) as f:
-            data = [{g:[{k:v for k,v in datum.items() if k != "http://www.w3.org/ns/prov#generatedAtTime"} for datum in data] if g == "@graph" else data for g, data in graph.items()} for graph in json.load(f)]
-            self.assertEqual(data, [{'@graph': [{
-                '@id': 'http://test/br/0601/prov/se/1', 
-                '@type': ['http://www.w3.org/ns/prov#Entity'], 
-                'http://purl.org/dc/terms/description': [{'@value': "The entity 'http://test/br/0601' has been created."}], 
-                'http://www.w3.org/ns/prov#specializationOf': [{'@id': 'http://test/br/0601'}], 
-                'http://www.w3.org/ns/prov#wasAttributedTo': [{'@id': 'http://resp_agent.test/'}]}], '@id': 'http://test/br/0601/prov/'}])
-
-    def test_provenance(self):
-        ts = SPARQLWrapper(self.ts)
-        ts.setQuery('delete{?x ?y ?z} where{?x ?y ?z}')
-        ts.setMethod(POST)
-        ts.query()
-        graph_set = GraphSet(self.base_iri, "", "060", False)
-        prov_set = ProvSet(graph_set, self.base_iri, info_dir=self.info_dir)
-        base_dir = os.path.join("oc_ocdm", "test", "storer", "test_provenance") + os.sep
-        graph_set.add_br(self.resp_agent)
-        graph_set.add_br(self.resp_agent)
-        graph_set.add_br(self.resp_agent)
-        prov_set.generate_provenance()
-        storer = Storer(graph_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='json-ld', zip_output=False)
-        prov_storer = Storer(prov_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='json-ld', zip_output=False)
-        prov_storer.store_all(base_dir, self.base_iri)
-        storer.upload_all(self.ts, base_dir)
-        graph_set.commit_changes()
-        entities_to_process = [('http://test/br/0601',), ('http://test/br/0602',), ('http://test/br/0603',)]
-        with Pool(processes=3) as pool:
-            pool.starmap(process_entity, entities_to_process)
-
-def process_entity(entity):
-    base_iri = "http://test/"
-    ts = 'http://127.0.0.1:9999/blazegraph/sparql'
-    resp_agent = "http://resp_agent.test/"
-    base_dir = os.path.join("oc_ocdm", "test", "storer", "test_provenance") + os.sep
-    info_dir = os.path.join("oc_ocdm", "test", "storer", "test_provenance", "info_dir")
-    graph_set = GraphSet(base_iri, "", "060", False)
-    Reader.import_entity_from_triplestore(graph_set, ts, URIRef(entity), resp_agent)
-    br = graph_set.get_entity(URIRef(entity))
-    br.has_title("Hola")
-    prov_set = ProvSet(graph_set, base_iri, info_dir=info_dir)
-    prov_set.generate_provenance()
-    storer = Storer(graph_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='json-ld', zip_output=False)
-    prov_storer = Storer(prov_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='json-ld', zip_output=False)
-    prov_storer.store_all(base_dir, base_iri)
-    storer.upload_all(ts, base_dir)
-
-
-if __name__ == '__main__':
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+import json
+import os
+import unittest
+from platform import system
+from zipfile import ZipFile
+from multiprocessing import Pool
+from SPARQLWrapper import POST, SPARQLWrapper
+
+from rdflib import ConjunctiveGraph, URIRef, compare
+
+from oc_ocdm.graph.graph_set import GraphSet
+from oc_ocdm.prov.prov_set import ProvSet
+from oc_ocdm.storer import Storer
+from oc_ocdm.reader import Reader
+
+from shutil import rmtree
+
+class TestStorer(unittest.TestCase):
+    def setUp(self):
+        self.resp_agent = "http://resp_agent.test/"
+        self.base_iri = "http://test/"
+        self.ts = 'http://127.0.0.1:9999/blazegraph/sparql'
+        self.graph_set = GraphSet(self.base_iri, "", "060", False)
+        self.prov_set = ProvSet(self.graph_set, self.base_iri, "", False)
+        self.br = self.graph_set.add_br(self.resp_agent)
+        self.data_dir = os.path.join("oc_ocdm", "test", "storer", "data")
+        self.prov_dir = os.path.join("oc_ocdm", "test", "storer", "test_provenance")
+        self.info_dir = os.path.join(self.prov_dir, "info_dir")
+
+    def tearDown(self):
+        if os.path.exists(self.data_dir):
+            rmtree(self.data_dir)
+        if os.path.exists(self.prov_dir):
+            rmtree(os.path.join(self.prov_dir))
+
+    def test_store_graphs_in_file(self):
+        base_dir = os.path.join("oc_ocdm", "test", "storer", "data", "rdf") + os.sep
+        with self.subTest("output_format=json-ld, zip_output=True"):
+            modified_entities = self.prov_set.generate_provenance()
+            prov_storer = Storer(self.prov_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='json-ld', zip_output=True)
+            storer = Storer(self.graph_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='json-ld', zip_output=True, modified_entities=modified_entities)
+            storer.store_all(base_dir, self.base_iri)
+            prov_storer.store_all(base_dir, self.base_iri)
+            self.graph_set.commit_changes()
+            with ZipFile(os.path.join(base_dir, "br", "060", "10000", "1000.zip"), mode="r") as archive:
+                with archive.open("1000.json") as f:
+                    data = json.load(f)
+                    self.assertEqual(data, [{'@graph': [{'@id': 'http://test/br/0601', '@type': ['http://purl.org/spar/fabio/Expression']}], '@id': 'http://test/br/'}])
+            with ZipFile(os.path.join(base_dir, "br", "060", "10000", "1000", "prov", "se.zip"), mode="r") as archive:
+                with archive.open("se.json") as f:
+                    data = [{g:[{k:v for k,v in datum.items() if k != "http://www.w3.org/ns/prov#generatedAtTime"} for datum in data] if g == "@graph" else data for g, data in graph.items()} for graph in json.load(f)]
+                    self.assertEqual(data, [{'@graph': [{
+                        '@id': 'http://test/br/0601/prov/se/1', 
+                        '@type': ['http://www.w3.org/ns/prov#Entity'], 
+                        'http://purl.org/dc/terms/description': [{'@value': "The entity 'http://test/br/0601' has been created."}], 
+                        'http://www.w3.org/ns/prov#specializationOf': [{'@id': 'http://test/br/0601'}], 
+                        'http://www.w3.org/ns/prov#wasAttributedTo': [{'@id': 'http://resp_agent.test/'}]}], '@id': 'http://test/br/0601/prov/'}])
+        with self.subTest("output_format=json-ld, zip_output=False"):
+            base_dir_1 = os.path.join("oc_ocdm", "test", "storer", "data", "rdf_1") + os.sep
+            storer = Storer(self.graph_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='json-ld', zip_output=False)
+            self.prov_set.generate_provenance()
+            prov_storer = Storer(self.prov_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='json-ld', zip_output=False)
+            storer.store_all(base_dir_1, self.base_iri)
+            prov_storer.store_all(base_dir_1, self.base_iri)
+            self.graph_set.commit_changes()
+            with open(os.path.join(base_dir_1, "br", "060", "10000", "1000.json")) as f:
+                data = json.load(f)
+                self.assertEqual(data, [{'@graph': [{'@id': 'http://test/br/0601', '@type': ['http://purl.org/spar/fabio/Expression']}], '@id': 'http://test/br/'}])
+            with open(os.path.join(base_dir_1, "br", "060", "10000", "1000", "prov", "se.json")) as f:
+                data = [{g:[{k:v for k,v in datum.items() if k != "http://www.w3.org/ns/prov#generatedAtTime"} for datum in data] if g == "@graph" else data for g, data in graph.items()} for graph in json.load(f)]
+                self.assertEqual(data, [{'@graph': [{
+                    '@id': 'http://test/br/0601/prov/se/1', 
+                    '@type': ['http://www.w3.org/ns/prov#Entity'], 
+                    'http://purl.org/dc/terms/description': [{'@value': "The entity 'http://test/br/0601' has been created."}], 
+                    'http://www.w3.org/ns/prov#specializationOf': [{'@id': 'http://test/br/0601'}], 
+                    'http://www.w3.org/ns/prov#wasAttributedTo': [{'@id': 'http://resp_agent.test/'}]}], '@id': 'http://test/br/0601/prov/'}])
+        with self.subTest("output_format=nquads, zip_output=True"):
+            base_dir_2 = os.path.join("oc_ocdm", "test", "storer", "data", "rdf_2") + os.sep
+            storer = Storer(self.graph_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='nquads', zip_output=True)
+            self.prov_set.generate_provenance()
+            prov_storer = Storer(self.prov_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='nquads', zip_output=True)
+            storer.store_all(base_dir_2, self.base_iri)
+            prov_storer.store_all(base_dir_2, self.base_iri)
+            self.graph_set.commit_changes()
+            with ZipFile(os.path.join(base_dir_2, "br", "060", "10000", "1000.zip"), mode="r") as archive:
+                with archive.open("1000.nt") as f:
+                    data = f.read().decode("utf-8")
+                    self.assertEqual(data, "<http://test/br/0601> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://purl.org/spar/fabio/Expression> <http://test/br/> .\n\n")
+            with ZipFile(os.path.join(base_dir_2, "br", "060", "10000", "1000", "prov", "se.zip"), mode="r") as archive:
+                with archive.open("se.nq") as f:
+                    data = f.read().decode("utf-8")
+                    data_g = ConjunctiveGraph()
+                    expected_data_g = ConjunctiveGraph()
+                    data_g.parse(data=data, format="nquads")
+                    expected_data_g.parse(data="""
+                        <http://test/br/0601/prov/se/1> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://www.w3.org/ns/prov#Entity> <http://test/br/0601/prov/> .
+                        <http://test/br/0601/prov/se/1> <http://www.w3.org/ns/prov#specializationOf> <http://test/br/0601> <http://test/br/0601/prov/> .
+                        <http://test/br/0601/prov/se/1> <http://www.w3.org/ns/prov#wasAttributedTo> <http://resp_agent.test/> <http://test/br/0601/prov/> .
+                        <http://test/br/0601/prov/se/1> <http://purl.org/dc/terms/description> "The entity 'http://test/br/0601' has been created." <http://test/br/0601/prov/> .
+                    """, format="nquads")
+                    for s, p, o, c in data_g.quads():
+                        if p == URIRef("http://www.w3.org/ns/prov#generatedAtTime"):
+                            data_g.remove((s, p, o, c))
+                    self.assertTrue(compare.isomorphic(data_g, expected_data_g))
+        with self.subTest("output_format=nquads, zip_output=False"):
+            base_dir_3 = os.path.join("oc_ocdm", "test", "storer", "data", "rdf_3") + os.sep
+            storer = Storer(self.graph_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='nquads', zip_output=False)
+            self.prov_set.generate_provenance()
+            prov_storer = Storer(self.prov_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='nquads', zip_output=False)
+            storer.store_all(base_dir_3, self.base_iri)
+            prov_storer.store_all(base_dir_3, self.base_iri)
+            self.graph_set.commit_changes()
+            prov_unzipped = ConjunctiveGraph()
+            expected_prov_unzipped = ConjunctiveGraph()
+            with open(os.path.join(base_dir_3, "br", "060", "10000", "1000.nt"), "r", encoding="utf-8") as f:
+                data_unzipped = f.read()
+            prov_unzipped.parse(source=os.path.join(base_dir_3, "br", "060", "10000", "1000", "prov", "se.nq"), format="nquads")
+            expected_prov_unzipped.parse(data="""
+                <http://test/br/0601/prov/se/1> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://www.w3.org/ns/prov#Entity> <http://test/br/0601/prov/> .
+                <http://test/br/0601/prov/se/1> <http://www.w3.org/ns/prov#specializationOf> <http://test/br/0601> <http://test/br/0601/prov/> .
+                <http://test/br/0601/prov/se/1> <http://www.w3.org/ns/prov#wasAttributedTo> <http://resp_agent.test/> <http://test/br/0601/prov/> .
+                <http://test/br/0601/prov/se/1> <http://purl.org/dc/terms/description> "The entity 'http://test/br/0601' has been created." <http://test/br/0601/prov/> .
+            """, format="nquads")
+            for s, p, o, c in prov_unzipped.quads():
+                if p == URIRef("http://www.w3.org/ns/prov#generatedAtTime"):
+                    prov_unzipped.remove((s, p, o, c))
+            self.assertEqual(data_unzipped, "<http://test/br/0601> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://purl.org/spar/fabio/Expression> <http://test/br/> .\n\n")
+            self.assertTrue(compare.isomorphic(prov_unzipped, expected_prov_unzipped))
+
+    def test_store_graphs_in_file_multiprocessing(self):
+        base_dir = os.path.join("oc_ocdm", "test", "storer", "data", "multiprocessing") + os.sep
+        storer = Storer(self.graph_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='json-ld', zip_output=False)
+        self.prov_set.generate_provenance()
+        prov_storer = Storer(self.prov_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='json-ld', zip_output=False)
+        storer.store_all(base_dir, self.base_iri, process_id=7)
+        prov_storer.store_all(base_dir, self.base_iri, process_id=7)
+        with open(os.path.join(base_dir, "br", "060", "10000", "1000_7.json")) as f:
+            data = json.load(f)
+            self.assertEqual(data, [{'@graph': [{'@id': 'http://test/br/0601', '@type': ['http://purl.org/spar/fabio/Expression']}], '@id': 'http://test/br/'}])
+        with open(os.path.join(base_dir, "br", "060", "10000", "1000", "prov", "se_7.json")) as f:
+            data = [{g:[{k:v for k,v in datum.items() if k != "http://www.w3.org/ns/prov#generatedAtTime"} for datum in data] if g == "@graph" else data for g, data in graph.items()} for graph in json.load(f)]
+            self.assertEqual(data, [{'@graph': [{
+                '@id': 'http://test/br/0601/prov/se/1', 
+                '@type': ['http://www.w3.org/ns/prov#Entity'], 
+                'http://purl.org/dc/terms/description': [{'@value': "The entity 'http://test/br/0601' has been created."}], 
+                'http://www.w3.org/ns/prov#specializationOf': [{'@id': 'http://test/br/0601'}], 
+                'http://www.w3.org/ns/prov#wasAttributedTo': [{'@id': 'http://resp_agent.test/'}]}], '@id': 'http://test/br/0601/prov/'}])
+
+    def test_provenance(self):
+        ts = SPARQLWrapper(self.ts)
+        ts.setQuery('delete{?x ?y ?z} where{?x ?y ?z}')
+        ts.setMethod(POST)
+        ts.query()
+        graph_set = GraphSet(self.base_iri, "", "060", False)
+        prov_set = ProvSet(graph_set, self.base_iri, info_dir=self.info_dir)
+        base_dir = os.path.join("oc_ocdm", "test", "storer", "test_provenance") + os.sep
+        graph_set.add_br(self.resp_agent)
+        graph_set.add_br(self.resp_agent)
+        graph_set.add_br(self.resp_agent)
+        prov_set.generate_provenance()
+        storer = Storer(graph_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='json-ld', zip_output=False)
+        prov_storer = Storer(prov_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='json-ld', zip_output=False)
+        prov_storer.store_all(base_dir, self.base_iri)
+        storer.upload_all(self.ts, base_dir)
+        graph_set.commit_changes()
+        entities_to_process = [('http://test/br/0601',), ('http://test/br/0602',), ('http://test/br/0603',)]
+        with Pool(processes=3) as pool:
+            pool.starmap(process_entity, entities_to_process)
+
+def process_entity(entity):
+    base_iri = "http://test/"
+    ts = 'http://127.0.0.1:9999/blazegraph/sparql'
+    resp_agent = "http://resp_agent.test/"
+    base_dir = os.path.join("oc_ocdm", "test", "storer", "test_provenance") + os.sep
+    info_dir = os.path.join("oc_ocdm", "test", "storer", "test_provenance", "info_dir")
+    graph_set = GraphSet(base_iri, "", "060", False)
+    Reader.import_entity_from_triplestore(graph_set, ts, URIRef(entity), resp_agent)
+    br = graph_set.get_entity(URIRef(entity))
+    br.has_title("Hola")
+    prov_set = ProvSet(graph_set, base_iri, info_dir=info_dir)
+    prov_set.generate_provenance()
+    storer = Storer(graph_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='json-ld', zip_output=False)
+    prov_storer = Storer(prov_set, context_map={}, dir_split=10000, n_file_item=1000, default_dir="_", output_format='json-ld', zip_output=False)
+    prov_storer.store_all(base_dir, base_iri)
+    storer.upload_all(ts, base_dir)
+
+
+if __name__ == '__main__':
     unittest.main()
```

### Comparing `oc_ocdm-8.0.2/oc_ocdm/test/support/test_support.py` & `oc_ocdm-8.1.0/oc_ocdm/test/support/test_support.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,130 +1,130 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
-#
-# Permission to use, copy, modify, and/or distribute this software for any purpose
-# with or without fee is hereby granted, provided that the above copyright notice
-# and this permission notice appear in all copies.
-#
-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
-# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-# SOFTWARE.
-import os
-import unittest
-
-from rdflib import Namespace, URIRef
-
-from oc_ocdm.graph.graph_set import GraphSet
-from oc_ocdm.prov.prov_set import ProvSet
-from oc_ocdm.support.support import (find_paths,
-                                     get_ordered_contributors_from_br)
-
-
-class TestSupport(unittest.TestCase):
-    resp_agent = 'http://resp_agent.test/'
-    pro = Namespace("http://purl.org/spar/pro/")
-
-    def setUp(self):
-        self.graph_set = GraphSet("http://test/", "./info_dir/", "", False)
-        self.prov_set = ProvSet(self.graph_set, "http://test/", "./info_dir/", False)
-
-        self.br = self.graph_set.add_br(self.resp_agent)
-
-    def _prepare_ordered_authors_list(self, list_len):
-        # First of all, we must cleanup the GraphSet:
-        self.br.remove_contributor()
-
-        for ar in self.graph_set.get_ar():
-            del self.graph_set.res_to_entity[ar.res]
-        for ra in self.graph_set.get_ra():
-            del self.graph_set.res_to_entity[ra.res]
-
-        # Then, we initialize a new well-formed linked list of authors:
-        ar_ordered_list = []
-
-        for i in range(list_len):
-            ra = self.graph_set.add_ra(self.resp_agent)
-
-            ar = self.graph_set.add_ar(self.resp_agent)
-            ar.create_author()
-            ar.is_held_by(ra)
-
-            self.br.has_contributor(ar)
-            ar_ordered_list.append(ar)
-
-        # Here each node of the list gets linked to the next one:
-        for i in range(list_len - 1):
-            ar_ordered_list[i].has_next(ar_ordered_list[i + 1])
-
-        return ar_ordered_list
-
-    @staticmethod
-    def _extract_ra_list(ar_list):
-        # Here the RA list is built and returned:
-        ra_list = []
-        for i in range(len(ar_list)):
-            ra = ar_list[i].get_is_held_by()
-            if ra is not None:
-                ra_list.append(ra)
-
-        return ra_list
-
-    def test_get_ordered_contributors_from_br(self):
-        list_len = 100
-        with self.subTest("Empty linked list"):
-            result = get_ordered_contributors_from_br(self.br, self.pro.author)
-
-            self.assertIsNotNone(result)
-            self.assertListEqual([], result)
-
-        with self.subTest("Well-formed linked list"):
-            correct_list = self._prepare_ordered_authors_list(list_len)
-            result = get_ordered_contributors_from_br(self.br, self.pro.author)
-
-            self.assertIsNotNone(result)
-            ar_list = self._extract_ra_list(correct_list)
-            self.assertListEqual(ar_list, result)
-
-        with self.subTest("Linked list with a loop"):
-            correct_list = self._prepare_ordered_authors_list(list_len)
-            # Here we corrupt the well-formed linked list introducing a loop:
-            correct_list[80].has_next(correct_list[50])
-
-            self.assertRaises(ValueError, get_ordered_contributors_from_br, self.br, self.pro.author)
-
-        with self.subTest("Linked list split in two sub-lists"):
-            correct_list = self._prepare_ordered_authors_list(list_len)
-            # Here we corrupt the well-formed linked list introducing a loop:
-            correct_list[64].remove_next()
-
-            self.assertRaises(ValueError, get_ordered_contributors_from_br, self.br, self.pro.author)
-    
-    def test_find_paths(self):
-        cur_dir_path, cur_file_path = find_paths(
-            res = URIRef('https://w3id.org/oc/meta/br/060169'),
-            base_dir = os.path.join('support', 'test', 'data', 'rdf'),
-            base_iri = 'https://w3id.org/oc/meta',
-            default_dir = '_',
-            dir_split = 10000,
-            n_file_item = 1000,
-            is_json = True)
-        self.assertEqual((cur_dir_path, cur_file_path), (os.path.join('support', 'test', 'data', 'rdfbr', '060', '10000'), os.path.join('support', 'test', 'data', 'rdfbr', '060', '10000', '1000.json')))
-
-    def test_find_paths_prov(self):
-        cur_dir_path, cur_file_path = find_paths(
-            res = URIRef('https://w3id.org/oc/meta/br/060165/prov/se/1'),
-            base_dir = os.path.join('support', 'test', 'data', 'rdf'),
-            base_iri = 'https://w3id.org/oc/meta',
-            default_dir = '_',
-            dir_split = 10000,
-            n_file_item = 1000,
-            is_json = True)
-        self.assertEqual((cur_dir_path, cur_file_path), (os.path.join('support', 'test', 'data', 'rdfbr', '060', '10000', '1000', 'prov'), os.path.join('support', 'test', 'data', 'rdfbr', '060', '10000', '1000', 'prov', 'se.json')))
-
-
-if __name__ == '__main__':
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
+#
+# Permission to use, copy, modify, and/or distribute this software for any purpose
+# with or without fee is hereby granted, provided that the above copyright notice
+# and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+# SOFTWARE.
+import os
+import unittest
+
+from rdflib import Namespace, URIRef
+
+from oc_ocdm.graph.graph_set import GraphSet
+from oc_ocdm.prov.prov_set import ProvSet
+from oc_ocdm.support.support import (find_paths,
+                                     get_ordered_contributors_from_br)
+
+
+class TestSupport(unittest.TestCase):
+    resp_agent = 'http://resp_agent.test/'
+    pro = Namespace("http://purl.org/spar/pro/")
+
+    def setUp(self):
+        self.graph_set = GraphSet("http://test/", "./info_dir/", "", False)
+        self.prov_set = ProvSet(self.graph_set, "http://test/", "./info_dir/", False)
+
+        self.br = self.graph_set.add_br(self.resp_agent)
+
+    def _prepare_ordered_authors_list(self, list_len):
+        # First of all, we must cleanup the GraphSet:
+        self.br.remove_contributor()
+
+        for ar in self.graph_set.get_ar():
+            del self.graph_set.res_to_entity[ar.res]
+        for ra in self.graph_set.get_ra():
+            del self.graph_set.res_to_entity[ra.res]
+
+        # Then, we initialize a new well-formed linked list of authors:
+        ar_ordered_list = []
+
+        for i in range(list_len):
+            ra = self.graph_set.add_ra(self.resp_agent)
+
+            ar = self.graph_set.add_ar(self.resp_agent)
+            ar.create_author()
+            ar.is_held_by(ra)
+
+            self.br.has_contributor(ar)
+            ar_ordered_list.append(ar)
+
+        # Here each node of the list gets linked to the next one:
+        for i in range(list_len - 1):
+            ar_ordered_list[i].has_next(ar_ordered_list[i + 1])
+
+        return ar_ordered_list
+
+    @staticmethod
+    def _extract_ra_list(ar_list):
+        # Here the RA list is built and returned:
+        ra_list = []
+        for i in range(len(ar_list)):
+            ra = ar_list[i].get_is_held_by()
+            if ra is not None:
+                ra_list.append(ra)
+
+        return ra_list
+
+    def test_get_ordered_contributors_from_br(self):
+        list_len = 100
+        with self.subTest("Empty linked list"):
+            result = get_ordered_contributors_from_br(self.br, self.pro.author)
+
+            self.assertIsNotNone(result)
+            self.assertListEqual([], result)
+
+        with self.subTest("Well-formed linked list"):
+            correct_list = self._prepare_ordered_authors_list(list_len)
+            result = get_ordered_contributors_from_br(self.br, self.pro.author)
+
+            self.assertIsNotNone(result)
+            ar_list = self._extract_ra_list(correct_list)
+            self.assertListEqual(ar_list, result)
+
+        with self.subTest("Linked list with a loop"):
+            correct_list = self._prepare_ordered_authors_list(list_len)
+            # Here we corrupt the well-formed linked list introducing a loop:
+            correct_list[80].has_next(correct_list[50])
+
+            self.assertRaises(ValueError, get_ordered_contributors_from_br, self.br, self.pro.author)
+
+        with self.subTest("Linked list split in two sub-lists"):
+            correct_list = self._prepare_ordered_authors_list(list_len)
+            # Here we corrupt the well-formed linked list introducing a loop:
+            correct_list[64].remove_next()
+
+            self.assertRaises(ValueError, get_ordered_contributors_from_br, self.br, self.pro.author)
+    
+    def test_find_paths(self):
+        cur_dir_path, cur_file_path = find_paths(
+            res = URIRef('https://w3id.org/oc/meta/br/060169'),
+            base_dir = os.path.join('support', 'test', 'data', 'rdf'),
+            base_iri = 'https://w3id.org/oc/meta',
+            default_dir = '_',
+            dir_split = 10000,
+            n_file_item = 1000,
+            is_json = True)
+        self.assertEqual((cur_dir_path, cur_file_path), (os.path.join('support', 'test', 'data', 'rdfbr', '060', '10000'), os.path.join('support', 'test', 'data', 'rdfbr', '060', '10000', '1000.json')))
+
+    def test_find_paths_prov(self):
+        cur_dir_path, cur_file_path = find_paths(
+            res = URIRef('https://w3id.org/oc/meta/br/060165/prov/se/1'),
+            base_dir = os.path.join('support', 'test', 'data', 'rdf'),
+            base_iri = 'https://w3id.org/oc/meta',
+            default_dir = '_',
+            dir_split = 10000,
+            n_file_item = 1000,
+            is_json = True)
+        self.assertEqual((cur_dir_path, cur_file_path), (os.path.join('support', 'test', 'data', 'rdfbr', '060', '10000', '1000', 'prov'), os.path.join('support', 'test', 'data', 'rdfbr', '060', '10000', '1000', 'prov', 'se.json')))
+
+
+if __name__ == '__main__':
     unittest.main()
```

### Comparing `oc_ocdm-8.0.2/pyproject.toml` & `oc_ocdm-8.1.0/pyproject.toml`

 * *Files 26% similar despite different names*

```diff
@@ -1,54 +1,54 @@
-[tool.poetry]
-name = "oc_ocdm"
-version = "8.0.2"
-description = "Object mapping library for manipulating RDF graphs that are compliant with the OpenCitations datamodel."
-authors = [
-    "Silvio Peroni <essepuntato@gmail.com>",
-    "Marilena Daquino <marilena.daquino2@unibo.it>",
-    "Fabio Mariani <fabio.mariani6@studio.unibo.it>",
-    "Simone Persiani <iosonopersia@gmail.com>",
-    "Arcangelo Massari <arcangelo.massari@unibo.it>"
-]
-readme = "README.md"
-license = "ISC"
-homepage = "https://opencitations.net"
-repository = "https://github.com/opencitations/oc_ocdm"
-documentation = "https://oc-ocdm.readthedocs.io"
-keywords = ["opencitations", "openscience", "datamodel", "mapping"]
-
-classifiers = [
-    "Intended Audience :: Developers",
-    "Intended Audience :: Science/Research",
-    "License :: OSI Approved :: ISC License (ISCL)",
-    "Natural Language :: English",
-    "Operating System :: OS Independent",
-    "Programming Language :: Python",
-    "Topic :: Database",
-    "Topic :: Software Development :: Libraries :: Python Modules",
-    "Topic :: System :: Archiving",
-    "Typing :: Typed"
-]
-
-[tool.poetry.dependencies]
-python = "^3.8"
-rdflib = "^6.0.0"
-SPARQLWrapper = "2.0.0"
-filelock = "^3.6.0"
-pyshacl = "0.23.0"
-setuptools = "^68.2.2"
-
-[tool.poetry.dev-dependencies]
-Sphinx = "^4.4.0"
-sphinx_rtd_theme = "^1.0.0"
-
-[tool.poetry.group.dev.dependencies]
-coverage = "^6.5.0"
-coverage-badge = "^1.1.0"
-wget = "^3.2"
-
-[build-system]
-requires = ["poetry>=1.1.12"]
-build-backend = "poetry.masonry.api"
-
-[tool.poetry.scripts]
+[tool.poetry]
+name = "oc_ocdm"
+version = "8.1.0"
+description = "Object mapping library for manipulating RDF graphs that are compliant with the OpenCitations datamodel."
+authors = [
+    "Silvio Peroni <essepuntato@gmail.com>",
+    "Marilena Daquino <marilena.daquino2@unibo.it>",
+    "Fabio Mariani <fabio.mariani6@studio.unibo.it>",
+    "Simone Persiani <iosonopersia@gmail.com>",
+    "Arcangelo Massari <arcangelo.massari@unibo.it>"
+]
+readme = "README.md"
+license = "ISC"
+homepage = "https://opencitations.net"
+repository = "https://github.com/opencitations/oc_ocdm"
+documentation = "https://oc-ocdm.readthedocs.io"
+keywords = ["opencitations", "openscience", "datamodel", "mapping"]
+
+classifiers = [
+    "Intended Audience :: Developers",
+    "Intended Audience :: Science/Research",
+    "License :: OSI Approved :: ISC License (ISCL)",
+    "Natural Language :: English",
+    "Operating System :: OS Independent",
+    "Programming Language :: Python",
+    "Topic :: Database",
+    "Topic :: Software Development :: Libraries :: Python Modules",
+    "Topic :: System :: Archiving",
+    "Typing :: Typed"
+]
+
+[tool.poetry.dependencies]
+python = "^3.8"
+rdflib = "^6.0.0"
+SPARQLWrapper = "2.0.0"
+filelock = "^3.6.0"
+pyshacl = "0.23.0"
+setuptools = "^68.2.2"
+
+[tool.poetry.dev-dependencies]
+Sphinx = "^4.4.0"
+sphinx_rtd_theme = "^1.0.0"
+
+[tool.poetry.group.dev.dependencies]
+coverage = "^6.5.0"
+coverage-badge = "^1.1.0"
+wget = "^3.2"
+
+[build-system]
+requires = ["poetry>=1.1.12"]
+build-backend = "poetry.masonry.api"
+
+[tool.poetry.scripts]
 test = 'scripts:main'
```

### Comparing `oc_ocdm-8.0.2/README.md` & `oc_ocdm-8.1.0/README.md`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,126 +1,126 @@
-# oc_ocdm
-[<img src="https://img.shields.io/badge/powered%20by-OpenCitations-%239931FC?labelColor=2D22DE" />](http://opencitations.net)
-[![Run tests](https://github.com/opencitations/oc_ocdm/actions/workflows/run_tests.yml/badge.svg)](https://github.com/opencitations/oc_ocdm/actions/workflows/run_tests.yml)
-![Coverage](https://raw.githubusercontent.com/opencitations/oc_ocdm/master/oc_ocdm/test/coverage/coverage.svg)
-[![Documentation Status](https://readthedocs.org/projects/oc-ocdm/badge/?version=latest)](https://oc-ocdm.readthedocs.io/en/latest/?badge=latest)
-[![PyPI version](https://badge.fury.io/py/oc-ocdm.svg)](https://badge.fury.io/py/oc-ocdm)
-![PyPI](https://img.shields.io/pypi/pyversions/oc_meta)
-
-[![DOI](https://zenodo.org/badge/322327342.svg)](https://zenodo.org/badge/latestdoi/322327342)
-[![License: ISC](https://img.shields.io/badge/License-ISC-blue.svg)](https://opensource.org/licenses/ISC)
-
-Documentation can be found here: [https://oc-ocdm.readthedocs.io](https://oc-ocdm.readthedocs.io).
-
-**oc_ocdm** is a Python &ge;3.7 library that enables the user to import, produce, modify and export RDF data
-structures which are compliant with the [OCDM v2.0.1](https://figshare.com/articles/Metadata_for_the_OpenCitations_Corpus/3443876) specification.
-
-## User's guide
-This package can be simply installed with **pip**:
-``` bash
-    pip install oc_ocdm
-```
-**Please, have a look at the notebooks [available here](https://github.com/opencitations/oc_ocdm/blob/master/notebooks/).**
-
-## Developer's guide
-
-### First steps
-  1. Install Poetry:
-``` bash
-    pip install poetry
-```
-  2. Clone this repository:
-``` bash
-    git clone https://github.com/iosonopersia/oc_ocdm
-    cd ./oc_ocdm
-```
-  3. Install all the dependencies:
-``` bash
-    poetry install
-```
-  4. Build the package (_output dir:_ `dist`):
-``` bash
-    poetry build
-```
-  5. Globally install the package (_alternatively, you can also install it inside a virtual-env,
-  by providing the full path to the .tar.gz archive_):
-``` bash
-    pip install ./dist/oc_ocdm-<VERSION>.tar.gz
-```
-  6. If everything went the right way, than you should be able to use the `oc_ocdm` library in your Python modules as follows:
-``` python
-    from oc_ocdm.graph import GraphSet
-    from oc_ocdm.graph.entities.bibliographic import AgentRole
-    # ...
-```
-
-### How to run the tests
-Just run the following command inside the root project folder:
-``` bash
-    poetry run test
-```
-
-### How to manage the project using Poetry
-See [Poetry commands documentation](https://python-poetry.org/docs/cli/).
-
-**AAA: when adding a non-dev dependency via `poetry add`, always remember to add
-that same dependency to the `autodoc_mock_imports` list in `docs/source/conf.py`**
-(otherwise "Read the Docs" won't be able to compile the documentation correctly!).
-
-### How to publish the package onto Pypi
-``` bash
-    poetry publish --build
-```
-### Install dependencies needed for the documentation
-``` bash
-    pip install Sphinx sphinx_rtd_theme
-```
-### How to generate the documentation
-``` bash
-    rm ./docs/source/modules/*
-    sphinx-apidoc  -o ./docs/source/modules oc_ocdm *test*
-```
-
-### How to build the documentation
-___
-**Warning! In order to avoid getting the following `WARNING: html_static_path entry '_static' does not exist`, you'll
-need to manually create an empty `_static` folder with the command:**
-``` bash
-    mkdir docs/source/_static
-```
-___
-  1. Always remember to move inside the `docs` folder:
-``` bash
-    cd docs
-```
-  2. Use the Makefile provided to build the docs:
-      + _on Windows_
-        ```
-            make.bat html
-        ```
-      + _on Linux and MacOs_
-        ```
-            make html
-        ```
-  3. Open the `build/html/index.html` file with a web browser of your choice!
-
-## Citation
-If you are using or extending `oc_ocdm` as part of a scientific publication, we would appreciate a citation of our [article](https://link.springer.com/chapter/10.1007/978-3-031-06981-9_18).
-
-```bibtex
-@inproceedings{persiani2022programming,
-  title={{A} {P}rogramming {I}nterface for {C}reating {D}ata {A}ccording to the {SPAR} {O}ntologies and the {O}pen{C}itations {D}ata {M}odel},
-  author={Persiani, Simone and Daquino, Marilena and Peroni, Silvio},
-  booktitle={The Semantic Web: 19th International Conference, ESWC 2022, Hersonissos, Crete, Greece, May 29--June 2, 2022, Proceedings},
-  pages={305--322},
-  year={2022},
-  organization={Springer}
-}
-```
-
-## Acknowledgements
-This work has been funded by the project “Open Biomedical Citations in Context Corpus”
-(Wellcome Trust, Grant n. 214471/Z/18/Z) and the project “Wikipedia Citations in Wikidata”
-(Wikimedia Foundation, https://meta.wikimedia.org/wiki/Wikicite/grant/Wikipedia_Citations_in_Wikidata).
-
-We would like to thank (in alphabetic order) Fabio Mariani (@FabioMariani), Arcangelo
-Massari (@arcangelo7), and Gabriele Pisciotta (@GabrielePisciotta) for the constructive feedback.
+# oc_ocdm
+[<img src="https://img.shields.io/badge/powered%20by-OpenCitations-%239931FC?labelColor=2D22DE" />](http://opencitations.net)
+[![Run tests](https://github.com/opencitations/oc_ocdm/actions/workflows/run_tests.yml/badge.svg)](https://github.com/opencitations/oc_ocdm/actions/workflows/run_tests.yml)
+![Coverage](https://raw.githubusercontent.com/opencitations/oc_ocdm/master/oc_ocdm/test/coverage/coverage.svg)
+[![Documentation Status](https://readthedocs.org/projects/oc-ocdm/badge/?version=latest)](https://oc-ocdm.readthedocs.io/en/latest/?badge=latest)
+[![PyPI version](https://badge.fury.io/py/oc-ocdm.svg)](https://badge.fury.io/py/oc-ocdm)
+![PyPI](https://img.shields.io/pypi/pyversions/oc_meta)
+
+[![DOI](https://zenodo.org/badge/322327342.svg)](https://zenodo.org/badge/latestdoi/322327342)
+[![License: ISC](https://img.shields.io/badge/License-ISC-blue.svg)](https://opensource.org/licenses/ISC)
+
+Documentation can be found here: [https://oc-ocdm.readthedocs.io](https://oc-ocdm.readthedocs.io).
+
+**oc_ocdm** is a Python &ge;3.7 library that enables the user to import, produce, modify and export RDF data
+structures which are compliant with the [OCDM v2.0.1](https://figshare.com/articles/Metadata_for_the_OpenCitations_Corpus/3443876) specification.
+
+## User's guide
+This package can be simply installed with **pip**:
+``` bash
+    pip install oc_ocdm
+```
+**Please, have a look at the notebooks [available here](https://github.com/opencitations/oc_ocdm/blob/master/notebooks/).**
+
+## Developer's guide
+
+### First steps
+  1. Install Poetry:
+``` bash
+    pip install poetry
+```
+  2. Clone this repository:
+``` bash
+    git clone https://github.com/iosonopersia/oc_ocdm
+    cd ./oc_ocdm
+```
+  3. Install all the dependencies:
+``` bash
+    poetry install
+```
+  4. Build the package (_output dir:_ `dist`):
+``` bash
+    poetry build
+```
+  5. Globally install the package (_alternatively, you can also install it inside a virtual-env,
+  by providing the full path to the .tar.gz archive_):
+``` bash
+    pip install ./dist/oc_ocdm-<VERSION>.tar.gz
+```
+  6. If everything went the right way, than you should be able to use the `oc_ocdm` library in your Python modules as follows:
+``` python
+    from oc_ocdm.graph import GraphSet
+    from oc_ocdm.graph.entities.bibliographic import AgentRole
+    # ...
+```
+
+### How to run the tests
+Just run the following command inside the root project folder:
+``` bash
+    poetry run test
+```
+
+### How to manage the project using Poetry
+See [Poetry commands documentation](https://python-poetry.org/docs/cli/).
+
+**AAA: when adding a non-dev dependency via `poetry add`, always remember to add
+that same dependency to the `autodoc_mock_imports` list in `docs/source/conf.py`**
+(otherwise "Read the Docs" won't be able to compile the documentation correctly!).
+
+### How to publish the package onto Pypi
+``` bash
+    poetry publish --build
+```
+### Install dependencies needed for the documentation
+``` bash
+    pip install Sphinx sphinx_rtd_theme
+```
+### How to generate the documentation
+``` bash
+    rm ./docs/source/modules/*
+    sphinx-apidoc  -o ./docs/source/modules oc_ocdm *test*
+```
+
+### How to build the documentation
+___
+**Warning! In order to avoid getting the following `WARNING: html_static_path entry '_static' does not exist`, you'll
+need to manually create an empty `_static` folder with the command:**
+``` bash
+    mkdir docs/source/_static
+```
+___
+  1. Always remember to move inside the `docs` folder:
+``` bash
+    cd docs
+```
+  2. Use the Makefile provided to build the docs:
+      + _on Windows_
+        ```
+            make.bat html
+        ```
+      + _on Linux and MacOs_
+        ```
+            make html
+        ```
+  3. Open the `build/html/index.html` file with a web browser of your choice!
+
+## Citation
+If you are using or extending `oc_ocdm` as part of a scientific publication, we would appreciate a citation of our [article](https://link.springer.com/chapter/10.1007/978-3-031-06981-9_18).
+
+```bibtex
+@inproceedings{persiani2022programming,
+  title={{A} {P}rogramming {I}nterface for {C}reating {D}ata {A}ccording to the {SPAR} {O}ntologies and the {O}pen{C}itations {D}ata {M}odel},
+  author={Persiani, Simone and Daquino, Marilena and Peroni, Silvio},
+  booktitle={The Semantic Web: 19th International Conference, ESWC 2022, Hersonissos, Crete, Greece, May 29--June 2, 2022, Proceedings},
+  pages={305--322},
+  year={2022},
+  organization={Springer}
+}
+```
+
+## Acknowledgements
+This work has been funded by the project “Open Biomedical Citations in Context Corpus”
+(Wellcome Trust, Grant n. 214471/Z/18/Z) and the project “Wikipedia Citations in Wikidata”
+(Wikimedia Foundation, https://meta.wikimedia.org/wiki/Wikicite/grant/Wikipedia_Citations_in_Wikidata).
+
+We would like to thank (in alphabetic order) Fabio Mariani (@FabioMariani), Arcangelo
+Massari (@arcangelo7), and Gabriele Pisciotta (@GabrielePisciotta) for the constructive feedback.
```

### Comparing `oc_ocdm-8.0.2/PKG-INFO` & `oc_ocdm-8.1.0/PKG-INFO`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: oc_ocdm
-Version: 8.0.2
+Version: 8.1.0
 Summary: Object mapping library for manipulating RDF graphs that are compliant with the OpenCitations datamodel.
 Home-page: https://opencitations.net
 License: ISC
 Keywords: opencitations,openscience,datamodel,mapping
 Author: Silvio Peroni
 Author-email: essepuntato@gmail.com
 Requires-Python: >=3.8,<4.0
@@ -16,14 +16,15 @@
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: 3.12
 Classifier: Topic :: Database
 Classifier: Topic :: Software Development :: Libraries :: Python Modules
 Classifier: Topic :: System :: Archiving
 Classifier: Typing :: Typed
 Requires-Dist: SPARQLWrapper (==2.0.0)
 Requires-Dist: filelock (>=3.6.0,<4.0.0)
 Requires-Dist: pyshacl (==0.23.0)
```

